/** @file
  File name:    MMRCMC_DEC_MEM_CSR_DDR.h
  Input File:   SPR_MRC_DDR.xlsx
  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.
  If edits are needed in this file, they must be done via the MSP tool.
  If there is additional project-specific data required by the MSP, it
  can be placed in MMRCMC_DEC_MEM_CSR_DDR.h, which is used for non-tool-generated
  data
  Includes register defines specific to a project.

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2005 - 2020 Intel Corporation. <BR>

  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.

  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.

  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
**/

#ifndef _MMRCMC_DEC_MEM_CSR_DDR_H_DDR_
#define _MMRCMC_DEC_MEM_CSR_DDR_H_DDR_

#include "MspDataTypes.h"

#define NM_DRAM_RULE_CFG0_L_MC_DEC_MEM_CSR_REG_DDR         0x00020C00
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 rule_enable : 1;
    //
    // This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:1], RW, default = 0x0
    //
    UINT32 limit : 26;
    //
    // NmChnWays - Near Memory Channel Ways: used to calculate ChnLID
    //               000 = 1 way (ChnLID = 0)
    //               001 = 2 ways (ChnLID = modulo 2 of System Address)
    //               010 = 3 ways (ChnLID = modulo 3 of System Address)
    //               011 = 8 ways (ChnLID = module 8 of System Address)
    //               100 = 4 ways (ChnLID = module 4 of System Address)
    //         
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINT32 nm_chn_ways : 3;
    //
    // NmChnGran - Near Memory Channel Granularity:
    //               000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved
    //         
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 nm_chn_gran : 2;
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG0_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define NM_DRAM_RULE_CFG0_H_MC_DEC_MEM_CSR_REG_DDR         0x00020C04
typedef union {
  struct {
    //
    // NmChnGran - Near Memory Channel Granularity:
    //               000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved
    //         
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 nm_chn_gran : 1;
    //
    // NmTargetWays - Near Memory Target Ways: used to calculate ChnLID
    //               00 = 1 way
    //               01 = 2 ways
    //               10 = 4 ways
    //               11 = 8 ways
    //         
    // 
    // Bits[2:1], RW, default = 0x0
    //
    UINT32 nm_target_ways : 2;
    //
    // When set to 0, indicate near memory target and channel granularity are different,
    // or target way is 1. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 nm_gran_eq : 1;
    //
    // NmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)
    //               NmChnL2PID[ 2: 0] = mapping from ChnLID=0 to ChnPID
    //               NmChnL2PID[ 5: 3] = mapping from ChnLID=1 to ChnPID
    //               NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to ChnPID
    //               NmChnL2PID[11: 9] = mapping from ChnLID=3 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[14:12] = mapping from ChnLID=4 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[17:15] = mapping from ChnLID=5 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[20:18] = mapping from ChnLID=6 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[23:21] = mapping from ChnLID=7 to ChnPID; only used in
    // HBM mode 
    //               Default value maps ChnLID to the same ChnPID
    //         
    // 
    // Bits[27:4], RW, default = 0xFAC688
    //
    UINT32 nm_chn_l2pid : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 4;
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG0_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define NM_DRAM_RULE_CFG1_L_MC_DEC_MEM_CSR_REG_DDR         0x00020C08
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 rule_enable : 1;
    //
    // This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:1], RW, default = 0x0
    //
    UINT32 limit : 26;
    //
    // NmChnWays - Near Memory Channel Ways: used to calculate ChnLID
    //               000 = 1 way (ChnLID = 0)
    //               001 = 2 ways (ChnLID = modulo 2 of System Address)
    //               010 = 3 ways (ChnLID = modulo 3 of System Address)
    //               011 = 8 ways (ChnLID = module 8 of System Address)
    //               100 = 4 ways (ChnLID = module 4 of System Address)
    //         
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINT32 nm_chn_ways : 3;
    //
    // NmChnGran - Near Memory Channel Granularity:
    //               000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved
    //         
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 nm_chn_gran : 2;
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG1_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define NM_DRAM_RULE_CFG1_H_MC_DEC_MEM_CSR_REG_DDR         0x00020C0C
typedef union {
  struct {
    //
    // NmChnGran - Near Memory Channel Granularity:
    //               000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved
    //         
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 nm_chn_gran : 1;
    //
    // NmTargetWays - Near Memory Target Ways: used to calculate ChnLID
    //               00 = 1 way
    //               01 = 2 ways
    //               10 = 4 ways
    //               11 = 8 ways
    //         
    // 
    // Bits[2:1], RW, default = 0x0
    //
    UINT32 nm_target_ways : 2;
    //
    // When set to 0, indicate near memory target and channel granularity are different,
    // or target way is 1. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 nm_gran_eq : 1;
    //
    // NmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)
    //               NmChnL2PID[ 2: 0] = mapping from ChnLID=0 to ChnPID
    //               NmChnL2PID[ 5: 3] = mapping from ChnLID=1 to ChnPID
    //               NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to ChnPID
    //               NmChnL2PID[11: 9] = mapping from ChnLID=3 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[14:12] = mapping from ChnLID=4 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[17:15] = mapping from ChnLID=5 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[20:18] = mapping from ChnLID=6 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[23:21] = mapping from ChnLID=7 to ChnPID; only used in
    // HBM mode 
    //               Default value maps ChnLID to the same ChnPID
    //         
    // 
    // Bits[27:4], RW, default = 0xFAC688
    //
    UINT32 nm_chn_l2pid : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 4;
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG1_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define NM_DRAM_RULE_CFG2_L_MC_DEC_MEM_CSR_REG_DDR         0x00020C10
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 rule_enable : 1;
    //
    // This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:1], RW, default = 0x0
    //
    UINT32 limit : 26;
    //
    // NmChnWays - Near Memory Channel Ways: used to calculate ChnLID
    //               000 = 1 way (ChnLID = 0)
    //               001 = 2 ways (ChnLID = modulo 2 of System Address)
    //               010 = 3 ways (ChnLID = modulo 3 of System Address)
    //               011 = 8 ways (ChnLID = module 8 of System Address)
    //               100 = 4 ways (ChnLID = module 4 of System Address)
    //         
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINT32 nm_chn_ways : 3;
    //
    // NmChnGran - Near Memory Channel Granularity:
    //               000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved
    //         
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 nm_chn_gran : 2;
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG2_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define NM_DRAM_RULE_CFG2_H_MC_DEC_MEM_CSR_REG_DDR         0x00020C14
typedef union {
  struct {
    //
    // NmChnGran - Near Memory Channel Granularity:
    //               000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved
    //         
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 nm_chn_gran : 1;
    //
    // NmTargetWays - Near Memory Target Ways: used to calculate ChnLID
    //               00 = 1 way
    //               01 = 2 ways
    //               10 = 4 ways
    //               11 = 8 ways
    //         
    // 
    // Bits[2:1], RW, default = 0x0
    //
    UINT32 nm_target_ways : 2;
    //
    // When set to 0, indicate near memory target and channel granularity are different,
    // or target way is 1. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 nm_gran_eq : 1;
    //
    // NmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)
    //               NmChnL2PID[ 2: 0] = mapping from ChnLID=0 to ChnPID
    //               NmChnL2PID[ 5: 3] = mapping from ChnLID=1 to ChnPID
    //               NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to ChnPID
    //               NmChnL2PID[11: 9] = mapping from ChnLID=3 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[14:12] = mapping from ChnLID=4 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[17:15] = mapping from ChnLID=5 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[20:18] = mapping from ChnLID=6 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[23:21] = mapping from ChnLID=7 to ChnPID; only used in
    // HBM mode 
    //               Default value maps ChnLID to the same ChnPID
    //         
    // 
    // Bits[27:4], RW, default = 0xFAC688
    //
    UINT32 nm_chn_l2pid : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 4;
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG2_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define NM_DRAM_RULE_CFG3_L_MC_DEC_MEM_CSR_REG_DDR         0x00020C18
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 rule_enable : 1;
    //
    // This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:1], RW, default = 0x0
    //
    UINT32 limit : 26;
    //
    // NmChnWays - Near Memory Channel Ways: used to calculate ChnLID
    //               000 = 1 way (ChnLID = 0)
    //               001 = 2 ways (ChnLID = modulo 2 of System Address)
    //               010 = 3 ways (ChnLID = modulo 3 of System Address)
    //               011 = 8 ways (ChnLID = module 8 of System Address)
    //               100 = 4 ways (ChnLID = module 4 of System Address)
    //         
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINT32 nm_chn_ways : 3;
    //
    // NmChnGran - Near Memory Channel Granularity:
    //               000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved
    //         
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 nm_chn_gran : 2;
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG3_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define NM_DRAM_RULE_CFG3_H_MC_DEC_MEM_CSR_REG_DDR         0x00020C1C
typedef union {
  struct {
    //
    // NmChnGran - Near Memory Channel Granularity:
    //               000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved
    //         
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 nm_chn_gran : 1;
    //
    // NmTargetWays - Near Memory Target Ways: used to calculate ChnLID
    //               00 = 1 way
    //               01 = 2 ways
    //               10 = 4 ways
    //               11 = 8 ways
    //         
    // 
    // Bits[2:1], RW, default = 0x0
    //
    UINT32 nm_target_ways : 2;
    //
    // When set to 0, indicate near memory target and channel granularity are different,
    // or target way is 1. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 nm_gran_eq : 1;
    //
    // NmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)
    //               NmChnL2PID[ 2: 0] = mapping from ChnLID=0 to ChnPID
    //               NmChnL2PID[ 5: 3] = mapping from ChnLID=1 to ChnPID
    //               NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to ChnPID
    //               NmChnL2PID[11: 9] = mapping from ChnLID=3 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[14:12] = mapping from ChnLID=4 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[17:15] = mapping from ChnLID=5 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[20:18] = mapping from ChnLID=6 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[23:21] = mapping from ChnLID=7 to ChnPID; only used in
    // HBM mode 
    //               Default value maps ChnLID to the same ChnPID
    //         
    // 
    // Bits[27:4], RW, default = 0xFAC688
    //
    UINT32 nm_chn_l2pid : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 4;
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG3_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define NM_DRAM_RULE_CFG4_L_MC_DEC_MEM_CSR_REG_DDR         0x00020C20
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 rule_enable : 1;
    //
    // This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:1], RW, default = 0x0
    //
    UINT32 limit : 26;
    //
    // NmChnWays - Near Memory Channel Ways: used to calculate ChnLID
    //               000 = 1 way (ChnLID = 0)
    //               001 = 2 ways (ChnLID = modulo 2 of System Address)
    //               010 = 3 ways (ChnLID = modulo 3 of System Address)
    //               011 = 8 ways (ChnLID = module 8 of System Address)
    //               100 = 4 ways (ChnLID = module 4 of System Address)
    //         
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINT32 nm_chn_ways : 3;
    //
    // NmChnGran - Near Memory Channel Granularity:
    //               000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved
    //         
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 nm_chn_gran : 2;
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG4_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define NM_DRAM_RULE_CFG4_H_MC_DEC_MEM_CSR_REG_DDR         0x00020C24
typedef union {
  struct {
    //
    // NmChnGran - Near Memory Channel Granularity:
    //               000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved
    //         
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 nm_chn_gran : 1;
    //
    // NmTargetWays - Near Memory Target Ways: used to calculate ChnLID
    //               00 = 1 way
    //               01 = 2 ways
    //               10 = 4 ways
    //               11 = 8 ways
    //         
    // 
    // Bits[2:1], RW, default = 0x0
    //
    UINT32 nm_target_ways : 2;
    //
    // When set to 0, indicate near memory target and channel granularity are different,
    // or target way is 1. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 nm_gran_eq : 1;
    //
    // NmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)
    //               NmChnL2PID[ 2: 0] = mapping from ChnLID=0 to ChnPID
    //               NmChnL2PID[ 5: 3] = mapping from ChnLID=1 to ChnPID
    //               NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to ChnPID
    //               NmChnL2PID[11: 9] = mapping from ChnLID=3 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[14:12] = mapping from ChnLID=4 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[17:15] = mapping from ChnLID=5 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[20:18] = mapping from ChnLID=6 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[23:21] = mapping from ChnLID=7 to ChnPID; only used in
    // HBM mode 
    //               Default value maps ChnLID to the same ChnPID
    //         
    // 
    // Bits[27:4], RW, default = 0xFAC688
    //
    UINT32 nm_chn_l2pid : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 4;
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG4_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define NM_DRAM_RULE_CFG5_L_MC_DEC_MEM_CSR_REG_DDR         0x00020C28
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 rule_enable : 1;
    //
    // This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:1], RW, default = 0x0
    //
    UINT32 limit : 26;
    //
    // NmChnWays - Near Memory Channel Ways: used to calculate ChnLID
    //               000 = 1 way (ChnLID = 0)
    //               001 = 2 ways (ChnLID = modulo 2 of System Address)
    //               010 = 3 ways (ChnLID = modulo 3 of System Address)
    //               011 = 8 ways (ChnLID = module 8 of System Address)
    //               100 = 4 ways (ChnLID = module 4 of System Address)
    //         
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINT32 nm_chn_ways : 3;
    //
    // NmChnGran - Near Memory Channel Granularity:
    //               000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved
    //         
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 nm_chn_gran : 2;
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG5_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define NM_DRAM_RULE_CFG5_H_MC_DEC_MEM_CSR_REG_DDR         0x00020C2C
typedef union {
  struct {
    //
    // NmChnGran - Near Memory Channel Granularity:
    //               000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved
    //         
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 nm_chn_gran : 1;
    //
    // NmTargetWays - Near Memory Target Ways: used to calculate ChnLID
    //               00 = 1 way
    //               01 = 2 ways
    //               10 = 4 ways
    //               11 = 8 ways
    //         
    // 
    // Bits[2:1], RW, default = 0x0
    //
    UINT32 nm_target_ways : 2;
    //
    // When set to 0, indicate near memory target and channel granularity are different,
    // or target way is 1. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 nm_gran_eq : 1;
    //
    // NmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)
    //               NmChnL2PID[ 2: 0] = mapping from ChnLID=0 to ChnPID
    //               NmChnL2PID[ 5: 3] = mapping from ChnLID=1 to ChnPID
    //               NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to ChnPID
    //               NmChnL2PID[11: 9] = mapping from ChnLID=3 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[14:12] = mapping from ChnLID=4 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[17:15] = mapping from ChnLID=5 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[20:18] = mapping from ChnLID=6 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[23:21] = mapping from ChnLID=7 to ChnPID; only used in
    // HBM mode 
    //               Default value maps ChnLID to the same ChnPID
    //         
    // 
    // Bits[27:4], RW, default = 0xFAC688
    //
    UINT32 nm_chn_l2pid : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 4;
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG5_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define NM_DRAM_RULE_CFG6_L_MC_DEC_MEM_CSR_REG_DDR         0x00020C30
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 rule_enable : 1;
    //
    // This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:1], RW, default = 0x0
    //
    UINT32 limit : 26;
    //
    // NmChnWays - Near Memory Channel Ways: used to calculate ChnLID
    //               000 = 1 way (ChnLID = 0)
    //               001 = 2 ways (ChnLID = modulo 2 of System Address)
    //               010 = 3 ways (ChnLID = modulo 3 of System Address)
    //               011 = 8 ways (ChnLID = module 8 of System Address)
    //               100 = 4 ways (ChnLID = module 4 of System Address)
    //         
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINT32 nm_chn_ways : 3;
    //
    // NmChnGran - Near Memory Channel Granularity:
    //               000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved
    //         
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 nm_chn_gran : 2;
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG6_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define NM_DRAM_RULE_CFG6_H_MC_DEC_MEM_CSR_REG_DDR         0x00020C34
typedef union {
  struct {
    //
    // NmChnGran - Near Memory Channel Granularity:
    //               000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved
    //         
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 nm_chn_gran : 1;
    //
    // NmTargetWays - Near Memory Target Ways: used to calculate ChnLID
    //               00 = 1 way
    //               01 = 2 ways
    //               10 = 4 ways
    //               11 = 8 ways
    //         
    // 
    // Bits[2:1], RW, default = 0x0
    //
    UINT32 nm_target_ways : 2;
    //
    // When set to 0, indicate near memory target and channel granularity are different,
    // or target way is 1. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 nm_gran_eq : 1;
    //
    // NmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)
    //               NmChnL2PID[ 2: 0] = mapping from ChnLID=0 to ChnPID
    //               NmChnL2PID[ 5: 3] = mapping from ChnLID=1 to ChnPID
    //               NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to ChnPID
    //               NmChnL2PID[11: 9] = mapping from ChnLID=3 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[14:12] = mapping from ChnLID=4 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[17:15] = mapping from ChnLID=5 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[20:18] = mapping from ChnLID=6 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[23:21] = mapping from ChnLID=7 to ChnPID; only used in
    // HBM mode 
    //               Default value maps ChnLID to the same ChnPID
    //         
    // 
    // Bits[27:4], RW, default = 0xFAC688
    //
    UINT32 nm_chn_l2pid : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 4;
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG6_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define NM_DRAM_RULE_CFG7_L_MC_DEC_MEM_CSR_REG_DDR         0x00020C38
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 rule_enable : 1;
    //
    // This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:1], RW, default = 0x0
    //
    UINT32 limit : 26;
    //
    // NmChnWays - Near Memory Channel Ways: used to calculate ChnLID
    //               000 = 1 way (ChnLID = 0)
    //               001 = 2 ways (ChnLID = modulo 2 of System Address)
    //               010 = 3 ways (ChnLID = modulo 3 of System Address)
    //               011 = 8 ways (ChnLID = module 8 of System Address)
    //               100 = 4 ways (ChnLID = module 4 of System Address)
    //         
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINT32 nm_chn_ways : 3;
    //
    // NmChnGran - Near Memory Channel Granularity:
    //               000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved
    //         
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 nm_chn_gran : 2;
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG7_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define NM_DRAM_RULE_CFG7_H_MC_DEC_MEM_CSR_REG_DDR         0x00020C3C
typedef union {
  struct {
    //
    // NmChnGran - Near Memory Channel Granularity:
    //               000=64B, 001=256B, 010=4KB, 100-111=128B,512B,1KB,2KB; other reserved
    //         
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 nm_chn_gran : 1;
    //
    // NmTargetWays - Near Memory Target Ways: used to calculate ChnLID
    //               00 = 1 way
    //               01 = 2 ways
    //               10 = 4 ways
    //               11 = 8 ways
    //         
    // 
    // Bits[2:1], RW, default = 0x0
    //
    UINT32 nm_target_ways : 2;
    //
    // When set to 0, indicate near memory target and channel granularity are different,
    // or target way is 1. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 nm_gran_eq : 1;
    //
    // NmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)
    //               NmChnL2PID[ 2: 0] = mapping from ChnLID=0 to ChnPID
    //               NmChnL2PID[ 5: 3] = mapping from ChnLID=1 to ChnPID
    //               NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to ChnPID
    //               NmChnL2PID[11: 9] = mapping from ChnLID=3 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[14:12] = mapping from ChnLID=4 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[17:15] = mapping from ChnLID=5 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[20:18] = mapping from ChnLID=6 to ChnPID; only used in
    // HBM mode 
    //               NmChnL2PID[23:21] = mapping from ChnLID=7 to ChnPID; only used in
    // HBM mode 
    //               Default value maps ChnLID to the same ChnPID
    //         
    // 
    // Bits[27:4], RW, default = 0xFAC688
    //
    UINT32 nm_chn_l2pid : 24;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 4;
  } Bits;
  UINT32 Data;
} NM_DRAM_RULE_CFG7_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MC_SAD2TAD_CFG0_MC_DEC_MEM_CSR_REG_DDR             0x00020CC4
typedef union {
  struct {
    //
    // SAD2TAD mapping entry 0 for write through
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINT32 sad2tad0 : 4;
    //
    // SAD2TAD mapping entry 1 for write through
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINT32 sad2tad1 : 4;
    //
    // SAD2TAD mapping entry 2 for write through
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINT32 sad2tad2 : 4;
    //
    // SAD2TAD mapping entry 3 for write through
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINT32 sad2tad3 : 4;
    //
    // SAD2TAD mapping entry 4 for write through
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINT32 sad2tad4 : 4;
    //
    // SAD2TAD mapping entry 5 for write through
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINT32 sad2tad5 : 4;
    //
    // SAD2TAD mapping entry 6 for write through
    // 
    // Bits[27:24], RW, default = 0x0
    //
    UINT32 sad2tad6 : 4;
    //
    // SAD2TAD mapping entry 7 for write through
    // 
    // Bits[31:28], RW, default = 0x0
    //
    UINT32 sad2tad7 : 4;
  } Bits;
  UINT32 Data;
} MC_SAD2TAD_CFG0_MC_DEC_MEM_CSR_STRUCT_DDR;

#define PCOMMIT_CONTROL_MC_DEC_MEM_CSR_REG_DDR             0x00020CD0
typedef union {
  struct {
    //
    // Unused - 
    //                          One bit per MC channel.
    //                          When the bit is set, then a Pcommit will target DDR4
    // on that channel. 
    //                          When the bit is clear, then a Pcommit will target DDRT
    // on that channel. 
    //                      
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 nvdimm_chn_msk : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:3], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 13;
  } Bits;
  UINT32 Data;
} PCOMMIT_CONTROL_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DRAM_RULE_CFG0_L_MC_DEC_MEM_CSR_REG_DDR            0x00020CE8
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 rule_enable : 1;
    //
    // This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:1], RW, default = 0x0
    //
    UINT32 limit : 26;
    //
    // FmTarget - Target Far Memory MC; Bit 0 defines the half target (KNH) that all
    // traffic go to. 
    // 
    // Bits[28:27], RW, default = 0x0
    //
    UINT32 fm_target : 2;
    //
    // FmChnWays - Far Memory Channel Ways: used to calculate ChnLID
    //               00 = 1 way (ChnLID = 0)
    //               01 = 2 ways (ChnLID = modulo 2 of System Address)
    //               10 = 3 ways (ChnLID = modulo 3 of System Address)
    //               11 = Reserved
    //         
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 fm_chn_ways : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG0_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DRAM_RULE_CFG0_H_MC_DEC_MEM_CSR_REG_DDR            0x00020CEC
typedef union {
  struct {
    //
    // FmChnGran - Far Memory Channel Granularity:
    //               001=256B, 010=4KB, 111=2KB, other reserved
    //         
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 fm_chn_gran : 3;
    //
    // FmTargetWays - Far Memory Target Ways: used to calculate ChnLID when fm_gran_eq
    // = 1 
    //               000 = 1 way
    //               001 = 2 ways
    //               010 = 4 ways
    //               011 = 8 ways
    //               100 = 16 ways
    //         
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 fm_target_ways : 3;
    //
    // When set to 0, indicate far memory target and channel granularity are different,
    // or target way is 1. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 fm_gran_eq : 1;
    //
    // FmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)
    //               FmChnL2PID[1:0] = mapping from ChnLID=0 to ChnPID
    //               FmChnL2PID[3:2] = mapping from ChnLID=1 to ChnPID
    //               FmChnL2PID[5:4] = mapping from ChnLID=2 to ChnPID
    //               ChnPID values are 00-01-10, value 11 is not valid
    //         
    // 
    // Bits[12:7], RW, default = 0x24
    //
    UINT32 fm_chn_l2pid : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 19;
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG0_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DRAM_RULE_CFG1_L_MC_DEC_MEM_CSR_REG_DDR            0x00020CF0
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 rule_enable : 1;
    //
    // This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:1], RW, default = 0x0
    //
    UINT32 limit : 26;
    //
    // FmTarget - Target Far Memory MC; Bit 0 defines the half target (KNH) that all
    // traffic go to. 
    // 
    // Bits[28:27], RW, default = 0x0
    //
    UINT32 fm_target : 2;
    //
    // FmChnWays - Far Memory Channel Ways: used to calculate ChnLID
    //               00 = 1 way (ChnLID = 0)
    //               01 = 2 ways (ChnLID = modulo 2 of System Address)
    //               10 = 3 ways (ChnLID = modulo 3 of System Address)
    //               11 = Reserved
    //         
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 fm_chn_ways : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG1_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DRAM_RULE_CFG1_H_MC_DEC_MEM_CSR_REG_DDR            0x00020CF4
typedef union {
  struct {
    //
    // FmChnGran - Far Memory Channel Granularity:
    //               001=256B, 010=4KB, 111=2KB, other reserved
    //         
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 fm_chn_gran : 3;
    //
    // FmTargetWays - Far Memory Target Ways: used to calculate ChnLID when fm_gran_eq
    // = 1 
    //               000 = 1 way
    //               001 = 2 ways
    //               010 = 4 ways
    //               011 = 8 ways
    //               100 = 16 ways
    //         
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 fm_target_ways : 3;
    //
    // When set to 0, indicate far memory target and channel granularity are different,
    // or target way is 1. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 fm_gran_eq : 1;
    //
    // FmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)
    //               FmChnL2PID[1:0] = mapping from ChnLID=0 to ChnPID
    //               FmChnL2PID[3:2] = mapping from ChnLID=1 to ChnPID
    //               FmChnL2PID[5:4] = mapping from ChnLID=2 to ChnPID
    //               ChnPID values are 00-01-10, value 11 is not valid
    //         
    // 
    // Bits[12:7], RW, default = 0x24
    //
    UINT32 fm_chn_l2pid : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 19;
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG1_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DRAM_RULE_CFG2_L_MC_DEC_MEM_CSR_REG_DDR            0x00020CF8
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 rule_enable : 1;
    //
    // This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:1], RW, default = 0x0
    //
    UINT32 limit : 26;
    //
    // FmTarget - Target Far Memory MC; Bit 0 defines the half target (KNH) that all
    // traffic go to. 
    // 
    // Bits[28:27], RW, default = 0x0
    //
    UINT32 fm_target : 2;
    //
    // FmChnWays - Far Memory Channel Ways: used to calculate ChnLID
    //               00 = 1 way (ChnLID = 0)
    //               01 = 2 ways (ChnLID = modulo 2 of System Address)
    //               10 = 3 ways (ChnLID = modulo 3 of System Address)
    //               11 = Reserved
    //         
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 fm_chn_ways : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG2_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DRAM_RULE_CFG2_H_MC_DEC_MEM_CSR_REG_DDR            0x00020CFC
typedef union {
  struct {
    //
    // FmChnGran - Far Memory Channel Granularity:
    //               001=256B, 010=4KB, 111=2KB, other reserved
    //         
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 fm_chn_gran : 3;
    //
    // FmTargetWays - Far Memory Target Ways: used to calculate ChnLID when fm_gran_eq
    // = 1 
    //               000 = 1 way
    //               001 = 2 ways
    //               010 = 4 ways
    //               011 = 8 ways
    //               100 = 16 ways
    //         
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 fm_target_ways : 3;
    //
    // When set to 0, indicate far memory target and channel granularity are different,
    // or target way is 1. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 fm_gran_eq : 1;
    //
    // FmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)
    //               FmChnL2PID[1:0] = mapping from ChnLID=0 to ChnPID
    //               FmChnL2PID[3:2] = mapping from ChnLID=1 to ChnPID
    //               FmChnL2PID[5:4] = mapping from ChnLID=2 to ChnPID
    //               ChnPID values are 00-01-10, value 11 is not valid
    //         
    // 
    // Bits[12:7], RW, default = 0x24
    //
    UINT32 fm_chn_l2pid : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 19;
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG2_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DRAM_RULE_CFG3_L_MC_DEC_MEM_CSR_REG_DDR            0x00020D00
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 rule_enable : 1;
    //
    // This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:1], RW, default = 0x0
    //
    UINT32 limit : 26;
    //
    // FmTarget - Target Far Memory MC; Bit 0 defines the half target (KNH) that all
    // traffic go to. 
    // 
    // Bits[28:27], RW, default = 0x0
    //
    UINT32 fm_target : 2;
    //
    // FmChnWays - Far Memory Channel Ways: used to calculate ChnLID
    //               00 = 1 way (ChnLID = 0)
    //               01 = 2 ways (ChnLID = modulo 2 of System Address)
    //               10 = 3 ways (ChnLID = modulo 3 of System Address)
    //               11 = Reserved
    //         
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 fm_chn_ways : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG3_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DRAM_RULE_CFG3_H_MC_DEC_MEM_CSR_REG_DDR            0x00020D04
typedef union {
  struct {
    //
    // FmChnGran - Far Memory Channel Granularity:
    //               001=256B, 010=4KB, 111=2KB, other reserved
    //         
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 fm_chn_gran : 3;
    //
    // FmTargetWays - Far Memory Target Ways: used to calculate ChnLID when fm_gran_eq
    // = 1 
    //               000 = 1 way
    //               001 = 2 ways
    //               010 = 4 ways
    //               011 = 8 ways
    //               100 = 16 ways
    //         
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 fm_target_ways : 3;
    //
    // When set to 0, indicate far memory target and channel granularity are different,
    // or target way is 1. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 fm_gran_eq : 1;
    //
    // FmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)
    //               FmChnL2PID[1:0] = mapping from ChnLID=0 to ChnPID
    //               FmChnL2PID[3:2] = mapping from ChnLID=1 to ChnPID
    //               FmChnL2PID[5:4] = mapping from ChnLID=2 to ChnPID
    //               ChnPID values are 00-01-10, value 11 is not valid
    //         
    // 
    // Bits[12:7], RW, default = 0x24
    //
    UINT32 fm_chn_l2pid : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 19;
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG3_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DRAM_RULE_CFG4_L_MC_DEC_MEM_CSR_REG_DDR            0x00020D08
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 rule_enable : 1;
    //
    // This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:1], RW, default = 0x0
    //
    UINT32 limit : 26;
    //
    // FmTarget - Target Far Memory MC; Bit 0 defines the half target (KNH) that all
    // traffic go to. 
    // 
    // Bits[28:27], RW, default = 0x0
    //
    UINT32 fm_target : 2;
    //
    // FmChnWays - Far Memory Channel Ways: used to calculate ChnLID
    //               00 = 1 way (ChnLID = 0)
    //               01 = 2 ways (ChnLID = modulo 2 of System Address)
    //               10 = 3 ways (ChnLID = modulo 3 of System Address)
    //               11 = Reserved
    //         
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 fm_chn_ways : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG4_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DRAM_RULE_CFG4_H_MC_DEC_MEM_CSR_REG_DDR            0x00020D0C
typedef union {
  struct {
    //
    // FmChnGran - Far Memory Channel Granularity:
    //               001=256B, 010=4KB, 111=2KB, other reserved
    //         
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 fm_chn_gran : 3;
    //
    // FmTargetWays - Far Memory Target Ways: used to calculate ChnLID when fm_gran_eq
    // = 1 
    //               000 = 1 way
    //               001 = 2 ways
    //               010 = 4 ways
    //               011 = 8 ways
    //               100 = 16 ways
    //         
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 fm_target_ways : 3;
    //
    // When set to 0, indicate far memory target and channel granularity are different,
    // or target way is 1. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 fm_gran_eq : 1;
    //
    // FmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)
    //               FmChnL2PID[1:0] = mapping from ChnLID=0 to ChnPID
    //               FmChnL2PID[3:2] = mapping from ChnLID=1 to ChnPID
    //               FmChnL2PID[5:4] = mapping from ChnLID=2 to ChnPID
    //               ChnPID values are 00-01-10, value 11 is not valid
    //         
    // 
    // Bits[12:7], RW, default = 0x24
    //
    UINT32 fm_chn_l2pid : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 19;
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG4_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DRAM_RULE_CFG5_L_MC_DEC_MEM_CSR_REG_DDR            0x00020D10
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 rule_enable : 1;
    //
    // This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:1], RW, default = 0x0
    //
    UINT32 limit : 26;
    //
    // FmTarget - Target Far Memory MC; Bit 0 defines the half target (KNH) that all
    // traffic go to. 
    // 
    // Bits[28:27], RW, default = 0x0
    //
    UINT32 fm_target : 2;
    //
    // FmChnWays - Far Memory Channel Ways: used to calculate ChnLID
    //               00 = 1 way (ChnLID = 0)
    //               01 = 2 ways (ChnLID = modulo 2 of System Address)
    //               10 = 3 ways (ChnLID = modulo 3 of System Address)
    //               11 = Reserved
    //         
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 fm_chn_ways : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG5_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DRAM_RULE_CFG5_H_MC_DEC_MEM_CSR_REG_DDR            0x00020D14
typedef union {
  struct {
    //
    // FmChnGran - Far Memory Channel Granularity:
    //               001=256B, 010=4KB, 111=2KB, other reserved
    //         
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 fm_chn_gran : 3;
    //
    // FmTargetWays - Far Memory Target Ways: used to calculate ChnLID when fm_gran_eq
    // = 1 
    //               000 = 1 way
    //               001 = 2 ways
    //               010 = 4 ways
    //               011 = 8 ways
    //               100 = 16 ways
    //         
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 fm_target_ways : 3;
    //
    // When set to 0, indicate far memory target and channel granularity are different,
    // or target way is 1. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 fm_gran_eq : 1;
    //
    // FmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)
    //               FmChnL2PID[1:0] = mapping from ChnLID=0 to ChnPID
    //               FmChnL2PID[3:2] = mapping from ChnLID=1 to ChnPID
    //               FmChnL2PID[5:4] = mapping from ChnLID=2 to ChnPID
    //               ChnPID values are 00-01-10, value 11 is not valid
    //         
    // 
    // Bits[12:7], RW, default = 0x24
    //
    UINT32 fm_chn_l2pid : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 19;
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG5_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DRAM_RULE_CFG6_L_MC_DEC_MEM_CSR_REG_DDR            0x00020D18
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 rule_enable : 1;
    //
    // This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:1], RW, default = 0x0
    //
    UINT32 limit : 26;
    //
    // FmTarget - Target Far Memory MC; Bit 0 defines the half target (KNH) that all
    // traffic go to. 
    // 
    // Bits[28:27], RW, default = 0x0
    //
    UINT32 fm_target : 2;
    //
    // FmChnWays - Far Memory Channel Ways: used to calculate ChnLID
    //               00 = 1 way (ChnLID = 0)
    //               01 = 2 ways (ChnLID = modulo 2 of System Address)
    //               10 = 3 ways (ChnLID = modulo 3 of System Address)
    //               11 = Reserved
    //         
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 fm_chn_ways : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG6_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DRAM_RULE_CFG6_H_MC_DEC_MEM_CSR_REG_DDR            0x00020D1C
typedef union {
  struct {
    //
    // FmChnGran - Far Memory Channel Granularity:
    //               001=256B, 010=4KB, 111=2KB, other reserved
    //         
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 fm_chn_gran : 3;
    //
    // FmTargetWays - Far Memory Target Ways: used to calculate ChnLID when fm_gran_eq
    // = 1 
    //               000 = 1 way
    //               001 = 2 ways
    //               010 = 4 ways
    //               011 = 8 ways
    //               100 = 16 ways
    //         
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 fm_target_ways : 3;
    //
    // When set to 0, indicate far memory target and channel granularity are different,
    // or target way is 1. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 fm_gran_eq : 1;
    //
    // FmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)
    //               FmChnL2PID[1:0] = mapping from ChnLID=0 to ChnPID
    //               FmChnL2PID[3:2] = mapping from ChnLID=1 to ChnPID
    //               FmChnL2PID[5:4] = mapping from ChnLID=2 to ChnPID
    //               ChnPID values are 00-01-10, value 11 is not valid
    //         
    // 
    // Bits[12:7], RW, default = 0x24
    //
    UINT32 fm_chn_l2pid : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 19;
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG6_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DRAM_RULE_CFG7_L_MC_DEC_MEM_CSR_REG_DDR            0x00020D20
typedef union {
  struct {
    //
    // Enable for this DRAM rule.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 rule_enable : 1;
    //
    // This correspond to Addr[51:26] of the DRAM rule top limit address. Must be strickly
    // greater then previous rule, even if this rule is disabled, unless this rule and
    // all following rules are disabled. Lower limit is the previous rule (or 0 if this
    // is the first rule) 
    // 
    // Bits[26:1], RW, default = 0x0
    //
    UINT32 limit : 26;
    //
    // FmTarget - Target Far Memory MC; Bit 0 defines the half target (KNH) that all
    // traffic go to. 
    // 
    // Bits[28:27], RW, default = 0x0
    //
    UINT32 fm_target : 2;
    //
    // FmChnWays - Far Memory Channel Ways: used to calculate ChnLID
    //               00 = 1 way (ChnLID = 0)
    //               01 = 2 ways (ChnLID = modulo 2 of System Address)
    //               10 = 3 ways (ChnLID = modulo 3 of System Address)
    //               11 = Reserved
    //         
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 fm_chn_ways : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG7_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DRAM_RULE_CFG7_H_MC_DEC_MEM_CSR_REG_DDR            0x00020D24
typedef union {
  struct {
    //
    // FmChnGran - Far Memory Channel Granularity:
    //               001=256B, 010=4KB, 111=2KB, other reserved
    //         
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 fm_chn_gran : 3;
    //
    // FmTargetWays - Far Memory Target Ways: used to calculate ChnLID when fm_gran_eq
    // = 1 
    //               000 = 1 way
    //               001 = 2 ways
    //               010 = 4 ways
    //               011 = 8 ways
    //               100 = 16 ways
    //         
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 fm_target_ways : 3;
    //
    // When set to 0, indicate far memory target and channel granularity are different,
    // or target way is 1. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 fm_gran_eq : 1;
    //
    // FmChnL2PID - translation table for Logical (ChnLID) to Physical ID (ChnPID)
    //               FmChnL2PID[1:0] = mapping from ChnLID=0 to ChnPID
    //               FmChnL2PID[3:2] = mapping from ChnLID=1 to ChnPID
    //               FmChnL2PID[5:4] = mapping from ChnLID=2 to ChnPID
    //               ChnPID values are 00-01-10, value 11 is not valid
    //         
    // 
    // Bits[12:7], RW, default = 0x24
    //
    UINT32 fm_chn_l2pid : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 19;
  } Bits;
  UINT32 Data;
} DRAM_RULE_CFG7_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MCNMCACHINGCFG_MC_DEC_MEM_CSR_REG_DDR              0x00020DAC
typedef union {
  struct {
    //
    // Enables 2LM near memory caching of far memory if set. Locked by 2LM disable uCR.
    // This field is programmed on the per iMC basis, i.e. need to maintain consistency
    // with other populated channels in this iMC.  A related register - McNMCachingCfg2
    // - is per channel and is located in MC2LMCNTL block. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 mcnmcachingenb : 1;
    //
    // 1LM or 2LM mode but with AG2 memory enabled if set. Locked by PMem disable uCR.
    // This field is programmed on the per iMC basis, i.e. need to maintain consistency
    // with other populated channels in this iMC. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 mcpmemenb : 1;
    //
    // For PMem transactions, write to both near and far memory if set. Locked by PMem
    // Write-Thru disable uCR. This field is programmed on the per iMC basis, i.e. need
    // to maintain consistency with other populated channels in this iMC. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 mcnmcachingpmemwt : 1;
    //
    // For WCILF if NM dir=i/s do not squash the fillrd on a miss if this bit is set
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 wcilfoptdis : 1;
    //
    // Reserved
    // 
    // Bits[7:4], RO, default = 0x0
    //
    UINT32 rsvd0 : 4;
    //
    // Configured for mirroring - far memory is in the same channel as near memory if
    // set. Locked by mirroring disable uCR. This field is programmed on the per iMC
    // basis, i.e. need to maintain consistency with other populated channels in this
    // iMC. 
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 mcmirrormode : 1;
    //
    // TAD index used for 2LM NM for patrol and sparing address generation.
    // 
    // Bits[11:9], RW, default = 0x0
    //
    UINT32 nmcachingtad : 3;
    //
    // Enable for TAD index used for 2LM NM for patrol and sparing address generation.
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINT32 nmcachingtaden : 1;
    //
    // Force all patrol transaction destination to 2LM NM.
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINT32 patforcenm : 1;
    //
    // Force all sparing transaction destination to 2LM NM.
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Reserved
    // 
    // Bits[31:15], RO, default = 0x0
    //
    UINT32 rsvd1 : 17;
  } Bits;
  UINT32 Data;
} MCNMCACHINGCFG_MC_DEC_MEM_CSR_STRUCT_DDR;

#define TADBASE_0_MC_DEC_MEM_CSR_REG_DDR                   0x00020DB0
typedef union {
  struct {
    //
    // Mirroring enabled on this TAD 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 mirror_en : 1;
    //
    // Set to 1 to indicate mirror failover happened on this TAD. Patrol address to the
    // channel programmed in failed_ch for this TAD will be skipped. Set to 1 for the
    // failed channel and also the channel whose mirror channel has failed. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 en_failover : 1;
    //
    // Downgrades patrol scrubbing uncorrectable errors to correactable for this TAD
    // range. Use for partial mirroring mode. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 ign_ptrl_uc : 1;
    //
    // lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[51:26].
    // 
    // Bits[28:3], RW, default = 0x0
    //
    UINT32 base : 26;
    //
    // Used when en_failover bit is set for this TAD. Indicates the channel that has
    // failed. 
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 failed_ch : 2;
    //
    // This TAD is used for Dedup region
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 dedup_en : 1;
  } Bits;
  UINT32 Data;
} TADBASE_0_MC_DEC_MEM_CSR_STRUCT_DDR;

#define TADBASE_1_MC_DEC_MEM_CSR_REG_DDR                   0x00020DB4
typedef union {
  struct {
    //
    // Mirroring enabled on this TAD 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 mirror_en : 1;
    //
    // Set to 1 to indicate mirror failover happened on this TAD. Patrol address to the
    // channel programmed in failed_ch for this TAD will be skipped. Set to 1 for the
    // failed channel and also the channel whose mirror channel has failed. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 en_failover : 1;
    //
    // Downgrades patrol scrubbing uncorrectable errors to correactable for this TAD
    // range. Use for partial mirroring mode. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 ign_ptrl_uc : 1;
    //
    // lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[51:26].
    // 
    // Bits[28:3], RW, default = 0x0
    //
    UINT32 base : 26;
    //
    // Used when en_failover bit is set for this TAD. Indicates the channel that has
    // failed. 
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 failed_ch : 2;
    //
    // This TAD is used for Dedup region
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 dedup_en : 1;
  } Bits;
  UINT32 Data;
} TADBASE_1_MC_DEC_MEM_CSR_STRUCT_DDR;

#define TADBASE_2_MC_DEC_MEM_CSR_REG_DDR                   0x00020DB8
typedef union {
  struct {
    //
    // Mirroring enabled on this TAD 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 mirror_en : 1;
    //
    // Set to 1 to indicate mirror failover happened on this TAD. Patrol address to the
    // channel programmed in failed_ch for this TAD will be skipped. Set to 1 for the
    // failed channel and also the channel whose mirror channel has failed. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 en_failover : 1;
    //
    // Downgrades patrol scrubbing uncorrectable errors to correactable for this TAD
    // range. Use for partial mirroring mode. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 ign_ptrl_uc : 1;
    //
    // lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[51:26].
    // 
    // Bits[28:3], RW, default = 0x0
    //
    UINT32 base : 26;
    //
    // Used when en_failover bit is set for this TAD. Indicates the channel that has
    // failed. 
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 failed_ch : 2;
    //
    // This TAD is used for Dedup region
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 dedup_en : 1;
  } Bits;
  UINT32 Data;
} TADBASE_2_MC_DEC_MEM_CSR_STRUCT_DDR;

#define TADBASE_3_MC_DEC_MEM_CSR_REG_DDR                   0x00020DBC
typedef union {
  struct {
    //
    // Mirroring enabled on this TAD 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 mirror_en : 1;
    //
    // Set to 1 to indicate mirror failover happened on this TAD. Patrol address to the
    // channel programmed in failed_ch for this TAD will be skipped. Set to 1 for the
    // failed channel and also the channel whose mirror channel has failed. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 en_failover : 1;
    //
    // Downgrades patrol scrubbing uncorrectable errors to correactable for this TAD
    // range. Use for partial mirroring mode. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 ign_ptrl_uc : 1;
    //
    // lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[51:26].
    // 
    // Bits[28:3], RW, default = 0x0
    //
    UINT32 base : 26;
    //
    // Used when en_failover bit is set for this TAD. Indicates the channel that has
    // failed. 
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 failed_ch : 2;
    //
    // This TAD is used for Dedup region
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 dedup_en : 1;
  } Bits;
  UINT32 Data;
} TADBASE_3_MC_DEC_MEM_CSR_STRUCT_DDR;

#define TADBASE_4_MC_DEC_MEM_CSR_REG_DDR                   0x00020DC0
typedef union {
  struct {
    //
    // Mirroring enabled on this TAD 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 mirror_en : 1;
    //
    // Set to 1 to indicate mirror failover happened on this TAD. Patrol address to the
    // channel programmed in failed_ch for this TAD will be skipped. Set to 1 for the
    // failed channel and also the channel whose mirror channel has failed. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 en_failover : 1;
    //
    // Downgrades patrol scrubbing uncorrectable errors to correactable for this TAD
    // range. Use for partial mirroring mode. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 ign_ptrl_uc : 1;
    //
    // lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[51:26].
    // 
    // Bits[28:3], RW, default = 0x0
    //
    UINT32 base : 26;
    //
    // Used when en_failover bit is set for this TAD. Indicates the channel that has
    // failed. 
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 failed_ch : 2;
    //
    // This TAD is used for Dedup region
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 dedup_en : 1;
  } Bits;
  UINT32 Data;
} TADBASE_4_MC_DEC_MEM_CSR_STRUCT_DDR;

#define TADBASE_5_MC_DEC_MEM_CSR_REG_DDR                   0x00020DC4
typedef union {
  struct {
    //
    // Mirroring enabled on this TAD 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 mirror_en : 1;
    //
    // Set to 1 to indicate mirror failover happened on this TAD. Patrol address to the
    // channel programmed in failed_ch for this TAD will be skipped. Set to 1 for the
    // failed channel and also the channel whose mirror channel has failed. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 en_failover : 1;
    //
    // Downgrades patrol scrubbing uncorrectable errors to correactable for this TAD
    // range. Use for partial mirroring mode. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 ign_ptrl_uc : 1;
    //
    // lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[51:26].
    // 
    // Bits[28:3], RW, default = 0x0
    //
    UINT32 base : 26;
    //
    // Used when en_failover bit is set for this TAD. Indicates the channel that has
    // failed. 
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 failed_ch : 2;
    //
    // This TAD is used for Dedup region
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 dedup_en : 1;
  } Bits;
  UINT32 Data;
} TADBASE_5_MC_DEC_MEM_CSR_STRUCT_DDR;

#define TADBASE_6_MC_DEC_MEM_CSR_REG_DDR                   0x00020DC8
typedef union {
  struct {
    //
    // Mirroring enabled on this TAD 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 mirror_en : 1;
    //
    // Set to 1 to indicate mirror failover happened on this TAD. Patrol address to the
    // channel programmed in failed_ch for this TAD will be skipped. Set to 1 for the
    // failed channel and also the channel whose mirror channel has failed. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 en_failover : 1;
    //
    // Downgrades patrol scrubbing uncorrectable errors to correactable for this TAD
    // range. Use for partial mirroring mode. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 ign_ptrl_uc : 1;
    //
    // lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[51:26].
    // 
    // Bits[28:3], RW, default = 0x0
    //
    UINT32 base : 26;
    //
    // Used when en_failover bit is set for this TAD. Indicates the channel that has
    // failed. 
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 failed_ch : 2;
    //
    // This TAD is used for Dedup region
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 dedup_en : 1;
  } Bits;
  UINT32 Data;
} TADBASE_6_MC_DEC_MEM_CSR_STRUCT_DDR;

#define TADBASE_7_MC_DEC_MEM_CSR_REG_DDR                   0x00020DCC
typedef union {
  struct {
    //
    // Mirroring enabled on this TAD 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 mirror_en : 1;
    //
    // Set to 1 to indicate mirror failover happened on this TAD. Patrol address to the
    // channel programmed in failed_ch for this TAD will be skipped. Set to 1 for the
    // failed channel and also the channel whose mirror channel has failed. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 en_failover : 1;
    //
    // Downgrades patrol scrubbing uncorrectable errors to correactable for this TAD
    // range. Use for partial mirroring mode. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 ign_ptrl_uc : 1;
    //
    // lowest address of the range in system address space, 64MB granularity, i.e. TADRANGEBASE[51:26].
    // 
    // Bits[28:3], RW, default = 0x0
    //
    UINT32 base : 26;
    //
    // Used when en_failover bit is set for this TAD. Indicates the channel that has
    // failed. 
    // 
    // Bits[30:29], RW, default = 0x0
    //
    UINT32 failed_ch : 2;
    //
    // This TAD is used for Dedup region
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 dedup_en : 1;
  } Bits;
  UINT32 Data;
} TADBASE_7_MC_DEC_MEM_CSR_STRUCT_DDR;

#define TADWAYNESS_0_MC_DEC_MEM_CSR_REG_DDR                0x00020DD4
typedef union {
  struct {
    //
    // 
    //          TargetLID: target logical ID, a.k.a., base_offset
    //          The position of the MC in the socket interleave list in the SAD rule
    // that maps to this TAD rule. 
    //          If 1-way interleaved to one MC, base_offset is 0.
    //          If 2-way interleaved across two MCs, base_offset is either 0 or 1.
    //          4-way, 0 through 3.  8-way, 0 through 7.
    //       
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 target_lid : 3;
    //
    // ChnLID: channel logical ID. logical channel for channel interleave.
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 chn_lid : 3;
    //
    // highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[51:26].
    // In case of 3 channel interleave, exclude the address not accessed by the system,
    // even if the address is valid in memory. 
    // 
    // Bits[31:6], RW, default = 0x0
    //
    UINT32 tad_limit : 26;
  } Bits;
  UINT32 Data;
} TADWAYNESS_0_MC_DEC_MEM_CSR_STRUCT_DDR;

#define TADWAYNESS_1_MC_DEC_MEM_CSR_REG_DDR                0x00020DD8
typedef union {
  struct {
    //
    // 
    //          TargetLID: target logical ID, a.k.a., base_offset
    //          The position of the MC in the socket interleave list in the SAD rule
    // that maps to this TAD rule. 
    //          If 1-way interleaved to one MC, base_offset is 0.
    //          If 2-way interleaved across two MCs, base_offset is either 0 or 1.
    //          4-way, 0 through 3.  8-way, 0 through 7.
    //       
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 target_lid : 3;
    //
    // ChnLID: channel logical ID. logical channel for channel interleave.
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 chn_lid : 3;
    //
    // highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[51:26].
    // In case of 3 channel interleave, exclude the address not accessed by the system,
    // even if the address is valid in memory. 
    // 
    // Bits[31:6], RW, default = 0x0
    //
    UINT32 tad_limit : 26;
  } Bits;
  UINT32 Data;
} TADWAYNESS_1_MC_DEC_MEM_CSR_STRUCT_DDR;

#define TADWAYNESS_2_MC_DEC_MEM_CSR_REG_DDR                0x00020DDC
typedef union {
  struct {
    //
    // 
    //          TargetLID: target logical ID, a.k.a., base_offset
    //          The position of the MC in the socket interleave list in the SAD rule
    // that maps to this TAD rule. 
    //          If 1-way interleaved to one MC, base_offset is 0.
    //          If 2-way interleaved across two MCs, base_offset is either 0 or 1.
    //          4-way, 0 through 3.  8-way, 0 through 7.
    //       
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 target_lid : 3;
    //
    // ChnLID: channel logical ID. logical channel for channel interleave.
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 chn_lid : 3;
    //
    // highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[51:26].
    // In case of 3 channel interleave, exclude the address not accessed by the system,
    // even if the address is valid in memory. 
    // 
    // Bits[31:6], RW, default = 0x0
    //
    UINT32 tad_limit : 26;
  } Bits;
  UINT32 Data;
} TADWAYNESS_2_MC_DEC_MEM_CSR_STRUCT_DDR;

#define TADWAYNESS_3_MC_DEC_MEM_CSR_REG_DDR                0x00020DE0
typedef union {
  struct {
    //
    // 
    //          TargetLID: target logical ID, a.k.a., base_offset
    //          The position of the MC in the socket interleave list in the SAD rule
    // that maps to this TAD rule. 
    //          If 1-way interleaved to one MC, base_offset is 0.
    //          If 2-way interleaved across two MCs, base_offset is either 0 or 1.
    //          4-way, 0 through 3.  8-way, 0 through 7.
    //       
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 target_lid : 3;
    //
    // ChnLID: channel logical ID. logical channel for channel interleave.
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 chn_lid : 3;
    //
    // highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[51:26].
    // In case of 3 channel interleave, exclude the address not accessed by the system,
    // even if the address is valid in memory. 
    // 
    // Bits[31:6], RW, default = 0x0
    //
    UINT32 tad_limit : 26;
  } Bits;
  UINT32 Data;
} TADWAYNESS_3_MC_DEC_MEM_CSR_STRUCT_DDR;

#define TADWAYNESS_4_MC_DEC_MEM_CSR_REG_DDR                0x00020DE4
typedef union {
  struct {
    //
    // 
    //          TargetLID: target logical ID, a.k.a., base_offset
    //          The position of the MC in the socket interleave list in the SAD rule
    // that maps to this TAD rule. 
    //          If 1-way interleaved to one MC, base_offset is 0.
    //          If 2-way interleaved across two MCs, base_offset is either 0 or 1.
    //          4-way, 0 through 3.  8-way, 0 through 7.
    //       
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 target_lid : 3;
    //
    // ChnLID: channel logical ID. logical channel for channel interleave.
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 chn_lid : 3;
    //
    // highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[51:26].
    // In case of 3 channel interleave, exclude the address not accessed by the system,
    // even if the address is valid in memory. 
    // 
    // Bits[31:6], RW, default = 0x0
    //
    UINT32 tad_limit : 26;
  } Bits;
  UINT32 Data;
} TADWAYNESS_4_MC_DEC_MEM_CSR_STRUCT_DDR;

#define TADWAYNESS_5_MC_DEC_MEM_CSR_REG_DDR                0x00020DE8
typedef union {
  struct {
    //
    // 
    //          TargetLID: target logical ID, a.k.a., base_offset
    //          The position of the MC in the socket interleave list in the SAD rule
    // that maps to this TAD rule. 
    //          If 1-way interleaved to one MC, base_offset is 0.
    //          If 2-way interleaved across two MCs, base_offset is either 0 or 1.
    //          4-way, 0 through 3.  8-way, 0 through 7.
    //       
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 target_lid : 3;
    //
    // ChnLID: channel logical ID. logical channel for channel interleave.
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 chn_lid : 3;
    //
    // highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[51:26].
    // In case of 3 channel interleave, exclude the address not accessed by the system,
    // even if the address is valid in memory. 
    // 
    // Bits[31:6], RW, default = 0x0
    //
    UINT32 tad_limit : 26;
  } Bits;
  UINT32 Data;
} TADWAYNESS_5_MC_DEC_MEM_CSR_STRUCT_DDR;

#define TADWAYNESS_6_MC_DEC_MEM_CSR_REG_DDR                0x00020DEC
typedef union {
  struct {
    //
    // 
    //          TargetLID: target logical ID, a.k.a., base_offset
    //          The position of the MC in the socket interleave list in the SAD rule
    // that maps to this TAD rule. 
    //          If 1-way interleaved to one MC, base_offset is 0.
    //          If 2-way interleaved across two MCs, base_offset is either 0 or 1.
    //          4-way, 0 through 3.  8-way, 0 through 7.
    //       
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 target_lid : 3;
    //
    // ChnLID: channel logical ID. logical channel for channel interleave.
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 chn_lid : 3;
    //
    // highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[51:26].
    // In case of 3 channel interleave, exclude the address not accessed by the system,
    // even if the address is valid in memory. 
    // 
    // Bits[31:6], RW, default = 0x0
    //
    UINT32 tad_limit : 26;
  } Bits;
  UINT32 Data;
} TADWAYNESS_6_MC_DEC_MEM_CSR_STRUCT_DDR;

#define TADWAYNESS_7_MC_DEC_MEM_CSR_REG_DDR                0x00020DF0
typedef union {
  struct {
    //
    // 
    //          TargetLID: target logical ID, a.k.a., base_offset
    //          The position of the MC in the socket interleave list in the SAD rule
    // that maps to this TAD rule. 
    //          If 1-way interleaved to one MC, base_offset is 0.
    //          If 2-way interleaved across two MCs, base_offset is either 0 or 1.
    //          4-way, 0 through 3.  8-way, 0 through 7.
    //       
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 target_lid : 3;
    //
    // ChnLID: channel logical ID. logical channel for channel interleave.
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 chn_lid : 3;
    //
    // highest address of the range in system address space, 64MB granularity, i.e. TADRANGLIMIT[51:26].
    // In case of 3 channel interleave, exclude the address not accessed by the system,
    // even if the address is valid in memory. 
    // 
    // Bits[31:6], RW, default = 0x0
    //
    UINT32 tad_limit : 26;
  } Bits;
  UINT32 Data;
} TADWAYNESS_7_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MCMTR2_MC_DEC_MEM_CSR_REG_DDR                      0x00020DF4
typedef union {
  struct {
    //
    // Monroe Technology software channel force SRcontrol. When set, the corresponding
    // channel is ignoring the ForceSRExit. A new transaction arrive at this channel
    // will still cause the SR exit. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 monroe_chn_force_sr : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:1], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // This bit is set to designate access to exclusive functionality in ADDDC. Both
    // adddc_exclusive and adddc_exclusive2 need to be set for the exclusive functionality
    // to work. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 adddc_exclusive2 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 27;
  } Bits;
  UINT32 Data;
} MCMTR2_MC_DEC_MEM_CSR_STRUCT_DDR;

#define RCOMP_TIMER_MC_DEC_MEM_CSR_REG_DDR                 0x00020DFC
typedef union {
  struct {
    //
    // Unused spare bits.  There is no logic behind this field
    // 
    // Bits[15:0], RW, default = 0x0
    //
    UINT32 count : 16;
    //
    // This is a status bit that indicates the first RCOMP has been completed. It is
    // cleared on reset, and set by MC HW when the first RCOMP is completed. Bios should
    // wait until this bit is set before executing any DDR command 
    // 
    // Bits[16:16], RW/V, default = 0x0
    //
    UINT32 first_rcomp_done : 1;
    //
    // Increase RCOMP quiet time.
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 increase_rcomp : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
    //
    // no mdll fsm override.
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 no_mdll_fsm_override : 1;
    //
    // ignore mdll locked bit.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 ignore_mdll_locked_bit : 1;
    //
    // Count for timer to expire before asserting spid_bus_quiet_time_gnt. Value = global
    // sched blocking time + roundtrip time 
    // 
    // Bits[29:22], RW, default = 0x2C
    //
    UINT32 rcompblock : 8;
    //
    // Unused. Intel reserved
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 unused : 1;
    //
    // rcomp is in progress.
    // 
    // Bits[31:31], RW/V, default = 0x0
    //
    UINT32 rcomp_in_progress : 1;
  } Bits;
  UINT32 Data;
} RCOMP_TIMER_MC_DEC_MEM_CSR_STRUCT_DDR;

#define IMC_FUSE_DOWNLOAD_SHADOW_MC_DEC_MEM_CSR_REG_DDR    0x00020E00
typedef union {
  struct {
    //
    // Fused channel disable control. When set, the corresponding channel is disabled.
    // Fuse download may change the default value after reset de-assertion. Setting to
    // all 1 may disable msg channel. 
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_chn_disable_mc0 : 1;
    //
    // Fused channel disable control. When set, the corresponding channel is disabled.
    // Fuse download may change the default value after reset de-assertion. Setting to
    // all 1 may disable msg channel. 
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_persistent_cache : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:2], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Force ddr4 command address parity to be zero. This requires DDR4 DRAMs to be initialized
    // to disable parity checking. 
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_ddr4_caparity : 1;
    //
    // Fused 2 DPC disable control. When set, CS signals for DIMM slot 1 (i.e. slot 0
    // is not disabled) are disabled. Note: some CS may have multiplexed with address
    // signal to support extended addressing. The CS signal disabling is only applicable
    // to CS not the being multiplexed with address. Fuse download may change the default
    // value after reset de-assertion. 
    // 
    // Bits[4:4], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_2_dpc : 1;
    //
    // Fused patrol scrub disable control. When set, rank patrol scrub is disabled. Fuse
    // download may change the default value after reset de-assertion. 
    // 
    // Bits[5:5], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_patrol_scrub : 1;
    //
    // Fused 3DS (3D stacked die) disable control. When set, the C0, C1 and C2 signals
    // will forced to zero. Fuse download may change the default value after reset de-assertion.
    // 
    // Bits[6:6], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_3ds : 1;
    //
    // Fused 16Gb or higher disable control for DDR4 and 24Gb or higher disable for DDR5.
    // When set, the address decode to the corresponding 16Gb or higher (or 24Gb or higher
    // for DDR5) mapping is disabled. Note: LR-DIMMs logical device density is also limited
    // to 16Gb when this fuse is set. Fuse download may change the default value after
    // reset de-assertion. 
    // 
    // Bits[7:7], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_16gbit : 1;
    //
    // We're using this bit to know if it is KNH or ICX-SP.  1 = KNH.  0 = ICX-SP.
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_soc_id : 1;
    //
    // Fused ADR disable control. When set, memory ignores ADR event. Fuse download may
    // change the default value after reset de-assertion. 
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_dis_asyncsr_adr : 1;
    //
    // Fused ECC disable control. When set, ECC is disabled. Fuse download may change
    // the default value after reset de-assertion. 
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_ecc : 1;
    //
    // Fused DIR disable control. When set, directory is disabled. Fuse download may
    // change the default value after reset de-assertion. 
    // 
    // Bits[11:11], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_dir : 1;
    //
    // Fuse for mc_mca_recovery. Blown to 0 for EP, HEDT, ... etc, i.e. Means recovery
    // from uncorrectable Patrol scrub errors is not supported. In addition, iMC hardware
    // logs uncorrectable PS errors in the MCA bank with MCi_STATUS.PCC when set. When
    // the fuse is blown to 1 in in EX only, this means that when poisoning is enabled,
    // recovery from uncorrectable patrol scrub errors is supported. MC hardware will
    // log uncorrectable Patrol scrub errors in the MCA bank with a recoverable error
    // signature. Please refer to MCA HAS for further details. 
    // 
    // Bits[12:12], RO/V, default = 0x1
    //
    UINT32 fuse_shadow_mc_mca_recovery : 1;
    //
    // Fused RDIMM disable control. When set, RDIMM support is disabled by forcing the
    // upper 5 bits of the 13b T_STAB register to be zeros, i.e. the T_STAB can only
    // have max of 255 DCLK delay after clock-stopped power down mode which is in sufficient
    // for normal RDIMM clock stablization; hence, users will not be able to support
    // self-refresh with clock off mode (S3, pkg C6) if the RDIMM disable fuse is blown
    // to one. 
    // Fuse download may change the default value after reset de-assertion.
    // 
    // Bits[13:13], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_rdimm : 1;
    //
    // If 1, disable the high RAS version of adddc (use standard version of RAS for adddc).
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_adddc_high_ras : 1;
    //
    // If 1, disable ECC correction for SDDC+1 or ADDDC+1 mode; any error in +1 mode
    // will be uncorrectable. 
    // 
    // Bits[15:15], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_plus1_corr : 1;
    //
    // Fused sparing disable control. When set, all sparing modes are disabled. Fuse
    // download may change the default value after reset de-assertion. 
    // 
    // Bits[16:16], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_sparing : 1;
    //
    // Fused ADDDC disable control. When set, all ADDDC regions are disabled. Fuse download
    // may change the default value after reset de-assertion. 
    // 
    // Bits[17:17], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_adddc : 1;
    //
    // Reserved for future use.
    // 
    // Bits[19:18], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_rfu_2 : 2;
    //
    // Single device data correction fuse download. When set, will disable 4-bit device
    // SDDC. 
    // 
    // Bits[20:20], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_sddc_x4 : 1;
    //
    // Single device data correction fuse download. When set, will disable 8-bit device
    // SDDC. 
    // 
    // Bits[21:21], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_sddc_x8 : 1;
    //
    // Single device data correction fuse download. When set, will disable SDDC plus
    // one for x4 SDDC mode. 
    // 
    // Bits[22:22], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_sddc_x4_plus1 : 1;
    //
    // Single device data correction fuse download. When set, will disable SDDC plus
    // one for x8 SDDC mode. 
    // 
    // Bits[23:23], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_sddc_x8_plus1 : 1;
    //
    // Disable the BIST feature.
    // 
    // Bits[24:24], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_bist : 1;
    //
    // Disable PCLS (Partial Cache Line Sparing)
    // 
    // Bits[25:25], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_pcls : 1;
    //
    // There was a recent change and now this reg does nothing.
    // 
    // Bits[26:26], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_mee : 1;
    //
    // Disable two-level memory
    // 
    // Bits[27:27], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_2lm : 1;
    //
    // Disable the use of DDRT devices, once the fuse is blown to one, iMC will not issue
    // any DDRT commands or responding DDRT bus request. Internally, any request targeting
    // DDRT port is treated as programming error. System may hang. 
    // 
    // Bits[28:28], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_ddrt : 1;
    //
    // Disable use of Persistent Memory with Crystal Ridge.
    // 
    // Bits[29:29], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_cr_pmem : 1;
    //
    // Disable use of Persistent Memory Write Through with Crystal Ridge.
    // 
    // Bits[30:30], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_cr_pmem_wt : 1;
    //
    // Disable use of mirroring.
    // 
    // Bits[31:31], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_disable_mcmirrormode : 1;
  } Bits;
  UINT32 Data;
} IMC_FUSE_DOWNLOAD_SHADOW_MC_DEC_MEM_CSR_STRUCT_DDR;

#define IMC_FUSE_DOWNLOAD2_SHADOW_MC_DEC_MEM_CSR_REG_DDR   0x00020E04
typedef union {
  struct {
    //
    // Reserved for future use.
    // 
    // Bits[0:0], RO/V, default = 0x1
    //
    UINT32 fuse_shadow_spare_fuse_0 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[1:1], RO/V, default = 0x1
    //
    UINT32 fuse_shadow_spare_fuse_1 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[2:2], RO/V, default = 0x1
    //
    UINT32 fuse_shadow_spare_fuse_2 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[3:3], RO/V, default = 0x1
    //
    UINT32 fuse_shadow_spare_fuse_3 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[4:4], RO/V, default = 0x1
    //
    UINT32 fuse_shadow_spare_fuse_4 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[5:5], RO/V, default = 0x1
    //
    UINT32 fuse_shadow_spare_fuse_5 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[6:6], RO/V, default = 0x1
    //
    UINT32 fuse_shadow_spare_fuse_6 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[7:7], RO/V, default = 0x1
    //
    UINT32 fuse_shadow_spare_fuse_7 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[8:8], RO/V, default = 0x1
    //
    UINT32 fuse_shadow_spare_fuse_8 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[9:9], RO/V, default = 0x1
    //
    UINT32 fuse_shadow_spare_fuse_9 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[10:10], RO/V, default = 0x1
    //
    UINT32 fuse_shadow_spare_fuse_10 : 1;
    //
    // Reserved for future use.
    // 
    // Bits[11:11], RO/V, default = 0x1
    //
    UINT32 fuse_shadow_spare_fuse_11 : 1;
    //
    // DDR/HBM speed.
    // 
    // Bits[15:12], RO/V, default = 0x0
    //
    UINT32 fuse_shadow_speed : 4;
    //
    // This fuse csr stores the temperature threshold for the HBM 4x refresh rate.  It
    // gets set by the fuse, and then BIOS reads this CSR in order to know what to write
    // to the mc_thr CSR. 
    // 
    // Bits[23:16], RO/V, default = 0x5F
    //
    UINT32 fuse_shadow_temp_fourxref : 8;
    //
    // This fuse csr stores the temperature threshold for the HBM 2x refresh rate.  It
    // gets set by the fuse, and then BIOS reads this CSR in order to know what to write
    // to the mc_thr CSR. 
    // 
    // Bits[31:24], RO/V, default = 0x55
    //
    UINT32 fuse_shadow_temp_twoxref : 8;
  } Bits;
  UINT32 Data;
} IMC_FUSE_DOWNLOAD2_SHADOW_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MCDECVISACFG_MC_DEC_MEM_CSR_REG_DDR                0x00020E0C
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RW/P/L, default = 0x0
    //
    UINT32 lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RW/P/L, default = 0x0
    //
    UINT32 lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RW/P/L, default = 0x0
    //
    UINT32 lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RW/P/L, default = 0x0
    //
    UINT32 lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RW/P/L, default = 0x0
    //
    UINT32 clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 7;
  } Bits;
  UINT32 Data;
} MCDECVISACFG_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MCMAIN_CHKN_BITS_MC_DEC_MEM_CSR_REG_DDR            0x00020E14
typedef union {
  struct {
    //
    // When set to 1, non-mirrored region is only scrubbed once when partial mirroring
    // is enabled. Should only be set to 1 if partial mirroring is used. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 pat_skip_non_mirr : 1;
    //
    // Disable signalling of SMI from patrol scrub engine.
    // Patrol scrub is able to signal SMI when it stops on error or reaches end of address
    // range. See SCRUBCTL for details. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 rsvd_chkn_b1 : 1;
    //
    // Disable spare error logging
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 dis_spr_err_log : 1;
    //
    // Force spare start
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 frc_spr_strt : 1;
    //
    // Keep patrol address to continue after PkgC
    // 
    // Bits[4:4], RW, default = 0x1
    //
    UINT32 frc_spr_end : 1;
    //
    // Disable spare RIR update
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINT32 dis_spr_rir_updt : 1;
    //
    // Disable patrol retry
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 dis_ptrl_rty : 1;
    //
    // Disable patrol error logging
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 unused1 : 1;
    //
    // Reserved - unused.
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 frc_sngl_ptrl : 1;
    //
    // Reserved
    // 
    // Bits[9:9], RW, default = 0x1
    //
    UINT32 rsvd_chkn_b9 : 1;
    //
    // Reserved - unused.
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINT32 frc_sngl_mtst : 1;
    //
    // Disable rcomp
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINT32 dis_rcomp : 1;
    //
    // unused
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINT32 unused : 1;
    //
    // Disable local clock gating - mcmains
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINT32 dis_lcl_ck_gate_mcmain : 1;
    //
    // Increase RCOMP quiet time
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINT32 increase_rcomp : 1;
    //
    // Disable bug fix for HSX be4768490 when set to 1
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINT32 dis_msg_ch_ck_gate_mc : 1;
    //
    // Disable message channel clock gating
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINT32 dis_actual_msg_ch_ck_gate_mc : 1;
    //
    // Reserved - unused.
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 dis_dbg_bgf_push : 1;
    //
    // Allow patrol to stop at end of rank
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 unused2 : 1;
    //
    // Reserved - unused.
    // 
    // Bits[19:19], RW/P, default = 0x0
    //
    UINT32 bgftune_lock : 1;
    //
    // Bug fix for HSD b3123628:
    // When set, tells MC that this is a frequency_change flow. When the bit is set,
    // following changes take place 
    // 1. When PmRsBlock is asserted, we block message channel to M2M
    // 2. PkgC Empty and FullEmpty will ignore msgChEmpty when this bit is set
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 freq_chng_flow : 1;
    //
    // Disable leaky bucket counter in mc_dec
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 dis_leak_cntr : 1;
    //
    // When set to 1, disables the hold logic on the BlockAck going to the MC PMA, that
    // keeps the BlockAck asserted once set, until the BlockReq de-asserts 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINT32 dis_pma_blockack_hold : 1;
    //
    // Reserved
    // 
    // Bits[24:23], RW, default = 0x0
    //
    UINT32 rsvd_chkn_b24_b23 : 2;
    //
    // MC PMA interface override for channel when not occupied. When set to 1, MCActive
    // will de-assert and InSRD will assert. 
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINT32 frc_not_occ_0 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:26], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // Disable patrol scrub poison line on finding uncorr error
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINT32 dis_ptrl_psn : 1;
    //
    // When set to 1, the MC will not backpressure the M2M during an ADR sequence.
    // When set to 0 and the MC receives the AsyncSR signal from the PMA, the MC will
    // immediately backpressure the M2M, stopping any new transactions from being sent
    // to the MC. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 dis_asyncsr_habackpress : 1;
    //
    // When set to 1, rcomp request is never blocked even if ZQCal is on-going.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 defeature_10 : 1;
  } Bits;
  UINT32 Data;
} MCMAIN_CHKN_BITS_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MCMAIN_CHKN_BITS2_MC_DEC_MEM_CSR_REG_DDR           0x00020E18
typedef union {
  struct {
    //
    // Enable checking for all page closed during sparing all the time/mode
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Disable sparing clock gating
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:2], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // When set 1, PkgCEmpty should check RT empty including patrol transaction
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 dis_pat_pkgc : 1;
    //
    // When set 1, DDRT gnt is not blocked during sparing before the first spare is issued.
    // This block is done to avoid DDRT read when the round trip delay changes due to
    // sparing (device substitution enabled). Current RDB already stop read from going
    // through datapath when the delay changes so this blocking is likely not needed
    // anymore. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 dis_spr_ddrt_gnt_blk : 1;
    //
    // Controls whether to inject a parity error on a NM eviction in 2LM mode:
    // 0 - no injection
    // 1 - always inject errors
    // 2 - reserved
    // 3 - reserved
    //         
    // 
    // Bits[6:5], RW/P/L, default = 0x0
    //
    UINT32 evict_addr_par_inj_err : 2;
    //
    // Chicken bits:
    //            Bit 7  : disable moving back to idle in TXN_DONE state when patrol
    // is disabled; 
    //            Bit 8  : disable fix for SKX b311323
    //            Bit 9  : 
    //            Bit 10 : disable fix for SKX b311569
    //            Bit 11 : DDRT PC6 clock stop will not de-assert PMA Queue Full Empty
    // if error FSM comes on. 
    //            Bit 12 : DDRT PC6 clock stop will not de-assert PMA Pkgc Empty if error
    // FSM comes on. 
    //            Bit 13 : DDRT PC6 clock stop will not de-assert PMA Queue Full Empty
    // if DDRT RPQ is not empty. 
    //            Bit 14 : DDRT PC6 clock stop will not de-assert PMA Pkgc Empty if DDRT
    // RPQ is not empty. 
    //            Bit 15 : Set to 1 to disable check for SB empty during sparing flush.
    //            Bit 16: Clear end signal for eADR done.
    //            Bit 30:17: reserved and keep at 0
    //            Bit 31: Disable check for retry FSM idle during spare flush.
    // 
    // 
    // Bits[31:7], RW, default = 0x0
    //
    UINT32 defeature : 25;
  } Bits;
  UINT32 Data;
} MCMAIN_CHKN_BITS2_MC_DEC_MEM_CSR_STRUCT_DDR;

#define SPAREADDRESSLO_MC_DEC_MEM_CSR_REG_DDR              0x00020E24
typedef union {
  struct {
    //
    // Always points to the lower address for the next sparing operation. This register
    // will not be affected by the M2M access to the spare source rank during the M2M
    // window. 
    // 
    // 
    // Bits[31:0], RW/V, default = 0x0
    //
    UINT32 rankadd : 32;
  } Bits;
  UINT32 Data;
} SPAREADDRESSLO_MC_DEC_MEM_CSR_STRUCT_DDR;

#define SCRUBCTL_MC_DEC_MEM_CSR_REG_DDR                    0x00020E28
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[16:0], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 17;
    //
    // Number of clock cycles to wait when address is being skipped
    // 
    // Bits[20:17], RW, default = 0xF
    //
    UINT32 reserved : 4;
    //
    // Scrub only one address; test mode
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Reserved; keep this bit at 0.
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 stop_on_rank : 1;
    //
    // Reserved; keep this bit at 0.
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 dis_ptrl_err_log : 1;
    //
    // When Set, the Patrol scrub engine will start from the address in the scrub address
    // registers. Once the scrub is issued this bit is reset. For rank address based
    // patrol scrub (when scrubaddresshi.ptl_sa_mode = 0), this bit should be set to
    // 1 when scrub is enabled. 
    // 
    // Bits[24:24], RW/V, default = 0x0
    //
    UINT32 startscrub : 1;
    //
    // When Set, the patrol scrub engine will issue the address in the scrub address
    // registers only once and stop.  Software is responsible to turn off periodic patrol
    // before issuing patrol once. The patrol interval in PMA should be set to 0 in issue
    // once mode. No cross product of patrol once with PkgC is allowed. 
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINT32 issueonce : 1;
    //
    // When Set, the scrub address registers contain the last scrub address issued
    // 
    // Bits[26:26], RW/V, default = 0x0
    //
    UINT32 scrubissued : 1;
    //
    // Reserved
    // 
    // Bits[27:27], RW/V, default = 0x0
    //
    UINT32 ptl_stopped : 1;
    //
    // Reserved; keep this bit at 0.
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINT32 stop_on_err : 1;
    //
    // When stop_on_cmpl is enabled, patrol will stop at the end of the address range
    // and set this bit. 
    // Patrol will resume from beginning of address range when this bit or stop_on_cmpl
    // is cleared by BIOS and patrol scrub is still enabled by scrub_en. 
    // 
    // Bits[29:29], RW/V, default = 0x0
    //
    UINT32 ptl_cmpl : 1;
    //
    // Stop patrol scrub at end of memory range. This mode is meant to be used as part
    // of memory migration flow.  
    //             SMI is signalled by default.
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 stop_on_cmpl : 1;
    //
    // Scrub Enable when set.  
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 scrub_en : 1;
  } Bits;
  UINT32 Data;
} SCRUBCTL_MC_DEC_MEM_CSR_STRUCT_DDR;

#define SCRUBADDRESSLO_MC_DEC_MEM_CSR_REG_DDR              0x00020E2C
typedef union {
  struct {
    //
    // Contains the rank address or bits 37:6 of the system address of the last scrub
    // issued. Can be written to specify the next scrub address with STARTSCRUB. Base
    // system address in scrubaddress2lo/hi also need to be programmed in system address
    // mode for the programmed address to work properly. In system address mode, scrubaddresshi.ptl_sa_mode
    // must be cleared to 0 and then set back to 1 after STARTSCRUB is set for address
    // written to take effect. RESTRICTIONS: Patrol Scrubs must be disabled when writing
    // to this field. Bit 0 of this register maps to bit 6 of address. When target or
    // channel XOR is enabled, address in this register wouldn't / shouldn't be the true
    // system address, the system address with XOR applied. Error logging on patrol scrub
    // error will reflect the true system address though. 
    // 
    // Bits[31:0], RW/V, default = 0x0
    //
    UINT32 rankadd : 32;
  } Bits;
  UINT32 Data;
} SCRUBADDRESSLO_MC_DEC_MEM_CSR_STRUCT_DDR;

#define SCRUBADDRESSHI_MC_DEC_MEM_CSR_REG_DDR              0x00020E30
typedef union {
  struct {
    //
    // Contains bits 52:38 of the system address of the last scrub issued. Can be written
    // to specify the next scrub address with STARTSCRUB. Base system address in scrubaddress2lo/hi
    // also need to be programmed in system address mode for the programmed address to
    // work properly. scrubaddresshi.ptl_sa_mode must be cleared to 0 and then set back
    // to 1 after STARTSCRUB is set for address written to take effect. RESTRICTIONS:
    // Patrol Scrubs must be disabled when writing to this field. Only used system address
    // patrol mode. 
    // 
    // Bits[14:0], RW/V, default = 0x0
    //
    UINT32 rankaddhi : 15;
    //
    // Contains the primary indication when mirroring is enabled. Can be written to specify
    // the next scrub address. RESTRICTION: Patrol Scrubs must be disabled when writing
    // to this field. Only used for system address patrol mode. 
    // 
    // Bits[15:15], RW/V, default = 0x1
    //
    UINT32 mirr_pri : 1;
    //
    // Contains the physical rank ID of the last scrub issued. Can be written to specify
    // the next scrub address with STARTSCRUB. RESTRICTION: Patrol Scrubs must be disabled
    // when writing to this field. Only used for legacy (non system address) patrol mode.
    // 
    // Bits[18:16], RW/V, default = 0x0
    //
    UINT32 rank : 3;
    //
    // Can be written to specify the next scrub address with STARTSCRUB. This register
    // is updated with channel address of the last scrub address issued. RESTRICTIONS:
    // Patrol Scrubs must be disabled when writing to this field. Only used for legacy
    // (non system address) patrol mode. 
    // 
    // Bits[21:19], RW/V, default = 0x0
    //
    UINT32 chnl : 3;
    //
    // Contains the TAD rule of the last scrub issued. Can be written to specify the
    // next scrub address with STARTSCRUB. scrubaddresshi.ptl_sa_mode must be cleared
    // to 0 and then set back to 1 after STARTSCRUB is set for address written to take
    // effect. RESTRICTION: Patrol Scrubs must be disabled when writing to this field.
    // Only used system address patrol mode. 
    // 
    // Bits[24:22], RW/V, default = 0x0
    //
    UINT32 tad_rule : 3;
    //
    // 
    //             First TAD rule used for patrol address generation. Set to 0 to begin
    // generating system addresses for patrol at the lowest address mapped to the MC.
    //         
    // 
    // Bits[27:25], RW, default = 0x0
    //
    UINT32 minimum_tad_rule : 3;
    //
    // 
    //             Last TAD rule used for patrol address generation. Set to the maximum
    // valid TAD rule number used on the MC to generate system addresses for patrol up
    // to the maximum address mapped to the MC. 
    //         
    // 
    // Bits[30:28], RW, default = 0x0
    //
    UINT32 maximum_tad_rule : 3;
    //
    // Patrol runs in system address generation mode if patrol is enabled. Keep this
    // bit at 1 for proper operation. 
    // 
    // Bits[31:31], RW, default = 0x1
    //
    UINT32 ptl_sa_mode : 1;
  } Bits;
  UINT32 Data;
} SCRUBADDRESSHI_MC_DEC_MEM_CSR_STRUCT_DDR;

#define HOTPLUG_MC_DEC_MEM_CSR_REG_DDR                     0x00020E34
typedef union {
  struct {
    //
    // Status bit for hot plug. BIOS to write this bit to indicate to MC that it is currently
    // in the memory hot add/ hot remove flow. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // This bit will be 1 when all WDB entries are drained on all channels, 0 when any
    // WDB has valid entries. 
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:2], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 6;
  } Bits;
  UINT32 Data;
} HOTPLUG_MC_DEC_MEM_CSR_STRUCT_DDR;

#define RASENABLES_MC_DEC_MEM_CSR_REG_DDR                  0x00020E3C
typedef union {
  struct {
    //
    // Mirror mode enable. The channel mapping must be set up before this bit will have
    // an effect on IMC operation. This changes the error policy. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 mirroren : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:1], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // The secondary channel number when the primary channel is channel 0 for mirroring.
    // This is used by patrol logic. 
    // 
    // Bits[5:4], RW, default = 0x1
    //
    UINT32 ch0_mirror : 2;
    //
    // The secondary channel number when the primary channel is channel 1 for mirroring.
    // This is used by patrol logic. 
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINT32 ch1_mirror : 2;
    //
    // The secondary channel number when the primary channel is channel 2 for mirroring.
    // This is used by patrol logic. 
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINT32 ch2_mirror : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:10], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 22;
  } Bits;
  UINT32 Data;
} RASENABLES_MC_DEC_MEM_CSR_STRUCT_DDR;

#define SMISPARECTL_MC_DEC_MEM_CSR_REG_DDR                 0x00020E40
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:0], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 15;
    //
    // SMI enable. Set to enable SMi signaling. Clear to disable SMI signaling.
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINT32 intrpt_sel_smi : 1;
    //
    // (CMCI used as a proxy for NMI signaling). Set to enable NMI signaling. Clear to
    // disable NMI signaling. If both NMI and 
    // SMI enable bits are set then only SMI is sent.
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINT32 intrpt_sel_cmci : 1;
    //
    // Enable pin signaling. When set the interrupt is signaled via the err[0] pin to
    // get the attention of a BMC. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 intrpt_sel_pin : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 14;
  } Bits;
  UINT32 Data;
} SMISPARECTL_MC_DEC_MEM_CSR_STRUCT_DDR;

#define LEAKY_BUCKET_CFG_MC_DEC_MEM_CSR_REG_DDR            0x00020E44
typedef union {
  struct {
    //
    // This is the lower order bit select mask of the two hot encoding threshold. The
    // value of this field specify the bit position of the mask: 
    // 00h: reserved
    // 01h: LEAKY_BUCKET_CNTR_LO bit 1, i.e. bit 12 of the full 53b counter
    // ...
    // 1Fh: LEAKY_BUCKET_CNTR_LO bit 31, i.e. bit 42 of the full 53b counter
    // 20h: LEAKY_BUCKET_CNTR_HI bit 0, i.e. bit 43 of the full 53b counter
    // ...
    // 29h: LEAKY_BUCKET_CNTR_HI bit 9, i.e. bit 52 of the full 53b counter
    // 2Ah - 3F: reserved
    // When both counter bits selected by the LEAKY_BKT_CFG_HI and LEAKY_BKT_CFG_LO are
    // set, the 53b leaky bucket counter will be reset and the logic will generate a
    // LEAK pulse to decrement the correctable error counter by 1. 
    // MRC BIOS must program this register to any non-zero value before switching to
    // NORMAL mode. 
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINT32 leaky_bkt_cfg_lo : 6;
    //
    // This is the higher order bit select mask of the two hot encoding threshold. The
    // value of this field specify the bit position of the mask: 
    // 00h: reserved
    // 01h: LEAKY_BUCKET_CNTR_LO bit 1, i.e. bit 12 of the full 53b counter
    // ...
    // 1Fh: LEAKY_BUCKET_CNTR_LO bit 31, i.e. bit 42 of the full 53b counter
    // 20h: LEAKY_BUCKET_CNTR_HI bit 0, i.e. bit 43 of the full 53b counter
    // ...
    // 29h: LEAKY_BUCKET_CNTR_HI bit 9, i.e. bit 52 of the full 53b counter
    // 2Ah - 3F: reserved
    // When both counter bits selected by the LEAKY_BKT_CFG_HI and LEAKY_BKT_CFG_LO are
    // set, the 53b leaky bucket counter will be reset and the logic will generate a
    // LEAK pulse to decrement the correctable error counter by 1. 
    // MRC BIOS must program this register to any non-zero value before switching to
    // NORMAL mode. 
    // 
    // Bits[11:6], RW, default = 0x0
    //
    UINT32 leaky_bkt_cfg_hi : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:12], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 20;
  } Bits;
  UINT32 Data;
} LEAKY_BUCKET_CFG_MC_DEC_MEM_CSR_STRUCT_DDR;

#define LEAKY_BUCKET_CNTR_LO_MC_DEC_MEM_CSR_REG_DDR        0x00020E48
typedef union {
  struct {
    //
    // This is the lower half of the leaky bucket counter. The full counter is actually
    // a 53b DCLK counter. There is a least significant 11b of the 53b counter is not
    // captured in CSR. The carry strobe from the not-shown least significant 11b counter
    // will trigger this 42b counter pair to count. The 42b counter-pair is compared
    // with the two-hot encoding threshold specified by the LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO
    // pair. When the counter bits specified by the LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO
    // are both set, the 53b counter is reset and the leaky bucket logic will generate
    // a LEAK strobe last for 1 DCLK.   
    // 
    // Bits[31:0], RW/V, default = 0x0
    //
    UINT32 leaky_bkt_cntr_lo : 32;
  } Bits;
  UINT32 Data;
} LEAKY_BUCKET_CNTR_LO_MC_DEC_MEM_CSR_STRUCT_DDR;

#define LEAKY_BUCKET_CNTR_HI_MC_DEC_MEM_CSR_REG_DDR        0x00020E4C
typedef union {
  struct {
    //
    // This is the upper half of the leaky bucket counter. The full counter is actually
    // a 53b DCLK counter. There is a least significant 11b of the 53b counter is not
    // captured in CSR. The carry strobe from the not-shown least significant 11b counter
    // will trigger this 42b counter pair to count. The 42b counter-pair is compared
    // with the two-hot encoding threshold specified by the LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO
    // pair. When the counter bits specified by the LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO
    // are both set, the 53b counter is reset and the leaky bucket logic will generate
    // a LEAK strobe last for 1 DCLK.   
    // 
    // Bits[9:0], RW/V, default = 0x0
    //
    UINT32 leaky_bkt_cntr_hi : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:10], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 22;
  } Bits;
  UINT32 Data;
} LEAKY_BUCKET_CNTR_HI_MC_DEC_MEM_CSR_STRUCT_DDR;

#define SCRUBADDRESS2LO_MC_DEC_MEM_CSR_REG_DDR             0x00020E50
typedef union {
  struct {
    //
    // Contains bits 37:6 of the base system address of the last scrub issued. This is
    // the base of the current system address. Can be written to specify the next scrub
    // address with STARTSCRUB. System address in scrubaddresslo/hi also need to be programmed
    // in system address mode for the programmed address to take effect. scrubaddresshi.ptl_sa_mode
    // must be cleared to 0 and then set back to 1 after STARTSCRUB is set for address
    // written to take effect. RESTRICTIONS: Patrol Scrubs must be disabled when writing
    // to this field. Only used system address patrol mode. When target or channel XOR
    // is enabled, address in this register wouldn't / shouldn't be the true system address,
    // the system address with XOR applied. Error logging on patrol scrub error will
    // reflect the true system address though. 
    // 
    // Bits[31:0], RW/V, default = 0x0
    //
    UINT32 baseadd : 32;
  } Bits;
  UINT32 Data;
} SCRUBADDRESS2LO_MC_DEC_MEM_CSR_STRUCT_DDR;

#define SCRUBADDRESS2HI_MC_DEC_MEM_CSR_REG_DDR             0x00020E54
typedef union {
  struct {
    //
    // Contains bits 52:38 of the base system address of the last scrub issued. This
    // is the base of the current system address. Can be written to specify the next
    // scrub address with STARTSCRUB. System address in scrubaddresslo/hi also need to
    // be programmed in system address mode for the programmed address to work properly.
    // scrubaddresshi.ptl_sa_mode must be cleared to 0 and then set back to 1 after STARTSCRUB
    // is set for address written to take effect. RESTRICTIONS: Patrol Scrubs must be
    // disabled when writing to this field. Only used system address patrol mode. 
    // 
    // Bits[14:0], RW/V, default = 0x0
    //
    UINT32 baseaddhi : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 17;
  } Bits;
  UINT32 Data;
} SCRUBADDRESS2HI_MC_DEC_MEM_CSR_STRUCT_DDR;

#define EMCALTCTL_MC_DEC_MEM_CSR_REG_DDR                   0x00020E5C
typedef union {
  struct {
    //
    // SMI enable. Set to enable SMI signaling for each correctable error. Clear to disable
    // SMI signaling and signal CMCI when correctable error threshold is reached. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 emcalt_sel_smi : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:1], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 7;
  } Bits;
  UINT32 Data;
} EMCALTCTL_MC_DEC_MEM_CSR_STRUCT_DDR;

#define LBITMAP_MC_DEC_MEM_CSR_REG_DDR                     0x00020E60
typedef union {
  struct {
    //
    // selects which bit to set in the one-hot payload of the Global Error Message that
    // iMC sends to UBOX.  
    // 
    // Bits[4:0], RW, default = 0x8
    //
    UINT32 bit_select : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 27;
  } Bits;
  UINT32 Data;
} LBITMAP_MC_DEC_MEM_CSR_STRUCT_DDR;

#define SCRUBMASK_MC_DEC_MEM_CSR_REG_DDR                   0x00020E6C
typedef union {
  struct {
    //
    // Patrol scrub channel mask. Setting this bit will skip patrol scrub on that channel.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 ch_mask : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:1], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // Reserved; keep this bit at 0.
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 all_ranks : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 3;
    //
    // Reserved; keep this field at 0.
    // 
    // Bits[10:8], RW, default = 0x0
    //
    UINT32 ch0_rank : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Reserved; keep this field at 0.
    // 
    // Bits[19:12], RW, default = 0x0
    //
    UINT32 rank_dec : 8;
    //
    // link fail.
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 link_fail : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:21], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 11;
  } Bits;
  UINT32 Data;
} SCRUBMASK_MC_DEC_MEM_CSR_STRUCT_DDR;

#define SPARING_CONTROL_SOURCE_MC_DEC_MEM_CSR_REG_DDR      0x00020E74
typedef union {
  struct {
    //
    // 
    //                          The value in this field is encoded (Chip Selects are
    // normally 1-hot), corresponding to CS0-CS7.   
    //                          For SDDC or rank sparing this field specifies the source
    // rank (Chip Select, CS0-CS7) for the sparing copy.   
    //                          For ADDDC, this field specifies the failed rank for the
    // sparing copy.   
    //                       
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 source_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:3], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 9;
    //
    // 
    //                             For ADDDC used at the bank granularity (region_size=bank),
    // this field specifies the bank address (BA2-BA0) to match for the sparing copy.
    //                         
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINT32 source_ba : 2;
    //
    // 
    //                             For ADDDC used at the bank granularity (region_size=bank),
    // this field specifies the bank group (BG1-BG0) to match for the sparing copy. 
    //                         
    // 
    // Bits[15:14], RW, default = 0x0
    //
    UINT32 source_bg : 2;
    //
    // 
    //                          The enable bit for buddy_cs field. This enable bit is
    // only set for SDDC sparing in x8 mode, or SDDC sparing after ADDDC is enabled.
    //                       
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINT32 buddy_cs_en : 1;
    //
    // 
    //                          The value in this field is encoded (Chip Selects are
    // normally 1-hot), corresponding to CS0-CS7.   
    //                          This field is only used for SDDC sparing in x8 mode,
    // or SDDC sparing after ADDDC is enabled. 
    //                          This field specifies the primary rank (Chip Select, CS0-CS7)
    // of an ADDDC transaction whose buddy is in the rank represented by source_cs. 
    //                          This field is used only if buddy_cs_en bit is set to
    // 1. 
    //                       
    // 
    // Bits[19:17], RW, default = 0x0
    //
    UINT32 buddy_cs : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 12;
  } Bits;
  UINT32 Data;
} SPARING_CONTROL_SOURCE_MC_DEC_MEM_CSR_STRUCT_DDR;

#define SPARING_CONTROL_DESTINATION_MC_DEC_MEM_CSR_REG_DDR 0x00020E78
typedef union {
  struct {
    //
    // 
    //                           The value in this field is encoded (Chip Selects are
    // normally 1-hot), corresponding to CS0-CS7.   
    //                           For rank sparing this field specifies the destination
    // rank (Chip Select, CS0-CS7) for the sparing copy.   
    //                           For all other sparing operation, including ADDDC sparing,
    // this field should have the same value as sparing_control_source.source_cs. 
    //                      
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 destination_cs : 3;
    //
    //  Reserved for future use.  
    // 
    // Bits[15:3], RW, default = 0x0
    //
    UINT32 reserved : 13;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 16;
  } Bits;
  UINT32 Data;
} SPARING_CONTROL_DESTINATION_MC_DEC_MEM_CSR_STRUCT_DDR;

#define SPARING_PATROL_STATUS_MC_DEC_MEM_CSR_REG_DDR       0x00020E7C
typedef union {
  struct {
    //
    // 
    //                   This bit indicates that the sparing copy operation is in progress.
    //  
    //                   This bit is set by hardware once the sparing copy has started.
    // It is cleared by hardware once the copy operation is complete or fails. 
    //               
    // 
    // Bits[0:0], RW/V, default = 0x0
    //
    UINT32 copy_in_progress : 1;
    //
    // 
    //                   Sparing copy operation complete. Set by hardware once operation
    // is complete.  
    //                   This bit is cleared by hardware when a new operation is enabled.
    //               
    // 
    // Bits[1:1], RW/V, default = 0x0
    //
    UINT32 copy_complete : 1;
    //
    // 
    //                   All memory has been scrubbed. Hardware sets this bit each time
    // the patrol engine steps through all memory locations. If software wants to monitor
    // 0 to 1 transition after the bit has been set, the software will need to clear
    // the bit by writing a one to clear this bit in order to distinguish the next patrol
    // scrub completion. Clearing the bit will not affect the patrol scrub operation.
    // Note, when mirroring is enabled, this bit will be set to 1 after either primary
    // or secondary address scrubbing is done. If software clears this bit to observe
    // 0 to 1 transition, the transition will happen twice to get full address scrubbed.
    //               
    // 
    // Bits[2:2], RW/1C/V, default = 0x0
    //
    UINT32 patrol_complete : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:3], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 29;
  } Bits;
  UINT32 Data;
} SPARING_PATROL_STATUS_MC_DEC_MEM_CSR_STRUCT_DDR;

#define IMC0_POISON_SOURCE_L_MC_DEC_MEM_CSR_REG_DDR        0x00020E80
typedef union {
  struct {
    //
    // System address for poison source
    // 
    // Bits[31:0], RW/V/P, default = 0x0
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} IMC0_POISON_SOURCE_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define IMC0_POISON_SOURCE_H_MC_DEC_MEM_CSR_REG_DDR        0x00020E84
typedef union {
  struct {
    //
    // System address for poison source
    // 
    // Bits[13:0], RW/V/P, default = 0x0
    //
    UINT32 reserved : 14;
    //
    // This bit will be 1 when poison is due patrol uncorectable error.
    // 
    // Bits[14:14], RW/V/P, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // This bit will be 1 when poison is due spare copy uncorectable error.
    // 
    // Bits[15:15], RW/V/P, default = 0x0
    //
    UINT32 reserved_2 : 1;
    //
    // This bit will be 1 when poison is due WDB parity error.
    // 
    // Bits[16:16], RW/V/P, default = 0x0
    //
    UINT32 reserved_3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:17], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 12;
    //
    // Set this bit to 1 to enable logging in this register.
    // 
    // Bits[29:29], RW/P, default = 0x0
    //
    UINT32 reserved_4 : 1;
    //
    // When set to 1, indicates new poison source is detected when information logged
    // in this register is still valid. 
    // 
    // Bits[30:30], RW/V/P, default = 0x0
    //
    UINT32 reserved_5 : 1;
    //
    // When set to 1, a poison source is logged in this register and no new error source
    // can be logged. Software clears this bit to 0 to re-enable logging. 
    // 
    // Bits[31:31], RW/V/P, default = 0x0
    //
    UINT32 reserved_6 : 1;
  } Bits;
  UINT32 Data;
} IMC0_POISON_SOURCE_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define SPARING_CONTROL_TAD_MC_DEC_MEM_CSR_REG_DDR         0x00020E88
typedef union {
  struct {
    //
    // This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This field
    // contains the next TAD number from TAD 0 with the same mirror_en bit as TAD 0 in
    // tadbase. 
    // 
    // Bits[2:0], RW, default = 0x1
    //
    UINT32 nxt_tad_0 : 3;
    //
    // This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This field
    // contains the next TAD number from TAD 1 with the same mirror_en bit as TAD 1 in
    // tadbase. 
    // 
    // Bits[5:3], RW, default = 0x2
    //
    UINT32 nxt_tad_1 : 3;
    //
    // This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This field
    // contains the next TAD number from TAD 2 with the same mirror_en bit as TAD 2 in
    // tadbase. 
    // 
    // Bits[8:6], RW, default = 0x3
    //
    UINT32 nxt_tad_2 : 3;
    //
    // This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This field
    // contains the next TAD number from TAD 3 with the same mirror_en bit as TAD 3 in
    // tadbase. 
    // 
    // Bits[11:9], RW, default = 0x4
    //
    UINT32 nxt_tad_3 : 3;
    //
    // This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This field
    // contains the next TAD number from TAD 4 with the same mirror_en bit as TAD 4 in
    // tadbase. 
    // 
    // Bits[14:12], RW, default = 0x5
    //
    UINT32 nxt_tad_4 : 3;
    //
    // This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This field
    // contains the next TAD number from TAD 5 with the same mirror_en bit as TAD 5 in
    // tadbase. 
    // 
    // Bits[17:15], RW, default = 0x6
    //
    UINT32 nxt_tad_5 : 3;
    //
    // This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. This field
    // contains the next TAD number from TAD 6 with the same mirror_en bit as TAD 6 in
    // tadbase. 
    // 
    // Bits[20:18], RW, default = 0x7
    //
    UINT32 nxt_tad_6 : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:21], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 11;
  } Bits;
  UINT32 Data;
} SPARING_CONTROL_TAD_MC_DEC_MEM_CSR_STRUCT_DDR;

#define SPARE_FSM_STATE_MC_DEC_MEM_CSR_REG_DDR             0x00020E8C
typedef union {
  struct {
    //
    // Current encoded state of spare copy FSM
    // 
    // Bits[4:0], RO/V, default = 0x1F
    //
    UINT32 spr_current_state : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // Previous encoded state of spare copy FSM
    // 
    // Bits[12:8], RO/V, default = 0x1F
    //
    UINT32 spr_previous_state : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 3;
    //
    // Current encoded state of system address FSM for spare copy
    // 
    // Bits[19:16], RO/V, default = 0xF
    //
    UINT32 ssa_current_state : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 4;
    //
    // Previous encoded state of system address FSM for spare copy
    // 
    // Bits[27:24], RO/V, default = 0xF
    //
    UINT32 ssa_previous_state : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 4;
  } Bits;
  UINT32 Data;
} SPARE_FSM_STATE_MC_DEC_MEM_CSR_STRUCT_DDR;

#define PATROL_FSM_STATE_MC_DEC_MEM_CSR_REG_DDR            0x00020E90
typedef union {
  struct {
    //
    // Current encoded state of patrol scrub FSM
    // 
    // Bits[4:0], RO/V, default = 0x1F
    //
    UINT32 pat_current_state : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // Previous encoded state of patrol scrub FSM
    // 
    // Bits[12:8], RO/V, default = 0x1F
    //
    UINT32 pat_previous_state : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 3;
    //
    // Current encoded state of system address FSM for patrol scrub
    // 
    // Bits[19:16], RO/V, default = 0xF
    //
    UINT32 psa_current_state : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 4;
    //
    // Previous encoded state of system address FSM for patrol scrub
    // 
    // Bits[27:24], RO/V, default = 0xF
    //
    UINT32 psa_previous_state : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 4;
  } Bits;
  UINT32 Data;
} PATROL_FSM_STATE_MC_DEC_MEM_CSR_STRUCT_DDR;

#define FINAL_TRIG_CTL_MC_DEC_MEM_CSR_REG_DDR              0x00020E9C
typedef union {
  struct {
    //
    // 
    //         Final MC_TRIGGER0 select:
    //             0: SPID command filter
    //             1: DDR-T Debug
    //             2: VERR state machine 
    //             3: DDR-T FNV drain
    //             4: CPGC global start
    //             5: CPGC error
    //             6: CPGC done
    //         
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINT32 trig_select0 : 4;
    //
    // 
    //         Final MC_TRIGGER1 select:
    //             0: SPID command filter
    //             1: DDR-T Debug
    //             2: VERR state machine 
    //             3: DDR-T FNV drain
    //             4: CPGC global start
    //             5: CPGC error
    //             6: CPGC done
    //         
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINT32 trig_select1 : 4;
    //
    // 
    //         Final MC_TRIGGER2 select:
    //             0: SPID command filter
    //             1: DDR-T Debug
    //             2: VERR state machine 
    //             3: DDR-T FNV drain
    //             4: CPGC global start
    //             5: CPGC error
    //             6: CPGC done
    //         
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINT32 trig_select2 : 4;
    //
    // 
    //         Final MC_TRIGGER3 select:
    //             0: SPID command filter
    //             1: DDR-T Debug
    //             2: VERR state machine 
    //             3: DDR-T FNV drain
    //             4: CPGC global start
    //             5: CPGC error
    //             6: CPGC done
    //         
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINT32 trig_select3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 16;
  } Bits;
  UINT32 Data;
} FINAL_TRIG_CTL_MC_DEC_MEM_CSR_STRUCT_DDR;

#define VIRALCTL_MC_DEC_MEM_CSR_REG_DDR                    0x00020EB0
typedef union {
  struct {
    //
    // When set to 1, clears viral level signal in MC. Clear to 0 to allow viral signal
    // to be set again. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 viral_clear : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:1], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // Viral test bit for current channel.
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 viral_ch0 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 3;
  } Bits;
  UINT32 Data;
} VIRALCTL_MC_DEC_MEM_CSR_STRUCT_DDR;

#define SPARING_CONTROL_THRESH_MC_DEC_MEM_CSR_REG_DDR      0x00020EC8
typedef union {
  struct {
    //
    // Threshold to exit spare window when number of skipped addresses reaches this value.
    // The value shouldn't be programmed to 0 even if addr_skip_en = 0. 
    // 
    // Bits[15:0], RW, default = 0x100
    //
    UINT32 addr_skip : 16;
    //
    // Enable exiting spare window when number of skipped addresses reaches threshold
    // (addr_skip). 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINT32 addr_skip_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:17], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 15;
  } Bits;
  UINT32 Data;
} SPARING_CONTROL_THRESH_MC_DEC_MEM_CSR_STRUCT_DDR;

#define IMC0_MC8_ADDR_SHADOW_L_MC_DEC_MEM_CSR_REG_DDR      0x00020ED0
typedef union {
  struct {
    //
    // Address associated with the error.
    // 
    // Bits[31:0], RW/V/P, default = 0x0
    //
    UINT32 reserved : 32;
  } Bits;
  UINT32 Data;
} IMC0_MC8_ADDR_SHADOW_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define IMC0_MC8_ADDR_SHADOW_H_MC_DEC_MEM_CSR_REG_DDR      0x00020ED4
typedef union {
  struct {
    //
    // Address associated with the error.
    // 
    // Bits[19:0], RW/V/P, default = 0x0
    //
    UINT32 reserved : 20;
    //
    // These bits are not implemented in that they will never by set to one due to a
    // detected error. They can be written and read for software testing. 
    // 
    // Bits[25:20], RW/P, default = 0x0
    //
    UINT32 reserved_1 : 6;
    //
    // A unique id which is used for software to aid in conversion of dedup addresses
    // to physical addresses 
    // 
    // Bits[31:26], RW/V/P, default = 0x0
    //
    UINT32 reserved_2 : 6;
  } Bits;
  UINT32 Data;
} IMC0_MC8_ADDR_SHADOW_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define RETRY_RD_ERR_LOG_ADDRESS3_L_MC_DEC_MEM_CSR_REG_DDR 0x00020ED8
typedef union {
  struct {
    //
    // System address for last retry
    // 
    // Bits[31:0], RW/V/P, default = 0x0
    //
    UINT32 sysaddress : 32;
  } Bits;
  UINT32 Data;
} RETRY_RD_ERR_LOG_ADDRESS3_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define RETRY_RD_ERR_LOG_ADDRESS3_H_MC_DEC_MEM_CSR_REG_DDR 0x00020EDC
typedef union {
  struct {
    //
    // System address for last retry
    // 
    // Bits[19:0], RW/V/P, default = 0x0
    //
    UINT32 sysaddress : 20;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 12;
  } Bits;
  UINT32 Data;
} RETRY_RD_ERR_LOG_ADDRESS3_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define RETRY_RD_ERR_SET2_LOG_ADDRESS3_L_MC_DEC_MEM_CSR_REG_DDR 0x00020EE0
typedef union {
  struct {
    //
    // System address for last retry
    // 
    // Bits[31:0], RW/V/P, default = 0x0
    //
    UINT32 sysaddress : 32;
  } Bits;
  UINT32 Data;
} RETRY_RD_ERR_SET2_LOG_ADDRESS3_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define RETRY_RD_ERR_SET2_LOG_ADDRESS3_H_MC_DEC_MEM_CSR_REG_DDR 0x00020EE4
typedef union {
  struct {
    //
    // System address for last retry
    // 
    // Bits[19:0], RW/V/P, default = 0x0
    //
    UINT32 sysaddress : 20;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 12;
  } Bits;
  UINT32 Data;
} RETRY_RD_ERR_SET2_LOG_ADDRESS3_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MC_INIT_STATE_G_MC_DEC_MEM_CSR_REG_DDR             0x00020EE8
typedef union {
  struct {
    //
    // This bit should be set to 1 by bios as soon as the MRC has successfully completed
    // and all required information (e.g. - training) is in the Bios flash. It indicates
    // that first MRC has been completed 
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINT32 pu_mrc_done : 1;
    //
    // Reserved - unused.
    // 
    // Bits[1:1], RW, default = 0x1
    //
    UINT32 ddr_reset : 1;
    //
    // Reserved - unused.
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 dclk_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:3], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
    //
    // DDR IO reset
    // In order to reset the IO this bit has to be set for 20 DCLKs and then cleared.
    // Setting this bit will reset the DDRIO receive FIFO registers only. 
    // It is required in some of the training steps.
    //         
    // 
    // Bits[5:5], RW, default = 0x1
    //
    UINT32 reset_io : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // MRC done.
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 mrc_done : 1;
    //
    // This bit indicates if it is safe to keep the MC in SR during MC-reset. If it is
    // clear when reset occurs, it means that the reset is without warning and the DDR-reset
    // should be asserted. If set when reset occurs, it indicates that DDR is already
    // in SR and it can keep it this way. This bit can also indicate MRC if reset without
    // warning has occured, and if it has, cold-reset flow should be selected 
    // Note to MRC BIOS: clear this bit at MRC entry.
    // 
    // Bits[8:8], RW/P, default = 0x1
    //
    UINT32 safe_sr : 1;
    //
    // Reserved - unused.
    // 
    // Bits[9:9], RW/P, default = 0x0
    //
    UINT32 cs_oe_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:10], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 22;
  } Bits;
  UINT32 Data;
} MC_INIT_STATE_G_MC_DEC_MEM_CSR_STRUCT_DDR;

#define SPAREINTERVAL_MC_DEC_MEM_CSR_REG_DDR               0x00020EF0
typedef union {
  struct {
    //
    // Normal operation duration. System requests will be serviced during this interval.
    // 
    // Bits[15:0], RW, default = 0xC80
    //
    UINT32 normopdur : 16;
    //
    // Sparing operation duration. System requests will be blocked during this interval
    // and only sparing copy operations will be serviced. This needs to be an even number
    // is ADDDC sparing mode. The value needs to be 32 or less in rank sparing mode.
    // 
    // Bits[28:16], RW, default = 0x320
    //
    UINT32 numspare : 13;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
  } Bits;
  UINT32 Data;
} SPAREINTERVAL_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MCMTR_MC_DEC_MEM_CSR_REG_DDR                       0x00020EF8
typedef union {
  struct {
    //
    // Use close page address mapping if set; otherwise, open page.
    // 
    // Bits[0:0], RW/P, default = 0x0
    //
    UINT32 close_pg : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[1:1], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // ECC enable.
    // 
    // Bits[2:2], RW/V/P, default = 0x0
    //
    UINT32 ecc_en : 1;
    //
    // Directory Enable. Read-Only (RO) with 0 value if not supported. 
    //       This bit is not used by the design. M2M controls directory enable behavior.
    //  
    //         
    // 
    // Bits[3:3], RW/V/P, default = 0x0
    //
    UINT32 dir_en : 1;
    //
    // HBM Only.  Enable DBI for memory reads.  This bit is not used in DDR mode.
    // 
    // Bits[4:4], RW, default = 0x1
    //
    UINT32 read_dbi_en : 1;
    //
    // HBM Only.  Enable DBI for memory writes.  This bit is not used in DDR mode.
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINT32 write_dbi_en : 1;
    //
    // HBM Only.  Enable parity for memory reads.  This bit is not used in DDR mode.
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 read_parity_en : 1;
    //
    // HBM Only.  Enable parity for memory writes.  This bit is not used in DDR mode.
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 write_parity_en : 1;
    //
    // 0: Training mode
    // 1: Normal Mode
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 normal : 1;
    //
    // When set, this bit will enable bank XORing. This is targeted at workloads that
    // bank thrashing caused by certain stride or page mappings. If one detects unexpectedly
    // poor page hit rates, one can attempt to flip this bit to see if it helps. 
    // [0]: Our base configuration. Bank selection is done using rank address bits 12:17:18
    // for open page mapping and bits 6:7:8 for close page mapping. 
    // [1]: Bank XORing enabled. Bank selection is done using rank address bits:
    // (1219):(1720):(1821) for open page mapping
    // (619):(720):(821) for close page mapping
    // 
    // Bits[9:9], RW/P, default = 0x0
    //
    UINT32 bank_xor_enable : 1;
    //
    // 00: reserved
    // 01: Native CPGC Mode. (mcmtr.normal must be zero for this mode)
    // 10: reserved
    // 11: Normal Mode (mcmtr.normal is a dont care for this mode)
    // 
    // Bits[11:10], RW, default = 0x0
    //
    UINT32 trng_mode : 2;
    //
    // This bit is used to enable DDR5 9x4 mode.
    // 0 - DDR5 10x4
    // 1 - DDR5   9x4
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINT32 ddr5_9x4_en : 1;
    //
    // XOR hash enable for Dimm Select of the Rank Target (Bit [2] of 3 bit target rank)
    // This bit should be set only when the channel has 2 DDR5 DIMMs. Both DIMMs need
    // to be identical. This bit cannot be set for a DDR4 channel or for a 1 DPC DDR5
    // channel.  
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINT32 dimm_xor_enable : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[17:14], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 4;
    //
    // Channel disable control. When set, the channel is disabled. 
    //             Note: Message Channel may not work if all channels are set to disable
    // in this field. 
    // 
    // Bits[18:18], RW/P, default = 0x0
    //
    UINT32 chn_disable : 1;
    //
    // XOR hash enable for pseudo channel or sub-channel.
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINT32 pch_xor_enable : 1;
    //
    // XOR hash enable for 2 or 4 or 8 channels.
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 channel_xor_enable : 1;
    //
    // XOR hash enable for 2 or 4 clusters.
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 cluster_xor_enable : 1;
    //
    // unused on 10nm
    // 
    // Bits[22:22], RW/P, default = 0x0
    //
    UINT32 ch23cmd_ctl_delay : 1;
    //
    // XOR hash enable for Rank Select of the Rank Target (Bit [1] of 3 bit target rank)
    // This bit should be set only when the channel has DDR5 dual-rank DIMMs. In a 2DPC
    // configuration, both DIMMs need to be identical. This bit cannot be set for a DDR4
    // channel or if the channel has a single rank DIMM.  
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 rank_xor_enable : 1;
    //
    // XOR hash enable for subrank bits.
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINT32 sid_xor_enable : 1;
    //
    // Per channel based target. 
    //             0 = CPGC transactions go to DRAM scheduler.
    //             1 = CPGC transactions go to DDRT scheduler.  
    //         
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINT32 trng_target : 1;
    //
    // Number of cluster indication: 0 = hemi (or 2 clusters); 1 = quad (or 4 clusters)
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINT32 num_cluster : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 2;
    //
    // This bit specifies which kind of MC this is, HBM or DDR.  When 1, the MC is an
    // HBM MC.  When 0, it is a DDR MC (this includes both DDR4 and DDRT). 
    // 
    // Bits[29:29], RO/V, default = 0x0
    //
    UINT32 hbm_mc_mode : 1;
    //
    // This bit allows CPGC to drive traffic (CMI Mux and Address Decode) while in normal
    // mode. Training Mode implications are not observed by the MC while in this mode.
    // This bit has no effect when normal_mode=0. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 cpgc_active : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
  } Bits;
  UINT32 Data;
} MCMTR_MC_DEC_MEM_CSR_STRUCT_DDR;

#define SPARING_CONTROL_MC_DEC_MEM_CSR_REG_DDR             0x00020EFC
typedef union {
  struct {
    //
    // Spare enable when set to 1. Hardware clears this bit after the sparing completion.
    // 
    // Bits[0:0], RW/V, default = 0x0
    //
    UINT32 spare_enable : 1;
    //
    // 
    //                   Setting this bit will cause sparing engine to be run in reverse
    // (move from virtual lockstep back to independent) when sparing has been started
    // via the spare_enable bit. 
    //                   Expected usage models are upgrading a region failure from bank
    // to rank and post-silicon testing  
    //               
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 spare_reverse : 1;
    //
    // 
    //                   This bit causes the sparing copy to be rank sparing when sparing
    // copy has been started via the spare_enable bit. 
    // This bit is mutually exclusive with the adddc_sparing and sddc_sparing bits.
    //                   This register is locked by the DISABLE_RANK_SPARING bit from
    // IMC_FUSE_DOWNLOAD register. 
    //               
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 rank_sparing : 1;
    //
    // 
    //                   This bit causes the sparing copy to be ADDDC sparing when sparing
    // copy has been started via the spare_enable bit. 
    //                   This bit is mutually exclusive with the rank_sparing and sddc_sparing
    // bits. 
    //                   This register is locked by the DISABLE_ADDDC_SPARING bit from
    // IMC_FUSE_DOWNLOAD register. 
    //               
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 adddc_sparing : 1;
    //
    // 
    //                   This bit causes the sparing copy to transition ECC to the SDDC
    // state when sparing copy has been started via the spare_enable bit. 
    //                   This bit is mutually exclusive with the adddc_sparing and rank_sparing
    // bits. 
    //                   This register is locked by the DISABLE_SDDC bit from IMC_FUSE_DOWNLOAD
    // register. 
    //               
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 sddc_sparing : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
    //
    // 
    //                       This field selects the granularity for the sparing copy
    // operation: 
    //                       00=Bank
    //                       01=Rank
    //                       1X=Reserved
    //                   
    // 
    // Bits[8:7], RW, default = 0x0
    //
    UINT32 region_size : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // This bit indicates bank sparing is enabled
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINT32 bank_sparing : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // First TAD rule used for spare address generation. Set to 0 to begin generating
    // system addresses for sparing at the lowest address mapped to the MC. When mirr_adddc_en
    // = 1 and partial_mirr_en = 1, this represent the first TAD rule with mirror_en
    // = 1. 
    // 
    // Bits[14:12], RW, default = 0x0
    //
    UINT32 minimum_tad_rule : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // Last TAD rule used for spare address generation. Set to the maximum valid TAD
    // rule number used on the MC to generate system addresses for sparing up to the
    // maximum address mapped to the MC. When mirr_adddc_en = 1 and partial_mirr_en =
    // 1, this represent the last TAD rule with mirror_en = 1. 
    // 
    // Bits[18:16], RW, default = 0x0
    //
    UINT32 maximum_tad_rule : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 1;
    //
    // Enabling special spare copy mode for ADDDC and mirroring enable. In this mode,
    // system addresses will be gone through 3 times, with first pass for non-mirror
    // addresses, second pass for mirror primary addresses, and third pass for mirror
    // secondary addresses. For this function to work, amap.mirr_adddc_en needs to be
    // set to 1 in the channel spare copy is done. 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 mirr_adddc_en : 1;
    //
    // Only used when mirr_adddc_en = 1. When set to 1, indicates partial mirroring is
    // enabled and system addresses will be generated 3 times. If set to 0, only full
    // mirroring is enabled and first pass system address will be skipped. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 partial_mirr_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:22], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_5 : 2;
    //
    // First TAD rule for non-mirror region used for spare address generation. Set to
    // minimum valid TAD rule number with mirror_en = 0 to begin generating system addresses
    // for sparing at the lowest non-mirror address mapped to the MC. This field is used
    // only when mirr_adddc_en = 1 and partial_mirr_en = 1. 
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 minimum_tad_rule_nonmirr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_6 : 1;
    //
    // Last TAD rule for non-mirror region used for spare address generation. Set to
    // the maximum valid TAD rule number with mirror_en = 0 used on the MC to generate
    // system addresses for sparing up to the maximum non-mirror address mapped to the
    // MC. This field is used only when mirr_adddc_en = 1 and partial_mirr_en = 1. 
    // 
    // Bits[30:28], RW, default = 0x0
    //
    UINT32 maximum_tad_rule_nonmirr : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_7 : 1;
  } Bits;
  UINT32 Data;
} SPARING_CONTROL_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MCMAINDBGPRESEL0_MC_DEC_MEM_CSR_REG_DDR            0x00020F00
typedef union {
  struct {
    //
    // This selects which set of signals will be driven on lane 0 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[4:0], RW/P/L, default = 0x0
    //
    UINT32 ln0dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // This selects which set of signals will be driven on lane 1 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[12:8], RW/P/L, default = 0x0
    //
    UINT32 ln1dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 3;
    //
    // This selects which set of signals will be driven on lane 2 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[20:16], RW/P/L, default = 0x0
    //
    UINT32 ln2dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 3;
    //
    // This selects which set of signals will be driven on lane 3 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[28:24], RW/P/L, default = 0x0
    //
    UINT32 ln3dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 3;
  } Bits;
  UINT32 Data;
} MCMAINDBGPRESEL0_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MCMAINDBGPRESEL1_MC_DEC_MEM_CSR_REG_DDR            0x00020F04
typedef union {
  struct {
    //
    // This selects which set of signals will be driven on lane 4 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[4:0], RW/P/L, default = 0x0
    //
    UINT32 ln4dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // This selects which set of signals will be driven on lane 5 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[12:8], RW/P/L, default = 0x0
    //
    UINT32 ln5dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 3;
    //
    // This selects which set of signals will be driven on lane 6 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[20:16], RW/P/L, default = 0x0
    //
    UINT32 ln6dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:21], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 3;
    //
    // This selects which set of signals will be driven on lane 7 of the debug bus:
    // For Lane i of Ln[i]DbgEvSel, where i={0-7} and for each register field value of
    // j where the 5-bit j={0-31}: 
    // j: nibble lane i (bit [i*4+3 : i*4]) of event set j, which select debug bus bit[j*32+i*4+3
    // : j*32+i*4] 
    // 
    // Bits[28:24], RW/P/L, default = 0x0
    //
    UINT32 ln7dbgevsel : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 3;
  } Bits;
  UINT32 Data;
} MCMAINDBGPRESEL1_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MCMAINDBGSEL_MC_DEC_MEM_CSR_REG_DDR                0x00020F08
typedef union {
  struct {
    //
    // lane 0 select
    // 
    // Bits[5:0], RW/P/L, default = 0x0
    //
    UINT32 lane0sel : 6;
    //
    // lane 1 select
    // 
    // Bits[11:6], RW/P/L, default = 0x0
    //
    UINT32 lane1sel : 6;
    //
    // lane 2 select
    // 
    // Bits[17:12], RW/P/L, default = 0x0
    //
    UINT32 lane2sel : 6;
    //
    // lane 3 select
    // 
    // Bits[23:18], RW/P/L, default = 0x0
    //
    UINT32 lane3sel : 6;
    //
    // clock enable for debug mux
    // 
    // Bits[24:24], RW/P/L, default = 0x0
    //
    UINT32 clken : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 7;
  } Bits;
  UINT32 Data;
} MCMAINDBGSEL_MC_DEC_MEM_CSR_STRUCT_DDR;

#define RETRY_RD_ERR_SET3_LOG_ADDRESS3_L_MC_DEC_MEM_CSR_REG_DDR 0x00020F10
typedef union {
  struct {
    //
    // System address for last retry
    // 
    // Bits[31:0], RW/V/P, default = 0x0
    //
    UINT32 sysaddress : 32;
  } Bits;
  UINT32 Data;
} RETRY_RD_ERR_SET3_LOG_ADDRESS3_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define RETRY_RD_ERR_SET3_LOG_ADDRESS3_H_MC_DEC_MEM_CSR_REG_DDR 0x00020F14
typedef union {
  struct {
    //
    // System address for last retry
    // 
    // Bits[19:0], RW/V/P, default = 0x0
    //
    UINT32 sysaddress : 20;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 12;
  } Bits;
  UINT32 Data;
} RETRY_RD_ERR_SET3_LOG_ADDRESS3_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MCDBGBUSCNTRL1_MC_DEC_MEM_CSR_REG_DDR              0x00020F18
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:0], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 15;
    //
    // This will enable the debug bus. Can be used to gate clocks for all Debug flops.
    // This should really be RWS-L but the tool is not allowing me to do that.
    // 
    // Bits[15:15], RW/P/L, default = 0x0
    //
    UINT32 dbgbusen : 1;
  } Bits;
  UINT32 Data;
} MCDBGBUSCNTRL1_MC_DEC_MEM_CSR_STRUCT_DDR;

#define SCRATCHPAD_MC_DEC_MEM_CSR_REG_DDR                  0x00020F20
typedef union {
  struct {
    //
    // SCRATCHPAD
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINT32 scratchpad : 32;
  } Bits;
  UINT32 Data;
} SCRATCHPAD_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MCGLBRSPCNTL_MC_DEC_MEM_CSR_REG_DDR                0x00020F28
typedef union {
  struct {
    //
    // This selects which trigger will be driven out.
    // 000: MBP_OUT[0]
    // 001: MBP_OUT[1]
    // 010: ASC[0] output
    // 011: ASC[1] output
    // 100: CTS trigger out
    // 101: Do it forever
    // 110: Always 1
    // 111: Never assert output
    // 
    // Bits[2:0], RW/P/L, default = 0x7
    //
    UINT32 glbrsp0starttrigsel : 3;
    //
    // This selects the event that will cause the output to be deasserted.
    // 000: MBP[0]
    // 001: MBP[1]
    // 010: ASC[0]
    // 011: ASC[1]
    // 100: CTS Trigger out
    // 101: Stop 1 cycle after start
    // 110: Do it forever
    // 111: Stop when start is false
    // 
    // Bits[5:3], RW/P/L, default = 0x0
    //
    UINT32 glbrsp0stopsel : 3;
    //
    // Disable Global response logic 0.  This will abort any pending response.
    // 
    // Bits[6:6], RW/P/L, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This selects which trigger will be driven out.
    // 000: MBP_OUT[0]
    // 001: MBP_OUT[1]
    // 010: ASC[0] output
    // 011: ASC[1] output
    // 100: CTS trigger out
    // 101: Do it forever
    // 110: Always 1
    // 111: Never assert output
    // 
    // Bits[10:8], RW/P/L, default = 0x7
    //
    UINT32 glbrsp1starttrigsel : 3;
    //
    // This selects the event that will cause the output to be deasserted.
    // 000: MBP[0]
    // 001: MBP[1]
    // 010: ASC[0]
    // 011: ASC[1]
    // 100: CTS Trigger out
    // 101: Stop 1 cycle after start
    // 110: Do it forever
    // 111: Stop when start is false
    // 
    // Bits[13:11], RW/P/L, default = 0x0
    //
    UINT32 glbrsp1stopsel : 3;
    //
    // Disable Global response logic 1.  This will abort any pending response.
    // 
    // Bits[14:14], RW/P/L, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // This selects which trigger will be driven out.
    // 000: MBP_OUT[0]
    // 001: MBP_OUT[1]
    // 010: ASC[0] output
    // 011: ASC[1] output
    // 100: CTS trigger out
    // 101: Reserved
    // 110: Always 1
    // 111: Never assert output
    // 
    // Bits[18:16], RW/P/L, default = 0x7
    //
    UINT32 glbrsp2starttrigsel : 3;
    //
    // This selects the event that will cause the output to be deasserted.
    // 000: MBP[0]
    // 001: MBP[1]
    // 010: ASC[0]
    // 011: ASC[1]
    // 100: CTS Trigger out
    // 101: Stop 1 cycle after start
    // 110: Do it forever
    // 111: Stop when start is false
    // 
    // Bits[21:19], RW/P/L, default = 0x0
    //
    UINT32 glbrsp2stopsel : 3;
    //
    // Disable Global response logic 2.  This will abort any pending response.
    // 
    // Bits[22:22], RW/P/L, default = 0x0
    //
    UINT32 reserved_2 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 9;
  } Bits;
  UINT32 Data;
} MCGLBRSPCNTL_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MCNOASEL_MC_DEC_MEM_CSR_REG_DDR                    0x00020F48
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:0], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 12;
    //
    // This level of muxing will be used for taking only 8 bits of data instead of 16
    // to reduce the data rate on the NOA bus. The 8 bits selected will be accumulated
    // for 2 cycles and sent as one 16 bit value at half the rate. Output8[7:0]: 0 selects
    // output16[7:0]; 1 selects output16[15:8] 
    // 
    // Bits[12:12], RW/P/L, default = 0x0
    //
    UINT32 muxsel2 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Selects if the full rate or the half rate data should be sent out on the NOA bus.
    // 0: Select full speed data
    // 1: Select half rate data.
    // 
    // Bits[14:14], RW/P/L, default = 0x0
    //
    UINT32 noaoutsel : 1;
    //
    // This bit enables the NOA logic. No output is sent out on the NOA bus from iMC
    // if this bit is not set. 
    // 0: Disable NOA output from MC
    // 1: Enable NOA output from iMC.
    // 
    // Bits[15:15], RW/P/L, default = 0x0
    //
    UINT32 noaen : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 16;
  } Bits;
  UINT32 Data;
} MCNOASEL_MC_DEC_MEM_CSR_STRUCT_DDR;

#define VISA_CTL_DATA_MC_DEC_MEM_CSR_REG_DDR               0x00020F50
typedef union {
  struct {
    //
    // Read/Write data for VISA controller data registers
    // 
    // Bits[31:0], RW/P/L, default = 0x0
    //
    UINT32 visactldata : 32;
  } Bits;
  UINT32 Data;
} VISA_CTL_DATA_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MCDFXBGFCONTROL_MC_DEC_MEM_CSR_REG_DDR             0x00020F58
typedef union {
  struct {
    //
    // 
    //             BGF Stop Override (BgfStopOvrd):
    //             The DFx BGF is primarily controlled by the BgfRun signal of primary,
    // functional BGFs in 
    //             DFx BGFs neighborhood. Setting this field to 1, however, forces the
    // DFx BGF to stop. While the BGF is stopped,  
    //             the pattern generator, pattern checker and error counter are not running.
    // When the BGF is restarted  
    //             (i.e. when this field is cleared to 0), the error counter (i.e. the
    // ErrorCount field) is reset. 
    //             
    //             If the BGFs configuration is changed while it is running, spurious
    // errors will be logged.  
    //             To change configuration (pattern mode, read delay, read back borrow,
    // pointer separation offset), the standard procedure  
    //             is to stop the BGF (i.e. set this field 1), change the configuration,
    // and restart the BGF (set this field back to 0). 
    //             All the other writable fields should be sticky through reset. This
    // field is the exception; it should clear during reset. 
    //         
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 bgfstopovrd : 1;
    //
    // 
    //             Pattern Mode (PatternMode):
    //             This field controls the type of test pattern that runs through the
    // DFx FIFO:  
    //               0 = toggle pattern, 
    //               1 = pseudo-random bit sequence. 
    //             (This setting should not be changed while the BGF is running. See
    // Bgf StopOvrd.)  
    //             Path from register to pattern generator and checker may be multi-cycle.
    //         
    // 
    // Bits[1:1], RW/P, default = 0x1
    //
    UINT32 patternmode : 1;
    //
    // 
    //             Enable Read Delay (EnRdDelay):
    //             While this field (and EnRdBkBrw) is set to 0, BGF read timing follows
    // standard BGF behavior. If this field is set to 1,  
    //             all reads are delayed by one cycle. This setting may be combined with
    // EnRdBkBrw.   
    //             (This setting should not be changed while the BGF is running. See
    // BgfStopOvrd.)        
    //             Path from register to pattern checker may be multi-cycle.
    //         
    // 
    // Bits[2:2], RW/P, default = 0x0
    //
    UINT32 enrddelay : 1;
    //
    // 
    //             Pointer Separation Offset (EnRdBkBrw):
    //             While this field (and EnRdDelay) is set to 0, BGF read timing follows
    // standard BGF behavior.  
    //             If this field is set to 1, read data is sampled half a read clock
    // earlier. This setting may be combined 
    //             with EnRdDelay. (This setting should not be changed while the BGF
    // is running. See BgfStopOvrd.)     
    //             Path from register to pattern checker may be multi-cycle.
    //         
    // 
    // Bits[3:3], RW/P, default = 0x0
    //
    UINT32 enrdbkbrw : 1;
    //
    // 
    //             Pointer Separation Offset (PtrSepOffset):
    //             This field specifies the offset between the pointer separation of
    // nearby primary, functional BGFs to the pointer  
    //             separation of the DFx BGF. The DFx BGFs pointer separation is the
    // primary BGFs pointer separation minus this offset.  
    //             (This setting should not be changed while the BGF is running. See
    // bgfstopovrd.)   
    //             Path from register to DFx BGFs pointer separation calculation logic
    // may be multi-cycle. 
    //         
    // 
    // Bits[6:4], RW/P, default = 0x1
    //
    UINT32 ptrsepoffset : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // 
    //             Effective Pointer Separation (PtrSepEff):
    //             This field shows the effective pointer separation applied to the DFx
    // BGF (i.e. it is the primary BGF  
    //             pointer separation minus PtrSepOffset). Note that this value is actually
    // the program value; the 
    //             conceptual pointer separation is the program value plus two.  Shouldnt
    // need any flip-flops at register. 
    //             Value may flow through from logic that computes the effective pointer
    // separation. Path to register may be multi-cycle. 
    //         
    // 
    // Bits[10:8], RO/V, default = 0x0
    //
    UINT32 ptrsepeff : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // 
    //             This field shows the number of errors accumulated since the DFx BGF
    // was last started. The error count  
    //             saturates at its maximum value. It may be cleared (write 1 to clear)
    // while the BGF is running. 
    //             (Clearing this field does not reset the pattern generator, BGF or
    // pattern checker; they keep running.)      
    //             Shouldnt need any flip-flops at register. Value may flow through from
    // error counter.  
    //             Path from error counter to register may be multi-cycle. 
    //             If path is multi-cycle, then BGF should be stopped (see BgfStopOvrd)
    // to read a, reliable, stable error count value. 
    //             When a 1 is written to this field, send a two-cycle long clear signal
    // to the error counter logic.  
    //             The clear signal may be multi-cycle.
    //         
    // 
    // Bits[31:12], RW/1C/V/P, default = 0x0
    //
    UINT32 errorcount : 20;
  } Bits;
  UINT32 Data;
} MCDFXBGFCONTROL_MC_DEC_MEM_CSR_STRUCT_DDR;

#define VISA_CTL_ADDR_MC_DEC_MEM_CSR_REG_DDR               0x00020F60
typedef union {
  struct {
    //
    // Read/Write addr for VISA controller addr registers
    // 
    // Bits[31:0], RW/P/L, default = 0x0
    //
    UINT32 visactladdr : 32;
  } Bits;
  UINT32 Data;
} VISA_CTL_ADDR_MC_DEC_MEM_CSR_STRUCT_DDR;

#define LT_CPGC_CONTROL_MC_DEC_MEM_CSR_REG_DDR             0x00020F68
typedef union {
  struct {
    //
    // CPGC engine lock control from UCODE. This register controls write access to all
    // cpgc registers 
    // with the excpetion of cpgc_pda_shadow,cpgc_pda,cpgc_patwdbclmux,cpgc_patwdb,cpgc_patwdbcl,
    // cpgc_patwdb_wr0/cpgc_patwdb_wr1 registers.
    // 00: CPGC is fully unlocked in non_normal mode (training). In normal mode, determined
    // by 
    // MCMTR.normal and MCMTR.trng_mode, this setting operates the same as 10 setting.
    // margining (MRS issue from CADB) are unlocked.
    // 01: Reserved. CPGC is locked. Nothing can be issued by CPGC engine. mc_init_state_g
    // is locked. 
    // 10: Only parts of CPGC engine necessary for Vref margining (MRS issue from CADB)
    // is 
    // unlocked (regardless of value of normal mode); mc_init_state_g is locked. The
    // register fields 
    // which are unlocked in this mode are: cpgc_seqctl*.global_control,cpgc_seqctl*.local_start_test,
    // all fields of cpgc_patcadbmrs_mrs,all fields of cr_cpgc_patcadbprog*,
    // cpgc_patcadbwrpntr.write_pointer .
    // cr_cpgc_seqctl*.initialization_mode is restricted to MRS mode.
    // 11: CPGC is locked. Nothing can be issued by CPGC engine. mc_init_state_g is locked.
    // 
    // Bits[1:0], RW, default = 0x3
    //
    UINT32 res_lock : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:2], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 30;
  } Bits;
  UINT32 Data;
} LT_CPGC_CONTROL_MC_DEC_MEM_CSR_STRUCT_DDR;

#define INTERNAL_ERROR_2LMMISC_L_MC_DEC_MEM_CSR_REG_DDR    0x00020F70
typedef union {
  struct {
    //
    // Programmed scrub starting base address above TAD limit
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINT32 pat_illegal_init_addr : 1;
    //
    // Programmed scrub starting address above TAD limit
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINT32 pat_illegal_init_addr2 : 1;
    //
    // Patrol error
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINT32 pat_illegal_ack_inc : 1;
    //
    // Sparing error
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINT32 spr_sparesissued_underflow : 1;
    //
    // Sparing error
    // 
    // Bits[4:4], RO/V, default = 0x0
    //
    UINT32 spr_m2m_conflict : 1;
    //
    // PkgC error
    // 
    // Bits[5:5], RO/V, default = 0x0
    //
    UINT32 com_pkgc_pkgs_err : 1;
    //
    // DDRT error
    // 
    // Bits[6:6], RO/V, default = 0x0
    //
    UINT32 ddrt2_reads_linkfail : 1;
    //
    // DDRT error
    // 
    // Bits[7:7], RO/V, default = 0x0
    //
    UINT32 ddrt_wpq_valid_pwr_not_found : 1;
    //
    // 2LM controller error
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINT32 mc2lm_unexp_intlv : 1;
    //
    // 2LM controller error
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINT32 mc2lm_bad_ddr4_attr : 1;
    //
    // 2LM controller error
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINT32 mc2lm_nm_mirr_bit_set : 1;
    //
    // 2LM controller error
    // 
    // Bits[11:11], RO/V, default = 0x0
    //
    UINT32 mc2lm_reuse_valid_sbentry : 1;
    //
    // 2LM controller error
    // 
    // Bits[12:12], RO/V, default = 0x0
    //
    UINT32 mc2lm_bad_sbentry_patrol : 1;
    //
    // 2LM controller error
    // 
    // Bits[13:13], RO/V, default = 0x0
    //
    UINT32 mc2lm_bad_sbentry_nonpatrol : 1;
    //
    // 2LM controller error
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINT32 mc2lm_nmfill_wr_camvec_none : 1;
    //
    // 2LM controller error
    // 
    // Bits[15:15], RO/V, default = 0x0
    //
    UINT32 mc2lm_unexp_wrflush_done : 1;
    //
    // 2LM controller error
    // 
    // Bits[16:16], RO/V, default = 0x0
    //
    UINT32 mc2lm_unexp_wrflush : 1;
    //
    // 2LM controller error
    // 
    // Bits[17:17], RO/V, default = 0x0
    //
    UINT32 mc2lm_erid_cmpl_err : 1;
    //
    // 2LM controller error
    // 
    // Bits[18:18], RO/V, default = 0x0
    //
    UINT32 mc2lm_bad_ddr4_wrt_cmpl0 : 1;
    //
    // 2LM controller error
    // 
    // Bits[19:19], RO/V, default = 0x0
    //
    UINT32 mc2lm_bad_ddr4_wrt_cmpl1 : 1;
    //
    // 2LM controller error
    // 
    // Bits[20:20], RO/V, default = 0x0
    //
    UINT32 mc2lm_bad_ddrt0_wrt_cmpl : 1;
    //
    // 2LM controller error
    // 
    // Bits[21:21], RO/V, default = 0x0
    //
    UINT32 mc2lm_bad_ddrt1_wrt_cmpl : 1;
    //
    // 2LM controller error
    // 
    // Bits[22:22], RO/V, default = 0x0
    //
    UINT32 mc2lm_ddr4_read_cpl_should_hit_sb : 1;
    //
    // 2LM controller error
    // 
    // Bits[23:23], RO/V, default = 0x0
    //
    UINT32 mc2lm_ddrt_read_cpl_should_hit_sb : 1;
    //
    // 2LM controller error
    // 
    // Bits[24:24], RO/V, default = 0x0
    //
    UINT32 mc2lm_invalid_retry_htid : 1;
    //
    // 2LM controller error
    // 
    // Bits[25:25], RO/V, default = 0x0
    //
    UINT32 mc2lm_patrol_overflow : 1;
    //
    // 2LM controller error
    // 
    // Bits[26:26], RO/V, default = 0x0
    //
    UINT32 mc2lm_sb_tag_arr_rden : 1;
    //
    // 2LM controller error
    // 
    // Bits[27:27], RO/V, default = 0x0
    //
    UINT32 mc2lm_sb_index_arr_rden : 1;
    //
    // Decoder error
    // 
    // Bits[28:28], RO/V, default = 0x0
    //
    UINT32 decs_bad_accept : 1;
    //
    // Decoder error
    // 
    // Bits[29:29], RO/V, default = 0x0
    //
    UINT32 decs_sys2chn_dec_err : 1;
    //
    // Decoder error
    // 
    // Bits[30:30], RO/V, default = 0x0
    //
    UINT32 decs_chn2rir_dec_err : 1;
    //
    // Decoder error
    // 
    // Bits[31:31], RO/V, default = 0x0
    //
    UINT32 decs_ddrt_specread : 1;
  } Bits;
  UINT32 Data;
} INTERNAL_ERROR_2LMMISC_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define INTERNAL_ERROR_2LMMISC_H_MC_DEC_MEM_CSR_REG_DDR    0x00020F74
typedef union {
  struct {
    //
    // Decoder error
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINT32 decs_patrol_retry_confl : 1;
    //
    // CMI error
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINT32 cmi_cpl_fifo_uf : 1;
    //
    // CMI error
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINT32 cmi_cpl_fifo_of : 1;
    //
    // CMI error
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINT32 cmi_cpl_cmd_fifo_uf : 1;
    //
    // CMI error
    // 
    // Bits[4:4], RO/V, default = 0x0
    //
    UINT32 cmi_cpl_cmd_fifo_of : 1;
    //
    // CMI error
    // 
    // Bits[5:5], RO/V, default = 0x0
    //
    UINT32 cmi_cpl_late_viol : 1;
    //
    // CMI error
    // 
    // Bits[6:6], RO/V, default = 0x0
    //
    UINT32 cmi_cpl_late_viol_2 : 1;
    //
    // CMI error
    // 
    // Bits[7:7], RO/V, default = 0x0
    //
    UINT32 cmi_cpl_late_viol_3 : 1;
    //
    // CMI error
    // 
    // Bits[8:8], RO/V, default = 0x0
    //
    UINT32 cmi_cpl_data_viol : 1;
    //
    // CMI error
    // 
    // Bits[9:9], RO/V, default = 0x0
    //
    UINT32 cmi_cpl_data_viol_2 : 1;
    //
    // CMI error
    // 
    // Bits[10:10], RO/V, default = 0x0
    //
    UINT32 cmi_req_viol : 1;
    //
    // CMI error
    // 
    // Bits[11:11], RO/V, default = 0x0
    //
    UINT32 cmi_rsp_viol_1 : 1;
    //
    // CMI error
    // 
    // Bits[12:12], RO/V, default = 0x0
    //
    UINT32 cmi_rsp_viol_2 : 1;
    //
    // CMI error
    // 
    // Bits[13:13], RO/V, default = 0x0
    //
    UINT32 cmi_rsp_viol_3 : 1;
    //
    // 2LM controller error
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINT32 mc2lm_sb_overflow : 1;
    //
    // Decoder error
    // 
    // Bits[15:15], RO/V, default = 0x0
    //
    UINT32 decs_wrong_spr_rank : 1;
    //
    // DDRT error
    // 
    // Bits[16:16], RO/V, default = 0x0
    //
    UINT32 ddrt_rpq_valid_idle : 1;
    //
    // DDRT error
    // 
    // Bits[17:17], RO/V, default = 0x0
    //
    UINT32 ddrt_wpq_valid_idle : 1;
    //
    // DDRT error
    // 
    // Bits[18:18], RO/V, default = 0x0
    //
    UINT32 ddrt2_wrcrdt_starvation : 1;
    //
    // DDRT error
    // 
    // Bits[19:19], RO/V, default = 0x0
    //
    UINT32 ddrt2_tgr_starvation : 1;
    //
    // DDRT error - combined illegal conditions ( invalid req pulse width, info/interrupt
    // packet received on secondary subchannel, read data came on different subchannel
    // etc) 
    // 
    // Bits[20:20], RO/V, default = 0x0
    //
    UINT32 ddrt2_illegal_conditions : 1;
    //
    // 2LM internal error
    // 
    // Bits[21:21], RO/V, default = 0x0
    //
    UINT32 mc2lm_sbtag_fifo_overflow : 1;
    //
    // 2LM internal error
    // 
    // Bits[22:22], RO/V, default = 0x0
    //
    UINT32 mc2lm_sbtag_fifo_underflow : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 9;
  } Bits;
  UINT32 Data;
} INTERNAL_ERROR_2LMMISC_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DIS_INTERNAL_ERROR_2LMMISC_L_MC_DEC_MEM_CSR_REG_DDR 0x00020F78
typedef union {
  struct {
    //
    // Disable error caused by programmed scrub starting base address above TAD limit
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 dis_pat_illegal_init_addr : 1;
    //
    // Disable error caused by programmed scrub starting address above TAD limit
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 dis_pat_illegal_init_addr2 : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 dis_pat_illegal_ack_inc : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 dis_spr_sparesissued_underflow : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 dis_spr_m2m_conflict : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[5:5], RW, default = 0x1
    //
    UINT32 dis_com_pkgc_pkgs_err : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 dis_ddrt2_reads_linkfail : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 dis_ddrt_wpq_valid_pwr_not_found : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 dis_mc2lm_unexp_intlv : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINT32 dis_mc2lm_bad_ddr4_attr : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINT32 dis_mc2lm_nm_mirr_bit_set : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINT32 dis_mc2lm_reuse_valid_sbentry : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINT32 dis_mc2lm_bad_sbentry_patrol : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINT32 dis_mc2lm_bad_sbentry_nonpatrol : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINT32 dis_mc2lm_nmfill_wr_camvec_none : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINT32 dis_mc2lm_unexp_wrflush_done : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINT32 dis_mc2lm_unexp_wrflush : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 dis_mc2lm_erid_cmpl_err : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 dis_mc2lm_bad_ddr4_wrt_cmpl0 : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINT32 dis_mc2lm_bad_ddr4_wrt_cmpl : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 dis_mc2lm_bad_ddrt0_wrt_cmpl : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 dis_mc2lm_bad_ddrt1_wrt_cmpl : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINT32 dis_mc2lm_ddr4_read_cpl_should_hit_sb : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 dis_mc2lm_ddrt_read_cpl_should_hit_sb : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[24:24], RW, default = 0x0
    //
    UINT32 dis_mc2lm_invalid_retry_htid : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[25:25], RW, default = 0x0
    //
    UINT32 dis_mc2lm_patrol_overflow : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINT32 dis_mc2lm_sb_tag_arr_rden : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 dis_mc2lm_sb_index_arr_rden : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINT32 dis_decs_bad_accept : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINT32 dis_decs_sys2chn_dec_err : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 dis_decs_chn2rir_dec_err : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 dis_decs_ddrt_specread : 1;
  } Bits;
  UINT32 Data;
} DIS_INTERNAL_ERROR_2LMMISC_L_MC_DEC_MEM_CSR_STRUCT_DDR;

#define DIS_INTERNAL_ERROR_2LMMISC_H_MC_DEC_MEM_CSR_REG_DDR 0x00020F7C
typedef union {
  struct {
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 dis_decs_patrol_retry_confl : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 dis_cmi_cpl_fifo_uf : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 dis_cmi_cpl_fifo_of : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 dis_cmi_cpl_cmd_fifo_uf : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 dis_cmi_cpl_cmd_fifo_of : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINT32 dis_cmi_cpl_late_viol : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 dis_cmi_cpl_late_viol_2 : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 dis_cmi_cpl_late_viol_3 : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 dis_cmi_cpl_data_viol : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINT32 dis_cmi_cpl_data_viol_2 : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINT32 dis_cmi_req_viol : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINT32 dis_cmi_rsp_viol_1 : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINT32 dis_cmi_rsp_viol_2 : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINT32 dis_cmi_rsp_viol_3 : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINT32 dis_mc2lm_sb_overflow : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINT32 dis_decs_wrong_spr_rank : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[16:16], RW, default = 0x1
    //
    UINT32 dis_ddrt_rpq_valid_idle : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[17:17], RW, default = 0x1
    //
    UINT32 dis_ddrt_wpq_valid_idle : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[18:18], RW, default = 0x1
    //
    UINT32 dis_ddrt2_wrcrdt_starvation : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[19:19], RW, default = 0x1
    //
    UINT32 dis_ddrt2_tgr_starvation : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[20:20], RW, default = 0x1
    //
    UINT32 ddrt2_illegal_conditions : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 dis_mc2lm_sbtag_fifo_overflow : 1;
    //
    // Disable corresponding error in internal_error_2lmmisc register
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINT32 dis_mc2lm_sbtag_fifo_underflow : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 9;
  } Bits;
  UINT32 Data;
} DIS_INTERNAL_ERROR_2LMMISC_H_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MC_CPGC_CTL_MC_DEC_MEM_CSR_REG_DDR                 0x00020F80
typedef union {
  struct {
    //
    // 0x0 = Clock gating operates as usual
    // 0x1 = CPGC clock forced to enabled
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 cpgc_safe_mode : 1;
    //
    // 0x0 = No manual reset asserted from this CR,
    // 0x1 = Manual warm reset asserted (bios needs to clear this bit after setting it)
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 cpgc_reset : 1;
    //
    // 0x0 = Replace HTID with contiguous sequenc (0,1,2..)
    // 0x1 = Replace HTID with even sequenc (0,2,4..)
    // 0x2 = Replace HTID with oddsequenc (1,3,5..)
    // 0x3 = Use HTID that came over CMI from CPGC,
    // 
    // Bits[3:2], RW, default = 0x0
    //
    UINT32 cpgc_htid_replace : 2;
    //
    // Self clearing CR where HTID replacement values are cleared
    // 
    // Bits[4:4], RW/V, default = 0x0
    //
    UINT32 cpgc_htid_reset : 1;
    //
    // 0x0 = No Replace
    // 0x1 = No Replace
    // 0x2 = Replace CPGC ReqLen with 0
    // 0x3 = Replace CPGC ReqLen with 1
    // 
    // Bits[6:5], RW, default = 0x0
    //
    UINT32 cpgc_reqlen_replace : 2;
    //
    // 0x0 = CRNode Request Addr bit 0 wakes up CPGC
    // 0x1 = CRNode Request Addr bit 0 doesn't wake up CPGC
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 cpgc_disable_sb_wakeup : 1;
    //
    // If set, MC will supress traffic CS to the rank specified in cpgc_nocs_rank_match
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 cpgc_nocs_rank_en : 1;
    //
    // MC will supress traffic CS to the rank specified by this value if cpgc_nocs_rank_en
    // is set 
    // 
    // Bits[11:9], RW, default = 0x0
    //
    UINT32 cpgc_nocs_rank_match : 3;
    //
    // If set, MC will send traffic to DDRT for rank specified in cpgc_mixed_ddrt_rank_match
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINT32 cpgc_mixed_ddrt_rank_en : 1;
    //
    // MC will send traffic to DDRT for the rank specified by this value if cpgc_mixed_ddrt_rank_en
    // is set 
    // 
    // Bits[15:13], RW, default = 0x0
    //
    UINT32 cpgc_mixed_ddrt_rank_match : 3;
    //
    // 0x0 = BG[1:0] and BA[1:0] are swapped (like normal functional traffic bank)
    // 0x1 = CPGC Bank outputed from the CPGC is 1:1 mapped to the scheduler
    // 
    // Bits[16:16], RW, default = 0x1
    //
    UINT32 cpgc_bank_map : 1;
    //
    // 0x0 = CPGC Rank is Sched Rank (rank bit 0 = pseudochan)
    // 0x1 = Sched Rank bit 0 is fixed to pseudochan strap, sched rank bit 1 is cpgc
    // rank bit 0 
    // 
    // Bits[17:17], RW, default = 0x1
    //
    UINT32 cpgc_use_chan_id : 1;
    //
    // 0x0 = DDR5-only - shifts column to have cpgc lsb at CA4
    // 0x1 = Disables the shift and has cpgc lsb at CA3 (like ddr4)
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 cpgc_use_critical_bit : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:19], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 13;
  } Bits;
  UINT32 Data;
} MC_CPGC_CTL_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MC_CPGC_RANK_MAP_MC_DEC_MEM_CSR_REG_DDR            0x00020F84
typedef union {
  struct {
    //
    // Defines what Physical Rank Address (Memory controller Rank Mapping) is mapped
    // to this logical Rank Address-0 
    // (Sequence Address logic doamin).
    // It is possible to use more Logical_to_Physical_Rank#_Mapping fileds than actual
    // Physical Ranks which is useful for more complex 
    // tests where non linear Physical Rank Sequences are needed.
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 rank0_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Rank Address-1 mapping
    // 
    // Bits[6:4], RW, default = 0x0
    //
    UINT32 rank1_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Rank Address-2 mapping
    // 
    // Bits[10:8], RW, default = 0x0
    //
    UINT32 rank2_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Rank Address-3 mapping
    // 
    // Bits[14:12], RW, default = 0x0
    //
    UINT32 rank3_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // Rank Address-4 mapping
    // 
    // Bits[18:16], RW, default = 0x0
    //
    UINT32 rank4_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 1;
    //
    // Rank Address-5 mapping
    // 
    // Bits[22:20], RW, default = 0x0
    //
    UINT32 rank5_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_5 : 1;
    //
    // Rank Address-6 mapping
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rank6_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_6 : 1;
    //
    // Rank Address-7 mapping
    // 
    // Bits[30:28], RW, default = 0x0
    //
    UINT32 rank7_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_7 : 1;
  } Bits;
  UINT32 Data;
} MC_CPGC_RANK_MAP_MC_DEC_MEM_CSR_STRUCT_DDR;

#define MC_CPGC_SUBRANK_MAP_MC_DEC_MEM_CSR_REG_DDR         0x00020F90
typedef union {
  struct {
    //
    // Defines what Physical Rank Address (Memory controller Rank Mapping) is mapped
    // to this logical Rank Address-0 
    // (Sequence Address logic doamin).
    // It is possible to use more Logical_to_Physical_Rank#_Mapping fileds than actual
    // Physical Ranks which is useful for more complex 
    // tests where non linear Physical Rank Sequences are needed.
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 rank0_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Rank Address-1 mapping
    // 
    // Bits[6:4], RW, default = 0x0
    //
    UINT32 rank1_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Rank Address-2 mapping
    // 
    // Bits[10:8], RW, default = 0x0
    //
    UINT32 rank2_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Rank Address-3 mapping
    // 
    // Bits[14:12], RW, default = 0x0
    //
    UINT32 rank3_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // Rank Address-4 mapping
    // 
    // Bits[18:16], RW, default = 0x0
    //
    UINT32 rank4_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 1;
    //
    // Rank Address-5 mapping
    // 
    // Bits[22:20], RW, default = 0x0
    //
    UINT32 rank5_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_5 : 1;
    //
    // Rank Address-6 mapping
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rank6_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_6 : 1;
    //
    // Rank Address-7 mapping
    // 
    // Bits[30:28], RW, default = 0x0
    //
    UINT32 rank7_mapping : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_7 : 1;
  } Bits;
  UINT32 Data;
} MC_CPGC_SUBRANK_MAP_MC_DEC_MEM_CSR_STRUCT_DDR;


#endif // _MMRCMC_DEC_MEM_CSR_DDR_H_DDR_
