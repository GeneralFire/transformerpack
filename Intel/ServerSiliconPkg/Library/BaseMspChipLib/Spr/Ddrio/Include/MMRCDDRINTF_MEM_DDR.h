/** @file
  File name:    MMRCDDRINTF_MEM_DDR.h
  Input File:   SPR_MRC_DDR.xlsx
  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.
  If edits are needed in this file, they must be done via the MSP tool.
  If there is additional project-specific data required by the MSP, it
  can be placed in MMRCDDRINTF_MEM_DDR.h, which is used for non-tool-generated
  data
  Includes register defines specific to a project.

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2005 - 2020 Intel Corporation. <BR>

  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.

  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.

  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
**/

#ifndef _MMRCDDRINTF_MEM_DDR_H_DDR_
#define _MMRCDDRINTF_MEM_DDR_H_DDR_

#include "MspDataTypes.h"

#define DDRINTF_CTL0_CH_0__DDRINTF_MEM_REG_DDR             0x00013F00
typedef union {
  struct {
    //
    // Set to 1 to enable HW to gate DCLK. Default is disable clock gating. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 dclk_gate_en : 1;
    //
    // Channel Disable[br]
    //                     - shut off all analog/DCLK/DLL
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 ch_dis : 1;
    //
    // Enable write crc mode.[br]
    //                     DDR4: extend BL8 write to BL10.[br]
    //                     DDR5: extend BL16 write to BL18.
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 wr_crc_en : 1;
    //
    // When set to 1, HW uses the rank_value_ovr field to select rank parameters instead
    // of rank number from MC. It is used for training step that require to read out
    // rank specific infomration without MC command.[br] 
    //                     Note: The current use case is for DDR4 Write leveling training.
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 rank_ovr_en : 1;
    //
    // When rank_ovr_en is set, this rank override value is used by HW to select rank
    // parameters instead of rank number from MC. It is used for training step that require
    // to read out rank specific infomration without MC command.[br] 
    //                     Note: The current use case is for DDR4 Write leveling training.
    // 
    // Bits[6:4], RW, default = 0x0
    //
    UINT32 rank_value_ovr : 3;
    //
    // DDR5: Set to 1 to gate txfifo_wren during write leveling[br]
    //                     DDR4: Set to 1 to enable INTF to generate a BL8 DQS output
    // enable every 32 DCLK for 1K DCLK duration, also gates txfifo_wren during write
    // leveling.[br] 
    //                     Note: For DDR4, setting any sub-channel control bit will start
    // the write leveling logic in INTF for the entire channel. 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 wr_level_train_en : 1;
    //
    // Set to 1 to enable HW to gate DCLK for TX repeaters. Default is disable clock
    // gating.  
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 txclk_gate_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 23;
  } Bits;
  UINT32 Data;
} DDRINTF_CTL0_CH_0__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_CTL0_CH_1__DDRINTF_MEM_REG_DDR             0x00013F04
typedef union {
  struct {
    //
    // Set to 1 to enable HW to gate DCLK. Default is disable clock gating. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 dclk_gate_en : 1;
    //
    // Channel Disable[br]
    //                     - shut off all analog/DCLK/DLL
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 ch_dis : 1;
    //
    // Enable write crc mode.[br]
    //                     DDR4: extend BL8 write to BL10.[br]
    //                     DDR5: extend BL16 write to BL18.
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 wr_crc_en : 1;
    //
    // When set to 1, HW uses the rank_value_ovr field to select rank parameters instead
    // of rank number from MC. It is used for training step that require to read out
    // rank specific infomration without MC command.[br] 
    //                     Note: The current use case is for DDR4 Write leveling training.
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 rank_ovr_en : 1;
    //
    // When rank_ovr_en is set, this rank override value is used by HW to select rank
    // parameters instead of rank number from MC. It is used for training step that require
    // to read out rank specific infomration without MC command.[br] 
    //                     Note: The current use case is for DDR4 Write leveling training.
    // 
    // Bits[6:4], RW, default = 0x0
    //
    UINT32 rank_value_ovr : 3;
    //
    // DDR5: Set to 1 to gate txfifo_wren during write leveling[br]
    //                     DDR4: Set to 1 to enable INTF to generate a BL8 DQS output
    // enable every 32 DCLK for 1K DCLK duration, also gates txfifo_wren during write
    // leveling.[br] 
    //                     Note: For DDR4, setting any sub-channel control bit will start
    // the write leveling logic in INTF for the entire channel. 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 wr_level_train_en : 1;
    //
    // Set to 1 to enable HW to gate DCLK for TX repeaters. Default is disable clock
    // gating.  
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 txclk_gate_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 23;
  } Bits;
  UINT32 Data;
} DDRINTF_CTL0_CH_1__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_CTL0_CH_2__DDRINTF_MEM_REG_DDR             0x00013F08
typedef union {
  struct {
    //
    // Set to 1 to enable HW to gate DCLK. Default is disable clock gating. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 dclk_gate_en : 1;
    //
    // Channel Disable[br]
    //                     - shut off all analog/DCLK/DLL
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 ch_dis : 1;
    //
    // Enable write crc mode.[br]
    //                     DDR4: extend BL8 write to BL10.[br]
    //                     DDR5: extend BL16 write to BL18.
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 wr_crc_en : 1;
    //
    // When set to 1, HW uses the rank_value_ovr field to select rank parameters instead
    // of rank number from MC. It is used for training step that require to read out
    // rank specific infomration without MC command.[br] 
    //                     Note: The current use case is for DDR4 Write leveling training.
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 rank_ovr_en : 1;
    //
    // When rank_ovr_en is set, this rank override value is used by HW to select rank
    // parameters instead of rank number from MC. It is used for training step that require
    // to read out rank specific infomration without MC command.[br] 
    //                     Note: The current use case is for DDR4 Write leveling training.
    // 
    // Bits[6:4], RW, default = 0x0
    //
    UINT32 rank_value_ovr : 3;
    //
    // DDR5: Set to 1 to gate txfifo_wren during write leveling[br]
    //                     DDR4: Set to 1 to enable INTF to generate a BL8 DQS output
    // enable every 32 DCLK for 1K DCLK duration, also gates txfifo_wren during write
    // leveling.[br] 
    //                     Note: For DDR4, setting any sub-channel control bit will start
    // the write leveling logic in INTF for the entire channel. 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 wr_level_train_en : 1;
    //
    // Set to 1 to enable HW to gate DCLK for TX repeaters. Default is disable clock
    // gating.  
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 txclk_gate_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 23;
  } Bits;
  UINT32 Data;
} DDRINTF_CTL0_CH_2__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_CTL0_CH_3__DDRINTF_MEM_REG_DDR             0x00013F0C
typedef union {
  struct {
    //
    // Set to 1 to enable HW to gate DCLK. Default is disable clock gating. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 dclk_gate_en : 1;
    //
    // Channel Disable[br]
    //                     - shut off all analog/DCLK/DLL
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 ch_dis : 1;
    //
    // Enable write crc mode.[br]
    //                     DDR4: extend BL8 write to BL10.[br]
    //                     DDR5: extend BL16 write to BL18.
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 wr_crc_en : 1;
    //
    // When set to 1, HW uses the rank_value_ovr field to select rank parameters instead
    // of rank number from MC. It is used for training step that require to read out
    // rank specific infomration without MC command.[br] 
    //                     Note: The current use case is for DDR4 Write leveling training.
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 rank_ovr_en : 1;
    //
    // When rank_ovr_en is set, this rank override value is used by HW to select rank
    // parameters instead of rank number from MC. It is used for training step that require
    // to read out rank specific infomration without MC command.[br] 
    //                     Note: The current use case is for DDR4 Write leveling training.
    // 
    // Bits[6:4], RW, default = 0x0
    //
    UINT32 rank_value_ovr : 3;
    //
    // DDR5: Set to 1 to gate txfifo_wren during write leveling[br]
    //                     DDR4: Set to 1 to enable INTF to generate a BL8 DQS output
    // enable every 32 DCLK for 1K DCLK duration, also gates txfifo_wren during write
    // leveling.[br] 
    //                     Note: For DDR4, setting any sub-channel control bit will start
    // the write leveling logic in INTF for the entire channel. 
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 wr_level_train_en : 1;
    //
    // Set to 1 to enable HW to gate DCLK for TX repeaters. Default is disable clock
    // gating.  
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 txclk_gate_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 23;
  } Bits;
  UINT32 Data;
} DDRINTF_CTL0_CH_3__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_RT_LAT0_CH_0__DDRINTF_MEM_REG_DDR          0x00013F10
typedef union {
  struct {
    //
    // Roundtrip Latency for rank 0 (in DCLKs)
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINT32 rt_lat0 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Roundtrip Latency for rank 1 (in DCLKs)
    // 
    // Bits[14:8], RW, default = 0x0
    //
    UINT32 rt_lat1 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Roundtrip Latency for rank 2 (in DCLKs)
    // 
    // Bits[22:16], RW, default = 0x0
    //
    UINT32 rt_lat2 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Roundtrip Latency for rank 3 (in DCLKs)
    // 
    // Bits[30:24], RW, default = 0x0
    //
    UINT32 rt_lat3 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
  } Bits;
  UINT32 Data;
} DDRINTF_RT_LAT0_CH_0__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_RT_LAT0_CH_1__DDRINTF_MEM_REG_DDR          0x00013F14
typedef union {
  struct {
    //
    // Roundtrip Latency for rank 0 (in DCLKs)
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINT32 rt_lat0 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Roundtrip Latency for rank 1 (in DCLKs)
    // 
    // Bits[14:8], RW, default = 0x0
    //
    UINT32 rt_lat1 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Roundtrip Latency for rank 2 (in DCLKs)
    // 
    // Bits[22:16], RW, default = 0x0
    //
    UINT32 rt_lat2 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Roundtrip Latency for rank 3 (in DCLKs)
    // 
    // Bits[30:24], RW, default = 0x0
    //
    UINT32 rt_lat3 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
  } Bits;
  UINT32 Data;
} DDRINTF_RT_LAT0_CH_1__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_RT_LAT0_CH_2__DDRINTF_MEM_REG_DDR          0x00013F18
typedef union {
  struct {
    //
    // Roundtrip Latency for rank 0 (in DCLKs)
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINT32 rt_lat0 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Roundtrip Latency for rank 1 (in DCLKs)
    // 
    // Bits[14:8], RW, default = 0x0
    //
    UINT32 rt_lat1 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Roundtrip Latency for rank 2 (in DCLKs)
    // 
    // Bits[22:16], RW, default = 0x0
    //
    UINT32 rt_lat2 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Roundtrip Latency for rank 3 (in DCLKs)
    // 
    // Bits[30:24], RW, default = 0x0
    //
    UINT32 rt_lat3 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
  } Bits;
  UINT32 Data;
} DDRINTF_RT_LAT0_CH_2__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_RT_LAT0_CH_3__DDRINTF_MEM_REG_DDR          0x00013F1C
typedef union {
  struct {
    //
    // Roundtrip Latency for rank 0 (in DCLKs)
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINT32 rt_lat0 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Roundtrip Latency for rank 1 (in DCLKs)
    // 
    // Bits[14:8], RW, default = 0x0
    //
    UINT32 rt_lat1 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Roundtrip Latency for rank 2 (in DCLKs)
    // 
    // Bits[22:16], RW, default = 0x0
    //
    UINT32 rt_lat2 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Roundtrip Latency for rank 3 (in DCLKs)
    // 
    // Bits[30:24], RW, default = 0x0
    //
    UINT32 rt_lat3 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
  } Bits;
  UINT32 Data;
} DDRINTF_RT_LAT0_CH_3__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_RT_LAT1_CH_0__DDRINTF_MEM_REG_DDR          0x00013F20
typedef union {
  struct {
    //
    // Roundtrip Latency for rank 4 (in DCLKs)
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINT32 rt_lat4 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Roundtrip Latency for rank 5 (in DCLKs)
    // 
    // Bits[14:8], RW, default = 0x0
    //
    UINT32 rt_lat5 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Roundtrip Latency for rank 6 (in DCLKs)
    // 
    // Bits[22:16], RW, default = 0x0
    //
    UINT32 rt_lat6 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Roundtrip Latency for rank 7 (in DCLKs)
    // 
    // Bits[30:24], RW, default = 0x0
    //
    UINT32 rt_lat7 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
  } Bits;
  UINT32 Data;
} DDRINTF_RT_LAT1_CH_0__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_RT_LAT1_CH_1__DDRINTF_MEM_REG_DDR          0x00013F24
typedef union {
  struct {
    //
    // Roundtrip Latency for rank 4 (in DCLKs)
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINT32 rt_lat4 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Roundtrip Latency for rank 5 (in DCLKs)
    // 
    // Bits[14:8], RW, default = 0x0
    //
    UINT32 rt_lat5 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Roundtrip Latency for rank 6 (in DCLKs)
    // 
    // Bits[22:16], RW, default = 0x0
    //
    UINT32 rt_lat6 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Roundtrip Latency for rank 7 (in DCLKs)
    // 
    // Bits[30:24], RW, default = 0x0
    //
    UINT32 rt_lat7 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
  } Bits;
  UINT32 Data;
} DDRINTF_RT_LAT1_CH_1__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_RT_LAT1_CH_2__DDRINTF_MEM_REG_DDR          0x00013F28
typedef union {
  struct {
    //
    // Roundtrip Latency for rank 4 (in DCLKs)
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINT32 rt_lat4 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Roundtrip Latency for rank 5 (in DCLKs)
    // 
    // Bits[14:8], RW, default = 0x0
    //
    UINT32 rt_lat5 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Roundtrip Latency for rank 6 (in DCLKs)
    // 
    // Bits[22:16], RW, default = 0x0
    //
    UINT32 rt_lat6 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Roundtrip Latency for rank 7 (in DCLKs)
    // 
    // Bits[30:24], RW, default = 0x0
    //
    UINT32 rt_lat7 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
  } Bits;
  UINT32 Data;
} DDRINTF_RT_LAT1_CH_2__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_RT_LAT1_CH_3__DDRINTF_MEM_REG_DDR          0x00013F2C
typedef union {
  struct {
    //
    // Roundtrip Latency for rank 4 (in DCLKs)
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINT32 rt_lat4 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Roundtrip Latency for rank 5 (in DCLKs)
    // 
    // Bits[14:8], RW, default = 0x0
    //
    UINT32 rt_lat5 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Roundtrip Latency for rank 6 (in DCLKs)
    // 
    // Bits[22:16], RW, default = 0x0
    //
    UINT32 rt_lat6 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Roundtrip Latency for rank 7 (in DCLKs)
    // 
    // Bits[30:24], RW, default = 0x0
    //
    UINT32 rt_lat7 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
  } Bits;
  UINT32 Data;
} DDRINTF_RT_LAT1_CH_3__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_IO_LAT0_CH_0__DDRINTF_MEM_REG_DDR          0x00013F30
typedef union {
  struct {
    //
    // IO Latency for rank 0 (in DCLKs)
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINT32 io_lat0 : 4;
    //
    // IO Latency for rank 1 (in DCLKs)
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINT32 io_lat1 : 4;
    //
    // IO Latency for rank 2 (in DCLKs)
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINT32 io_lat2 : 4;
    //
    // IO Latency for rank 3 (in DCLKs)
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINT32 io_lat3 : 4;
    //
    // IO Latency for rank 4 (in DCLKs)
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINT32 io_lat4 : 4;
    //
    // IO Latency for rank 5 (in DCLKs)
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINT32 io_lat5 : 4;
    //
    // IO Latency for rank 6 (in DCLKs)
    // 
    // Bits[27:24], RW, default = 0x0
    //
    UINT32 io_lat6 : 4;
    //
    // IO Latency for rank 7 (in DCLKs)
    // 
    // Bits[31:28], RW, default = 0x0
    //
    UINT32 io_lat7 : 4;
  } Bits;
  UINT32 Data;
} DDRINTF_IO_LAT0_CH_0__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_IO_LAT0_CH_1__DDRINTF_MEM_REG_DDR          0x00013F34
typedef union {
  struct {
    //
    // IO Latency for rank 0 (in DCLKs)
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINT32 io_lat0 : 4;
    //
    // IO Latency for rank 1 (in DCLKs)
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINT32 io_lat1 : 4;
    //
    // IO Latency for rank 2 (in DCLKs)
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINT32 io_lat2 : 4;
    //
    // IO Latency for rank 3 (in DCLKs)
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINT32 io_lat3 : 4;
    //
    // IO Latency for rank 4 (in DCLKs)
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINT32 io_lat4 : 4;
    //
    // IO Latency for rank 5 (in DCLKs)
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINT32 io_lat5 : 4;
    //
    // IO Latency for rank 6 (in DCLKs)
    // 
    // Bits[27:24], RW, default = 0x0
    //
    UINT32 io_lat6 : 4;
    //
    // IO Latency for rank 7 (in DCLKs)
    // 
    // Bits[31:28], RW, default = 0x0
    //
    UINT32 io_lat7 : 4;
  } Bits;
  UINT32 Data;
} DDRINTF_IO_LAT0_CH_1__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_IO_LAT0_CH_2__DDRINTF_MEM_REG_DDR          0x00013F38
typedef union {
  struct {
    //
    // IO Latency for rank 0 (in DCLKs)
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINT32 io_lat0 : 4;
    //
    // IO Latency for rank 1 (in DCLKs)
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINT32 io_lat1 : 4;
    //
    // IO Latency for rank 2 (in DCLKs)
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINT32 io_lat2 : 4;
    //
    // IO Latency for rank 3 (in DCLKs)
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINT32 io_lat3 : 4;
    //
    // IO Latency for rank 4 (in DCLKs)
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINT32 io_lat4 : 4;
    //
    // IO Latency for rank 5 (in DCLKs)
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINT32 io_lat5 : 4;
    //
    // IO Latency for rank 6 (in DCLKs)
    // 
    // Bits[27:24], RW, default = 0x0
    //
    UINT32 io_lat6 : 4;
    //
    // IO Latency for rank 7 (in DCLKs)
    // 
    // Bits[31:28], RW, default = 0x0
    //
    UINT32 io_lat7 : 4;
  } Bits;
  UINT32 Data;
} DDRINTF_IO_LAT0_CH_2__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_IO_LAT0_CH_3__DDRINTF_MEM_REG_DDR          0x00013F3C
typedef union {
  struct {
    //
    // IO Latency for rank 0 (in DCLKs)
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINT32 io_lat0 : 4;
    //
    // IO Latency for rank 1 (in DCLKs)
    // 
    // Bits[7:4], RW, default = 0x0
    //
    UINT32 io_lat1 : 4;
    //
    // IO Latency for rank 2 (in DCLKs)
    // 
    // Bits[11:8], RW, default = 0x0
    //
    UINT32 io_lat2 : 4;
    //
    // IO Latency for rank 3 (in DCLKs)
    // 
    // Bits[15:12], RW, default = 0x0
    //
    UINT32 io_lat3 : 4;
    //
    // IO Latency for rank 4 (in DCLKs)
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINT32 io_lat4 : 4;
    //
    // IO Latency for rank 5 (in DCLKs)
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINT32 io_lat5 : 4;
    //
    // IO Latency for rank 6 (in DCLKs)
    // 
    // Bits[27:24], RW, default = 0x0
    //
    UINT32 io_lat6 : 4;
    //
    // IO Latency for rank 7 (in DCLKs)
    // 
    // Bits[31:28], RW, default = 0x0
    //
    UINT32 io_lat7 : 4;
  } Bits;
  UINT32 Data;
} DDRINTF_IO_LAT0_CH_3__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_IO_LAT1_CH_0__DDRINTF_MEM_REG_DDR          0x00013F40
typedef union {
  struct {
    //
    // Number to indicate additional read data IO latency including inside the receiver
    // (in DCLKs)[br] 
    //                     Expected DDR4: 19[br]
    //                     Expected DDR5: 20
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINT32 io_lat_comp : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 26;
  } Bits;
  UINT32 Data;
} DDRINTF_IO_LAT1_CH_0__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_IO_LAT1_CH_1__DDRINTF_MEM_REG_DDR          0x00013F44
typedef union {
  struct {
    //
    // Number to indicate additional read data IO latency including inside the receiver
    // (in DCLKs)[br] 
    //                     Expected DDR4: 19[br]
    //                     Expected DDR5: 20
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINT32 io_lat_comp : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 26;
  } Bits;
  UINT32 Data;
} DDRINTF_IO_LAT1_CH_1__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_IO_LAT1_CH_2__DDRINTF_MEM_REG_DDR          0x00013F48
typedef union {
  struct {
    //
    // Number to indicate additional read data IO latency including inside the receiver
    // (in DCLKs)[br] 
    //                     Expected DDR4: 19[br]
    //                     Expected DDR5: 20
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINT32 io_lat_comp : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 26;
  } Bits;
  UINT32 Data;
} DDRINTF_IO_LAT1_CH_2__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_IO_LAT1_CH_3__DDRINTF_MEM_REG_DDR          0x00013F4C
typedef union {
  struct {
    //
    // Number to indicate additional read data IO latency including inside the receiver
    // (in DCLKs)[br] 
    //                     Expected DDR4: 19[br]
    //                     Expected DDR5: 20
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINT32 io_lat_comp : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 26;
  } Bits;
  UINT32 Data;
} DDRINTF_IO_LAT1_CH_3__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_DATA_TIMING0_CH_0__DDRINTF_MEM_REG_DDR     0x00013F50
typedef union {
  struct {
    //
    // Write CAS Latency used for DDR4/DDR5 DQ/DQS OutputEnable generation. If any DIMM
    // in a channel is DDR4 or DDR5, BIOS needs to program this field for DDR4/DDR5 DIMM's
    // t_cwl. 
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINT32 ddr_tcwl : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This register defines DDR4/DDR5 TCWL adjust value (in DCLK) to deal with write
    // logic delay. It is a signed number. The range is -8 to 7. The total DDR4/DDR5
    // CAS write latency is the sum this value with ddr_tcwl. 
    // 
    // Bits[10:7], RW, default = 0x0
    //
    UINT32 ddr_tcwl_adj : 4;
    //
    // This register defines the  DDR4/DDR-5 DQS adjust value in DCLK to deal with write
    // leveling and longer preambles length. The adjust range is -16 to 15.[br] 
    //                     DQS adjust = twcl adjust - preamble length
    // 
    // Bits[15:11], RW, default = 0x0
    //
    UINT32 ddr_dqs_adj : 5;
    //
    // Write CAS Latency used for DDR-T/DDR-T2 DQ/DQS OutputEnable generation. If any
    // DIMM in a channel is DDR-T or DDR-T2, BIOS needs to program this field for DDR-T/DDR-T2
    // DIMM's t_cwl. 
    // 
    // Bits[21:16], RW, default = 0x0
    //
    UINT32 ddrt_tcwl : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[22:22], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // This register defines DDR-T/DDR-T2 TCWL adjust value (in DCLK) to deal with write
    // logic delay. It is a signed number.The range is -8 to 7. The total DDR-T/DDR-T2
    // CAS write latency is the sum this value with ddrt_tcwl. 
    // 
    // Bits[26:23], RW, default = 0x0
    //
    UINT32 ddrt_tcwl_adj : 4;
    //
    // This register defines the  DDR-T/DDR-T2 DQS adjust value in DCLK to deal with
    // write leveling and longer preambles length. The adjust range is -16 to 15.[br]
    //                     DQS adjust = twcl adjust - preamble length
    // 
    // Bits[31:27], RW, default = 0x0
    //
    UINT32 ddrt_dqs_adj : 5;
  } Bits;
  UINT32 Data;
} DDRINTF_DATA_TIMING0_CH_0__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_DATA_TIMING0_CH_1__DDRINTF_MEM_REG_DDR     0x00013F54
typedef union {
  struct {
    //
    // Write CAS Latency used for DDR4/DDR5 DQ/DQS OutputEnable generation. If any DIMM
    // in a channel is DDR4 or DDR5, BIOS needs to program this field for DDR4/DDR5 DIMM's
    // t_cwl. 
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINT32 ddr_tcwl : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This register defines DDR4/DDR5 TCWL adjust value (in DCLK) to deal with write
    // logic delay. It is a signed number. The range is -8 to 7. The total DDR4/DDR5
    // CAS write latency is the sum this value with ddr_tcwl. 
    // 
    // Bits[10:7], RW, default = 0x0
    //
    UINT32 ddr_tcwl_adj : 4;
    //
    // This register defines the  DDR4/DDR-5 DQS adjust value in DCLK to deal with write
    // leveling and longer preambles length. The adjust range is -16 to 15.[br] 
    //                     DQS adjust = twcl adjust - preamble length
    // 
    // Bits[15:11], RW, default = 0x0
    //
    UINT32 ddr_dqs_adj : 5;
    //
    // Write CAS Latency used for DDR-T/DDR-T2 DQ/DQS OutputEnable generation. If any
    // DIMM in a channel is DDR-T or DDR-T2, BIOS needs to program this field for DDR-T/DDR-T2
    // DIMM's t_cwl. 
    // 
    // Bits[21:16], RW, default = 0x0
    //
    UINT32 ddrt_tcwl : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[22:22], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // This register defines DDR-T/DDR-T2 TCWL adjust value (in DCLK) to deal with write
    // logic delay. It is a signed number.The range is -8 to 7. The total DDR-T/DDR-T2
    // CAS write latency is the sum this value with ddrt_tcwl. 
    // 
    // Bits[26:23], RW, default = 0x0
    //
    UINT32 ddrt_tcwl_adj : 4;
    //
    // This register defines the  DDR-T/DDR-T2 DQS adjust value in DCLK to deal with
    // write leveling and longer preambles length. The adjust range is -16 to 15.[br]
    //                     DQS adjust = twcl adjust - preamble length
    // 
    // Bits[31:27], RW, default = 0x0
    //
    UINT32 ddrt_dqs_adj : 5;
  } Bits;
  UINT32 Data;
} DDRINTF_DATA_TIMING0_CH_1__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_DATA_TIMING0_CH_2__DDRINTF_MEM_REG_DDR     0x00013F58
typedef union {
  struct {
    //
    // Write CAS Latency used for DDR4/DDR5 DQ/DQS OutputEnable generation. If any DIMM
    // in a channel is DDR4 or DDR5, BIOS needs to program this field for DDR4/DDR5 DIMM's
    // t_cwl. 
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINT32 ddr_tcwl : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This register defines DDR4/DDR5 TCWL adjust value (in DCLK) to deal with write
    // logic delay. It is a signed number. The range is -8 to 7. The total DDR4/DDR5
    // CAS write latency is the sum this value with ddr_tcwl. 
    // 
    // Bits[10:7], RW, default = 0x0
    //
    UINT32 ddr_tcwl_adj : 4;
    //
    // This register defines the  DDR4/DDR-5 DQS adjust value in DCLK to deal with write
    // leveling and longer preambles length. The adjust range is -16 to 15.[br] 
    //                     DQS adjust = twcl adjust - preamble length
    // 
    // Bits[15:11], RW, default = 0x0
    //
    UINT32 ddr_dqs_adj : 5;
    //
    // Write CAS Latency used for DDR-T/DDR-T2 DQ/DQS OutputEnable generation. If any
    // DIMM in a channel is DDR-T or DDR-T2, BIOS needs to program this field for DDR-T/DDR-T2
    // DIMM's t_cwl. 
    // 
    // Bits[21:16], RW, default = 0x0
    //
    UINT32 ddrt_tcwl : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[22:22], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // This register defines DDR-T/DDR-T2 TCWL adjust value (in DCLK) to deal with write
    // logic delay. It is a signed number.The range is -8 to 7. The total DDR-T/DDR-T2
    // CAS write latency is the sum this value with ddrt_tcwl. 
    // 
    // Bits[26:23], RW, default = 0x0
    //
    UINT32 ddrt_tcwl_adj : 4;
    //
    // This register defines the  DDR-T/DDR-T2 DQS adjust value in DCLK to deal with
    // write leveling and longer preambles length. The adjust range is -16 to 15.[br]
    //                     DQS adjust = twcl adjust - preamble length
    // 
    // Bits[31:27], RW, default = 0x0
    //
    UINT32 ddrt_dqs_adj : 5;
  } Bits;
  UINT32 Data;
} DDRINTF_DATA_TIMING0_CH_2__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_DATA_TIMING0_CH_3__DDRINTF_MEM_REG_DDR     0x00013F5C
typedef union {
  struct {
    //
    // Write CAS Latency used for DDR4/DDR5 DQ/DQS OutputEnable generation. If any DIMM
    // in a channel is DDR4 or DDR5, BIOS needs to program this field for DDR4/DDR5 DIMM's
    // t_cwl. 
    // 
    // Bits[5:0], RW, default = 0x0
    //
    UINT32 ddr_tcwl : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This register defines DDR4/DDR5 TCWL adjust value (in DCLK) to deal with write
    // logic delay. It is a signed number. The range is -8 to 7. The total DDR4/DDR5
    // CAS write latency is the sum this value with ddr_tcwl. 
    // 
    // Bits[10:7], RW, default = 0x0
    //
    UINT32 ddr_tcwl_adj : 4;
    //
    // This register defines the  DDR4/DDR-5 DQS adjust value in DCLK to deal with write
    // leveling and longer preambles length. The adjust range is -16 to 15.[br] 
    //                     DQS adjust = twcl adjust - preamble length
    // 
    // Bits[15:11], RW, default = 0x0
    //
    UINT32 ddr_dqs_adj : 5;
    //
    // Write CAS Latency used for DDR-T/DDR-T2 DQ/DQS OutputEnable generation. If any
    // DIMM in a channel is DDR-T or DDR-T2, BIOS needs to program this field for DDR-T/DDR-T2
    // DIMM's t_cwl. 
    // 
    // Bits[21:16], RW, default = 0x0
    //
    UINT32 ddrt_tcwl : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[22:22], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // This register defines DDR-T/DDR-T2 TCWL adjust value (in DCLK) to deal with write
    // logic delay. It is a signed number.The range is -8 to 7. The total DDR-T/DDR-T2
    // CAS write latency is the sum this value with ddrt_tcwl. 
    // 
    // Bits[26:23], RW, default = 0x0
    //
    UINT32 ddrt_tcwl_adj : 4;
    //
    // This register defines the  DDR-T/DDR-T2 DQS adjust value in DCLK to deal with
    // write leveling and longer preambles length. The adjust range is -16 to 15.[br]
    //                     DQS adjust = twcl adjust - preamble length
    // 
    // Bits[31:27], RW, default = 0x0
    //
    UINT32 ddrt_dqs_adj : 5;
  } Bits;
  UINT32 Data;
} DDRINTF_DATA_TIMING0_CH_3__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_DATA_TIMING1_CH_0__DDRINTF_MEM_REG_DDR     0x00013F60
typedef union {
  struct {
    //
    // Set during ACIO loopback in the data fub.  This will couple the receive enable
    // with dqsoutputenable. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // This field controls the number of DCLK cycles that the rddata_valid is sent early
    // to MC. Expected program the same value for all sub-ch. 
    // 
    // Bits[5:1], RW, default = 0xC
    //
    UINT32 rddata_valid_early : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This field controls the number of DCLK cycles that rxaen is asserted before rcven.
    // Used to enable sense amp and odt circuits early.[br] 
    //                     Note: Expected program the same value for all sub-ch. Dependent
    // on preable and frequency. Supported range is 0 to 6.[br] 
    //                     DDR4: 0-2 DCLK[br]
    //                     DDR5: 0-3 DCLK[br]
    // 
    // Bits[10:7], RW, default = 0x0
    //
    UINT32 rx_analog_en_early : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // This field controls the number of DCLK cycles that idle_cnt_valid is asserted
    // before the failing edge of rcven. Used by dqsdeskew to account for interamble
    // scenerios. A CR value of 2 is the max support for DDR4[br] 
    //                     0: 1 Dclk before rcven failing edge[br]
    //                     1: 2 Dclk before rcven failing edge[br]
    //                     2: 3 Dclk before rcven failing edge[br]
    //                     3: 4 Dclk before rcven failing edge
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINT32 idle_cnt_valid_early : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:14], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 10;
    //
    // Per rank control to indicate which TCWL parameter is slected[br]
    //                     0: DDR 4 or DDR 5 [br]
    //                     1: DDR-T or DDR-T2 [br]
    //                     Used by delay logic to determine which set of timing CSRs
    // to use. Unpopulated/unused ranks can be programmed arbitrarliy since they will
    // never be accessed. 
    // 
    // Bits[31:24], RW, default = 0x0
    //
    UINT32 tcwl_para_sel : 8;
  } Bits;
  UINT32 Data;
} DDRINTF_DATA_TIMING1_CH_0__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_DATA_TIMING1_CH_1__DDRINTF_MEM_REG_DDR     0x00013F64
typedef union {
  struct {
    //
    // Set during ACIO loopback in the data fub.  This will couple the receive enable
    // with dqsoutputenable. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // This field controls the number of DCLK cycles that the rddata_valid is sent early
    // to MC. Expected program the same value for all sub-ch. 
    // 
    // Bits[5:1], RW, default = 0xC
    //
    UINT32 rddata_valid_early : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This field controls the number of DCLK cycles that rxaen is asserted before rcven.
    // Used to enable sense amp and odt circuits early.[br] 
    //                     Note: Expected program the same value for all sub-ch. Dependent
    // on preable and frequency. Supported range is 0 to 6.[br] 
    //                     DDR4: 0-2 DCLK[br]
    //                     DDR5: 0-3 DCLK[br]
    // 
    // Bits[10:7], RW, default = 0x0
    //
    UINT32 rx_analog_en_early : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // This field controls the number of DCLK cycles that idle_cnt_valid is asserted
    // before the failing edge of rcven. Used by dqsdeskew to account for interamble
    // scenerios. A CR value of 2 is the max support for DDR4[br] 
    //                     0: 1 Dclk before rcven failing edge[br]
    //                     1: 2 Dclk before rcven failing edge[br]
    //                     2: 3 Dclk before rcven failing edge[br]
    //                     3: 4 Dclk before rcven failing edge
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINT32 idle_cnt_valid_early : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:14], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 10;
    //
    // Per rank control to indicate which TCWL parameter is slected[br]
    //                     0: DDR 4 or DDR 5 [br]
    //                     1: DDR-T or DDR-T2 [br]
    //                     Used by delay logic to determine which set of timing CSRs
    // to use. Unpopulated/unused ranks can be programmed arbitrarliy since they will
    // never be accessed. 
    // 
    // Bits[31:24], RW, default = 0x0
    //
    UINT32 tcwl_para_sel : 8;
  } Bits;
  UINT32 Data;
} DDRINTF_DATA_TIMING1_CH_1__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_DATA_TIMING1_CH_2__DDRINTF_MEM_REG_DDR     0x00013F68
typedef union {
  struct {
    //
    // Set during ACIO loopback in the data fub.  This will couple the receive enable
    // with dqsoutputenable. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // This field controls the number of DCLK cycles that the rddata_valid is sent early
    // to MC. Expected program the same value for all sub-ch. 
    // 
    // Bits[5:1], RW, default = 0xC
    //
    UINT32 rddata_valid_early : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This field controls the number of DCLK cycles that rxaen is asserted before rcven.
    // Used to enable sense amp and odt circuits early.[br] 
    //                     Note: Expected program the same value for all sub-ch. Dependent
    // on preable and frequency. Supported range is 0 to 6.[br] 
    //                     DDR4: 0-2 DCLK[br]
    //                     DDR5: 0-3 DCLK[br]
    // 
    // Bits[10:7], RW, default = 0x0
    //
    UINT32 rx_analog_en_early : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // This field controls the number of DCLK cycles that idle_cnt_valid is asserted
    // before the failing edge of rcven. Used by dqsdeskew to account for interamble
    // scenerios. A CR value of 2 is the max support for DDR4[br] 
    //                     0: 1 Dclk before rcven failing edge[br]
    //                     1: 2 Dclk before rcven failing edge[br]
    //                     2: 3 Dclk before rcven failing edge[br]
    //                     3: 4 Dclk before rcven failing edge
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINT32 idle_cnt_valid_early : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:14], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 10;
    //
    // Per rank control to indicate which TCWL parameter is slected[br]
    //                     0: DDR 4 or DDR 5 [br]
    //                     1: DDR-T or DDR-T2 [br]
    //                     Used by delay logic to determine which set of timing CSRs
    // to use. Unpopulated/unused ranks can be programmed arbitrarliy since they will
    // never be accessed. 
    // 
    // Bits[31:24], RW, default = 0x0
    //
    UINT32 tcwl_para_sel : 8;
  } Bits;
  UINT32 Data;
} DDRINTF_DATA_TIMING1_CH_2__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_DATA_TIMING1_CH_3__DDRINTF_MEM_REG_DDR     0x00013F6C
typedef union {
  struct {
    //
    // Set during ACIO loopback in the data fub.  This will couple the receive enable
    // with dqsoutputenable. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // This field controls the number of DCLK cycles that the rddata_valid is sent early
    // to MC. Expected program the same value for all sub-ch. 
    // 
    // Bits[5:1], RW, default = 0xC
    //
    UINT32 rddata_valid_early : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This field controls the number of DCLK cycles that rxaen is asserted before rcven.
    // Used to enable sense amp and odt circuits early.[br] 
    //                     Note: Expected program the same value for all sub-ch. Dependent
    // on preable and frequency. Supported range is 0 to 6.[br] 
    //                     DDR4: 0-2 DCLK[br]
    //                     DDR5: 0-3 DCLK[br]
    // 
    // Bits[10:7], RW, default = 0x0
    //
    UINT32 rx_analog_en_early : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[11:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // This field controls the number of DCLK cycles that idle_cnt_valid is asserted
    // before the failing edge of rcven. Used by dqsdeskew to account for interamble
    // scenerios. A CR value of 2 is the max support for DDR4[br] 
    //                     0: 1 Dclk before rcven failing edge[br]
    //                     1: 2 Dclk before rcven failing edge[br]
    //                     2: 3 Dclk before rcven failing edge[br]
    //                     3: 4 Dclk before rcven failing edge
    // 
    // Bits[13:12], RW, default = 0x0
    //
    UINT32 idle_cnt_valid_early : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:14], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 10;
    //
    // Per rank control to indicate which TCWL parameter is slected[br]
    //                     0: DDR 4 or DDR 5 [br]
    //                     1: DDR-T or DDR-T2 [br]
    //                     Used by delay logic to determine which set of timing CSRs
    // to use. Unpopulated/unused ranks can be programmed arbitrarliy since they will
    // never be accessed. 
    // 
    // Bits[31:24], RW, default = 0x0
    //
    UINT32 tcwl_para_sel : 8;
  } Bits;
  UINT32 Data;
} DDRINTF_DATA_TIMING1_CH_3__DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_CTL0_DDRINTF_MEM_REG_DDR                   0x00013F80
typedef union {
  struct {
    //
    // Set to 1 to dsiable SPID LPMODE self refresh.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 sr_dis : 1;
    //
    // Set to 1 to dsiable SPID LPMODE CKE power down. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 cke_pwr_dn_dis : 1;
    //
    // Set to 1 to disable PM FSM to park clock to 0 in PM1 and PM2 state.
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 clk_park0_dis : 1;
    //
    // Set to 1 to disable PM FSM to turn off VSSHI in PM2 state.
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 vsshi_off_dis : 1;
    //
    // Set to 1 to disable PM FSM to turn off LDO in PM2 state.
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 ldo_off_dis : 1;
    //
    // Set to 1 to disable PM FSM to turn off DLL in PM2 state.
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINT32 dll_off_dis : 1;
    //
    // Set to 1 to enable HW to gate CSR CLK. Default is disable clock gating. [br]
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 csr_clk_gate_en : 1;
    //
    // Force Channel in Self Refresh. Normally asserted based on LPMODE
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 force_sr : 1;
    //
    // Force Channel in CKE power down. Normally asserted based on LPMODE
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 force_cke_pwr_dn : 1;
    //
    // Force the clock to park 0 (both P/N 0). Normally asserted in PM1 and PM2 state.
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINT32 force_clk_park0 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[10:10], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Channel 0 SW set, HW clear train reset. This train reset is logical ORed with
    // MC CH0 train reset (level). The intend use case is for BIOS to deassert the MC
    // train reset first and then use this train reset for each training step to reduce
    // the number of SW program step 
    // 
    // Bits[11:11], RW/V, default = 0x0
    //
    UINT32 ch0_train_rst : 1;
    //
    // Channel 1 SW set, HW clear train reset. This train reset is logical ORed with
    // MC CH1 train reset (level). The intend use case is for BIOS to deassert the MC
    // train reset first and then use this train reset for each training step to reduce
    // the number of SW program step 
    // 
    // Bits[12:12], RW/V, default = 0x0
    //
    UINT32 ch1_train_rst : 1;
    //
    // Set to 1 to disable SPID LPMODE from turning off DATA FUB DLL in SLOW IDLE state.
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINT32 lp_idle_dll_off_dis : 1;
    //
    // Set to 1 to disable SPID LPMODE from turning off DATA FUB DLL in SLOW CKE POWER
    // DOWN state. 
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINT32 lp_pd_dll_off_dis : 1;
    //
    // Set to 1 to disable SPID LPMODE from turning off DATA FUB DLL in HIGH LATENCY
    // SELF REFRESH state. 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINT32 lp_sr_dll_off_dis : 1;
    //
    // Set to 1 to enable data lane reversal to ease board routing.
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINT32 lane_reversal_en : 1;
    //
    // Set this bit to 1 for DDR5 ELR DIMM
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 elr_dimm : 1;
    //
    // For SPR, 2 Channel DDR-MC sub-system. It can either operate in DDR4/DDR-T or DDR5/DDR-T2.
    // It doesn't support DDR4/DDR-T mix with DDR5/DDR-T2.[br] 
    //                     Setting this bit to 1 indicate it is operating in DDR/DDR-T.
    // [br] 
    //                     0 inidate it is operating in DDR5/DDR-T2. [br]
    //                     INTF use this information for the MC input muxing.
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 ddr4 : 1;
    //
    // 0: 14 CA bits[br]
    //                     1: 7 CA bits[br]
    //                     It is used by INTF for MC input muxing.
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINT32 ca7_en : 1;
    //
    // DDR Initiated CompUpdate via auto-clearing CSR write. Forces Comp Update pulse
    // to be sent to all FUBs bypassing the SPID Comp FSM. 
    // 
    // Bits[20:20], RW/V, default = 0x0
    //
    UINT32 force_comp_update : 1;
    //
    // DDR Initiated CompBegin via auto-clearing CompComplete, allows BIOS to poll this
    // bit for CompComplete indication. Forces Comp Begin to be sent to COMP bypassing
    // the SPID Comp FSM. 
    // 
    // Bits[21:21], RW/V, default = 0x0
    //
    UINT32 force_comp_begin : 1;
    //
    // Enable PM state machine to generate train reset when in PM1 and PM2 states.
    // 
    // Bits[22:22], RW, default = 0x1
    //
    UINT32 pm_train_rst_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Enable PM FSM to wait for periodic Comp FSM to finish before return a PM ACK back
    // to MC during a low power state transtion sequence. 
    // 
    // Bits[25:25], RW, default = 0x1
    //
    UINT32 pm_wait_comp_finish : 1;
    //
    // 0: Send parity 1 dclk cycle after command. Parity for DDR4 RDIMM is always a cycle
    // late. [br] 
    //                     1: Send parity same cycle as commnad. Used for DDR5 RDIMM
    // and for training. DDR4 UDIMM parity needs to be in the same cycle. 
    // 
    // Bits[26:26], RW, default = 0x0
    //
    UINT32 same_cycle_par_en : 1;
    //
    // Specifies the number of Dclk cycles that the spid interface needs to be quiet,
    // in order for comp update to finish (see by the farthest Data FUB). On the SPID
    // interface term, it means after MC asserted Quiet Time Grant to DDR, how many DCLK
    // cycles DDR needs to wait to deassert the Quiet Time Request to MC. 
    // 
    // Bits[30:27], RW, default = 0xA
    //
    UINT32 comp_upd_quiet_time : 4;
    //
    // Specifies the number of Dclk cycles required for TX retraining values to be applied
    // by the Data FUBs. On the spid interface, indicates the amount of time required
    // to wait before acknowledging ispid_phy_update_req.[br] 
    //                     0: 16 Dclks[br]
    //                     1: 32 Dclks
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 tx_retrain_time : 1;
  } Bits;
  UINT32 Data;
} DDRINTF_CTL0_DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_PM_TIMING0_DDRINTF_MEM_REG_DDR             0x00013F84
typedef union {
  struct {
    //
    // This delay controls how long to wait between receiving PM1 or PM2 request and
    // actually moving PM FSM from PM0 to PM1. This delay value is in units of 64 Dclks.[br]
    //                     Note: Time wait before parking DIMM Clock to 0.
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINT32 pm0to1_pre_dly : 8;
    //
    // This delay controls how long to wait between receiving PM2 request and actually
    // moving PM FSM from PM1 to PM2. This delay value is in units of 64 Dclks.[br] 
    //                     Note: Time wait before turning off DLL, LDO, and VSSHI
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINT32 pm1to2_pre_dly : 8;
    //
    // This delay controls how long to wait between receiving PM0 request and actually
    // moving PM FSM from PM1 to PM0. This delay value is in units of 64 Dclks.[br] 
    //                     Note : Time to wait before un-parking DIMM clcok.
    // 
    // Bits[23:16], RW, default = 0x0
    //
    UINT32 pm1to0_pre_dly : 8;
    //
    // This delay controls how long to wait between receiving PM1 or PM0 request and
    // actually moving PM FSM from PM2 to PM1. This delay value is in units of 64 Dclks.[br]
    //                     Note: Time to wait before turning on DLL, LDO, and VSSHI.
    // 
    // Bits[31:24], RW, default = 0x0
    //
    UINT32 pm2to1_pre_dly : 8;
  } Bits;
  UINT32 Data;
} DDRINTF_PM_TIMING0_DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_PM_TIMING1_DDRINTF_MEM_REG_DDR             0x00013F88
typedef union {
  struct {
    //
    // After trasiton from PM0 to PM1, this delay controls how long to wait for any functions
    // to be turned off in PM1 state and responding with PM ACK to MC (if request was
    // for PM1) or moving to PM2 state (if request was for PM2). This delay value is
    // in units of 64 Dclks.[br] 
    //                     Note: Time to wait to park the DIMM clock to 0.
    // 
    // Bits[7:0], RW, default = 0x1
    //
    UINT32 pm0to1_post_dly : 8;
    //
    // After trasiton from PM1 to PM2, this delay controls how long to wait for any functions
    // to be turned off in PM2 state and responding with PM ACK to MC. This delay value
    // is in units of 64 Dclks.[br] 
    //                     Note: Analog componenets wait to turn off are DLL, LDO, and
    // VSSHI. 
    // 
    // Bits[15:8], RW, default = 0x1
    //
    UINT32 pm1to2_post_dly : 8;
    //
    // After trasiton from PM1 to PM0, this delay controls how long to wait for any functions
    // to be turned on in PM0 state and responding with PM ACK to MC. This delay value
    // is in units of 64 Dclks.[br] 
    //                     Note: Time to wait to un-parking DIMM clock.
    // 
    // Bits[23:16], RW, default = 0x1
    //
    UINT32 pm1to0_post_dly : 8;
    //
    // After trasiton from PM2 to PM1, this delay controls how long to wait for any functions
    // to be turned on in PM1 state and responding with PM ACK to MC (if request was
    // for PM1) or moving to PM0 state (if request was for PM0). This delay value is
    // in units of 64 Dclks.[br] 
    //                     Note: Analog componenets wait to turn on are DLL, LDO, and
    // VSSHI. 
    // 
    // Bits[31:24], RW, default = 0x93
    //
    UINT32 pm2to1_post_dly : 8;
  } Bits;
  UINT32 Data;
} DDRINTF_PM_TIMING1_DDRINTF_MEM_STRUCT_DDR;

#define DDRINTF_STATUS0_DDRINTF_MEM_REG_DDR                0x00013F8C
typedef union {
  struct {
    //
    // Channel 0 PM FSM current state:[br]
    //                     0 - PM0 Idle[br]
    //                     1 - PM0 Delay[br]
    //                     2 - PM1 Delay[br]
    //                     3 - PM2 Delay[br]
    //                     4 - PM2 Idle
    // 
    // Bits[2:0], RO/V, default = 0x0
    //
    UINT32 ch0_pm_fsm_status : 3;
    //
    // Channel 1 PM FSM current state:[br]
    //                     0 - PM0 Idle[br]
    //                     1 - PM0 Delay[br]
    //                     2 - PM1 Delay[br]
    //                     3 - PM2 Delay[br]
    //                     4 - PM2 Idle
    // 
    // Bits[5:3], RO/V, default = 0x0
    //
    UINT32 ch1_pm_fsm_status : 3;
    //
    // Channel 0 Update FSM current state:[br]
    //                     0 - Idle[br]
    //                     1 - COMP Begin[br]
    //                     2 - Bus Quiet Time Request[br]
    //                     3 - COMP Update[br]
    //                     4 - TX Retraining
    // 
    // Bits[8:6], RO/V, default = 0x0
    //
    UINT32 ch0_update_fsm_status : 3;
    //
    // Channel 1 Update FSM current state:[br]
    //                     0 - Idle[br]
    //                     1 - COMP Begin[br]
    //                     2 - Bus Quiet Time Request[br]
    //                     3 - COMP Update[br]
    //                     4 - TX Retraining
    // 
    // Bits[11:9], RO/V, default = 0x0
    //
    UINT32 ch1_update_fsm_status : 3;
    //
    // Channel 0 LPMODE current state:[br]
    //                     0 - Active (MC sending commands), Unused/No Action[br]
    //                     1 - Idle (MC not sending commands), Unused/No Action[br]
    //                     2 - Idle, DLL Off (MC not sending commands)[br]
    //                     3 - CKE Powerdown (all CKE are low)[br]
    //                     4 - Unused/Reserved[br]
    //                     5 - CKE Powerdown, DLL Off (all CKE are low)[br]
    //                     6 - SelfRefresh (all ranks in SR)[br]
    //                     7 - SelfRefresh, DLL Off  (all ranks in SR)
    // 
    // Bits[14:12], RO/V, default = 0x0
    //
    UINT32 ch0_lpmode_status : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Channel 1 LPMODE current state:[br]
    //                     0 - Active (MC sending commands), Unused/No Action[br]
    //                     1 - Idle (MC not sending commands), Unused/No Action[br]
    //                     2 - Idle, DLL Off (MC not sending commands)[br]
    //                     3 - CKE Powerdown (all CKE are low)[br]
    //                     4 - Unused/Reserved[br]
    //                     5 - CKE Powerdown, DLL Off (all CKE are low)[br]
    //                     6 - SelfRefresh (all ranks in SR)[br]
    //                     7 - SelfRefresh, DLL Off  (all ranks in SR)
    // 
    // Bits[18:16], RO/V, default = 0x0
    //
    UINT32 ch1_lpmode_status : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:19], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 13;
  } Bits;
  UINT32 Data;
} DDRINTF_STATUS0_DDRINTF_MEM_STRUCT_DDR;


#endif // _MMRCDDRINTF_MEM_DDR_H_DDR_
