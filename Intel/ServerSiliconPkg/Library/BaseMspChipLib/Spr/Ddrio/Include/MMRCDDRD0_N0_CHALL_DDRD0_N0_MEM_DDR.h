/** @file
  File name:    MMRCDDRD0_N0_CHALL_DDRD0_N0_MEM_DDR.h
  Input File:   SPR_MRC_DDR.xlsx
  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.
  If edits are needed in this file, they must be done via the MSP tool.
  If there is additional project-specific data required by the MSP, it
  can be placed in MMRCDDRD0_N0_CHALL_DDRD0_N0_MEM_DDR.h, which is used for non-tool-generated
  data
  Includes register defines specific to a project.

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2005 - 2020 Intel Corporation. <BR>

  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.

  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.

  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
**/

#ifndef _MMRCDDRD0_N0_CHALL_DDRD0_N0_MEM_DDR_H_DDR_
#define _MMRCDDRD0_N0_CHALL_DDRD0_N0_MEM_DDR_H_DDR_

#include "MspDataTypes.h"

#define DDRD_N0_RX_CTL0_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B800
typedef union {
  struct {
    //
    // Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     10:7 - It is used for logic delay.[br]
    //                     6:0 - The lower 7 bit is added with rcven_piref_offset and
    // piref_setup_adj, so the programed value is relative to the piref clock. The result
    // is sent to the rcven crossover logic and DLL.[br]  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 rcven_dly : 11;
    //
    // It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival
    // DQ.[br] 
    //                     The per bit range is 0 to 1.375 dclk with step size clkpi/128.
    // [br] 
    //                     The per bit calculation is [br]
    //                     rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj
    // (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed
    // number for BIOS margining sweep. Range is -128 to 127)[br] 
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[18:11], RW, default = 0x0
    //
    UINT32 rxdqsp_dly : 8;
    //
    // It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival
    // DQ.[br] 
    //                     The per bit range is 0 to 1.375 dclk with step size clkpi/128.
    // [br] 
    //                     The per bit calculation is [br]
    //                     rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj
    // (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed
    // number for BIOS margining sweep. Range is -128 to 127)[br] 
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[26:19], RW, default = 0x0
    //
    UINT32 rxdqsn_dly : 8;
    //
    // It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay
    // to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]
    //                     0: 1/16 UI offset,[br] 
    //                     1: 3/16 UI offset,[br] 
    //                     2: 5/16 UI offset,[br] 
    //                     3: 7/16 UI offset,[br] 
    //                     4: 9/16 UI offset,[br] 
    //                     5: 11/16 UI offset,[br] 
    //                     6,7: 13/16 UI offset.[br] 
    //                     When DFE is enabled, adds delay on the DFE feedback path (after
    // the DFE sampler).[br]  
    //                     0: 0 offset (bypass),[br] 
    //                     1: 2/16 UI offset,[br] 
    //                     2: 4/16 UI offset,[br] 
    //                     3: 6/16 UI offset,[br] 
    //                     4: 8/16 UI offset,[br] 
    //                     5: 10/16 UI offset,[br] 
    //                     6,7: 12/16 UI offset).
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINT32 rxdq_dly : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // RX Strobe Inversion for DFE
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 rx_strobe_inv : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL0_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL0_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B804
typedef union {
  struct {
    //
    // Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     10:7 - It is used for logic delay.[br]
    //                     6:0 - The lower 7 bit is added with rcven_piref_offset and
    // piref_setup_adj, so the programed value is relative to the piref clock. The result
    // is sent to the rcven crossover logic and DLL.[br]  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 rcven_dly : 11;
    //
    // It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival
    // DQ.[br] 
    //                     The per bit range is 0 to 1.375 dclk with step size clkpi/128.
    // [br] 
    //                     The per bit calculation is [br]
    //                     rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj
    // (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed
    // number for BIOS margining sweep. Range is -128 to 127)[br] 
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[18:11], RW, default = 0x0
    //
    UINT32 rxdqsp_dly : 8;
    //
    // It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival
    // DQ.[br] 
    //                     The per bit range is 0 to 1.375 dclk with step size clkpi/128.
    // [br] 
    //                     The per bit calculation is [br]
    //                     rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj
    // (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed
    // number for BIOS margining sweep. Range is -128 to 127)[br] 
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[26:19], RW, default = 0x0
    //
    UINT32 rxdqsn_dly : 8;
    //
    // It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay
    // to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]
    //                     0: 1/16 UI offset,[br] 
    //                     1: 3/16 UI offset,[br] 
    //                     2: 5/16 UI offset,[br] 
    //                     3: 7/16 UI offset,[br] 
    //                     4: 9/16 UI offset,[br] 
    //                     5: 11/16 UI offset,[br] 
    //                     6,7: 13/16 UI offset.[br] 
    //                     When DFE is enabled, adds delay on the DFE feedback path (after
    // the DFE sampler).[br]  
    //                     0: 0 offset (bypass),[br] 
    //                     1: 2/16 UI offset,[br] 
    //                     2: 4/16 UI offset,[br] 
    //                     3: 6/16 UI offset,[br] 
    //                     4: 8/16 UI offset,[br] 
    //                     5: 10/16 UI offset,[br] 
    //                     6,7: 12/16 UI offset).
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINT32 rxdq_dly : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // RX Strobe Inversion for DFE
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 rx_strobe_inv : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL0_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL0_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B808
typedef union {
  struct {
    //
    // Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     10:7 - It is used for logic delay.[br]
    //                     6:0 - The lower 7 bit is added with rcven_piref_offset and
    // piref_setup_adj, so the programed value is relative to the piref clock. The result
    // is sent to the rcven crossover logic and DLL.[br]  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 rcven_dly : 11;
    //
    // It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival
    // DQ.[br] 
    //                     The per bit range is 0 to 1.375 dclk with step size clkpi/128.
    // [br] 
    //                     The per bit calculation is [br]
    //                     rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj
    // (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed
    // number for BIOS margining sweep. Range is -128 to 127)[br] 
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[18:11], RW, default = 0x0
    //
    UINT32 rxdqsp_dly : 8;
    //
    // It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival
    // DQ.[br] 
    //                     The per bit range is 0 to 1.375 dclk with step size clkpi/128.
    // [br] 
    //                     The per bit calculation is [br]
    //                     rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj
    // (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed
    // number for BIOS margining sweep. Range is -128 to 127)[br] 
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[26:19], RW, default = 0x0
    //
    UINT32 rxdqsn_dly : 8;
    //
    // It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay
    // to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]
    //                     0: 1/16 UI offset,[br] 
    //                     1: 3/16 UI offset,[br] 
    //                     2: 5/16 UI offset,[br] 
    //                     3: 7/16 UI offset,[br] 
    //                     4: 9/16 UI offset,[br] 
    //                     5: 11/16 UI offset,[br] 
    //                     6,7: 13/16 UI offset.[br] 
    //                     When DFE is enabled, adds delay on the DFE feedback path (after
    // the DFE sampler).[br]  
    //                     0: 0 offset (bypass),[br] 
    //                     1: 2/16 UI offset,[br] 
    //                     2: 4/16 UI offset,[br] 
    //                     3: 6/16 UI offset,[br] 
    //                     4: 8/16 UI offset,[br] 
    //                     5: 10/16 UI offset,[br] 
    //                     6,7: 12/16 UI offset).
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINT32 rxdq_dly : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // RX Strobe Inversion for DFE
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 rx_strobe_inv : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL0_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL0_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B80C
typedef union {
  struct {
    //
    // Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     10:7 - It is used for logic delay.[br]
    //                     6:0 - The lower 7 bit is added with rcven_piref_offset and
    // piref_setup_adj, so the programed value is relative to the piref clock. The result
    // is sent to the rcven crossover logic and DLL.[br]  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 rcven_dly : 11;
    //
    // It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival
    // DQ.[br] 
    //                     The per bit range is 0 to 1.375 dclk with step size clkpi/128.
    // [br] 
    //                     The per bit calculation is [br]
    //                     rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj
    // (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed
    // number for BIOS margining sweep. Range is -128 to 127)[br] 
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[18:11], RW, default = 0x0
    //
    UINT32 rxdqsp_dly : 8;
    //
    // It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival
    // DQ.[br] 
    //                     The per bit range is 0 to 1.375 dclk with step size clkpi/128.
    // [br] 
    //                     The per bit calculation is [br]
    //                     rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj
    // (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed
    // number for BIOS margining sweep. Range is -128 to 127)[br] 
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[26:19], RW, default = 0x0
    //
    UINT32 rxdqsn_dly : 8;
    //
    // It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay
    // to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]
    //                     0: 1/16 UI offset,[br] 
    //                     1: 3/16 UI offset,[br] 
    //                     2: 5/16 UI offset,[br] 
    //                     3: 7/16 UI offset,[br] 
    //                     4: 9/16 UI offset,[br] 
    //                     5: 11/16 UI offset,[br] 
    //                     6,7: 13/16 UI offset.[br] 
    //                     When DFE is enabled, adds delay on the DFE feedback path (after
    // the DFE sampler).[br]  
    //                     0: 0 offset (bypass),[br] 
    //                     1: 2/16 UI offset,[br] 
    //                     2: 4/16 UI offset,[br] 
    //                     3: 6/16 UI offset,[br] 
    //                     4: 8/16 UI offset,[br] 
    //                     5: 10/16 UI offset,[br] 
    //                     6,7: 12/16 UI offset).
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINT32 rxdq_dly : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // RX Strobe Inversion for DFE
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 rx_strobe_inv : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL0_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL0_RANK_4__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B810
typedef union {
  struct {
    //
    // Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     10:7 - It is used for logic delay.[br]
    //                     6:0 - The lower 7 bit is added with rcven_piref_offset and
    // piref_setup_adj, so the programed value is relative to the piref clock. The result
    // is sent to the rcven crossover logic and DLL.[br]  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 rcven_dly : 11;
    //
    // It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival
    // DQ.[br] 
    //                     The per bit range is 0 to 1.375 dclk with step size clkpi/128.
    // [br] 
    //                     The per bit calculation is [br]
    //                     rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj
    // (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed
    // number for BIOS margining sweep. Range is -128 to 127)[br] 
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[18:11], RW, default = 0x0
    //
    UINT32 rxdqsp_dly : 8;
    //
    // It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival
    // DQ.[br] 
    //                     The per bit range is 0 to 1.375 dclk with step size clkpi/128.
    // [br] 
    //                     The per bit calculation is [br]
    //                     rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj
    // (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed
    // number for BIOS margining sweep. Range is -128 to 127)[br] 
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[26:19], RW, default = 0x0
    //
    UINT32 rxdqsn_dly : 8;
    //
    // It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay
    // to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]
    //                     0: 1/16 UI offset,[br] 
    //                     1: 3/16 UI offset,[br] 
    //                     2: 5/16 UI offset,[br] 
    //                     3: 7/16 UI offset,[br] 
    //                     4: 9/16 UI offset,[br] 
    //                     5: 11/16 UI offset,[br] 
    //                     6,7: 13/16 UI offset.[br] 
    //                     When DFE is enabled, adds delay on the DFE feedback path (after
    // the DFE sampler).[br]  
    //                     0: 0 offset (bypass),[br] 
    //                     1: 2/16 UI offset,[br] 
    //                     2: 4/16 UI offset,[br] 
    //                     3: 6/16 UI offset,[br] 
    //                     4: 8/16 UI offset,[br] 
    //                     5: 10/16 UI offset,[br] 
    //                     6,7: 12/16 UI offset).
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINT32 rxdq_dly : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // RX Strobe Inversion for DFE
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 rx_strobe_inv : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL0_RANK_4__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL0_RANK_5__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B814
typedef union {
  struct {
    //
    // Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     10:7 - It is used for logic delay.[br]
    //                     6:0 - The lower 7 bit is added with rcven_piref_offset and
    // piref_setup_adj, so the programed value is relative to the piref clock. The result
    // is sent to the rcven crossover logic and DLL.[br]  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 rcven_dly : 11;
    //
    // It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival
    // DQ.[br] 
    //                     The per bit range is 0 to 1.375 dclk with step size clkpi/128.
    // [br] 
    //                     The per bit calculation is [br]
    //                     rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj
    // (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed
    // number for BIOS margining sweep. Range is -128 to 127)[br] 
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[18:11], RW, default = 0x0
    //
    UINT32 rxdqsp_dly : 8;
    //
    // It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival
    // DQ.[br] 
    //                     The per bit range is 0 to 1.375 dclk with step size clkpi/128.
    // [br] 
    //                     The per bit calculation is [br]
    //                     rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj
    // (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed
    // number for BIOS margining sweep. Range is -128 to 127)[br] 
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[26:19], RW, default = 0x0
    //
    UINT32 rxdqsn_dly : 8;
    //
    // It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay
    // to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]
    //                     0: 1/16 UI offset,[br] 
    //                     1: 3/16 UI offset,[br] 
    //                     2: 5/16 UI offset,[br] 
    //                     3: 7/16 UI offset,[br] 
    //                     4: 9/16 UI offset,[br] 
    //                     5: 11/16 UI offset,[br] 
    //                     6,7: 13/16 UI offset.[br] 
    //                     When DFE is enabled, adds delay on the DFE feedback path (after
    // the DFE sampler).[br]  
    //                     0: 0 offset (bypass),[br] 
    //                     1: 2/16 UI offset,[br] 
    //                     2: 4/16 UI offset,[br] 
    //                     3: 6/16 UI offset,[br] 
    //                     4: 8/16 UI offset,[br] 
    //                     5: 10/16 UI offset,[br] 
    //                     6,7: 12/16 UI offset).
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINT32 rxdq_dly : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // RX Strobe Inversion for DFE
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 rx_strobe_inv : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL0_RANK_5__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL0_RANK_6__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B818
typedef union {
  struct {
    //
    // Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     10:7 - It is used for logic delay.[br]
    //                     6:0 - The lower 7 bit is added with rcven_piref_offset and
    // piref_setup_adj, so the programed value is relative to the piref clock. The result
    // is sent to the rcven crossover logic and DLL.[br]  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 rcven_dly : 11;
    //
    // It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival
    // DQ.[br] 
    //                     The per bit range is 0 to 1.375 dclk with step size clkpi/128.
    // [br] 
    //                     The per bit calculation is [br]
    //                     rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj
    // (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed
    // number for BIOS margining sweep. Range is -128 to 127)[br] 
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[18:11], RW, default = 0x0
    //
    UINT32 rxdqsp_dly : 8;
    //
    // It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival
    // DQ.[br] 
    //                     The per bit range is 0 to 1.375 dclk with step size clkpi/128.
    // [br] 
    //                     The per bit calculation is [br]
    //                     rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj
    // (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed
    // number for BIOS margining sweep. Range is -128 to 127)[br] 
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[26:19], RW, default = 0x0
    //
    UINT32 rxdqsn_dly : 8;
    //
    // It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay
    // to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]
    //                     0: 1/16 UI offset,[br] 
    //                     1: 3/16 UI offset,[br] 
    //                     2: 5/16 UI offset,[br] 
    //                     3: 7/16 UI offset,[br] 
    //                     4: 9/16 UI offset,[br] 
    //                     5: 11/16 UI offset,[br] 
    //                     6,7: 13/16 UI offset.[br] 
    //                     When DFE is enabled, adds delay on the DFE feedback path (after
    // the DFE sampler).[br]  
    //                     0: 0 offset (bypass),[br] 
    //                     1: 2/16 UI offset,[br] 
    //                     2: 4/16 UI offset,[br] 
    //                     3: 6/16 UI offset,[br] 
    //                     4: 8/16 UI offset,[br] 
    //                     5: 10/16 UI offset,[br] 
    //                     6,7: 12/16 UI offset).
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINT32 rxdq_dly : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // RX Strobe Inversion for DFE
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 rx_strobe_inv : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL0_RANK_6__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL0_RANK_7__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B81C
typedef union {
  struct {
    //
    // Receive Enable Delay. The range is 0 to 16UI with step size clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     10:7 - It is used for logic delay.[br]
    //                     6:0 - The lower 7 bit is added with rcven_piref_offset and
    // piref_setup_adj, so the programed value is relative to the piref clock. The result
    // is sent to the rcven crossover logic and DLL.[br]  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 rcven_dly : 11;
    //
    // It is used by RX DQS deskew logic to delay DQS_P to match the earlest arrival
    // DQ.[br] 
    //                     The per bit range is 0 to 1.375 dclk with step size clkpi/128.
    // [br] 
    //                     The per bit calculation is [br]
    //                     rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit delay) + rxrt_dqs_dly_adj
    // (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed
    // number for BIOS margining sweep. Range is -128 to 127)[br] 
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[18:11], RW, default = 0x0
    //
    UINT32 rxdqsp_dly : 8;
    //
    // It is used by RX DQS deskew logic to delay DQS_N to match the earlest arrival
    // DQ.[br] 
    //                     The per bit range is 0 to 1.375 dclk with step size clkpi/128.
    // [br] 
    //                     The per bit calculation is [br]
    //                     rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit delay) + rxrt_dqs_dly_adj
    // (singed number for rx retraining. Range is -64 to 63) + rxdqs_dly_adj (signed
    // number for BIOS margining sweep. Range is -128 to 127)[br] 
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[26:19], RW, default = 0x0
    //
    UINT32 rxdqsn_dly : 8;
    //
    // It is used by the RX deskew CBB. Normal usage (when DFE is disabled)  adds delay
    // to the DQ path, when DQ is earlier than DQS. This control only apply for DDR4.[br]
    //                     0: 1/16 UI offset,[br] 
    //                     1: 3/16 UI offset,[br] 
    //                     2: 5/16 UI offset,[br] 
    //                     3: 7/16 UI offset,[br] 
    //                     4: 9/16 UI offset,[br] 
    //                     5: 11/16 UI offset,[br] 
    //                     6,7: 13/16 UI offset.[br] 
    //                     When DFE is enabled, adds delay on the DFE feedback path (after
    // the DFE sampler).[br]  
    //                     0: 0 offset (bypass),[br] 
    //                     1: 2/16 UI offset,[br] 
    //                     2: 4/16 UI offset,[br] 
    //                     3: 6/16 UI offset,[br] 
    //                     4: 8/16 UI offset,[br] 
    //                     5: 10/16 UI offset,[br] 
    //                     6,7: 12/16 UI offset).
    // 
    // Bits[29:27], RW, default = 0x0
    //
    UINT32 rxdq_dly : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // RX Strobe Inversion for DFE
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 rx_strobe_inv : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL0_RANK_7__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL1_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B820
typedef union {
  struct {
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ0. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 rxdqsn_dly0 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ1. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 rxdqsn_dly1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ2. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINT32 rxdqsn_dly2 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ3. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 rxdqsn_dly3 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C.
    // 
    // Bits[26:25], RW, default = 0x0
    //
    UINT32 ctle_cap_en : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 1;
    //
    // CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]
    //                     Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]
    //                     where R is ~500 Ohms and depends on process.
    // 
    // Bits[30:28], RW, default = 0x0
    //
    UINT32 ctle_res_en : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_5 : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL1_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL1_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B824
typedef union {
  struct {
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ0. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 rxdqsn_dly0 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ1. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 rxdqsn_dly1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ2. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINT32 rxdqsn_dly2 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ3. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 rxdqsn_dly3 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C.
    // 
    // Bits[26:25], RW, default = 0x0
    //
    UINT32 ctle_cap_en : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 1;
    //
    // CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]
    //                     Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]
    //                     where R is ~500 Ohms and depends on process.
    // 
    // Bits[30:28], RW, default = 0x0
    //
    UINT32 ctle_res_en : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_5 : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL1_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL1_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B828
typedef union {
  struct {
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ0. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 rxdqsn_dly0 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ1. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 rxdqsn_dly1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ2. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINT32 rxdqsn_dly2 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ3. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 rxdqsn_dly3 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C.
    // 
    // Bits[26:25], RW, default = 0x0
    //
    UINT32 ctle_cap_en : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 1;
    //
    // CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]
    //                     Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]
    //                     where R is ~500 Ohms and depends on process.
    // 
    // Bits[30:28], RW, default = 0x0
    //
    UINT32 ctle_res_en : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_5 : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL1_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL1_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B82C
typedef union {
  struct {
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ0. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 rxdqsn_dly0 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ1. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 rxdqsn_dly1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ2. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINT32 rxdqsn_dly2 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ3. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 rxdqsn_dly3 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C.
    // 
    // Bits[26:25], RW, default = 0x0
    //
    UINT32 ctle_cap_en : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 1;
    //
    // CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]
    //                     Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]
    //                     where R is ~500 Ohms and depends on process.
    // 
    // Bits[30:28], RW, default = 0x0
    //
    UINT32 ctle_res_en : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_5 : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL1_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL1_RANK_4__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B830
typedef union {
  struct {
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ0. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 rxdqsn_dly0 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ1. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 rxdqsn_dly1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ2. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINT32 rxdqsn_dly2 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ3. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 rxdqsn_dly3 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C.
    // 
    // Bits[26:25], RW, default = 0x0
    //
    UINT32 ctle_cap_en : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 1;
    //
    // CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]
    //                     Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]
    //                     where R is ~500 Ohms and depends on process.
    // 
    // Bits[30:28], RW, default = 0x0
    //
    UINT32 ctle_res_en : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_5 : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL1_RANK_4__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL1_RANK_5__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B834
typedef union {
  struct {
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ0. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 rxdqsn_dly0 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ1. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 rxdqsn_dly1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ2. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINT32 rxdqsn_dly2 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ3. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 rxdqsn_dly3 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C.
    // 
    // Bits[26:25], RW, default = 0x0
    //
    UINT32 ctle_cap_en : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 1;
    //
    // CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]
    //                     Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]
    //                     where R is ~500 Ohms and depends on process.
    // 
    // Bits[30:28], RW, default = 0x0
    //
    UINT32 ctle_res_en : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_5 : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL1_RANK_5__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL1_RANK_6__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B838
typedef union {
  struct {
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ0. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 rxdqsn_dly0 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ1. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 rxdqsn_dly1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ2. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINT32 rxdqsn_dly2 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ3. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 rxdqsn_dly3 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C.
    // 
    // Bits[26:25], RW, default = 0x0
    //
    UINT32 ctle_cap_en : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 1;
    //
    // CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]
    //                     Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]
    //                     where R is ~500 Ohms and depends on process.
    // 
    // Bits[30:28], RW, default = 0x0
    //
    UINT32 ctle_res_en : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_5 : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL1_RANK_6__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL1_RANK_7__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B83C
typedef union {
  struct {
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ0. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 rxdqsn_dly0 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ1. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 rxdqsn_dly1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ2. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINT32 rxdqsn_dly2 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Per bit rxdqsn delay control to add on to rxdqsn_dly to delay DQS_N to match on
    // DQ3. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 rxdqsn_dly3 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C.
    // 
    // Bits[26:25], RW, default = 0x0
    //
    UINT32 ctle_cap_en : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 1;
    //
    // CTLE Resistor Enable (Controls DC gain). 0 = lowest DC gain (max peaking)[br]
    //                     Res: 0-3R, 1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3, 7=R/4[br]
    //                     where R is ~500 Ohms and depends on process.
    // 
    // Bits[30:28], RW, default = 0x0
    //
    UINT32 ctle_res_en : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_5 : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL1_RANK_7__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL2_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B840
typedef union {
  struct {
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ0. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 rxdqsp_dly0 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ1. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 rxdqsp_dly1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ2. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINT32 rxdqsp_dly2 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ3. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 rxdqsp_dly3 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL2_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL2_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B844
typedef union {
  struct {
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ0. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 rxdqsp_dly0 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ1. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 rxdqsp_dly1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ2. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINT32 rxdqsp_dly2 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ3. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 rxdqsp_dly3 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL2_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL2_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B848
typedef union {
  struct {
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ0. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 rxdqsp_dly0 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ1. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 rxdqsp_dly1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ2. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINT32 rxdqsp_dly2 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ3. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 rxdqsp_dly3 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL2_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL2_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B84C
typedef union {
  struct {
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ0. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 rxdqsp_dly0 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ1. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 rxdqsp_dly1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ2. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINT32 rxdqsp_dly2 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ3. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 rxdqsp_dly3 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL2_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL2_RANK_4__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B850
typedef union {
  struct {
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ0. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 rxdqsp_dly0 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ1. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 rxdqsp_dly1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ2. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINT32 rxdqsp_dly2 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ3. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 rxdqsp_dly3 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL2_RANK_4__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL2_RANK_5__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B854
typedef union {
  struct {
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ0. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 rxdqsp_dly0 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ1. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 rxdqsp_dly1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ2. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINT32 rxdqsp_dly2 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ3. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 rxdqsp_dly3 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL2_RANK_5__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL2_RANK_6__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B858
typedef union {
  struct {
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ0. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 rxdqsp_dly0 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ1. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 rxdqsp_dly1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ2. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINT32 rxdqsp_dly2 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ3. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 rxdqsp_dly3 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL2_RANK_6__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL2_RANK_7__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B85C
typedef union {
  struct {
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ0. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 rxdqsp_dly0 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ1. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 rxdqsp_dly1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ2. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[17:13], RW, default = 0x0
    //
    UINT32 rxdqsp_dly2 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Per bit rxdqsp delay control to add on to rxdqsp_dly to delay DQS_P to match on
    // DQ3. [br] 
    //                     The range is 0 to 0.25 dclk with step size clkpi/128. [br]
    //                     Note: BIOS must make sure the total delay not more than 1.375
    // dclk. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 rxdqsp_dly3 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL2_RANK_7__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DFE_COEFF_OFFSET0_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B860
typedef union {
  struct {
    //
    // DFE C1 offset for DQ0. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 dfe_c1_offset0 : 3;
    //
    // DFE C1 offset for DQ1. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 dfe_c1_offset1 : 3;
    //
    // DFE C1 offset for DQ2. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINT32 dfe_c1_offset2 : 3;
    //
    // DFE C1 offset for DQ3. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[11:9], RW, default = 0x0
    //
    UINT32 dfe_c1_offset3 : 3;
    //
    // DFE C2 offset for DQ0. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[14:12], RW, default = 0x0
    //
    UINT32 dfe_c2_offset0 : 3;
    //
    // DFE C2 offset for DQ1. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[17:15], RW, default = 0x0
    //
    UINT32 dfe_c2_offset1 : 3;
    //
    // DFE C2 offset for DQ2. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[20:18], RW, default = 0x0
    //
    UINT32 dfe_c2_offset2 : 3;
    //
    // DFE C2 offset for DQ3. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[23:21], RW, default = 0x0
    //
    UINT32 dfe_c2_offset3 : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_DFE_COEFF_OFFSET0_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DFE_COEFF_OFFSET0_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B864
typedef union {
  struct {
    //
    // DFE C1 offset for DQ0. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 dfe_c1_offset0 : 3;
    //
    // DFE C1 offset for DQ1. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 dfe_c1_offset1 : 3;
    //
    // DFE C1 offset for DQ2. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINT32 dfe_c1_offset2 : 3;
    //
    // DFE C1 offset for DQ3. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[11:9], RW, default = 0x0
    //
    UINT32 dfe_c1_offset3 : 3;
    //
    // DFE C2 offset for DQ0. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[14:12], RW, default = 0x0
    //
    UINT32 dfe_c2_offset0 : 3;
    //
    // DFE C2 offset for DQ1. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[17:15], RW, default = 0x0
    //
    UINT32 dfe_c2_offset1 : 3;
    //
    // DFE C2 offset for DQ2. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[20:18], RW, default = 0x0
    //
    UINT32 dfe_c2_offset2 : 3;
    //
    // DFE C2 offset for DQ3. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[23:21], RW, default = 0x0
    //
    UINT32 dfe_c2_offset3 : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_DFE_COEFF_OFFSET0_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DFE_COEFF_OFFSET0_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B868
typedef union {
  struct {
    //
    // DFE C1 offset for DQ0. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 dfe_c1_offset0 : 3;
    //
    // DFE C1 offset for DQ1. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 dfe_c1_offset1 : 3;
    //
    // DFE C1 offset for DQ2. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINT32 dfe_c1_offset2 : 3;
    //
    // DFE C1 offset for DQ3. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[11:9], RW, default = 0x0
    //
    UINT32 dfe_c1_offset3 : 3;
    //
    // DFE C2 offset for DQ0. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[14:12], RW, default = 0x0
    //
    UINT32 dfe_c2_offset0 : 3;
    //
    // DFE C2 offset for DQ1. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[17:15], RW, default = 0x0
    //
    UINT32 dfe_c2_offset1 : 3;
    //
    // DFE C2 offset for DQ2. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[20:18], RW, default = 0x0
    //
    UINT32 dfe_c2_offset2 : 3;
    //
    // DFE C2 offset for DQ3. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[23:21], RW, default = 0x0
    //
    UINT32 dfe_c2_offset3 : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_DFE_COEFF_OFFSET0_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DFE_COEFF_OFFSET0_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B86C
typedef union {
  struct {
    //
    // DFE C1 offset for DQ0. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 dfe_c1_offset0 : 3;
    //
    // DFE C1 offset for DQ1. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 dfe_c1_offset1 : 3;
    //
    // DFE C1 offset for DQ2. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINT32 dfe_c1_offset2 : 3;
    //
    // DFE C1 offset for DQ3. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[11:9], RW, default = 0x0
    //
    UINT32 dfe_c1_offset3 : 3;
    //
    // DFE C2 offset for DQ0. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[14:12], RW, default = 0x0
    //
    UINT32 dfe_c2_offset0 : 3;
    //
    // DFE C2 offset for DQ1. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[17:15], RW, default = 0x0
    //
    UINT32 dfe_c2_offset1 : 3;
    //
    // DFE C2 offset for DQ2. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[20:18], RW, default = 0x0
    //
    UINT32 dfe_c2_offset2 : 3;
    //
    // DFE C2 offset for DQ3. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[23:21], RW, default = 0x0
    //
    UINT32 dfe_c2_offset3 : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_DFE_COEFF_OFFSET0_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DFE_COEFF_OFFSET1_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B870
typedef union {
  struct {
    //
    // DFE C3 offset for DQ0. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 dfe_c3_offset0 : 3;
    //
    // DFE C3 offset for DQ1. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 dfe_c3_offset1 : 3;
    //
    // DFE C3 offset for DQ2. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINT32 dfe_c3_offset2 : 3;
    //
    // DFE C3 offset for DQ3. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[11:9], RW, default = 0x0
    //
    UINT32 dfe_c3_offset3 : 3;
    //
    // DFE C4 offset for DQ0. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[14:12], RW, default = 0x0
    //
    UINT32 dfe_c4_offset0 : 3;
    //
    // DFE C4 offset for DQ1. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[17:15], RW, default = 0x0
    //
    UINT32 dfe_c4_offset1 : 3;
    //
    // DFE C4 offset for DQ2. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[20:18], RW, default = 0x0
    //
    UINT32 dfe_c4_offset2 : 3;
    //
    // DFE C4 offset for DQ3. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[23:21], RW, default = 0x0
    //
    UINT32 dfe_c4_offset3 : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_DFE_COEFF_OFFSET1_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DFE_COEFF_OFFSET1_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B874
typedef union {
  struct {
    //
    // DFE C3 offset for DQ0. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 dfe_c3_offset0 : 3;
    //
    // DFE C3 offset for DQ1. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 dfe_c3_offset1 : 3;
    //
    // DFE C3 offset for DQ2. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINT32 dfe_c3_offset2 : 3;
    //
    // DFE C3 offset for DQ3. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[11:9], RW, default = 0x0
    //
    UINT32 dfe_c3_offset3 : 3;
    //
    // DFE C4 offset for DQ0. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[14:12], RW, default = 0x0
    //
    UINT32 dfe_c4_offset0 : 3;
    //
    // DFE C4 offset for DQ1. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[17:15], RW, default = 0x0
    //
    UINT32 dfe_c4_offset1 : 3;
    //
    // DFE C4 offset for DQ2. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[20:18], RW, default = 0x0
    //
    UINT32 dfe_c4_offset2 : 3;
    //
    // DFE C4 offset for DQ3. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[23:21], RW, default = 0x0
    //
    UINT32 dfe_c4_offset3 : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_DFE_COEFF_OFFSET1_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DFE_COEFF_OFFSET1_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B878
typedef union {
  struct {
    //
    // DFE C3 offset for DQ0. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 dfe_c3_offset0 : 3;
    //
    // DFE C3 offset for DQ1. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 dfe_c3_offset1 : 3;
    //
    // DFE C3 offset for DQ2. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINT32 dfe_c3_offset2 : 3;
    //
    // DFE C3 offset for DQ3. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[11:9], RW, default = 0x0
    //
    UINT32 dfe_c3_offset3 : 3;
    //
    // DFE C4 offset for DQ0. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[14:12], RW, default = 0x0
    //
    UINT32 dfe_c4_offset0 : 3;
    //
    // DFE C4 offset for DQ1. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[17:15], RW, default = 0x0
    //
    UINT32 dfe_c4_offset1 : 3;
    //
    // DFE C4 offset for DQ2. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[20:18], RW, default = 0x0
    //
    UINT32 dfe_c4_offset2 : 3;
    //
    // DFE C4 offset for DQ3. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[23:21], RW, default = 0x0
    //
    UINT32 dfe_c4_offset3 : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_DFE_COEFF_OFFSET1_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DFE_COEFF_OFFSET1_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B87C
typedef union {
  struct {
    //
    // DFE C3 offset for DQ0. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 dfe_c3_offset0 : 3;
    //
    // DFE C3 offset for DQ1. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 dfe_c3_offset1 : 3;
    //
    // DFE C3 offset for DQ2. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINT32 dfe_c3_offset2 : 3;
    //
    // DFE C3 offset for DQ3. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[11:9], RW, default = 0x0
    //
    UINT32 dfe_c3_offset3 : 3;
    //
    // DFE C4 offset for DQ0. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[14:12], RW, default = 0x0
    //
    UINT32 dfe_c4_offset0 : 3;
    //
    // DFE C4 offset for DQ1. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[17:15], RW, default = 0x0
    //
    UINT32 dfe_c4_offset1 : 3;
    //
    // DFE C4 offset for DQ2. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[20:18], RW, default = 0x0
    //
    UINT32 dfe_c4_offset2 : 3;
    //
    // DFE C4 offset for DQ3. It is a positive adjustment. BIOS will train to min value.
    // 
    // Bits[23:21], RW, default = 0x0
    //
    UINT32 dfe_c4_offset3 : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_DFE_COEFF_OFFSET1_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL0_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B880
typedef union {
  struct {
    //
    // Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128.
    // [br] 
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     10:7 - It is used for logic delay.[br]
    //                     6:0 - The lower 7 bit is added with txdqs_piref_offset and
    // piref_setup_adj, so the programed value is relative to the piref clock. Then The
    // result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover
    // logic and DLL.  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdqs_dly : 11;
    //
    // This offset is add to the txdqs_pio_code . The result is the txdqs pi even code
    // (txdqs_pie_code) to DLL.. Default value is 64. 
    // 
    // Bits[17:11], RW, default = 0x40
    //
    UINT32 txdqs_pie_offset : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // TxEQ 2nd tap coefficient.The following list all the legal programming values.
    // During TxEQ training BIOS should sweep the following codes in accending order:
    //                     txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 
    // 
    // Bits[22:19], RW, default = 0x0
    //
    UINT32 txeq_2nd_tap : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // TxEQ 1st tap coefficient.
    //                     The following list all the legal programming values. During
    // TxEQ training BIOS should sweep the following codes in accending order: 
    //                     txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63
    //  
    // 
    // Bits[29:24], RW, default = 0x0
    //
    UINT32 txeq_1st_tap : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL0_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL0_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B884
typedef union {
  struct {
    //
    // Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128.
    // [br] 
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     10:7 - It is used for logic delay.[br]
    //                     6:0 - The lower 7 bit is added with txdqs_piref_offset and
    // piref_setup_adj, so the programed value is relative to the piref clock. Then The
    // result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover
    // logic and DLL.  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdqs_dly : 11;
    //
    // This offset is add to the txdqs_pio_code . The result is the txdqs pi even code
    // (txdqs_pie_code) to DLL.. Default value is 64. 
    // 
    // Bits[17:11], RW, default = 0x40
    //
    UINT32 txdqs_pie_offset : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // TxEQ 2nd tap coefficient.The following list all the legal programming values.
    // During TxEQ training BIOS should sweep the following codes in accending order:
    //                     txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 
    // 
    // Bits[22:19], RW, default = 0x0
    //
    UINT32 txeq_2nd_tap : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // TxEQ 1st tap coefficient.
    //                     The following list all the legal programming values. During
    // TxEQ training BIOS should sweep the following codes in accending order: 
    //                     txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63
    //  
    // 
    // Bits[29:24], RW, default = 0x0
    //
    UINT32 txeq_1st_tap : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL0_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL0_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B888
typedef union {
  struct {
    //
    // Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128.
    // [br] 
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     10:7 - It is used for logic delay.[br]
    //                     6:0 - The lower 7 bit is added with txdqs_piref_offset and
    // piref_setup_adj, so the programed value is relative to the piref clock. Then The
    // result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover
    // logic and DLL.  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdqs_dly : 11;
    //
    // This offset is add to the txdqs_pio_code . The result is the txdqs pi even code
    // (txdqs_pie_code) to DLL.. Default value is 64. 
    // 
    // Bits[17:11], RW, default = 0x40
    //
    UINT32 txdqs_pie_offset : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // TxEQ 2nd tap coefficient.The following list all the legal programming values.
    // During TxEQ training BIOS should sweep the following codes in accending order:
    //                     txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 
    // 
    // Bits[22:19], RW, default = 0x0
    //
    UINT32 txeq_2nd_tap : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // TxEQ 1st tap coefficient.
    //                     The following list all the legal programming values. During
    // TxEQ training BIOS should sweep the following codes in accending order: 
    //                     txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63
    //  
    // 
    // Bits[29:24], RW, default = 0x0
    //
    UINT32 txeq_1st_tap : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL0_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL0_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B88C
typedef union {
  struct {
    //
    // Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128.
    // [br] 
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     10:7 - It is used for logic delay.[br]
    //                     6:0 - The lower 7 bit is added with txdqs_piref_offset and
    // piref_setup_adj, so the programed value is relative to the piref clock. Then The
    // result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover
    // logic and DLL.  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdqs_dly : 11;
    //
    // This offset is add to the txdqs_pio_code . The result is the txdqs pi even code
    // (txdqs_pie_code) to DLL.. Default value is 64. 
    // 
    // Bits[17:11], RW, default = 0x40
    //
    UINT32 txdqs_pie_offset : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // TxEQ 2nd tap coefficient.The following list all the legal programming values.
    // During TxEQ training BIOS should sweep the following codes in accending order:
    //                     txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 
    // 
    // Bits[22:19], RW, default = 0x0
    //
    UINT32 txeq_2nd_tap : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // TxEQ 1st tap coefficient.
    //                     The following list all the legal programming values. During
    // TxEQ training BIOS should sweep the following codes in accending order: 
    //                     txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63
    //  
    // 
    // Bits[29:24], RW, default = 0x0
    //
    UINT32 txeq_1st_tap : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL0_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL0_RANK_4__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B890
typedef union {
  struct {
    //
    // Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128.
    // [br] 
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     10:7 - It is used for logic delay.[br]
    //                     6:0 - The lower 7 bit is added with txdqs_piref_offset and
    // piref_setup_adj, so the programed value is relative to the piref clock. Then The
    // result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover
    // logic and DLL.  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdqs_dly : 11;
    //
    // This offset is add to the txdqs_pio_code . The result is the txdqs pi even code
    // (txdqs_pie_code) to DLL.. Default value is 64. 
    // 
    // Bits[17:11], RW, default = 0x40
    //
    UINT32 txdqs_pie_offset : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // TxEQ 2nd tap coefficient.The following list all the legal programming values.
    // During TxEQ training BIOS should sweep the following codes in accending order:
    //                     txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 
    // 
    // Bits[22:19], RW, default = 0x0
    //
    UINT32 txeq_2nd_tap : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // TxEQ 1st tap coefficient.
    //                     The following list all the legal programming values. During
    // TxEQ training BIOS should sweep the following codes in accending order: 
    //                     txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63
    //  
    // 
    // Bits[29:24], RW, default = 0x0
    //
    UINT32 txeq_1st_tap : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL0_RANK_4__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL0_RANK_5__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B894
typedef union {
  struct {
    //
    // Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128.
    // [br] 
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     10:7 - It is used for logic delay.[br]
    //                     6:0 - The lower 7 bit is added with txdqs_piref_offset and
    // piref_setup_adj, so the programed value is relative to the piref clock. Then The
    // result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover
    // logic and DLL.  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdqs_dly : 11;
    //
    // This offset is add to the txdqs_pio_code . The result is the txdqs pi even code
    // (txdqs_pie_code) to DLL.. Default value is 64. 
    // 
    // Bits[17:11], RW, default = 0x40
    //
    UINT32 txdqs_pie_offset : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // TxEQ 2nd tap coefficient.The following list all the legal programming values.
    // During TxEQ training BIOS should sweep the following codes in accending order:
    //                     txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 
    // 
    // Bits[22:19], RW, default = 0x0
    //
    UINT32 txeq_2nd_tap : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // TxEQ 1st tap coefficient.
    //                     The following list all the legal programming values. During
    // TxEQ training BIOS should sweep the following codes in accending order: 
    //                     txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63
    //  
    // 
    // Bits[29:24], RW, default = 0x0
    //
    UINT32 txeq_1st_tap : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL0_RANK_5__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL0_RANK_6__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B898
typedef union {
  struct {
    //
    // Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128.
    // [br] 
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     10:7 - It is used for logic delay.[br]
    //                     6:0 - The lower 7 bit is added with txdqs_piref_offset and
    // piref_setup_adj, so the programed value is relative to the piref clock. Then The
    // result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover
    // logic and DLL.  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdqs_dly : 11;
    //
    // This offset is add to the txdqs_pio_code . The result is the txdqs pi even code
    // (txdqs_pie_code) to DLL.. Default value is 64. 
    // 
    // Bits[17:11], RW, default = 0x40
    //
    UINT32 txdqs_pie_offset : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // TxEQ 2nd tap coefficient.The following list all the legal programming values.
    // During TxEQ training BIOS should sweep the following codes in accending order:
    //                     txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 
    // 
    // Bits[22:19], RW, default = 0x0
    //
    UINT32 txeq_2nd_tap : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // TxEQ 1st tap coefficient.
    //                     The following list all the legal programming values. During
    // TxEQ training BIOS should sweep the following codes in accending order: 
    //                     txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63
    //  
    // 
    // Bits[29:24], RW, default = 0x0
    //
    UINT32 txeq_1st_tap : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL0_RANK_6__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL0_RANK_7__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B89C
typedef union {
  struct {
    //
    // Write DQS delay control. The range is 0 to 16 UI with step size of clkpi/128.
    // [br] 
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     10:7 - It is used for logic delay.[br]
    //                     6:0 - The lower 7 bit is added with txdqs_piref_offset and
    // piref_setup_adj, so the programed value is relative to the piref clock. Then The
    // result is the txdqs pi odd code (txdqs_pio_code) that sent to the txdqs crossover
    // logic and DLL.  
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdqs_dly : 11;
    //
    // This offset is add to the txdqs_pio_code . The result is the txdqs pi even code
    // (txdqs_pie_code) to DLL.. Default value is 64. 
    // 
    // Bits[17:11], RW, default = 0x40
    //
    UINT32 txdqs_pie_offset : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // TxEQ 2nd tap coefficient.The following list all the legal programming values.
    // During TxEQ training BIOS should sweep the following codes in accending order:
    //                     txeq_2nd_tap: 0,1,2,3,4,5,6,7,12,13,14,15 
    // 
    // Bits[22:19], RW, default = 0x0
    //
    UINT32 txeq_2nd_tap : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // TxEQ 1st tap coefficient.
    //                     The following list all the legal programming values. During
    // TxEQ training BIOS should sweep the following codes in accending order: 
    //                     txeq_1st_tap:  0,1,2,3,4,5,6,7,12,13,14,15,28,29,30,31,60,61,62,63
    //  
    // 
    // Bits[29:24], RW, default = 0x0
    //
    UINT32 txeq_1st_tap : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL0_RANK_7__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL1_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8A0
typedef union {
  struct {
    //
    // Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdq_dly0 : 11;
    //
    // Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[21:11], RW/V, default = 0x0
    //
    UINT32 txdq_dly1 : 11;
    //
    // PXC delta for DQ0 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[23:22], RW, default = 0x0
    //
    UINT32 pxc_delta0 : 2;
    //
    // PXC delta for DQ1 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINT32 pxc_delta1 : 2;
    //
    // PXC delta for DQ2 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINT32 pxc_delta2 : 2;
    //
    // PXC delta for DQ3 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 pxc_delta3 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL1_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL1_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8A4
typedef union {
  struct {
    //
    // Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdq_dly0 : 11;
    //
    // Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[21:11], RW/V, default = 0x0
    //
    UINT32 txdq_dly1 : 11;
    //
    // PXC delta for DQ0 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[23:22], RW, default = 0x0
    //
    UINT32 pxc_delta0 : 2;
    //
    // PXC delta for DQ1 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINT32 pxc_delta1 : 2;
    //
    // PXC delta for DQ2 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINT32 pxc_delta2 : 2;
    //
    // PXC delta for DQ3 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 pxc_delta3 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL1_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL1_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8A8
typedef union {
  struct {
    //
    // Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdq_dly0 : 11;
    //
    // Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[21:11], RW/V, default = 0x0
    //
    UINT32 txdq_dly1 : 11;
    //
    // PXC delta for DQ0 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[23:22], RW, default = 0x0
    //
    UINT32 pxc_delta0 : 2;
    //
    // PXC delta for DQ1 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINT32 pxc_delta1 : 2;
    //
    // PXC delta for DQ2 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINT32 pxc_delta2 : 2;
    //
    // PXC delta for DQ3 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 pxc_delta3 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL1_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL1_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8AC
typedef union {
  struct {
    //
    // Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdq_dly0 : 11;
    //
    // Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[21:11], RW/V, default = 0x0
    //
    UINT32 txdq_dly1 : 11;
    //
    // PXC delta for DQ0 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[23:22], RW, default = 0x0
    //
    UINT32 pxc_delta0 : 2;
    //
    // PXC delta for DQ1 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINT32 pxc_delta1 : 2;
    //
    // PXC delta for DQ2 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINT32 pxc_delta2 : 2;
    //
    // PXC delta for DQ3 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 pxc_delta3 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL1_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL1_RANK_4__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8B0
typedef union {
  struct {
    //
    // Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdq_dly0 : 11;
    //
    // Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[21:11], RW/V, default = 0x0
    //
    UINT32 txdq_dly1 : 11;
    //
    // PXC delta for DQ0 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[23:22], RW, default = 0x0
    //
    UINT32 pxc_delta0 : 2;
    //
    // PXC delta for DQ1 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINT32 pxc_delta1 : 2;
    //
    // PXC delta for DQ2 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINT32 pxc_delta2 : 2;
    //
    // PXC delta for DQ3 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 pxc_delta3 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL1_RANK_4__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL1_RANK_5__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8B4
typedef union {
  struct {
    //
    // Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdq_dly0 : 11;
    //
    // Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[21:11], RW/V, default = 0x0
    //
    UINT32 txdq_dly1 : 11;
    //
    // PXC delta for DQ0 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[23:22], RW, default = 0x0
    //
    UINT32 pxc_delta0 : 2;
    //
    // PXC delta for DQ1 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINT32 pxc_delta1 : 2;
    //
    // PXC delta for DQ2 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINT32 pxc_delta2 : 2;
    //
    // PXC delta for DQ3 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 pxc_delta3 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL1_RANK_5__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL1_RANK_6__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8B8
typedef union {
  struct {
    //
    // Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdq_dly0 : 11;
    //
    // Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[21:11], RW/V, default = 0x0
    //
    UINT32 txdq_dly1 : 11;
    //
    // PXC delta for DQ0 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[23:22], RW, default = 0x0
    //
    UINT32 pxc_delta0 : 2;
    //
    // PXC delta for DQ1 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINT32 pxc_delta1 : 2;
    //
    // PXC delta for DQ2 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINT32 pxc_delta2 : 2;
    //
    // PXC delta for DQ3 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 pxc_delta3 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL1_RANK_6__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL1_RANK_7__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8BC
typedef union {
  struct {
    //
    // Write DQ 0 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdq_dly0 : 11;
    //
    // Write DQ 1 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[21:11], RW/V, default = 0x0
    //
    UINT32 txdq_dly1 : 11;
    //
    // PXC delta for DQ0 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[23:22], RW, default = 0x0
    //
    UINT32 pxc_delta0 : 2;
    //
    // PXC delta for DQ1 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINT32 pxc_delta1 : 2;
    //
    // PXC delta for DQ2 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINT32 pxc_delta2 : 2;
    //
    // PXC delta for DQ3 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 pxc_delta3 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL1_RANK_7__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL2_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8C0
typedef union {
  struct {
    //
    // Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdq_dly2 : 11;
    //
    // Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[21:11], RW/V, default = 0x0
    //
    UINT32 txdq_dly3 : 11;
    //
    // DDJC delta for DQ0 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[23:22], RW, default = 0x0
    //
    UINT32 ddjc_delta0 : 2;
    //
    // DDJC delta for DQ1 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINT32 ddjc_delta1 : 2;
    //
    // DDJC delta for DQ2 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINT32 ddjc_delta2 : 2;
    //
    // DDJC delta for DQ3 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 ddjc_delta3 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL2_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL2_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8C4
typedef union {
  struct {
    //
    // Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdq_dly2 : 11;
    //
    // Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[21:11], RW/V, default = 0x0
    //
    UINT32 txdq_dly3 : 11;
    //
    // DDJC delta for DQ0 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[23:22], RW, default = 0x0
    //
    UINT32 ddjc_delta0 : 2;
    //
    // DDJC delta for DQ1 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINT32 ddjc_delta1 : 2;
    //
    // DDJC delta for DQ2 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINT32 ddjc_delta2 : 2;
    //
    // DDJC delta for DQ3 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 ddjc_delta3 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL2_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL2_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8C8
typedef union {
  struct {
    //
    // Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdq_dly2 : 11;
    //
    // Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[21:11], RW/V, default = 0x0
    //
    UINT32 txdq_dly3 : 11;
    //
    // DDJC delta for DQ0 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[23:22], RW, default = 0x0
    //
    UINT32 ddjc_delta0 : 2;
    //
    // DDJC delta for DQ1 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINT32 ddjc_delta1 : 2;
    //
    // DDJC delta for DQ2 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINT32 ddjc_delta2 : 2;
    //
    // DDJC delta for DQ3 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 ddjc_delta3 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL2_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL2_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8CC
typedef union {
  struct {
    //
    // Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdq_dly2 : 11;
    //
    // Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[21:11], RW/V, default = 0x0
    //
    UINT32 txdq_dly3 : 11;
    //
    // DDJC delta for DQ0 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[23:22], RW, default = 0x0
    //
    UINT32 ddjc_delta0 : 2;
    //
    // DDJC delta for DQ1 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINT32 ddjc_delta1 : 2;
    //
    // DDJC delta for DQ2 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINT32 ddjc_delta2 : 2;
    //
    // DDJC delta for DQ3 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 ddjc_delta3 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL2_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL2_RANK_4__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8D0
typedef union {
  struct {
    //
    // Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdq_dly2 : 11;
    //
    // Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[21:11], RW/V, default = 0x0
    //
    UINT32 txdq_dly3 : 11;
    //
    // DDJC delta for DQ0 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[23:22], RW, default = 0x0
    //
    UINT32 ddjc_delta0 : 2;
    //
    // DDJC delta for DQ1 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINT32 ddjc_delta1 : 2;
    //
    // DDJC delta for DQ2 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINT32 ddjc_delta2 : 2;
    //
    // DDJC delta for DQ3 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 ddjc_delta3 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL2_RANK_4__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL2_RANK_5__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8D4
typedef union {
  struct {
    //
    // Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdq_dly2 : 11;
    //
    // Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[21:11], RW/V, default = 0x0
    //
    UINT32 txdq_dly3 : 11;
    //
    // DDJC delta for DQ0 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[23:22], RW, default = 0x0
    //
    UINT32 ddjc_delta0 : 2;
    //
    // DDJC delta for DQ1 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINT32 ddjc_delta1 : 2;
    //
    // DDJC delta for DQ2 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINT32 ddjc_delta2 : 2;
    //
    // DDJC delta for DQ3 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 ddjc_delta3 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL2_RANK_5__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL2_RANK_6__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8D8
typedef union {
  struct {
    //
    // Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdq_dly2 : 11;
    //
    // Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[21:11], RW/V, default = 0x0
    //
    UINT32 txdq_dly3 : 11;
    //
    // DDJC delta for DQ0 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[23:22], RW, default = 0x0
    //
    UINT32 ddjc_delta0 : 2;
    //
    // DDJC delta for DQ1 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINT32 ddjc_delta1 : 2;
    //
    // DDJC delta for DQ2 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINT32 ddjc_delta2 : 2;
    //
    // DDJC delta for DQ3 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 ddjc_delta3 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL2_RANK_6__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL2_RANK_7__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8DC
typedef union {
  struct {
    //
    // Write DQ 2 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[10:0], RW/V, default = 0x0
    //
    UINT32 txdq_dly2 : 11;
    //
    // Write DQ 3 delay control. The range is 0 to 16 UI with step size of clkpi/128.[br]
    //                     DDR4 range is < 10UI. (max of 4 logic delay) [br]
    //                     DDR5 range is < 16UI. (max of 7 logic delay) [br]
    //                     This field is added with txdq_dly_adj to allow BIOS for margining
    // sweep (signed numer -128 to 127). It, also, adds with txrt_dq_dly_adj for tx retraning
    // (signed numer -64 to 63).[br] 
    //                     The final delay - [br]
    //                     10:7 - is used for logic delay[br]
    //                     6:0 - The lower 7 bit is added with txdq_piref offset and
    // piref_setup_adj, so the programmed value is relative to the piref clock. The result
    // is the txdq pi odd code. [br] 
    //                     Note: bit 6 (MSB) is inverted before the addition, so the
    // delay see by BIOS is linear.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[21:11], RW/V, default = 0x0
    //
    UINT32 txdq_dly3 : 11;
    //
    // DDJC delta for DQ0 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[23:22], RW, default = 0x0
    //
    UINT32 ddjc_delta0 : 2;
    //
    // DDJC delta for DQ1 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[25:24], RW, default = 0x0
    //
    UINT32 ddjc_delta1 : 2;
    //
    // DDJC delta for DQ2 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[27:26], RW, default = 0x0
    //
    UINT32 ddjc_delta2 : 2;
    //
    // DDJC delta for DQ3 inside the nibble.[br]
    //                     Note: BIOS msut make sure the combine DDJC and PXC delta value
    // doesnt overflow or underflow the analog logic support range. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 ddjc_delta3 : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL2_RANK_7__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_RETRAIN_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8E0
typedef union {
  struct {
    //
    // Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated
    // by tx retraining HW logic. The adjust range is -64 to 63 
    // 
    // Bits[6:0], RO/V, default = 0x0
    //
    UINT32 txrt_dq_dly_adj : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This is the initial MRC training unmatch DRAM reciever delay in PI ticks with
    // 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj
    // for each retraining.[br] 
    //                     Note: The attribte is RW/V to allow SW to write to this field
    // but we don't have any use case yet. 
    // 
    // Bits[17:8], RW/V, default = 0x0
    //
    UINT32 txrt_init_picode : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 12;
    //
    // TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX
    // retraining. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 txrt_en : 1;
    //
    // Selects between the local byte or the adjacent byte to generate the RO count for
    // tx retraining calculation. Used for x16 devices.[br] 
    //                     Note: This control doesn't apply for ECC byte.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 txrt_adj_byte_sel : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_RETRAIN_RANK_0__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_RETRAIN_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8E4
typedef union {
  struct {
    //
    // Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated
    // by tx retraining HW logic. The adjust range is -64 to 63 
    // 
    // Bits[6:0], RO/V, default = 0x0
    //
    UINT32 txrt_dq_dly_adj : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This is the initial MRC training unmatch DRAM reciever delay in PI ticks with
    // 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj
    // for each retraining.[br] 
    //                     Note: The attribte is RW/V to allow SW to write to this field
    // but we don't have any use case yet. 
    // 
    // Bits[17:8], RW/V, default = 0x0
    //
    UINT32 txrt_init_picode : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 12;
    //
    // TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX
    // retraining. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 txrt_en : 1;
    //
    // Selects between the local byte or the adjacent byte to generate the RO count for
    // tx retraining calculation. Used for x16 devices.[br] 
    //                     Note: This control doesn't apply for ECC byte.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 txrt_adj_byte_sel : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_RETRAIN_RANK_1__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_RETRAIN_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8E8
typedef union {
  struct {
    //
    // Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated
    // by tx retraining HW logic. The adjust range is -64 to 63 
    // 
    // Bits[6:0], RO/V, default = 0x0
    //
    UINT32 txrt_dq_dly_adj : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This is the initial MRC training unmatch DRAM reciever delay in PI ticks with
    // 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj
    // for each retraining.[br] 
    //                     Note: The attribte is RW/V to allow SW to write to this field
    // but we don't have any use case yet. 
    // 
    // Bits[17:8], RW/V, default = 0x0
    //
    UINT32 txrt_init_picode : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 12;
    //
    // TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX
    // retraining. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 txrt_en : 1;
    //
    // Selects between the local byte or the adjacent byte to generate the RO count for
    // tx retraining calculation. Used for x16 devices.[br] 
    //                     Note: This control doesn't apply for ECC byte.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 txrt_adj_byte_sel : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_RETRAIN_RANK_2__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_RETRAIN_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8EC
typedef union {
  struct {
    //
    // Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated
    // by tx retraining HW logic. The adjust range is -64 to 63 
    // 
    // Bits[6:0], RO/V, default = 0x0
    //
    UINT32 txrt_dq_dly_adj : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This is the initial MRC training unmatch DRAM reciever delay in PI ticks with
    // 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj
    // for each retraining.[br] 
    //                     Note: The attribte is RW/V to allow SW to write to this field
    // but we don't have any use case yet. 
    // 
    // Bits[17:8], RW/V, default = 0x0
    //
    UINT32 txrt_init_picode : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 12;
    //
    // TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX
    // retraining. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 txrt_en : 1;
    //
    // Selects between the local byte or the adjacent byte to generate the RO count for
    // tx retraining calculation. Used for x16 devices.[br] 
    //                     Note: This control doesn't apply for ECC byte.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 txrt_adj_byte_sel : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_RETRAIN_RANK_3__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_RETRAIN_RANK_4__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8F0
typedef union {
  struct {
    //
    // Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated
    // by tx retraining HW logic. The adjust range is -64 to 63 
    // 
    // Bits[6:0], RO/V, default = 0x0
    //
    UINT32 txrt_dq_dly_adj : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This is the initial MRC training unmatch DRAM reciever delay in PI ticks with
    // 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj
    // for each retraining.[br] 
    //                     Note: The attribte is RW/V to allow SW to write to this field
    // but we don't have any use case yet. 
    // 
    // Bits[17:8], RW/V, default = 0x0
    //
    UINT32 txrt_init_picode : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 12;
    //
    // TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX
    // retraining. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 txrt_en : 1;
    //
    // Selects between the local byte or the adjacent byte to generate the RO count for
    // tx retraining calculation. Used for x16 devices.[br] 
    //                     Note: This control doesn't apply for ECC byte.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 txrt_adj_byte_sel : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_RETRAIN_RANK_4__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_RETRAIN_RANK_5__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8F4
typedef union {
  struct {
    //
    // Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated
    // by tx retraining HW logic. The adjust range is -64 to 63 
    // 
    // Bits[6:0], RO/V, default = 0x0
    //
    UINT32 txrt_dq_dly_adj : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This is the initial MRC training unmatch DRAM reciever delay in PI ticks with
    // 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj
    // for each retraining.[br] 
    //                     Note: The attribte is RW/V to allow SW to write to this field
    // but we don't have any use case yet. 
    // 
    // Bits[17:8], RW/V, default = 0x0
    //
    UINT32 txrt_init_picode : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 12;
    //
    // TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX
    // retraining. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 txrt_en : 1;
    //
    // Selects between the local byte or the adjacent byte to generate the RO count for
    // tx retraining calculation. Used for x16 devices.[br] 
    //                     Note: This control doesn't apply for ECC byte.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 txrt_adj_byte_sel : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_RETRAIN_RANK_5__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_RETRAIN_RANK_6__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8F8
typedef union {
  struct {
    //
    // Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated
    // by tx retraining HW logic. The adjust range is -64 to 63 
    // 
    // Bits[6:0], RO/V, default = 0x0
    //
    UINT32 txrt_dq_dly_adj : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This is the initial MRC training unmatch DRAM reciever delay in PI ticks with
    // 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj
    // for each retraining.[br] 
    //                     Note: The attribte is RW/V to allow SW to write to this field
    // but we don't have any use case yet. 
    // 
    // Bits[17:8], RW/V, default = 0x0
    //
    UINT32 txrt_init_picode : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 12;
    //
    // TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX
    // retraining. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 txrt_en : 1;
    //
    // Selects between the local byte or the adjacent byte to generate the RO count for
    // tx retraining calculation. Used for x16 devices.[br] 
    //                     Note: This control doesn't apply for ECC byte.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 txrt_adj_byte_sel : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_RETRAIN_RANK_6__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_RETRAIN_RANK_7__DDRD0_N0_CHALL_DDRD0_N0_MEM_REG_DDR 0x0001B8FC
typedef union {
  struct {
    //
    // Tx Retraining DQ delay adjust value for all the DQ bits. This field is updated
    // by tx retraining HW logic. The adjust range is -64 to 63 
    // 
    // Bits[6:0], RO/V, default = 0x0
    //
    UINT32 txrt_dq_dly_adj : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // This is the initial MRC training unmatch DRAM reciever delay in PI ticks with
    // 1 fractional bit (bit 0). It is used by HW logic to calculate the txrt_dq_dly_adj
    // for each retraining.[br] 
    //                     Note: The attribte is RW/V to allow SW to write to this field
    // but we don't have any use case yet. 
    // 
    // Bits[17:8], RW/V, default = 0x0
    //
    UINT32 txrt_init_picode : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 12;
    //
    // TX retrain enable. It should be set for DDR5 and not LRDIMM type to enable TX
    // retraining. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 txrt_en : 1;
    //
    // Selects between the local byte or the adjacent byte to generate the RO count for
    // tx retraining calculation. Used for x16 devices.[br] 
    //                     Note: This control doesn't apply for ECC byte.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 txrt_adj_byte_sel : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_RETRAIN_RANK_7__DDRD0_N0_CHALL_DDRD0_N0_MEM_STRUCT_DDR;


#endif // _MMRCDDRD0_N0_CHALL_DDRD0_N0_MEM_DDR_H_DDR_
