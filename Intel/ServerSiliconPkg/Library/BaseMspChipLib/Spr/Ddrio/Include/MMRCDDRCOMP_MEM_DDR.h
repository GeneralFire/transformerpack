/** @file
  File name:    MMRCDDRCOMP_MEM_DDR.h
  Input File:   SPR_MRC_DDR.xlsx
  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.
  If edits are needed in this file, they must be done via the MSP tool.
  If there is additional project-specific data required by the MSP, it
  can be placed in MMRCDDRCOMP_MEM_DDR.h, which is used for non-tool-generated
  data
  Includes register defines specific to a project.

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2005 - 2020 Intel Corporation. <BR>

  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.

  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.

  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
**/

#ifndef _MMRCDDRCOMP_MEM_DDR_H_DDR_
#define _MMRCDDRCOMP_MEM_DDR_H_DDR_

#include "MspDataTypes.h"

#define DDRCOMP_DATA_COMP0_DDRCOMP_MEM_REG_DDR             0x00017F00
typedef union {
  struct {
    //
    // Sets the resistive value (aka driving strength) of the pull-up block of the DQ/DQS
    // transmitter. When [br] 
    //                     dq_drv_up_ovr_en = 1, drive strength value is programmed by
    // software[br] 
    //                     dq_drv_up_ovr_en = 0, drive strength value is computed by
    // Comp FSM 
    // 
    // Bits[4:0], RW/V, default = 0x8
    //
    UINT32 rcomp_drv_up : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
    //
    // Sets the resistive value (aka driving strength) of the pull-down block of the
    // DQ/DQS transmitter. When [br] 
    //                     dq_drv_dn_ovr_en = 1, drive strength value is programmed by
    // software[br] 
    //                     dq_drv_dn_ovr_en = 0, drive strength value is computed by
    // Comp FSM  
    // 
    // Bits[11:7], RW/V, default = 0x8
    //
    UINT32 rcomp_drv_dn : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:12], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Sets the resistive value of the pull-up block of DQ On die termination.When [br]
    //                     dq_odt_up_ovr_en = 1, ODT value is programmed by software[br]
    //                     dq_odt_up_ovr_en = 0, ODT value is computed by Comp FSM 
    // 
    // Bits[18:14], RW/V, default = 0x0
    //
    UINT32 rcomp_odt_up : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:19], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 2;
    //
    // Sets the resistive value of the pull-dn block of DQ On die termination. When [br]
    //                     dq_odt_dn_ovr_en = 1, ODT value is programmed by software
    // [br] 
    //                     dq_odt_dn_ovr_en = 0, ODT value is computed by Comp FSM 
    // 
    // Bits[25:21], RW/V, default = 0x0
    //
    UINT32 rcomp_odt_dn : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:26], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 6;
  } Bits;
  UINT32 Data;
} DDRCOMP_DATA_COMP0_DDRCOMP_MEM_STRUCT_DDR;

#define DDRCOMP_CMD_COMP0_DDRCOMP_MEM_REG_DDR              0x00017F04
typedef union {
  struct {
    //
    // Sets the resistive value (aka driving strength) of the pull-Up block of the CMD
    // transmitter. When[br] 
    //                     cmd_drv_up_ovr_en = 1, drive strength value is programmed
    // by software[br] 
    //                     cmd_drv_up_ovr_en = 0, drive strength value is computed by
    // Comp FSM.[br]  
    //                     Note: CMD transmitter uses rcomp codes for ODT codes too.
    // 
    // Bits[4:0], RW/V, default = 0x0
    //
    UINT32 rcomp_drv_up : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
    //
    // Sets the resistive value (aka driving strength) of the pull-down block of the
    // CMD transmitter. When[br] 
    //                     cmd_drv_dn_ovr_en = 1, drive strength value is programmed
    // by software[br]  
    //                     cmd_drv_dn_ovr_en = 0, drive strength value is computed by
    // Comp FSM.[br] 
    //                     Note: CMD transmitter uses rcomp codes for ODT codes too.
    // 
    // Bits[11:7], RW/V, default = 0x0
    //
    UINT32 rcomp_drv_dn : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:12], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 20;
  } Bits;
  UINT32 Data;
} DDRCOMP_CMD_COMP0_DDRCOMP_MEM_STRUCT_DDR;

#define DDRCOMP_CLK_COMP0_DDRCOMP_MEM_REG_DDR              0x00017F08
typedef union {
  struct {
    //
    // Sets the resistive value (aka driving strength) of the pull-Up block of the CLK
    // transmitter. When[br] 
    //                     clk_drv_up_ovr_en = 1, drive strength value is programmed
    // by software[br] 
    //                     clk_drv_up_ovr_en = 0, drive strength value is computed by
    // Comp FSM 
    // 
    // Bits[4:0], RW/V, default = 0x0
    //
    UINT32 rcomp_drv_up : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
    //
    // Sets the resistive value (aka driving strength) of the pull-down block of the
    // CLK transmitter. When[br] 
    //                     clk_drv_dn_ovr_en = 1, drive strength value is programmed
    // by software[br] 
    //                     clk_drv_dn_ovr_en = 0, drive strength value is computed by
    // CompFSM 
    // 
    // Bits[11:7], RW/V, default = 0x0
    //
    UINT32 rcomp_drv_dn : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:12], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 20;
  } Bits;
  UINT32 Data;
} DDRCOMP_CLK_COMP0_DDRCOMP_MEM_STRUCT_DDR;

#define DDRCOMP_DQ_VREF_CTL_DDRCOMP_MEM_REG_DDR            0x00017F0C
typedef union {
  struct {
    //
    // DqRcompDrvUp Vref with step size of Vccddr_hv/256
    // 
    // Bits[6:0], RW, default = 0x4D
    //
    UINT32 dq_drv_pup_vref : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // DqRcompDrvDown Vref with step size of Vccddr_hv/256
    // 
    // Bits[14:8], RW, default = 0x40
    //
    UINT32 dq_drv_pdn_vref : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // DqOdtcompDrvUp Vref with step size of Vccddr_hv/256
    // 
    // Bits[22:16], RW, default = 0x40
    //
    UINT32 dq_odt_pup_vref : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:23], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // DqOdtRcompDrvDown Vref with step size of Vccddr_hv/256
    // 
    // Bits[30:24], RW, default = 0x40
    //
    UINT32 dq_odt_pdn_vref : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
  } Bits;
  UINT32 Data;
} DDRCOMP_DQ_VREF_CTL_DDRCOMP_MEM_STRUCT_DDR;

#define DDRCOMP_CMD_VREF_CTL_DDRCOMP_MEM_REG_DDR           0x00017F10
typedef union {
  struct {
    //
    // CmdRcompDrvUp Vref with step size of Vccddr_hv/256
    // 
    // Bits[6:0], RW, default = 0x50
    //
    UINT32 cmd_drv_pup_vref : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // CmdRcompDrvDown Vref with step size of Vccddr_hv/256
    // 
    // Bits[14:8], RW, default = 0x40
    //
    UINT32 cmd_drv_pdn_vref : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 17;
  } Bits;
  UINT32 Data;
} DDRCOMP_CMD_VREF_CTL_DDRCOMP_MEM_STRUCT_DDR;

#define DDRCOMP_CLK_VREF_CTL_DDRCOMP_MEM_REG_DDR           0x00017F14
typedef union {
  struct {
    //
    // ClkRcompDrvUp Vref with step size of Vccddr_hv/256
    // 
    // Bits[6:0], RW, default = 0x4D
    //
    UINT32 clk_drv_pup_vref : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // ClkRcompDrvDown Vref with step size of Vccddr_hv/256
    // 
    // Bits[14:8], RW, default = 0x40
    //
    UINT32 clk_drv_pdn_vref : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 17;
  } Bits;
  UINT32 Data;
} DDRCOMP_CLK_VREF_CTL_DDRCOMP_MEM_STRUCT_DDR;

#define DDRCOMP_STATIC_LEG_CTL0_DDRCOMP_MEM_REG_DDR        0x00017F18
typedef union {
  struct {
    //
    // DQ Comp Loop Staic Leg Control value for data comp.[br]
    //                     Sets number of DRV static legs.  First 3 MSB bits have weight
    // of 4[br] 
    //                     4th MSB has weight of 2 and LSB has weight of 1.[br]
    //                     Default of 0x1F has 15 static legs enabled.[br]
    //                     Static leg training starts with 0x1F (all 15 legs enabled)
    // 
    // Bits[4:0], RW, default = 0x1F
    //
    UINT32 txdq_static_leg_ctl : 5;
    //
    // Command Static Leg value used for cmd comp[br]
    //                     Sets number of DRV static legs.  First 3 MSB bits have weight
    // of 4[br] 
    //                     4th MSB has weight of 2 and LSB has weight of 1.[br]
    //                     Default of 0x1F has 15 static legs enabled.[br]
    //                     Static leg training starts with 0x1F (all 15 legs enabled)
    // 
    // Bits[9:5], RW, default = 0x1F
    //
    UINT32 cmd_static_leg_ctl : 5;
    //
    // Clock Static Leg value used for CLK comp[br]
    //                     Sets number of DRV static legs.  First 3 MSB bits have weight
    // of 4[br] 
    //                     4th MSB has weight of 2 and LSB has weight of 1.[br]
    //                     Default of 0x1F has 15 static legs enabled.[br]
    //                     Static leg training starts with 0x1F (all 15 legs enabled)
    // 
    // Bits[14:10], RW, default = 0x1F
    //
    UINT32 clk_static_leg_ctl : 5;
    //
    // ODT static leg value used for ODT comp[br]
    //                     Sets number of ODT static legs.  First 3 MSB bits have weight
    // of 4[br] 
    //                     4th MSB has weight of 2 and LSB has weight of 1.[br]
    //                     Default of 0x1F has 15 static legs enabled.[br]
    //                     Static leg training starts with 0x1F (all 15 legs enabled)
    // 
    // Bits[19:15], RW, default = 0x1F
    //
    UINT32 odt_static_leg_ctl : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 12;
  } Bits;
  UINT32 Data;
} DDRCOMP_STATIC_LEG_CTL0_DDRCOMP_MEM_STRUCT_DDR;

#define DDRCOMP_SEG_OVR_CTL0_DDRCOMP_MEM_REG_DDR           0x00017F1C
typedef union {
  struct {
    //
    // Dq segment Override Enable
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 dq_seg_ovr_en : 1;
    //
    // Dq Odt Segment Override Enable
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 odt_seg_ovr_en : 1;
    //
    // Cmd Segment Override Enable
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 cmd_seg_ovr_en : 1;
    //
    // Clk Segment Override
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 clk_seg_ovr_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:4], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 4;
    //
    // when dq_seg_ovr_en = 0, Dq Up segment Enable value = 1;[br] 
    //                     dq_seg_ovr_en = 1, Override value
    // 
    // Bits[9:8], RW, default = 0x3
    //
    UINT32 dq_up_seg_ovr_value : 2;
    //
    // when dq_seg_ovr_en = 0, Dq down segment Enable value = 1;[br]
    //                     dq_seg_ovr_en = 1, Override value
    // 
    // Bits[11:10], RW, default = 0x3
    //
    UINT32 dq_dn_seg_ovr_value : 2;
    //
    // when odt_seg_ovr_en = 0, Odt Up segment Enable value = 1;[br]
    //                     odt_seg_ovr_en = 1, Override value
    // 
    // Bits[13:12], RW, default = 0x1
    //
    UINT32 odt_up_seg_ovr_value : 2;
    //
    // when odt_seg_ovr_en = 0, Odt down segment Enable value = 1;[br]
    //                     odt_seg_ovr_en = 1, Override value
    // 
    // Bits[15:14], RW, default = 0x1
    //
    UINT32 odt_dn_seg_ovr_value : 2;
    //
    // when cmd_seg_ovr_en = 0, Cmd Up segment Enable value = 1;[br]
    //                     cmd_seg_ovr_en = 1, Override value
    // 
    // Bits[17:16], RW, default = 0x1
    //
    UINT32 cmd_up_seg_ovr_value : 2;
    //
    // when cmd_seg_ovr_en = 0, Cmd down segment Enable value = 1;[br]
    //                     cmd_seg_ovr_en = 1, Override value
    // 
    // Bits[19:18], RW, default = 0x1
    //
    UINT32 cmd_dn_seg_ovr_value : 2;
    //
    // when clk_seg_ovr_en= 0; Clk Up segment Enable value = 1;[br]
    //                     clk_seg_ovr_en = 1, Override value
    // 
    // Bits[21:20], RW, default = 0x1
    //
    UINT32 clk_up_seg_ovr_value : 2;
    //
    // when clk_seg_ovr_en = 0; Clk down segment Enable value = 1;[br]
    //                     clk_seg_ovr_en = 1, Override value
    // 
    // Bits[23:22], RW, default = 0x1
    //
    UINT32 clk_dn_seg_ovr_value : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 8;
  } Bits;
  UINT32 Data;
} DDRCOMP_SEG_OVR_CTL0_DDRCOMP_MEM_STRUCT_DDR;

#define DDRCOMP_DRV_OVR_CTL0_DDRCOMP_MEM_REG_DDR           0x00017F20
typedef union {
  struct {
    //
    // Override enable for Data Rcomp DriveUp Value
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 dq_drv_up_ovr_en : 1;
    //
    // Override enable for Data Rcomp DriveDn Value
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 dq_drv_dn_ovr_en : 1;
    //
    // Override enable for Data Rcomp OdtUp Value
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 dq_odt_up_ovr_en : 1;
    //
    // Override enable for Data Rcomp OdtDn Value
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 dq_odt_dn_ovr_en : 1;
    //
    // Override enable for Cmd Rcomp DriveUp Value
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 cmd_drv_up_ovr_en : 1;
    //
    // Override enable for Cmd Rcomp DriveDn Value
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINT32 cmd_drv_dn_ovr_en : 1;
    //
    // Override enable for Clk Rcomp DriveUp Value
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 clk_drv_up_ovr_en : 1;
    //
    // Override enable for Clk Rcomp DriveDn value
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 clk_drv_dn_ovr_en : 1;
    //
    // Used to drive ViewDig DriveEnable
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // DQS Comp Override
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINT32 dqscomp_ovr_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:10], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 22;
  } Bits;
  UINT32 Data;
} DDRCOMP_DRV_OVR_CTL0_DDRCOMP_MEM_STRUCT_DDR;

#define DDRCOMP_CTL0_DDRCOMP_MEM_REG_DDR                   0x00017F24
typedef union {
  struct {
    //
    // Set to 1 to enable HW to gate DCLK. Default is disable clock gating.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 dclk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate CSR CLK. Default is disable clock gating. [br]
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 csr_clk_gate_en : 1;
    //
    // Enable single step through the Main FSM for debug
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Advance the Main comp FSM by a single step for debug. HW auto clears this bit
    // to 0. Read to this bit always return 0 
    // 
    // Bits[3:3], RW/V, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // when rcomp_dfx_mode =0; switch cap comparator clock= fsm_clk; rcomp_dfx_mode=1;
    // switch cap comparator clock= fsm_clk/3 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 rcomp_dfx_mode : 1;
    //
    // Force ODT on used in dq/clk/cmd rcomp AIP for debug purpose.  Sets the pull down
    // segment as inverted pull up. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINT32 force_odt_on : 1;
    //
    // Extend the FSM bubble timer by.[br]
    //                     0 - 1x Default [br]
    //                     1 - 1.5x [br]
    //                     2 - 2x [br]
    //                     3 - 2.5
    // 
    // Bits[7:6], RW, default = 0x0
    //
    UINT32 bubble_tmr_ext : 2;
    //
    // 0: reset = 1 cycle, PreCharge = 1, cycle, evaluate = 1 cycle[br]
    //                     1: reset = 2 cycle, PreCharge = 2, cycle, evaluate = 1 cycle[br]
    //  
    //                     2: reset = 3 cycle, PreCharge = 3, cycle, evaluate = 1 cycle[br]
    //                     3: Reserved
    // 
    // Bits[9:8], RW, default = 0x2
    //
    UINT32 sw_cap_cmp_clk_sel : 2;
    //
    // Set to 1 to enable cbb clk gating during bubble state.
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINT32 bubble_cbb_clk_gate_en : 1;
    //
    // Changes the number of samples dropped during the binary FSM eval state. Setting
    // this bit increases the number of dropped samples from 14 to 256 for RCOMP and
    // from 7 to 14 for RXDQSCOMP 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINT32 eval_sample_x2 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:12], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 4;
    //
    // Offset between DqOdt Up and Down when fix OdtDn enable is set. Unused in wave3
    // 
    // Bits[21:16], RW, default = 0x0
    //
    UINT32 dq_odt_up_dn_offset : 6;
    //
    // Set to 1 to force both comp's vref enable to 1, regardless of the comp main fsm
    // state 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINT32 force_comp_vref_en : 1;
    //
    // Skip DqRcomOdtDn compensation and use [br]
    //                     DqOdtDn = ddrcomp_data_comp0.rcomp_odt_up + dq_odt_up_dn_offset.
    //                     Unused in wave3
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 fix_odt_dn : 1;
    //
    // software de-asserts o_reset_n_ddr_pad_hv by toggling (1 -> 0 ->1 ) this CR field
    //  
    // 
    // Bits[24:24], RW, default = 0x1
    //
    UINT32 dram_rst_n : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:25], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 6;
    //
    // Set to 1 to enable MC view inputs to ddrio view pins
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 reserved_2 : 1;
  } Bits;
  UINT32 Data;
} DDRCOMP_CTL0_DDRCOMP_MEM_STRUCT_DDR;

#define DDRCOMP_DIMM_VREF_CTL0_DDRCOMP_MEM_REG_DDR         0x00017F28
typedef union {
  struct {
    //
    // CH0 DIMM Vref Control.[br]
    //                     For 10nm Vref Gen step size is Vccddr_hv/256 and valid range
    // for DimmVref is Vccddr_hv/3  2*Vccddr_hv/3. The target code to vref decoding:
    // Vref = VrefCtrl*Vccddr_hv/256 
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINT32 ch0_dimm_vref_ctl : 8;
    //
    // CH1 DIMM Vref Control.[br]
    //                     For 10nm Vref Gen step size is Vccddr_hv/256 and valid range
    // for DimmVref is Vccddr_hv/3  2*Vccddr_hv/3. The target code to vref decoding:
    // Vref = VrefCtrl*Vccddr_hv/256 
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINT32 ch1_dimm_vref_ctl : 8;
    //
    // Current control for channel 0 DIMM Vref
    // 
    // Bits[17:16], RW, default = 0x1
    //
    UINT32 ch0_vref_bias_ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Current control for channel 1 DIMM Vref
    // 
    // Bits[20:19], RW, default = 0x1
    //
    UINT32 ch1_vref_bias_ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[21:21], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Enables Ch0 DIMM Vref
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINT32 ch0_dimm_vref_en : 1;
    //
    // Enables Ch1 DIMM Vref
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 ch1_dimm_vref_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 8;
  } Bits;
  UINT32 Data;
} DDRCOMP_DIMM_VREF_CTL0_DDRCOMP_MEM_STRUCT_DDR;

#define DDRCOMP_RX_RETRAIN0_DDRCOMP_MEM_REG_DDR            0x00017F2C
typedef union {
  struct {
    //
    // Set to 1 to indicate this is the 1st retraining to initialize the rxrt_init_picode.
    // HW will not calculate and apply the rxrt_dqs_dly_adj. Once HW finish the initialization,
    // it clears this bit. 
    // 
    // Bits[0:0], RW/V, default = 0x0
    //
    UINT32 rxrt_init : 1;
    //
    // HW only auto train the RxDqs logic path after prim reset deassertion. For debug
    // purpose, SW can set this bit to enable logic path training. HW clear this bit
    // after logic path training is completed. 
    // 
    // Bits[1:1], RW/V, default = 0x0
    //
    UINT32 logicpath_train_en : 1;
    //
    // Rx Retraining DQS delay adjust value for DQS N and P. This field is calcuated
    // by DDRCOMP fub and broadcast to all the data fub.  The adjust range is -64 to
    // 63. 
    // 
    // Bits[8:2], RW/V, default = 0x0
    //
    UINT32 rxrt_dqs_dly_adj : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Set this to 100 for 1 DCLK delay. 010 for 2 DCLK delay and 001 for 3 DCLK delay
    // 
    // Bits[12:10], RW/V, default = 0x4
    //
    UINT32 rxrt_logic_delay : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // This is the initial RX training unmatch reciever delay in PI ticks. It is used
    // by HW logic to calculate the rxrt_dqs_dly_adj for each retraining.[br] 
    //                     Note: The attribte is RW/V to allow SW to write to this field
    // but we don't have any use case yet. 
    // 
    // Bits[21:14], RW/V, default = 0x0
    //
    UINT32 rxrt_init_picode : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[22:22], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // pbias current mirror for the 2nd stage amplifier in the DQS COMP CBB. Adjusts
    // the bias current. 0=min, 7=max. 
    // 
    // Bits[25:23], RW, default = 0x0
    //
    UINT32 pbias_stg2amp_trim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:26], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // 00 - 1.5x (default for CMD/CLK)[br]
    //                     01 - 2x[br]
    //                     10 - 2.5x (default for DQ)[br]
    //                     11 - 3x
    // 
    // Bits[28:27], RW, default = 0x1
    //
    UINT32 rxdqscomp_rxgain_ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:29], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 2;
    //
    // Set to 1 to enable Rx DQS retraining
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 rxrt_en : 1;
  } Bits;
  UINT32 Data;
} DDRCOMP_RX_RETRAIN0_DDRCOMP_MEM_STRUCT_DDR;

#define DDRCOMP_RX_RETRAIN1_DDRCOMP_MEM_REG_DDR            0x00017F30
typedef union {
  struct {
    //
    // Rx Retrain logic path training PI code starting value
    // 
    // Bits[7:0], RW, default = 0x18
    //
    UINT32 rxrt_logic_path_train_picode : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:8], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 24;
  } Bits;
  UINT32 Data;
} DDRCOMP_RX_RETRAIN1_DDRCOMP_MEM_STRUCT_DDR;

#define DDRCOMP_VIEW_COMP0_DDRCOMP_MEM_REG_DDR             0x00017F34
typedef union {
  struct {
    //
    // Slew Rate comp up code fro view transmitter
    // 
    // Bits[4:0], RW, default = 0x0
    //
    UINT32 reserved : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Slew Rate comp down code fro view transmitter
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 reserved_1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 21;
  } Bits;
  UINT32 Data;
} DDRCOMP_VIEW_COMP0_DDRCOMP_MEM_STRUCT_DDR;


#endif // _MMRCDDRCOMP_MEM_DDR_H_DDR_
