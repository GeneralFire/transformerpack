/** @file
  File name:    MMRCDDRD1_N0_CH0_DDRD1_N0_MEM_DDR.h
  Input File:   SPR_MRC_DDR.xlsx
  THIS FILE IS AUTO-GENERATED BY THE MSP TOOL. DO NOT CHANGE THIS CODE.
  If edits are needed in this file, they must be done via the MSP tool.
  If there is additional project-specific data required by the MSP, it
  can be placed in MMRCDDRD1_N0_CH0_DDRD1_N0_MEM_DDR.h, which is used for non-tool-generated
  data
  Includes register defines specific to a project.

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2005 - 2020 Intel Corporation. <BR>

  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.

  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.

  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
**/

#ifndef _MMRCDDRD1_N0_CH0_DDRD1_N0_MEM_DDR_H_DDR_
#define _MMRCDDRD1_N0_CH0_DDRD1_N0_MEM_DDR_H_DDR_

#include "MspDataTypes.h"

#define DDRD_N0_TXDQ_PIE_OFFSET_RANK_0__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B100
typedef union {
  struct {
    //
    // This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code
    // (txdq_pie_code0) to DLL.. Default value is 64. 
    // 
    // Bits[6:0], RW, default = 0x40
    //
    UINT32 txdq_pie_offset0 : 7;
    //
    // This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code
    // (txdq_pie_code1) to DLL.. Default value is 64. 
    // 
    // Bits[13:7], RW, default = 0x40
    //
    UINT32 txdq_pie_offset1 : 7;
    //
    // This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code
    // (txdq_pie_code2) to DLL.. Default value is 64. 
    // 
    // Bits[20:14], RW, default = 0x40
    //
    UINT32 txdq_pie_offset2 : 7;
    //
    // This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code
    // (txdq_pie_code3) to DLL.. Default value is 64. 
    // 
    // Bits[27:21], RW, default = 0x40
    //
    UINT32 txdq_pie_offset3 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // x8 device enable
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 x8_device : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TXDQ_PIE_OFFSET_RANK_0__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TXDQ_PIE_OFFSET_RANK_1__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B104
typedef union {
  struct {
    //
    // This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code
    // (txdq_pie_code0) to DLL.. Default value is 64. 
    // 
    // Bits[6:0], RW, default = 0x40
    //
    UINT32 txdq_pie_offset0 : 7;
    //
    // This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code
    // (txdq_pie_code1) to DLL.. Default value is 64. 
    // 
    // Bits[13:7], RW, default = 0x40
    //
    UINT32 txdq_pie_offset1 : 7;
    //
    // This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code
    // (txdq_pie_code2) to DLL.. Default value is 64. 
    // 
    // Bits[20:14], RW, default = 0x40
    //
    UINT32 txdq_pie_offset2 : 7;
    //
    // This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code
    // (txdq_pie_code3) to DLL.. Default value is 64. 
    // 
    // Bits[27:21], RW, default = 0x40
    //
    UINT32 txdq_pie_offset3 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // x8 device enable
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 x8_device : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TXDQ_PIE_OFFSET_RANK_1__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TXDQ_PIE_OFFSET_RANK_2__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B108
typedef union {
  struct {
    //
    // This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code
    // (txdq_pie_code0) to DLL.. Default value is 64. 
    // 
    // Bits[6:0], RW, default = 0x40
    //
    UINT32 txdq_pie_offset0 : 7;
    //
    // This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code
    // (txdq_pie_code1) to DLL.. Default value is 64. 
    // 
    // Bits[13:7], RW, default = 0x40
    //
    UINT32 txdq_pie_offset1 : 7;
    //
    // This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code
    // (txdq_pie_code2) to DLL.. Default value is 64. 
    // 
    // Bits[20:14], RW, default = 0x40
    //
    UINT32 txdq_pie_offset2 : 7;
    //
    // This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code
    // (txdq_pie_code3) to DLL.. Default value is 64. 
    // 
    // Bits[27:21], RW, default = 0x40
    //
    UINT32 txdq_pie_offset3 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // x8 device enable
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 x8_device : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TXDQ_PIE_OFFSET_RANK_2__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TXDQ_PIE_OFFSET_RANK_3__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B10C
typedef union {
  struct {
    //
    // This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code
    // (txdq_pie_code0) to DLL.. Default value is 64. 
    // 
    // Bits[6:0], RW, default = 0x40
    //
    UINT32 txdq_pie_offset0 : 7;
    //
    // This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code
    // (txdq_pie_code1) to DLL.. Default value is 64. 
    // 
    // Bits[13:7], RW, default = 0x40
    //
    UINT32 txdq_pie_offset1 : 7;
    //
    // This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code
    // (txdq_pie_code2) to DLL.. Default value is 64. 
    // 
    // Bits[20:14], RW, default = 0x40
    //
    UINT32 txdq_pie_offset2 : 7;
    //
    // This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code
    // (txdq_pie_code3) to DLL.. Default value is 64. 
    // 
    // Bits[27:21], RW, default = 0x40
    //
    UINT32 txdq_pie_offset3 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // x8 device enable
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 x8_device : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TXDQ_PIE_OFFSET_RANK_3__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TXDQ_PIE_OFFSET_RANK_4__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B110
typedef union {
  struct {
    //
    // This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code
    // (txdq_pie_code0) to DLL.. Default value is 64. 
    // 
    // Bits[6:0], RW, default = 0x40
    //
    UINT32 txdq_pie_offset0 : 7;
    //
    // This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code
    // (txdq_pie_code1) to DLL.. Default value is 64. 
    // 
    // Bits[13:7], RW, default = 0x40
    //
    UINT32 txdq_pie_offset1 : 7;
    //
    // This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code
    // (txdq_pie_code2) to DLL.. Default value is 64. 
    // 
    // Bits[20:14], RW, default = 0x40
    //
    UINT32 txdq_pie_offset2 : 7;
    //
    // This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code
    // (txdq_pie_code3) to DLL.. Default value is 64. 
    // 
    // Bits[27:21], RW, default = 0x40
    //
    UINT32 txdq_pie_offset3 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // x8 device enable
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 x8_device : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TXDQ_PIE_OFFSET_RANK_4__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TXDQ_PIE_OFFSET_RANK_5__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B114
typedef union {
  struct {
    //
    // This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code
    // (txdq_pie_code0) to DLL.. Default value is 64. 
    // 
    // Bits[6:0], RW, default = 0x40
    //
    UINT32 txdq_pie_offset0 : 7;
    //
    // This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code
    // (txdq_pie_code1) to DLL.. Default value is 64. 
    // 
    // Bits[13:7], RW, default = 0x40
    //
    UINT32 txdq_pie_offset1 : 7;
    //
    // This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code
    // (txdq_pie_code2) to DLL.. Default value is 64. 
    // 
    // Bits[20:14], RW, default = 0x40
    //
    UINT32 txdq_pie_offset2 : 7;
    //
    // This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code
    // (txdq_pie_code3) to DLL.. Default value is 64. 
    // 
    // Bits[27:21], RW, default = 0x40
    //
    UINT32 txdq_pie_offset3 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // x8 device enable
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 x8_device : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TXDQ_PIE_OFFSET_RANK_5__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TXDQ_PIE_OFFSET_RANK_6__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B118
typedef union {
  struct {
    //
    // This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code
    // (txdq_pie_code0) to DLL.. Default value is 64. 
    // 
    // Bits[6:0], RW, default = 0x40
    //
    UINT32 txdq_pie_offset0 : 7;
    //
    // This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code
    // (txdq_pie_code1) to DLL.. Default value is 64. 
    // 
    // Bits[13:7], RW, default = 0x40
    //
    UINT32 txdq_pie_offset1 : 7;
    //
    // This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code
    // (txdq_pie_code2) to DLL.. Default value is 64. 
    // 
    // Bits[20:14], RW, default = 0x40
    //
    UINT32 txdq_pie_offset2 : 7;
    //
    // This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code
    // (txdq_pie_code3) to DLL.. Default value is 64. 
    // 
    // Bits[27:21], RW, default = 0x40
    //
    UINT32 txdq_pie_offset3 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // x8 device enable
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 x8_device : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TXDQ_PIE_OFFSET_RANK_6__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TXDQ_PIE_OFFSET_RANK_7__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B11C
typedef union {
  struct {
    //
    // This offset is add to the txdq_pio_code0. The result is the txdq0 pi even code
    // (txdq_pie_code0) to DLL.. Default value is 64. 
    // 
    // Bits[6:0], RW, default = 0x40
    //
    UINT32 txdq_pie_offset0 : 7;
    //
    // This offset is add to the txdq_pio_code1. The result is the txdq1 pi even code
    // (txdq_pie_code1) to DLL.. Default value is 64. 
    // 
    // Bits[13:7], RW, default = 0x40
    //
    UINT32 txdq_pie_offset1 : 7;
    //
    // This offset is add to the txdq_pio_code2. The result is the txdq2 pi even code
    // (txdq_pie_code2) to DLL.. Default value is 64. 
    // 
    // Bits[20:14], RW, default = 0x40
    //
    UINT32 txdq_pie_offset2 : 7;
    //
    // This offset is add to the txdq_pio_code3. The result is the txdq3 pi even code
    // (txdq_pie_code3) to DLL.. Default value is 64. 
    // 
    // Bits[27:21], RW, default = 0x40
    //
    UINT32 txdq_pie_offset3 : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // x8 device enable
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 x8_device : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TXDQ_PIE_OFFSET_RANK_7__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_SA_OFFSET_RANK_0__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B120
typedef union {
  struct {
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1E
    //
    UINT32 sa_offset0 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[12:7], RW/V, default = 0x1E
    //
    UINT32 sa_offset1 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[19:14], RW/V, default = 0x1E
    //
    UINT32 sa_offset2 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset,
    // 60=max -ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[26:21], RW/V, default = 0x1E
    //
    UINT32 sa_offset3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // selects which skewed DQS P for post receive enable counter clock in the RX Deskew
    // logic. For proper operation, always pick latest DQS P. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 rxdqsp_sel : 2;
    //
    // selects which skewed DQS N for post receive enable counter clock in the RX Deskew
    // logic. For proper operation, always pick latest DQS N. 
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 rxdqsn_sel : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_SA_OFFSET_RANK_0__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_SA_OFFSET_RANK_1__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B124
typedef union {
  struct {
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1E
    //
    UINT32 sa_offset0 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[12:7], RW/V, default = 0x1E
    //
    UINT32 sa_offset1 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[19:14], RW/V, default = 0x1E
    //
    UINT32 sa_offset2 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset,
    // 60=max -ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[26:21], RW/V, default = 0x1E
    //
    UINT32 sa_offset3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // selects which skewed DQS P for post receive enable counter clock in the RX Deskew
    // logic. For proper operation, always pick latest DQS P. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 rxdqsp_sel : 2;
    //
    // selects which skewed DQS N for post receive enable counter clock in the RX Deskew
    // logic. For proper operation, always pick latest DQS N. 
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 rxdqsn_sel : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_SA_OFFSET_RANK_1__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_SA_OFFSET_RANK_2__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B128
typedef union {
  struct {
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1E
    //
    UINT32 sa_offset0 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[12:7], RW/V, default = 0x1E
    //
    UINT32 sa_offset1 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[19:14], RW/V, default = 0x1E
    //
    UINT32 sa_offset2 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset,
    // 60=max -ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[26:21], RW/V, default = 0x1E
    //
    UINT32 sa_offset3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // selects which skewed DQS P for post receive enable counter clock in the RX Deskew
    // logic. For proper operation, always pick latest DQS P. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 rxdqsp_sel : 2;
    //
    // selects which skewed DQS N for post receive enable counter clock in the RX Deskew
    // logic. For proper operation, always pick latest DQS N. 
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 rxdqsn_sel : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_SA_OFFSET_RANK_2__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_SA_OFFSET_RANK_3__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B12C
typedef union {
  struct {
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1E
    //
    UINT32 sa_offset0 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[12:7], RW/V, default = 0x1E
    //
    UINT32 sa_offset1 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[19:14], RW/V, default = 0x1E
    //
    UINT32 sa_offset2 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset,
    // 60=max -ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[26:21], RW/V, default = 0x1E
    //
    UINT32 sa_offset3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // selects which skewed DQS P for post receive enable counter clock in the RX Deskew
    // logic. For proper operation, always pick latest DQS P. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 rxdqsp_sel : 2;
    //
    // selects which skewed DQS N for post receive enable counter clock in the RX Deskew
    // logic. For proper operation, always pick latest DQS N. 
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 rxdqsn_sel : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_SA_OFFSET_RANK_3__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_SA_OFFSET_RANK_4__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B130
typedef union {
  struct {
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1E
    //
    UINT32 sa_offset0 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[12:7], RW/V, default = 0x1E
    //
    UINT32 sa_offset1 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[19:14], RW/V, default = 0x1E
    //
    UINT32 sa_offset2 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset,
    // 60=max -ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[26:21], RW/V, default = 0x1E
    //
    UINT32 sa_offset3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // selects which skewed DQS P for post receive enable counter clock in the RX Deskew
    // logic. For proper operation, always pick latest DQS P. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 rxdqsp_sel : 2;
    //
    // selects which skewed DQS N for post receive enable counter clock in the RX Deskew
    // logic. For proper operation, always pick latest DQS N. 
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 rxdqsn_sel : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_SA_OFFSET_RANK_4__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_SA_OFFSET_RANK_5__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B134
typedef union {
  struct {
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1E
    //
    UINT32 sa_offset0 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[12:7], RW/V, default = 0x1E
    //
    UINT32 sa_offset1 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[19:14], RW/V, default = 0x1E
    //
    UINT32 sa_offset2 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset,
    // 60=max -ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[26:21], RW/V, default = 0x1E
    //
    UINT32 sa_offset3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // selects which skewed DQS P for post receive enable counter clock in the RX Deskew
    // logic. For proper operation, always pick latest DQS P. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 rxdqsp_sel : 2;
    //
    // selects which skewed DQS N for post receive enable counter clock in the RX Deskew
    // logic. For proper operation, always pick latest DQS N. 
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 rxdqsn_sel : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_SA_OFFSET_RANK_5__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_SA_OFFSET_RANK_6__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B138
typedef union {
  struct {
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1E
    //
    UINT32 sa_offset0 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[12:7], RW/V, default = 0x1E
    //
    UINT32 sa_offset1 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[19:14], RW/V, default = 0x1E
    //
    UINT32 sa_offset2 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset,
    // 60=max -ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[26:21], RW/V, default = 0x1E
    //
    UINT32 sa_offset3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // selects which skewed DQS P for post receive enable counter clock in the RX Deskew
    // logic. For proper operation, always pick latest DQS P. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 rxdqsp_sel : 2;
    //
    // selects which skewed DQS N for post receive enable counter clock in the RX Deskew
    // logic. For proper operation, always pick latest DQS N. 
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 rxdqsn_sel : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_SA_OFFSET_RANK_6__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_SA_OFFSET_RANK_7__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B13C
typedef union {
  struct {
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1E
    //
    UINT32 sa_offset0 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[12:7], RW/V, default = 0x1E
    //
    UINT32 sa_offset1 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max -ve offset, 30=no offset,
    // 60=max +ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[19:14], RW/V, default = 0x1E
    //
    UINT32 sa_offset2 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Rxamp (summer) offset Control. Mid code is 30. (0=max +ve offset, 30=no offset,
    // 60=max -ve offset, 61, 62, 63=not used)[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[26:21], RW/V, default = 0x1E
    //
    UINT32 sa_offset3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // selects which skewed DQS P for post receive enable counter clock in the RX Deskew
    // logic. For proper operation, always pick latest DQS P. 
    // 
    // Bits[29:28], RW, default = 0x0
    //
    UINT32 rxdqsp_sel : 2;
    //
    // selects which skewed DQS N for post receive enable counter clock in the RX Deskew
    // logic. For proper operation, always pick latest DQS N. 
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 rxdqsn_sel : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_SA_OFFSET_RANK_7__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DFE_COEFF_RANK_0__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B140
typedef union {
  struct {
    //
    // DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -120mV to +35mV in 5mV steps.
    // 
    // Bits[4:0], RW, default = 0x8
    //
    UINT32 dfe_coeff1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -40mV to +35mV in 5mV steps
    // 
    // Bits[9:6], RW, default = 0x6
    //
    UINT32 dfe_coeff2 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[10:10], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -40mV to +35mV in 5 mV steps
    // 
    // Bits[14:11], RW, default = 0x8
    //
    UINT32 dfe_coeff3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]
    //                     -40mV to +35mV in 5mV steps
    // 
    // Bits[19:16], RW, default = 0x8
    //
    UINT32 dfe_coeff4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 12;
  } Bits;
  UINT32 Data;
} DDRD_N0_DFE_COEFF_RANK_0__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DFE_COEFF_RANK_1__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B144
typedef union {
  struct {
    //
    // DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -120mV to +35mV in 5mV steps.
    // 
    // Bits[4:0], RW, default = 0x8
    //
    UINT32 dfe_coeff1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -40mV to +35mV in 5mV steps
    // 
    // Bits[9:6], RW, default = 0x6
    //
    UINT32 dfe_coeff2 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[10:10], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -40mV to +35mV in 5 mV steps
    // 
    // Bits[14:11], RW, default = 0x8
    //
    UINT32 dfe_coeff3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]
    //                     -40mV to +35mV in 5mV steps
    // 
    // Bits[19:16], RW, default = 0x8
    //
    UINT32 dfe_coeff4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 12;
  } Bits;
  UINT32 Data;
} DDRD_N0_DFE_COEFF_RANK_1__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DFE_COEFF_RANK_2__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B148
typedef union {
  struct {
    //
    // DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -120mV to +35mV in 5mV steps.
    // 
    // Bits[4:0], RW, default = 0x8
    //
    UINT32 dfe_coeff1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -40mV to +35mV in 5mV steps
    // 
    // Bits[9:6], RW, default = 0x6
    //
    UINT32 dfe_coeff2 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[10:10], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -40mV to +35mV in 5 mV steps
    // 
    // Bits[14:11], RW, default = 0x8
    //
    UINT32 dfe_coeff3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]
    //                     -40mV to +35mV in 5mV steps
    // 
    // Bits[19:16], RW, default = 0x8
    //
    UINT32 dfe_coeff4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 12;
  } Bits;
  UINT32 Data;
} DDRD_N0_DFE_COEFF_RANK_2__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DFE_COEFF_RANK_3__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B14C
typedef union {
  struct {
    //
    // DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -120mV to +35mV in 5mV steps.
    // 
    // Bits[4:0], RW, default = 0x8
    //
    UINT32 dfe_coeff1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -40mV to +35mV in 5mV steps
    // 
    // Bits[9:6], RW, default = 0x6
    //
    UINT32 dfe_coeff2 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[10:10], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -40mV to +35mV in 5 mV steps
    // 
    // Bits[14:11], RW, default = 0x8
    //
    UINT32 dfe_coeff3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]
    //                     -40mV to +35mV in 5mV steps
    // 
    // Bits[19:16], RW, default = 0x8
    //
    UINT32 dfe_coeff4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 12;
  } Bits;
  UINT32 Data;
} DDRD_N0_DFE_COEFF_RANK_3__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DFE_COEFF_RANK_4__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B150
typedef union {
  struct {
    //
    // DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -120mV to +35mV in 5mV steps.
    // 
    // Bits[4:0], RW, default = 0x8
    //
    UINT32 dfe_coeff1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -40mV to +35mV in 5mV steps
    // 
    // Bits[9:6], RW, default = 0x6
    //
    UINT32 dfe_coeff2 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[10:10], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -40mV to +35mV in 5 mV steps
    // 
    // Bits[14:11], RW, default = 0x8
    //
    UINT32 dfe_coeff3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]
    //                     -40mV to +35mV in 5mV steps
    // 
    // Bits[19:16], RW, default = 0x8
    //
    UINT32 dfe_coeff4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 12;
  } Bits;
  UINT32 Data;
} DDRD_N0_DFE_COEFF_RANK_4__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DFE_COEFF_RANK_5__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B154
typedef union {
  struct {
    //
    // DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -120mV to +35mV in 5mV steps.
    // 
    // Bits[4:0], RW, default = 0x8
    //
    UINT32 dfe_coeff1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -40mV to +35mV in 5mV steps
    // 
    // Bits[9:6], RW, default = 0x6
    //
    UINT32 dfe_coeff2 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[10:10], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -40mV to +35mV in 5 mV steps
    // 
    // Bits[14:11], RW, default = 0x8
    //
    UINT32 dfe_coeff3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]
    //                     -40mV to +35mV in 5mV steps
    // 
    // Bits[19:16], RW, default = 0x8
    //
    UINT32 dfe_coeff4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 12;
  } Bits;
  UINT32 Data;
} DDRD_N0_DFE_COEFF_RANK_5__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DFE_COEFF_RANK_6__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B158
typedef union {
  struct {
    //
    // DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -120mV to +35mV in 5mV steps.
    // 
    // Bits[4:0], RW, default = 0x8
    //
    UINT32 dfe_coeff1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -40mV to +35mV in 5mV steps
    // 
    // Bits[9:6], RW, default = 0x6
    //
    UINT32 dfe_coeff2 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[10:10], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -40mV to +35mV in 5 mV steps
    // 
    // Bits[14:11], RW, default = 0x8
    //
    UINT32 dfe_coeff3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]
    //                     -40mV to +35mV in 5mV steps
    // 
    // Bits[19:16], RW, default = 0x8
    //
    UINT32 dfe_coeff4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 12;
  } Bits;
  UINT32 Data;
} DDRD_N0_DFE_COEFF_RANK_6__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DFE_COEFF_RANK_7__DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B15C
typedef union {
  struct {
    //
    // DFE 1st post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -120mV to +35mV in 5mV steps.
    // 
    // Bits[4:0], RW, default = 0x8
    //
    UINT32 dfe_coeff1 : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // DFE 2nd post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -40mV to +35mV in 5mV steps
    // 
    // Bits[9:6], RW, default = 0x6
    //
    UINT32 dfe_coeff2 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[10:10], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // DFE 3rd post cursor tap coefficient. Used in DDR5 mode only.[br]
    //                     -40mV to +35mV in 5 mV steps
    // 
    // Bits[14:11], RW, default = 0x8
    //
    UINT32 dfe_coeff3 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // DFE 4th post cursor tap coefficient. (In DDR4 mode this is the floating tap coefficient).[br]
    //                     -40mV to +35mV in 5mV steps
    // 
    // Bits[19:16], RW, default = 0x8
    //
    UINT32 dfe_coeff4 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 12;
  } Bits;
  UINT32 Data;
} DDRD_N0_DFE_COEFF_RANK_7__DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DLL_CTL0_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B170
typedef union {
  struct {
    //
    // BIOS must program this DLL  discharge timer based on the analog tuning value and
    // hclk freq before enable the DLL. The default value is based on hclk is 1200 MHz
    // and discharge time is 30ns. 
    // 
    // Bits[5:0], RW, default = 0x24
    //
    UINT32 dll_discharge_tmr : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // BIOS must program this DLL lock timer based on the analog tuning value and hclk
    // freq before enable the DLL. The default value is based on hclk is 1200 MHz and
    // lock time is 50ns. 
    // 
    // Bits[13:7], RW, default = 0x3C
    //
    UINT32 dll_lock_tmr : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:14], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 18;
  } Bits;
  UINT32 Data;
} DDRD_N0_DLL_CTL0_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_RETRAIN0_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B174
typedef union {
  struct {
    //
    // TX retraining duration. SW must programs the same TCK duration value as progammed
    // in the memory device.[br] 
    //                     001: 128 x 16 TCK[br]
    //                     010: 256 x 16 TCK[br]
    //                     100: 512 x 16 TCK[br]
    //                     others: Reserved
    // 
    // Bits[2:0], RW, default = 0x1
    //
    UINT32 txrt_dur : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Set to 1 to indicate this is the 1st retraining to initialize the txrt_init_picode.
    // HW will not calculate and apply the txrt_dq_dly_adj. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 txrt_init : 1;
    //
    // Select which rank of RO count value to capture in txrt_ro_count for debug.
    // 
    // Bits[7:5], RW, default = 0x0
    //
    UINT32 txrt_debug_rank : 3;
    //
    // This is the last TX retraining Ring Oscillator count value captured by HW. HW
    // only capture the rank sepcify in txrt_debug_rank. 
    // 
    // Bits[21:8], RO/V, default = 0x0
    //
    UINT32 txrt_ro_count : 14;
    //
    // Set to 1 to apply the calculation results to txrt_init_picode or txrt_dq_dly_adj.
    // HW will clear this bit once it is applied. [br] 
    //                     HW does not require the spid_update_req/ack handshake to apply
    // the results if this CSR is used. [br] 
    //                     SW needs to guarantee that there are no CAP errors, and there
    // is no write traffic to the targeted rank before setting this bit. 
    // 
    // Bits[22:22], RW/V, default = 0x0
    //
    UINT32 txrt_update : 1;
    //
    // Set to 1 by HW to indicate MR46 rank did not match MR47 rank when txrt_update
    // or spid_update_req/ack occurs. [br] 
    //                     SW must clear this bit to 0 when enable HW calibration.
    // 
    // Bits[23:23], RW/1C/V, default = 0x0
    //
    UINT32 txrt_rank_err : 1;
    //
    // Reads back the TXRT FSM state. [br]
    //                     0: IDLE [br]
    //                     1: WAIT_MR [br]
    //                     2: CALC [br]
    //                     3: UPDATE
    // 
    // Bits[25:24], RO/V, default = 0x0
    //
    UINT32 txrt_fsm_status : 2;
    //
    // Reads back the MRR that the TXRT FSM is waiting on. [br]
    //                     bit 0: MR46. 1 indicates that the FSM is waiting for this
    // read. [br] 
    //                     bit 1: MR47. 1 indicates that the FSM is waiting for this
    // read. 
    // 
    // Bits[27:26], RO/V, default = 0x3
    //
    UINT32 txrt_mrr_status : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 4;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_RETRAIN0_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_SAMPLER_ODD_OFFSET_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B178
typedef union {
  struct {
    //
    // Rx Odd Sampler Offset Control.[br]
    //                     Normal operation (dfe_coeff_training_en=0): -155mV to +155mV
    // in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]
    //                     Extended range (dfe_coeff_training_en=1): -620mV to +620mV
    // in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br] 
    //                     Real range may be smaller due to limited signal swing & common-mode.[br]
    //                     This value is added with sampler_offset_adj to allow BIOS
    // for margining sweep (Signed number. The Range is -32 to 31).[br]  
    //                     Note: BIOS must make sure the sampler_offset_adj value doesn't
    // cause an overflow or underflow.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1F
    //
    UINT32 sampler_odd_offset0 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Rx Odd Sampler Offset Control.[br]
    //                     Normal operation (dfe_coeff_training_en=0): -155mV to +155mV
    // in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]
    //                     Extended range (dfe_coeff_training_en=1): -620mV to +620mV
    // in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br] 
    //                     Real range may be smaller due to limited signal swing & common-mode.[br]
    //                     This value is added with sampler_offset_adj to allow BIOS
    // for margining sweep (Signed number. The Range is -32 to 31).[br]  
    //                     Note: BIOS must make sure the sampler_offset_adj value doesn't
    // cause an overflow or underflow.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[12:7], RW/V, default = 0x1F
    //
    UINT32 sampler_odd_offset1 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Rx Odd Sampler Offset Control.[br]
    //                     Normal operation (dfe_coeff_training_en=0): -155mV to +155mV
    // in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]
    //                     Extended range (dfe_coeff_training_en=1): -620mV to +620mV
    // in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br] 
    //                     Real range may be smaller due to limited signal swing & common-mode.[br]
    //                     This value is added with sampler_offset_adj to allow BIOS
    // for margining sweep (Signed number. The Range is -32 to 31).[br]  
    //                     Note: BIOS must make sure the sampler_offset_adj value doesn't
    // cause an overflow or underflow.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[19:14], RW/V, default = 0x1F
    //
    UINT32 sampler_odd_offset2 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Rx Odd Sampler Offset Control.[br]
    //                     Normal operation (dfe_coeff_training_en=0): -155mV to +155mV
    // in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]
    //                     Extended range (dfe_coeff_training_en=1): -620mV to +620mV
    // in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br] 
    //                     Real range may be smaller due to limited signal swing & common-mode.[br]
    //                     This value is added with sampler_offset_adj to allow BIOS
    // for margining sweep (Signed number. The Range is -32 to 31).[br]  
    //                     Note: BIOS must make sure the sampler_offset_adj value doesn't
    // cause an overflow or underflow.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[26:21], RW/V, default = 0x1F
    //
    UINT32 sampler_odd_offset3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 5;
  } Bits;
  UINT32 Data;
} DDRD_N0_SAMPLER_ODD_OFFSET_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_SAMPLER_EVEN_OFFSET_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B17C
typedef union {
  struct {
    //
    // Rx Even Sampler Offset Control.[br]
    //                     Normal operation (dfe_coeff_training_en=0): -155mV to +155mV
    // in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]
    //                     Extended range (dfe_coeff_training_en=1): -620mV to +620mV
    // in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br] 
    //                     Real range may be smaller due to limited signal swing & common-mode.[br]
    //                     This value is added with sampler_offset_adj to allow BIOS
    // for margining sweep (Signed number. The Range is -32 to 31).[br]  
    //                     Note: BIOS must make sure the sampler_offset_adj value doesn't
    // cause an overflow or underflow.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[5:0], RW/V, default = 0x1F
    //
    UINT32 sampler_even_offset0 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:6], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Rx Even Sampler Offset Control.[br]
    //                     Normal operation (dfe_coeff_training_en=0): -155mV to +155mV
    // in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]
    //                     Extended range (dfe_coeff_training_en=1): -620mV to +620mV
    // in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br] 
    //                     Real range may be smaller due to limited signal swing & common-mode.[br]
    //                     This value is added with sampler_offset_adj to allow BIOS
    // for margining sweep (Signed number. The Range is -32 to 31).[br]  
    //                     Note: BIOS must make sure the sampler_offset_adj value doesn't
    // cause an overflow or underflow.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[12:7], RW/V, default = 0x1F
    //
    UINT32 sampler_even_offset1 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Rx Even Sampler Offset Control.[br]
    //                     Normal operation (dfe_coeff_training_en=0): -155mV to +155mV
    // in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]
    //                     Extended range (dfe_coeff_training_en=1): -620mV to +620mV
    // in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br] 
    //                     Real range may be smaller due to limited signal swing & common-mode.[br]
    //                     This value is added with sampler_offset_adj to allow BIOS
    // for margining sweep (Signed number. The Range is -32 to 31).[br]  
    //                     Note: BIOS must make sure the sampler_offset_adj value doesn't
    // cause an overflow or underflow.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[19:14], RW/V, default = 0x1F
    //
    UINT32 sampler_even_offset2 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Rx Even Sampler Offset Control.[br]
    //                     Normal operation (dfe_coeff_training_en=0): -155mV to +155mV
    // in 5mV steps in normal operation (0=-155mV, 31=no offset, 62=+155mV, 63=not used)[br]
    //                     Extended range (dfe_coeff_training_en=1): -620mV to +620mV
    // in 20mV steps (0=-620mV, 31=no offset, 62=+620mV, 63=not used). [br] 
    //                     Real range may be smaller due to limited signal swing & common-mode.[br]
    //                     This value is added with sampler_offset_adj to allow BIOS
    // for margining sweep (Signed number. The Range is -32 to 31).[br]  
    //                     Note: BIOS must make sure the sampler_offset_adj value doesn't
    // cause an overflow or underflow.[br] 
    //                     This field can be programmed by BIOS or HW cal FSM.
    // 
    // Bits[26:21], RW/V, default = 0x1F
    //
    UINT32 sampler_even_offset3 : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:27], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 5;
  } Bits;
  UINT32 Data;
} DDRD_N0_SAMPLER_EVEN_OFFSET_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RXVREF_CTL_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B180
typedef union {
  struct {
    //
    // Per bit Rx Vref Control for DQ0. This value is added with vref_adj to allow BIOS
    // for margining sweep (Signed number. The Range is -64 to 63). The final result
    // is sent to vref CBB. [br] 
    //                     Note: The vref CBB control input is 8-bit. The MSB (Bit 8
    // is tie to 1). It means the default value is 75% of vccddr_hv[br] 
    //                     Note: BIOS must make sure the vref_adj value doens't cause
    // an overflow or underflow.  
    // 
    // Bits[6:0], RW, default = 0x3F
    //
    UINT32 vref_ctl0 : 7;
    //
    // Per bit Rx Vref Control for DQ1. This value is added with vref_adj to allow BIOS
    // for margining sweep (Signed number. The Range is -64 to 63). The final result
    // is sent to vref CBB. [br] 
    //                     Note: The vref CBB control input is 8-bit. The MSB (Bit 8
    // is tie to 1). It means the default value is 75% of vccddr_hv[br] 
    //                     Note: BIOS must make sure the vref_adj value doens't cause
    // an overflow or underflow.  
    // 
    // Bits[13:7], RW, default = 0x3F
    //
    UINT32 vref_ctl1 : 7;
    //
    // Per bit Rx Vref Control for DQ2. This value is added with vref_adj to allow BIOS
    // for margining sweep (Signed number. The Range is -64 to 63). The final result
    // is sent to vref CBB. [br] 
    //                     Note: The vref CBB control input is 8-bit. The MSB (Bit 8
    // is tie to 1). It means the default value is 75% of vccddr_hv[br] 
    //                     Note: BIOS must make sure the vref_adj value doens't cause
    // an overflow or underflow.  
    // 
    // Bits[20:14], RW, default = 0x3F
    //
    UINT32 vref_ctl2 : 7;
    //
    // Per bit Rx Vref Control for DQ3. This value is added with vref_adj to allow BIOS
    // for margining sweep (Signed number. The Range is -64 to 63). The final result
    // is sent to vref CBB. [br] 
    //                     Note: The vref CBB control input is 8-bit. The MSB (Bit 8
    // is tie to 1). It means the default value is 75% of vccddr_hv[br] 
    //                     Note: BIOS must make sure the vref_adj value doens't cause
    // an overflow or underflow.  
    // 
    // Bits[27:21], RW, default = 0x3F
    //
    UINT32 vref_ctl3 : 7;
    //
    // enable Vref Dfx output for ADC measurement.[br]
    //                     Bit3: control DQ3 vref, Bit 2: control DQ2 vref etc.
    // 
    // Bits[31:28], RW, default = 0x0
    //
    UINT32 reserved : 4;
  } Bits;
  UINT32 Data;
} DDRD_N0_RXVREF_CTL_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_COMP_LA0_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B184
typedef union {
  struct {
    //
    // Data Rcomp Drive Up Comp Value. It is trained by COMP FSM.[br]
    //                     This value is added with rcomp_drv_up_adj (signed number.
    // Range is -8 to 7) before send it to the dqbuf and dqsbuf.[br] 
    //                     Note: HW checks for overflow and underflow condition.
    // 
    // Bits[4:0], RW/V, default = 0x8
    //
    UINT32 rcomp_drv_up : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
    //
    // Data Rcomp Drive Down Comp Value. It is trained by COMP FSM.[br]
    //                     This value is added with rcomp_drv_dn_adj (signed number.
    // Range is -8 to 7) before send it to the dqbuf and dqsbuf.[br] 
    //                     Note: HW checks for overflow and underflow condition.
    // 
    // Bits[11:7], RW/V, default = 0x8
    //
    UINT32 rcomp_drv_dn : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:12], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Data Rcomp OdtUp Comp Value. It is trained by COMP FSM.[br]
    //                     This value is added with rcomp_odt_up_adj (signed number.
    // Range is -8 to 7) before send it to the dqbuf and dqsbuf.[br] 
    //                     Note: HW checks for overflow and underflow condition.
    // 
    // Bits[18:14], RW/V, default = 0x8
    //
    UINT32 rcomp_odt_up : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:19], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 2;
    //
    // Data Rcomp Odt-Down Comp Value. It is trained by COMP FSM.[br]
    //                     This value is added with rcomp_odt_dn_adj (signed number.
    // Range is -8 to 7) before send it to the dqbuf and dqsbuf.[br] 
    //                     Note: HW checks for overflow and underflow condition.
    // 
    // Bits[25:21], RW/V, default = 0x8
    //
    UINT32 rcomp_odt_dn : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:26], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 6;
  } Bits;
  UINT32 Data;
} DDRD_N0_COMP_LA0_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_COMP_LA1_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B188
typedef union {
  struct {
    //
    // Data TCO Comp Value for dqbuf and dqsbuf. It is trained by BIOS.[br]
    //                     0/64: fastest rise & fall delay[br]
    //                     0->31: increasing fall delay[br]
    //                     64->95: increasing rise delay[br]
    //                     Other values are not used (32-63 & 96-127).[br]
    //                     To get monotonic increasing sweep of dutycycle, sweep from
    // (95 to 65, 0 to 31) 
    // 
    // Bits[6:0], RW, default = 0x0
    //
    UINT32 tco_comp : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Data Slew Rate Comp Value for dqbuf and dqsbuf. It is trained by BIOS.[br]
    //                     [br]
    //                     0 is fastest slew rate, 31 is slowest slew rate.[br]
    //                     The SCOMP Up/Down Code are generated from the following equation:[br]
    //                     SCOMP Up code[lb]4:0[rb] = scomp[lb]4:0[rb]  + scomp_up_adj[lb]3:0[rb];[br]
    //                     SCOMP Down code[lb]4:0[rb] = scomp[lb]4:0[rb] +  scomp_dn_adj[lb]3:0[rb];[br]
    //                     Note : both SCOMP up Adjust (scomp_up_adj) and SCOMP down
    // adjust (scomp_dn_adj) are signed valued. The adjust range is -8 to 7[br] 
    //                     Note: HW checks for overflow and underflow condition.
    // 
    // Bits[12:8], RW, default = 0x0
    //
    UINT32 scomp : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Rx Retraining DQS delay adjust value for DQS N and P. This field is calcuated
    // by DDRCOMP fub and broadcast to all the data fub. The adjust range is -64 to 63.
    // 
    // Bits[20:14], RO/V, default = 0x0
    //
    UINT32 rxrt_dqs_dly_adj : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:21], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 11;
  } Bits;
  UINT32 Data;
} DDRD_N0_COMP_LA1_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_COMP_OFFSET_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B18C
typedef union {
  struct {
    //
    // Signed number add to rcomp_drv_up to generate the RCOMP Drive up code. The adjust
    // range is -8 to 7. 
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINT32 rcomp_drv_up_adj : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:4], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Signed number add to rcomp_drv_dn to generate the RCOMP Drive down code. The adjust
    // range is -8 to 7. 
    // 
    // Bits[8:5], RW, default = 0x0
    //
    UINT32 rcomp_drv_dn_adj : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[9:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Signed number add to rcomp_odt_up to generate the RCOMP ODT up code. The adjust
    // range is -8 to 7 
    // 
    // Bits[13:10], RW, default = 0x0
    //
    UINT32 rcomp_odt_up_adj : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:14], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Signed number add to rcomp_odt_dn to generate the RCOMP ODT down code. The adjust
    // range is -8 to 7 
    // 
    // Bits[18:15], RW, default = 0x0
    //
    UINT32 rcomp_odt_dn_adj : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[19:19], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // Signed number add to scomp to generate the SCOMP Up Code. The adjust range is
    // -8 to 7. 
    // 
    // Bits[23:20], RW, default = 0x0
    //
    UINT32 scomp_up_adj : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[24:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 1;
    //
    // Signed number add to scomp to generate the SCOMP Down Code. The adjust range is
    // -8 to 7. 
    // 
    // Bits[28:25], RW, default = 0x0
    //
    UINT32 scomp_dn_adj : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_5 : 3;
  } Bits;
  UINT32 Data;
} DDRD_N0_COMP_OFFSET_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_VSSHI_CTL_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B190
typedef union {
  struct {
    //
    // VSSHI target code to vsshi vref control. Step size for 10nm VssHi is vccddr_hv/256.[br]
    //                     Code should be programmed according to analog_tuning field
    // in dll status register:[br] 
    //                                  DDR5/T2   DDR4/T[br]
    //                     3'd3:        0x45      0x55[br]
    //                     3'd1,3'd2:   0x3a      0x4a[br]
    //                     3'd0:        0x2e      0x40[br]
    //                     Note: the vref_ctrl MSB (Bit 7) is hardtie to 0 inside VSSHI.
    // Only the lower 7-bit is controlled by this field. 
    // 
    // Bits[6:0], RW, default = 0x18
    //
    UINT32 vsshi_target_code : 7;
    //
    // Vsshi Bias Current trim.[br]
    //                     The field should be programmed according to analog_tuning
    // field.[br] 
    //                     00: min current (if analog_tuning=3d3, fast skew)[br]
    //                     01: mid current (if analog_tuning=3d1/3d2, typ skew)[br]
    //                     11: max current (if analog_tuning=3d0, slow skew)
    // 
    // Bits[8:7], RW, default = 0x2
    //
    UINT32 vsshi_bias_ctl : 2;
    //
    // Pull VSSHI to VSS
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINT32 vsshi_pulldown_en : 1;
    //
    // Operates VssHi in Close loop mode
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINT32 vsshi_close_loop : 1;
    //
    // LDO output is bypassed to VCCDDRA
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINT32 ldo_bypass_ddra : 1;
    //
    // Use vccddra as LDO vref 
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINT32 ldo_vref_sel_ddra : 1;
    //
    // LDO driver strength based on process variation. Bit 1 is unused. Bit 0 used for
    // LDO Driver Strength[br] 
    //                     This field should be programmed according to analog_tuning
    // field in dll status register:[br] 
    //                     (Fast) 3'd3: 0x0[br]
    //                     (Typ) 3'd1,3'd2: 0x0[br]
    //                     (Slow) 3'd0: 0x1[br]
    // 
    // Bits[14:13], RW, default = 0x0
    //
    UINT32 ldo_bw_ctl : 2;
    //
    // LDO RC Filter Trim
    // 
    // Bits[17:15], RW, default = 0x0
    //
    UINT32 ldo_rcfilter_trim : 3;
    //
    // Sets the LDO reference voltage when ldo_vref_sel_ddra=0.[br]
    //                     Range is (vccddr_hv/2 to vccddr_hv), with step size of vccddr_hv/256.[br]
    //                     Note: the vref_ctrl MSB (Bit 7) is hardtie to 1 inside LDO.
    // Only the lower 7-bit is controlled by this field. 
    // 
    // Bits[24:18], RW, default = 0x18
    //
    UINT32 ldo_codetarget : 7;
    //
    // LDO Cap Trim Loop
    // 
    // Bits[28:25], RW, default = 0x0
    //
    UINT32 ldo_captrim_loop : 4;
    //
    // Operate LDO in close loop mode
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINT32 ldo_close_loop : 1;
    //
    // Double the timer for LDO/VSSHI settle time. Use for failsafe in case settle time
    // was underestimated.[br] 
    //                     0: 8K+1K=9K Dclk cycles[br]
    //                     1: 16K+2K=18K Dclk cycles[br]
    //                     Doubles the LDO/VSSHI settle time counter in case hard-coded
    // value is not adequate 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 vsshi_ldo_tmr_ext : 1;
    //
    // Set to 1 to enable HW to gate DCLK for VSSHI control logic. Default is disable
    // clock gating. 
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 vsshi_dclk_gate_en : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_VSSHI_CTL_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DLL_PI_TEST_ADC_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B194
typedef union {
  struct {
    //
    // Sets to 1 to run test.  SW must clear the bit to stop the test. HW detects deassertion
    // of this control bit to load the pifsm_cnt. 
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Load the load_cnt CR value  into the PI FSM
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Loads Count with how many times the selected PI toggled based on how long RunTest
    // was asserted. Mutex with ModeDV/ModeADC. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 reserved_2 : 1;
    //
    // Measures PI delay using  CFDL and returns results on Count (0 to 1023 with step
    // size of ~1pS).  Mutex with ModeHVM/ModeADC. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 reserved_3 : 1;
    //
    // Converts analog view voltage into digital Count code (0 to 1000 code with step
    // size of 1mV). Mutex with ModeHVM/ModeDV. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 reserved_4 : 1;
    //
    // Load FSM with a starting point for count
    // 
    // Bits[14:5], RW, default = 0x0
    //
    UINT32 reserved_5 : 10;
    //
    // Current Count code from the PI FSM (Read Only)
    // 
    // Bits[24:15], RO/V, default = 0x0
    //
    UINT32 reserved_6 : 10;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:25], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 7;
  } Bits;
  UINT32 Data;
} DDRD_N0_DLL_PI_TEST_ADC_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DLL_CSR_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR  0x0001B198
typedef union {
  struct {
    //
    // DLL Deterministic Lock Status
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINT32 detrm_lock : 1;
    //
    // DLL Raw Lock Status Sticky bit.
    // 
    // Bits[1:1], RO/V, default = 0x0
    //
    UINT32 raw_lock : 1;
    //
    // DLL Lock timeout.
    // 
    // Bits[2:2], RO/V, default = 0x0
    //
    UINT32 lock_timeout : 1;
    //
    // DLL Reset.
    // 
    // Bits[3:3], RO/V, default = 0x0
    //
    UINT32 dll_reset : 1;
    //
    // DLL ADC out.
    // 
    // Bits[13:4], RO/V, default = 0x0
    //
    UINT32 adcout : 10;
    //
    // DLL Long Lock Status.
    // 
    // Bits[14:14], RO/V, default = 0x0
    //
    UINT32 long_lock : 1;
    //
    // Detect lock CBB early lock sticky output
    // 
    // Bits[15:15], RO/V, default = 0x0
    //
    UINT32 detlock_earlylockstky : 1;
    //
    // DLL Weak Lock Status.
    // 
    // Bits[16:16], RO/V, default = 0x0
    //
    UINT32 weak_lock : 1;
    //
    // DLL ADC done.
    // 
    // Bits[17:17], RO/V, default = 0x0
    //
    UINT32 adc_done : 1;
    //
    // DLL output of PiDFx FSM to indciate Pi lags. In order to read this debug register,
    // clock gating must be disabled. 
    // 
    // Bits[18:18], RO/V, default = 0x0
    //
    UINT32 pilags : 1;
    //
    // MDLL open loop output
    // 
    // Bits[19:19], RO/V, default = 0x0
    //
    UINT32 openloop : 1;
    //
    // Detect lock CBB lock reset output
    // 
    // Bits[20:20], RO/V, default = 0x0
    //
    UINT32 lockrst_b : 1;
    //
    // BIOS should configure certain analog components based on the value of this register.[br]
    //                     Details will be found in the description of any CSR that relies
    // on this value 
    // 
    // Bits[23:21], RO/V, default = 0x0
    //
    UINT32 analog_tuning : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[26:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
    //
    // Bypasses flyby clock and selects H-tree clock when disbled
    // 
    // Bits[27:27], RW, default = 0x1
    //
    UINT32 flybyclk_sel : 1;
    //
    // BIOS program this IO Frequency range field based on PLL freq. It is half of the
    // DRAM transfer rate.[br] 
    //                     For example DDR 4800. The PLL freq is 2400.[br]
    //                     2b00: 933MHz - 1333MHz (i.e. 1867MT/s to 2667MT/s)[br]
    //                     2b01: 1467MHz  1600MHz (i.e. 2933MT/s to 3200MT/s)[br]
    //                     2b10: 1800MHz  2000MHz (i.e. 3600MT/s to 4000MT/s)[br]
    //                     2b11: 2200MHz  2400MHz, or above (i.e. 4400MT/s to 4800MT/s)
    // 
    // Bits[29:28], RW, default = 0x2
    //
    UINT32 iofreq_range : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // BIOS must enable DLL when program the IO freq range.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 dll_en : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_DLL_CSR_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RXFIFO_PTR_LOG_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B19C
typedef union {
  struct {
    //
    // Sticky error count. Reset by power good reset.[br]
    //                     Increment when data fub detect rxfifo read and write pointer
    // is out of sync. 
    // 
    // Bits[2:0], RW/1C/V, default = 0x0
    //
    UINT32 rxfifo_ptr_err_cnt : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:3], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 29;
  } Bits;
  UINT32 Data;
} DDRD_N0_RXFIFO_PTR_LOG_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TRAIN_OFFSET0_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B1A0
typedef union {
  struct {
    //
    // Rx DQS delay adjust value. It is added to all per bit RXDQS delay. It is used
    // by BIOS for margining sweep or ACIO HW training. The adjust range is -128 to 127.
    // The expected usage model is BIOS broadcast the same adjust value to all the bytes.
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINT32 rxdqs_dly_adj : 8;
    //
    // Tx DQ delay adjust value. It is added to all per bit TXDQ delay. It is used by
    // BIOS for margining sweep. The adjust range is -128 to 127. The expected usage
    // model is BIOS broadcast the same adjust value to all the bytes. 
    // 
    // Bits[15:8], RW, default = 0x0
    //
    UINT32 txdq_dly_adj : 8;
    //
    // Signed number with range from -64 to 63. It is used by BIOS for marging sweep.
    // This value is added to the vref_ctrl before sending to the DQ VREF. [br] 
    //                     Note: HW doesn't check for overflow and underflow. BIOS must
    // ensure the adjust value doesn't overflow or underflow the final vref control value.
    // 
    // Bits[22:16], RW, default = 0x0
    //
    UINT32 vref_adj : 7;
    //
    // Rx Sampler Offset adjust value. It is added to all sampler_even/odd_offset. It
    // is used by BIOS for sampler offsets margining. The adjust range is -32 to 31.
    // The expected usage model is BIOS broadcast the same value to all the bytes. 
    // 
    // Bits[28:23], RW, default = 0x0
    //
    UINT32 sampler_offset_adj : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:29], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 3;
  } Bits;
  UINT32 Data;
} DDRD_N0_TRAIN_OFFSET0_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_PIREF_OFFSET0_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B1A4
typedef union {
  struct {
    //
    // It is the train PI code to align the PIREF clock to the failing edge of DCLK with
    // data propagation delay after xover training. [br] 
    //                     This value is added with a signed piref_setup_adj (default
    //  value is 63) to generate the piref_code to DLL. The xover input is driven from
    // a failing edge of DCLK flop. [br] 
    //                     By moving the piref odd clock to the right by 63 ticks, we
    // will have 63 pi tick of setup margin.[br] 
    //                     This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[6:0], RW/V, default = 0x0
    //
    UINT32 piref_train_pi_code : 7;
    //
    // This rcven piref offset is added with a signed piref_setup_adj (default value
    // is 63). The result is added to the rcven_dly[6:0], so the txdq PI odd code is
    // relative to the piref clock. This field can be programed by BIOS or HW cal FSM.
    //  
    // 
    // Bits[13:7], RW/V, default = 0x0
    //
    UINT32 rcven_piref_offset : 7;
    //
    // This txdq piref offset is added with a signed piref_setup_adj (default value is
    // 63). The result is added to the per bit txdq_dly[6:0], so the txdq PI odd code
    // is relative to the piref clock. This field can be programed by BIOS or HW cal
    // FSM.  
    // 
    // Bits[20:14], RW/V, default = 0x0
    //
    UINT32 txdq_piref_offset : 7;
    //
    // This txdqs piref offset is added with a signed piref_setup_adj (default value
    // is 63). The result is added to the txdqs_dly[6:0], so the txdqs PI odd code is
    // relative to the piref clock. This field can be programed by BIOS or HW cal FSM.
    // 
    // Bits[27:21], RW/V, default = 0x0
    //
    UINT32 txdqs_piref_offset : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:28], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 4;
  } Bits;
  UINT32 Data;
} DDRD_N0_PIREF_OFFSET0_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_PIREF_OFFSET1_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B1A8
typedef union {
  struct {
    //
    // A singed number for piref setup adjust. Range is -64 to 63. [br]
    //                     The xover input is driven from a inverted DCLK flop. This
    // conrol allows BIOS to adjust the setup time to the input of the xover piref odd
    // clock flop. [br] 
    //                     Default value is 63. [br]
    //                     It means after xover training to align the piref odd clock
    // to the dclk. The piref odd clock is moved to the right by 64 ticks, and we will
    // have 64 pi tick of setup margin. [br] 
    //                     HW will add this value to all the pi codes before send to
    // DLL. 
    // 
    // Bits[6:0], RW/V, default = 0x3F
    //
    UINT32 piref_setup_adj : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:7], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 25;
  } Bits;
  UINT32 Data;
} DDRD_N0_PIREF_OFFSET1_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL0_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR  0x0001B1AC
typedef union {
  struct {
    //
    // Control number of ODT segment enable for DQ and DQS. ODT rotation is applied before
    // sending the control to CBB. The rotation is used to ensure the segment is evenly
    // burn. Rotation is happened when odten is deasserted. [br] 
    //                     Note: Setting this field to 0x3 means enable all segments
    // and rotation has no meaning. 
    // 
    // Bits[1:0], RW, default = 0x3
    //
    UINT32 odt_seg_en : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:2], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 5;
    //
    // Amplifier control.  The bits in this field control: [br]
    //                     2:1 - is used to adjust the bias current for the 2nd stage
    // amplifier in the DQS amplifier path. 0=min, 3=max. [br] 
    //                     0 - is used to force local receiver bias to on.  Otherwise,
    // local receiver bias is enabled through senseamp enable. 
    // 
    // Bits[9:7], RW, default = 0x0
    //
    UINT32 pbias_stg2amp_trim : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[10:10], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
    //
    // Repurposed for force local receiver bias on for DQbuf.[br]
    //                     When set to 1, it will keep the local bias mirror always enabled.[br]
    //                     When set to 0, local bias gets enabled with senseamp_enable.
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINT32 rxgainfuse_ovrd : 1;
    //
    // Rx summer output common mode control[br]
    //                     0: 0.25*vccddra[br]
    //                     1: 0.3*vccddra (default)[br]
    //                     2: 0.35*vccddra[br]
    //                     3: 0.4*vccddra
    // 
    // Bits[13:12], RW, default = 0x1
    //
    UINT32 rxbias_vcm_ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[14:14], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // 00  1.5x (default for CMD/CLK)[br]
    //                     01  2x[br]
    //                     10 - 2.5x (default for DQ)[br]
    //                     11  3x
    // 
    // Bits[16:15], RW, default = 0x1
    //
    UINT32 rxbias_rxgain_ctl : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[21:17], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 5;
    //
    // Sets number of ODT static legs. First 3 MSB bits has weight of 4, 4th MSB has
    // weight of 2 and LSB bit has weight of 1. [br] 
    //                     Default of 0x1F has 15 static legs enabled.[br]
    //                     Static leg training starts with 0x1F (all 15 legs enabled)
    // 
    // Bits[26:22], RW, default = 0x1F
    //
    UINT32 odt_static_leg_cfg : 5;
    //
    // CTLE enable
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 ctle_en : 1;
    //
    // RX Postamble Length.[br]
    //                     0: 0.5 TCK Postamble (default case)[br]
    //                     1: 1.5 TCK Postamble  (the extra 1 TCK pattern is toggle)
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINT32 rx_postamble_len : 1;
    //
    // This field is used by rxdeskew logic to determine preamble pattern type.[br]
    //                     0: 1 tclk - 10 Pattern (MSB is the 1st UI)[br]
    //                     1: 2 tclk - 0010 Pattern[br]
    //                     2: 2 tclk - 1110 Pattern [br]
    //                     3: 3 tclk - 000010 Pattern[br]
    //                     4: 4 tclk - 00001010 Pattern[br]
    //                     Others : Reserved
    // 
    // Bits[31:29], RW, default = 0x0
    //
    UINT32 rx_preamble_type : 3;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL0_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_RX_CTL1_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR  0x0001B1B0
typedef union {
  struct {
    //
    // strobe Rx Amp offset control in DQS RxAmp
    // 
    // Bits[5:0], RW, default = 0x1E
    //
    UINT32 rx_dqs_sa_offset : 6;
    //
    // enable the offset control in DQ/DQS RxAmp and RX BIAS.
    // 
    // Bits[6:6], RW, default = 0x1
    //
    UINT32 rx_offset_en : 1;
    //
    // Controls if the slave DLL is enabled in the Deskew logic.
    // 
    // Bits[7:7], RW, default = 0x1
    //
    UINT32 sdll_en : 1;
    //
    // Rx Sampler offset enable. Also enables the RDAC for the sampler offset correction.
    // Needs to be 1 for DDR5/DDRT2. 
    // 
    // Bits[8:8], RW, default = 0x1
    //
    UINT32 rx_sampler_offset_en : 1;
    //
    // Extend DDR4 RxDFE serializer pulse width.[br]
    //                     Set to 1 to extend the pulse width of the pulsed clocks to
    // the DDR4 RxDFE serializers.[br] 
    //                     Value of 1 seems to work across PVT. May need to set to 0
    // for slow silicon if we see issues in post silicon. 
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINT32 ext_rx_pulse_width : 1;
    //
    // Enable DFE in DQ. Also it is used in RXBIASANA.
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINT32 dfe_en : 1;
    //
    // When set the feedback data is muxed into the VCDL[br]
    //                     When cleared the DQ data from Amp is muxed into the VCDL
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINT32 set_vcdl_fdbk_path : 1;
    //
    // When set, the VCDL is removed from the DQ path from Amp to samplers[br]
    //                     When cleared, the DQ passes from Amp to VCDL and then to samplers
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINT32 byp_vcdl_fwd_path : 1;
    //
    // Set to 0 by default to enable all the devices in the current source legs across
    // all skews.[br] 
    //                     Set to 1 to reduce number of current sources for any sensitivity
    // issues during post silicon testing. 
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINT32 rx_sampler_tailtune : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:14], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 10;
    //
    // After training , this max value of picode is used for 
    //                     enabling appropriate number of delay cells in SDL for power
    // saving . It should be programmed with the max sdl picode from the nibble 
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 sdl_max_picode : 3;
    //
    // Set to 1 to enable gating of delay elements in SDL. Default is disable gating.
    //                     Note : gating must be disabled during any training steps.
    // BIOS can enable gating for power saving after all the training steps are done.
    // 
    // Bits[27:27], RW, default = 0x0
    //
    UINT32 sdl_gating_en : 1;
    //
    // Set to 1 to enable HW reset RXFIFO Pointer when there is no outstanding read in
    // DDRIO. 
    // 
    // Bits[28:28], RW, default = 0x0
    //
    UINT32 hw_rxfifo_ptr_rst_en : 1;
    //
    // Rload trimming in rx decoder
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINT32 loadtrim : 1;
    //
    // Negative cap BW extension
    // 
    // Bits[31:30], RW, default = 0x0
    //
    UINT32 bwextend : 2;
  } Bits;
  UINT32 Data;
} DDRD_N0_RX_CTL1_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL0_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR  0x0001B1B8
typedef union {
  struct {
    //
    // Sets number of DQ/DQS driver (Ron) static legs.[br]
    //                     First 3 MSB bits has weight of 4, 4th MSB has weight of 2
    // and LSB bit has weight of 1.[br] 
    //                     RTL default of 0x1F has 15 static legs enabled.[br]
    //                     Static leg training starts with 0x1F (all 15 legs enabled)
    // 
    // Bits[4:0], RW, default = 0x1F
    //
    UINT32 drv_static_leg_cfg : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Control number of data sement enable for DQ and DQS.
    // 
    // Bits[7:6], RW, default = 0x3
    //
    UINT32 data_seg_en : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[16:8], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 9;
    //
    // Enable Imode EQ per byte lane. [br]
    //                     0: Imode completely off [br]
    //                     1: Imode enabled (Xtalk cancellation OR swing boost selected
    // by ImodeCfg 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 imode_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:18], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // 2nd tap equalization sign bit[br]
    //                     0 +ve equalization[br]
    //                     1: -ve equalization
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINT32 eq_post2_sign : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[20:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 1;
    //
    // 2nd tap selection:[br]
    //                     0  txeq_2nd_tap used for 2nd post cursor tap[br]
    //                     1  txeq_2nd_tap used for extending range of 1st tap.
    // 
    // Bits[21:21], RW, default = 0x1
    //
    UINT32 eq_post2_sel : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[22:22], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_4 : 1;
    //
    // Imode coefficient, sets Imode current.[br]
    //                     Sweep values: (0-15, 40-42, 48-63) for a linear increase of
    // current from 0 to max. 
    // 
    // Bits[28:23], RW, default = 0x0
    //
    UINT32 imode_eq_code : 6;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:29], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_5 : 1;
    //
    // Set to 1 to extend the pulse width of the pulsed clocks to the Tx serializers.[br]
    //                     No need skew based settings, value of 1 seems to work across
    // PVT.[br] 
    //                     May need to set to 0 for slow silicon if we see issues in
    // post silicon. 
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 tx_serializer_pwradj : 1;
    //
    // 0 -DQBUF and DQSBUF bypass SCOMP and TCO delay in the transmitter. 
    // 
    // Bits[31:31], RW, default = 0x1
    //
    UINT32 scomp_tco_bypass_dis : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL0_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TX_CTL1_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR  0x0001B1BC
typedef union {
  struct {
    //
    // TX Preenable Length. [br]
    //                     Legal programming value for [br] 
    //                     DDR4: 1-2 TCK [br]
    //                     DDR5: 2-4 TCK
    // 
    // Bits[2:0], RW, default = 0x1
    //
    UINT32 tx_preamble_len : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[3:3], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Programmable Preamble pattern. Each bit represents a UI of the preamble pattern
    // starting at LSB for 1st UI.[br] 
    //                     Note: For DDR5 write leveling training, which require to mask
    // off the preamble strobe, BIOS can program the pattern to all 0's.[br] 
    //                     [br]
    //                     Legal value is listed below. [br]
    //                     DDR4-[br]
    //                     1 TCK: 8'bXXXX_XX01[br]
    //                     2 TCK: 8'bXXXX_0111 (Long Preamble)[br]
    //                     DDR5-[br]
    //                     2 TCK: 8'XXXX_0100[br]
    //                     3 TCK: 8'bXX01_0000 or 8'bXX01_0100[br]
    //                     4 TCK: 8'b0101_0000
    // 
    // Bits[11:4], RW, default = 0x1
    //
    UINT32 tx_preamble_pat : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:12], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 4;
    //
    // TX Postamble Length.[br]
    //                     0: 0.5 TCK Postamble (default case)[br]
    //                     1: 1.5 TCK Postamble  (the extra 1 TCK pattern is always differentially
    // low) 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINT32 tx_postamble_len : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:17], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 15;
  } Bits;
  UINT32 Data;
} DDRD_N0_TX_CTL1_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_PXC_CTL0_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B1C4
typedef union {
  struct {
    //
    // Select which bit within a byte is the attacker for dq0 in this nibble. [br]
    //                     Note: Attacker can be from the other nibble inside a byte.
    //  BIOS must not set the attacker to itself. 
    // 
    // Bits[2:0], RW, default = 0x0
    //
    UINT32 attacker_sel0 : 3;
    //
    // Select which bit within a byte is the attacker for dq1 in this nibble. [br]
    //                     Note: Attacker can be from the other nibble inside a byte.
    //  BIOS must not set the attacker to itself. 
    // 
    // Bits[5:3], RW, default = 0x0
    //
    UINT32 attacker_sel1 : 3;
    //
    // Select which bit within a byte is the attacker for dq2 in this nibble. [br]
    //                     Note: Attacker can be from the other nibble inside a byte.
    //  BIOS must not set the attacker to itself. 
    // 
    // Bits[8:6], RW, default = 0x0
    //
    UINT32 attacker_sel2 : 3;
    //
    // Select which bit within a byte is the attacker for dq3 in this nibble. [br]
    //                     Note: Attacker can be from the other nibble inside a byte.
    //  BIOS must not set the attacker to itself. 
    // 
    // Bits[11:9], RW, default = 0x0
    //
    UINT32 attacker_sel3 : 3;
    //
    // When set to 1, HW uses the pxc_value_ovr field instead of the calculation logic.[br]
    //                     Note: The current use case is for bench testing for PXC characterization.
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // When pxc_ovr_en is set, this pxc override value is passed directly to the PXC
    // circuit to configure the delay.[br] 
    //                     Note: The current use case is for bench testing for PXC characterization.
    // 
    // Bits[16:13], RW, default = 0x0
    //
    UINT32 reserved_1 : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[28:17], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 12;
    //
    // Select PXC is inductive or capacitive coupling cross talk dominant type[br]
    //                     0: capacitive coupling. If victim and attacker data have the
    // same transition phase, the xtalk delta is added; otherwise (oppsite transition
    // phase) the xtalk delta is subtracted.[br] 
    //                     1: inductive coupling. If victim and attacker data have the
    // same transition phase, the xtalk delta is subtracted ; otherwise (oppsite transition
    // phase) the xtalk delta is added. 
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINT32 pxc_coupling_type : 1;
    //
    // DDJC enable
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 ddjc_en : 1;
    //
    // Phase base cross talk cancellaton enable
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 pxc_en : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_PXC_CTL0_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_DFX_CTL0_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B1C8
typedef union {
  struct {
    //
    // Enable to close switch to pass vin to vout in HV Switcher CBB for NTL testing.
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[2:1], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
    //
    // Simulation-only control to shorten VSSHI and LDO timers
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // 0 - No Vref power saving in Self Refresh. All DQ Vref generators is enabled by
    // dq_vref_en.[br] 
    //                     1 - DQ Vref generators are switched off while in Self Refresh
    // regardless the setting of dq_vref_en. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 sr_vref_dis : 1;
    //
    // 0 - No Vref power saving in CKE power down. All DQ Vref generators is enabled
    // by dq_vref_en.[br] 
    //                     1 - DQ Vref generators are switched off while in CKE power
    // down regardless the setting of dq_vref_en. 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINT32 ckepd_vref_dis : 1;
    //
    // A value of 1 add extra 1 cycle of hold time for tx rank switching
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 tx_rank_chg_hold_adj : 1;
    //
    // A value of 1 add extra 1 cycle of hold time for rx rank switching
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 rx_rank_chg_hold_adj : 1;
    //
    // A value of 1 will allow the strobe to pass to the SDL, bypassing the rcven gating.[br]
    //                     This can be used to debug the SDL clock.
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 reserved_2 : 1;
    //
    // enable RDAC Dfx output for ADC measurement.[br]
    //                     Bit3: control DQ3, Bit 2: control DQ2 etc.
    // 
    // Bits[12:9], RW, default = 0x0
    //
    UINT32 reserved_3 : 4;
    //
    // Disable using rcvenpost early to control the rx rank switch latch.[br]
    //                     If this bit is set to 1, minimum Rd-Rd TR time will need to
    // increase by 1. 
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINT32 dis_rcvenpost_early : 1;
    //
    // NTL analog mux select for NTL testing
    // 
    // Bits[16:14], RW, default = 0x0
    //
    UINT32 reserved_4 : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:17], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 14;
    //
    // VOC RX pass gate enable for VOC training and NTL testing.
    // 
    // Bits[31:31], RW, default = 0x0
    //
    UINT32 rx_voc_pass_gate_en : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_DFX_CTL0_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_VREF_TRACK_CTL_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B1CC
typedef union {
  struct {
    //
    // Code for Vref Cap to supply. 0=min, 15=max. Sweep codes 0-15.
    // 
    // Bits[3:0], RW, default = 0xF
    //
    UINT32 vref_cntrl_cp : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:4], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Code for Vref Cap to gnd. 0=min, 15=max. Sweep codes 0-7,11-15
    // 
    // Bits[8:5], RW, default = 0xF
    //
    UINT32 vref_cntrl_cn : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:9], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 22;
    //
    // Vref Track enable
    // 
    // Bits[31:31], RW, default = 0x1
    //
    UINT32 vreftrack_en : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_VREF_TRACK_CTL_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_HW_TRAIN_CTL0_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B1D0
typedef union {
  struct {
    //
    // Set to 1 to enable xover training stage
    // 
    // Bits[0:0], RW, default = 0x0
    //
    UINT32 xover_stage_en : 1;
    //
    // Set to 1 to enable even/odd sampler training stage for all DQ bits.[br]
    //                     Note: The result is only logged to the sampler even/odd offset
    // register when both even and odd training are done. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 sampler_offset_stage_en : 1;
    //
    // Set to 1 to enable DFE summer offset training stage for all DQ bits.[br]
    //                     Note: the training result is applied to all ranks. BIOS will
    // adjust later for all ranks setting based on eye centering. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 dfe_summer_offset_stage_en : 1;
    //
    // Set to 1 to enable receive enable fine and coarse training stage. This state should
    // only be enabled for ACIO LB testing only. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 reserved : 1;
    //
    // Set to 1 to enable DQ DQS fine and coarse training stage. This state should only
    // be enabled for ACIO LB testing only. 
    // 
    // Bits[4:4], RW, default = 0x0
    //
    UINT32 reserved_1 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[6:5], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
    //
    // Set to 1  to double the analog settling time. [br]
    //                     The default settling time for each stage are [br]
    //                     Xover : 32 Dclk for 1st, 24 Dclk for subsequent [br]
    //                     Sampler offset : 528 Dclk for 1st time; 144 Dlck for subsequent
    // steps [br] 
    //                     DFE summer offset : 24 Dclk [br]
    //                     Rcven fine/coarse : 16 Dclk / 8 Dclk [br]
    //                     Dqdqs fine / coarse : 16 Dclk / 8 Dclk
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 settling_time_x2 : 1;
    //
    // Number of Sample to evaluate for each iteration step. It applied for all training
    // stages. [br] 
    //                     0: 16[br]
    //                     1: 32[br]
    //                     2: 64[br]
    //                     3: 2 (Should only used to speed up digitial simulation)
    // 
    // Bits[9:8], RW, default = 0x0
    //
    UINT32 sample_cnt : 2;
    //
    // Sample threshold value for voting logic.
    // 
    // Bits[15:10], RW, default = 0x8
    //
    UINT32 sample_thresh : 6;
    //
    // Control to select which DQ bit for dqdqs training stage[br]
    //                     1xx : Perform DQDQS training for all DQ bits in series.[br]
    //                     000 : DQ0 only and the result will apply for all bits within
    // the nibble.[br] 
    //                     001 : DQ1 only and the result will apply for all bits within
    // the nibble.[br] 
    //                     010 : DQ2 only and the result will apply for all bits within
    // the nibble.[br] 
    //                     011 : DQ3 only and the result will apply for all bits within
    // the nibble. 
    // 
    // Bits[18:16], RW, default = 0x4
    //
    UINT32 reserved_2 : 3;
    //
    // Set to 1 to enable full sweep for rcven and dqdqs fine training stages. Default
    // behavior is HW will stop when detects edge transition. Expect to enable this feature
    // only for debug. 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINT32 reserved_3 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[23:20], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 4;
    //
    // Set to 1 by HW to indicate xover training is failed. SW must clear this bit to
    // 0 when enable HW calibration. 
    // 
    // Bits[24:24], RW/1C/V, default = 0x0
    //
    UINT32 xover_err : 1;
    //
    // Set to 1 by HW to indicate even sampler offset training is failed. SW must clear
    // this bit to 0 when enable HW calibration. 
    // 
    // Bits[25:25], RW/1C/V, default = 0x0
    //
    UINT32 even_sampler_offset_err : 1;
    //
    // Set to 1 by HW to indicate odd sampler offset training is failed. SW must clear
    // this bit to 0 when enable HW calibration. 
    // 
    // Bits[26:26], RW/1C/V, default = 0x0
    //
    UINT32 odd_sampler_offset_err : 1;
    //
    // Set to 1 by HW to indicate dfe summer offset training is failed. SW must clear
    // this bit to 0 when enable HW calibration. 
    // 
    // Bits[27:27], RW/1C/V, default = 0x0
    //
    UINT32 dfe_summer_offset_err : 1;
    //
    // Set to 1 by HW to indicate receive enable training is failed. SW must clear this
    // bit to 0 when enable HW calibration. 
    // 
    // Bits[28:28], RW/1C/V, default = 0x0
    //
    UINT32 reserved_4 : 1;
    //
    // Set to 1 by HW to indicate dqdqs training is failed.  SW must clear this bit to
    // 0 when enable HW calibration. 
    // 
    // Bits[29:29], RW/1C/V, default = 0x0
    //
    UINT32 reserved_5 : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:30], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 1;
    //
    // Set to 1 to enable HW calibration. They are five HW calibration stages that SW
    // can request HW to perform. It is defined in bit 0 to 4 in this register. [br]
    //                     HW will self clear this bit when all the enabled calibration
    // stages are completed. [br] 
    //                     For BIOS training, XOVER, sampler offset, and DFE summer offset
    // training can be enabled by SW.[br]  
    //                     For ACIO testing, all 5 stages can be enabled by SW.
    // 
    // Bits[31:31], RW/V, default = 0x0
    //
    UINT32 hw_cal_en : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_HW_TRAIN_CTL0_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_HWCAL_SWEEP_RESULT0_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B1D8
typedef union {
  struct {
    //
    // The sweep result 0-2 register is used for debug to observe the full sweep result
    // for rcven or dqdqs fine training, so both stages can't be enabled at the same
    // time. For DQDQS training, it only valid if one DQ bit is enabled.[br] 
    //                     Note : we log every other step only. (0-143 step, only even
    // number of step is logged) 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 hwcal_sweep_result0 : 32;
  } Bits;
  UINT32 Data;
} DDRD_N0_HWCAL_SWEEP_RESULT0_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_HWCAL_SWEEP_RESULT1_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B1DC
typedef union {
  struct {
    //
    // The sweep result 0-2 register is used for debug to observe the full sweep result
    // for rcven or dqdqs fine training, so both stages can't be enabled at the same
    // time. For DQDQS training, it only valid if one DQ bit is enabled.[br] 
    //                     Note : we log every other step only. (0-143 step, only even
    // number of step is logged) 
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 hwcal_sweep_result1 : 32;
  } Bits;
  UINT32 Data;
} DDRD_N0_HWCAL_SWEEP_RESULT1_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_HWCAL_SWEEP_RESULT2_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B1E0
typedef union {
  struct {
    //
    // The sweep result 0-2 register is used for debug to observe the full sweep result
    // for rcven or dqdqs fine training, so both stages can't be enabled at the same
    // time. For DQDQS training, it only valid if one DQ bit is enabled.[br] 
    //                     Note : we log every other step only. (0-143 step, only even
    // number of step is logged) 
    // 
    // Bits[7:0], RO/V, default = 0x0
    //
    UINT32 hwcal_sweep_result2 : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:8], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 24;
  } Bits;
  UINT32 Data;
} DDRD_N0_HWCAL_SWEEP_RESULT2_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TRAIN_CTL0_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B1E4
typedef union {
  struct {
    //
    // Logic delay to turn on DQS ODT base on receive enable signal. Unit is DLCK. Range
    // is 0-12. 
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINT32 dqs_odt_dly : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:4], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
    //
    // Control how long the DQS ODT stay on after receive enable signal deasserted in
    // DCLK domain. Unit is DCLK. Range is 0-31. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 dqs_odt_dur : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Logic delay to turn on DQS Sense Amp base on receive enable signal. Unit is DCLK.
    // Range is 0-12. 
    // 
    // Bits[16:13], RW, default = 0x0
    //
    UINT32 dqs_sa_dly : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:17], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 2;
    //
    // Control how long the DQS Sense Amp stay on after receive enable signal deasserted
    // in DCLK domain. Unit is DCLK. Range is 0-31. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 dqs_sa_dur : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_TRAIN_CTL0_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TRAIN_CTL1_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B1E8
typedef union {
  struct {
    //
    // Enables the Command Training Counter mode (DQ receivers, ODT needs to be enabled
    // separately before setting this bit), resets the sample counter and starts the
    // counting of the samples. One of these per nibble that is used for feedback (i.e.
    // all DQ nibble and the fub with the ALERT_n feedback. DQ nibbles can be set with
    // broadcast). The value of this field remains at 1 until after the Counting Window
    // expires, then returns to 0. Can be polled to determine when the counting has completed.
    // When the Counting Window field is set to 0, this field will not return to 0. In
    // that case, this field must be set to 0 to disable.[br] 
    //                     When the CS Assertion Trigger Enable is set, the counting
    // window start is delayed until the first CS Assertion event  but this delay only
    // applies for the ALERT_n, RSP_A, and RSP_B signals. This does not apply to the
    // DQ counters. 
    // 
    // Bits[0:0], RW/V, default = 0x0
    //
    UINT32 cmd_train_ctr_en : 1;
    //
    // Enables Write Leveling Training Mode. Write Leveling training is not the same
    // for both DDR4 and DDR5. BIOS must set the ddr4 control bit to indicate write leveling
    // for DDR4 or DDR5.[br] 
    //                     For DDR5, when set, the strobes have their transmitter enable,
    // while the DQ signals have their receivers enabled. The Received value from the
    // DQ signals is sampled and stored in the training result register. This is a continously
    // sampled valued.[br] 
    //                     Note: all clock gate enable must 0 during Write Level training
    // mode. 
    // 
    // Bits[1:1], RW, default = 0x0
    //
    UINT32 wr_level_train_en : 1;
    //
    // Enables Read Leveling Training Mode. Read Leveling training step is the same for
    // DDR4 and DDR5.[br] 
    //                     Note: all clock gate enable must 0 during Read Level training
    // mode. 
    // 
    // Bits[2:2], RW, default = 0x0
    //
    UINT32 rd_level_train_en : 1;
    //
    // 0 : Front side[br]
    //                     1: Back side (DDR5 LRDIMM / 3D Xpoint DIMM)[br]
    //                     [br]
    //                     When rd_level_train_type is set to 1 and rd_level_train_en
    // is set to 1, the training counter increments based on the sampling of DQ with
    // the rising edge of rcven (DB sends feedback to host through DQ pins, DB samples
    // MDQS with its internal rcven signal). [br] 
    //                     When rd_level_train_type is set to 0 and rd_level_train_en
    // is set to 1,  the training counter increments based on the sampling of DQS with
    // the rising edge of rcven. 
    // 
    // Bits[3:3], RW, default = 0x0
    //
    UINT32 rd_level_train_type : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[4:4], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 1;
    //
    // Setting this bit to 1 will prepare data fub in a state to allow BIOS only to perform
    // Xover calibraton training. [br] 
    //                     - enable all the DCLK And PI clocks. (may remove clock gating
    // function) 
    // 
    // Bits[5:5], RW, default = 0x0
    //
    UINT32 xover_cal : 1;
    //
    // Tri-state the vref_hv output.  Set to 1 for NTL and Rx Summer Offset Cal.
    // 
    // Bits[6:6], RW, default = 0x0
    //
    UINT32 vref_highz : 1;
    //
    // Used for even sampler offset calibration mode. Shorts inputs of samplers to Vcm
    // 
    // Bits[7:7], RW, default = 0x0
    //
    UINT32 even_sampler_offset_cal_en : 1;
    //
    // Used for odd sampler offset calibration mode. Shorts inputs of samplers to Vcm
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 odd_sampler_offset_cal_en : 1;
    //
    // Should be set only during DFE coefficient initial training (pulse response). Increases
    // sampler offset range by 2X. 
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINT32 dfe_coeff_train_en : 1;
    //
    // Set this bit to 1 for DDR5 ELR DIMM type
    // 
    // Bits[10:10], RW, default = 0x0
    //
    UINT32 elr_dimm : 1;
    //
    // BIOS can disable a nibble within a byte. This can be used to disable 1 nibble
    // of the ECC for 9x4 DIMM support.[br] 
    //                     The entire ECC byte can also be disabled for DIMMs that doesn't
    // support ECC.  In DDR4, the unused byte can be disabled as well. 
    // 
    // Bits[11:11], RW, default = 0x0
    //
    UINT32 nibble_dis : 1;
    //
    // For SPR, 2 Channel DDR-MC sub-system. It can either operate in DDR4/DDR-T or DDR5/DDR-T2.
    // It doesn't support DDR4/DDR-T mix with DDR5/DDR-T2.[br] 
    //                     Setting this bit to 1 indicate it is operating in DDR4/DDR-T.
    // 0 inidate it is operating in DDR5/DDR-T2.[br] 
    //                     Fub use this bit to determine the training level different
    // between DDR4 vs DDR5. 
    // 
    // Bits[12:12], RW, default = 0x0
    //
    UINT32 ddr4 : 1;
    //
    // Set to 1 to enable HW to gate tx retraining logic for power saving. Default is
    // disable clock gating.[br]  
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[13:13], RW, default = 0x0
    //
    UINT32 txrt_clk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate effective register update CLK for power saving.
    // Default is disable clock gating.[br]  
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINT32 compeff_clk_gate_en : 1;
    //
    // Set to 1 to enable BCLK gating for Burnin/ADC counter and DLL lock timer for power
    // saving. 
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINT32 bclk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate TX PI CLK for transmit path logic. Default is disable
    // clock gating. [br] 
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[16:16], RW, default = 0x0
    //
    UINT32 tx_piclk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate RX PI CLK for receive path logics. Default is disable
    // clock gating. [br] 
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[17:17], RW, default = 0x0
    //
    UINT32 rx_piclk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate PI REF clock for power saving. Default is disable
    // clock gating. [br] 
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[18:18], RW, default = 0x0
    //
    UINT32 piref_clk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate TX CLK for transmit path logics. Default is disable
    // clock gating.[br]  
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[19:19], RW, default = 0x0
    //
    UINT32 tx_clk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate RX CLK for receive path logics. Default is disable
    // clock gating. [br] 
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 rx_clk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate CLK for training related logic (BIOS or HW training
    // logics). Default is disable clock gating. [br] 
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 train_clk_gate_en : 1;
    //
    // Set to 1 to enable HW to gate CSR CLK. Default is disable clock gating. [br]
    //                     Note: Clock gating must be disable during any training steps.
    // BIOS can enable clock gating for power saving after all the training steps are
    // done. 
    // 
    // Bits[22:22], RW, default = 0x0
    //
    UINT32 csr_clk_gate_en : 1;
    //
    // When set to 1, HW uses the rank_value_ovr field to select rank parameters instead
    // of rank number from MC. It is used for training step that require to read out
    // rank specific infomration without MC command.[br] 
    //                     Note: The current use case is for DDR4 Write leveling training.
    // 
    // Bits[23:23], RW, default = 0x0
    //
    UINT32 rank_ovr_en : 1;
    //
    // When rank_ovr_en is set, this rank override value is used by HW to select rank
    // parameters instead of rank number from MC. It is used for training step that require
    // to read out rank specific infomration without MC command.[br] 
    //                     Note: The current use case is for DDR4 Write leveling training.
    // 
    // Bits[26:24], RW, default = 0x0
    //
    UINT32 rank_value_ovr : 3;
    //
    // Force Weak DQS/DQ ODT on. It is used before ODT enable window is trained and program
    // by BIOS. [br] 
    //                     The weak ODT is ignored when drive enable is asserted. [br]
    //                     Note: For ACIO, ODT is provided by different DDR channel.
    //  
    // 
    // Bits[27:27], RW, default = 0x1
    //
    UINT32 force_odt_on : 1;
    //
    // Force Rx bias circuit on.[br]
    //                     Note: In SPR setting this bit to 1 doesnt force vref on. To
    // force vref on, user must set dq_vref_en to 1 and sr_vref_dis to 0. 
    // 
    // Bits[28:28], RW, default = 0x1
    //
    UINT32 force_rxbias_on : 1;
    //
    // Force Senseamp on. Use for overclocking support where we may not be able to hit
    // the fast exit latency. 
    // 
    // Bits[29:29], RW, default = 0x0
    //
    UINT32 force_sa_on : 1;
    //
    // Force Strong DQS/DQ ODT on. when set, it always enable one segement for ODT regardless
    // of the state of drive enable.[br] 
    //                     The intend use case is for ACIO with burnin.
    // 
    // Bits[30:30], RW, default = 0x0
    //
    UINT32 force_strong_odt_on : 1;
    //
    // Vref generator Enable. Set to 1 to enable all DQ bits vref.[br]
    //                     Note: The self refresh VREF disable control (sr_vref_dis)
    // can disable vref during DIMM in self refresh.[br] 
    //                     To force VREF on all the time in SPR, user must program sr_vref_dis
    // to 0 and ckepd_vref_dis to 0. [br] 
    //                     Note: Unlike wave 1 design, ForceBiasOn doesn't force verf
    // enable anymore. 
    // 
    // Bits[31:31], RW, default = 0x1
    //
    UINT32 dq_vref_en : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TRAIN_CTL1_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TRAIN_CTL2_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B1EC
typedef union {
  struct {
    //
    // Each bit in the TX strobe mask will mask out the strobe pulse associated with
    // each location in the write burst (i.e. for a BL16 there are 8 strobe pulses (rising/falling
    // combination)). A value of 00000000b will enable all strobes. A value of 1111_1110b
    // will enable a single strobe pulse at the first 2 UIs in the BL. [br] 
    //                     The current use case is for DDR5 write leveling training which
    // only enable the 1st TCK DQS strobe (0xFE)[br] 
    //                     Note: When drv_dqs_diff_high is set, the masked Strobe is
    // driven differentially high. On the other hand, when drv_dqs_diff_low is set, the
    // masked stobe is driven differentially low. 
    // 
    // Bits[7:0], RW, default = 0x0
    //
    UINT32 tx_strobe_mask : 8;
    //
    // When set, the strobe is driven differentially low, other than when a WRITE strobe
    // sequence is sent to the DRAM 
    // 
    // Bits[8:8], RW, default = 0x0
    //
    UINT32 drv_dqs_diff_low : 1;
    //
    // When set, the strobe is driven differentially high, other than when a WRITE strobe
    // sequence is sent to the DRAM.  
    // 
    // Bits[9:9], RW, default = 0x0
    //
    UINT32 drv_dqs_diff_high : 1;
    //
    // When the DQ Override Enable bit is set, this setting determines the value that
    // is driven by the DQ transmitter at all time. The value is constant over all UIs,
    // but can be set per DQ in the nibble. 
    // 
    // Bits[13:10], RW, default = 0x0
    //
    UINT32 dq_value_ovr : 4;
    //
    // This setting enables the over-ride operation associated with the DQ Value Override
    // setting.[br] 
    //                     Note: Once this bit is set, it turns on the TX driver and
    // drives the dq_value_ovr on all DQs pins  
    // 
    // Bits[14:14], RW, default = 0x0
    //
    UINT32 dq_ovr_en : 1;
    //
    // Determines if the command training counter will count 1 or 0.[br]
    //                     0: count 1[br]
    //                     1: count 0
    // 
    // Bits[15:15], RW, default = 0x0
    //
    UINT32 sample_sel : 1;
    //
    // Mask off any DQ bits not considered in the OR computation for the command training
    // counting. 
    // 
    // Bits[19:16], RW, default = 0x0
    //
    UINT32 dq_sample_mask : 4;
    //
    // Enables feedback from DQ SAL for any DDR5 training modes, requiring feedback from
    // DQ lanes. 
    // 
    // Bits[20:20], RW, default = 0x0
    //
    UINT32 sampler_feedback_en : 1;
    //
    // The unsampled path is automatically enabled in DDR4, but not for DDR5.  In DDR5,
    // set this bit to 0x1 during write level, and cmd training (DQ feedback is used).
    // 
    // Bits[21:21], RW, default = 0x0
    //
    UINT32 unsampled_path_en : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[27:22], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 6;
    //
    // Select which xover phase detect output for calibration. For each nibble, we have
    // 8 xover per DLL piref. 
    // 
    // Bits[30:28], RW, default = 0x0
    //
    UINT32 xover_cal_mux_sel : 3;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:31], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 1;
  } Bits;
  UINT32 Data;
} DDRD_N0_TRAIN_CTL2_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TRAIN_CTL3_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B1F0
typedef union {
  struct {
    //
    // Logic delay to turn on DQ ODT base on receive enable signal. Unit is DCLK. Range
    // is 0-12. 
    // 
    // Bits[3:0], RW, default = 0x0
    //
    UINT32 dq_odt_dly : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:4], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 2;
    //
    // Control how long the DQ ODT stay on after receive enable signal deasserted in
    // DCLK domain. Unit is DCLK. Range is 0-31. 
    // 
    // Bits[10:6], RW, default = 0x0
    //
    UINT32 dq_odt_dur : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[12:11], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_1 : 2;
    //
    // Logic delay to turn on DQ Sense Amp base on receive enable signal. Unit is DCLK.
    // Range is 0-12. 
    // 
    // Bits[16:13], RW, default = 0x0
    //
    UINT32 dq_sa_dly : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[18:17], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_2 : 2;
    //
    // Control how long the DQ Sense Amp stay on after receive enable signal deasserted
    // in DCLK domain. Unit is DCLK. Range is 0-31. 
    // 
    // Bits[23:19], RW, default = 0x0
    //
    UINT32 dq_sa_dur : 5;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description_3 : 8;
  } Bits;
  UINT32 Data;
} DDRD_N0_TRAIN_CTL3_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TRAIN_CNT_WINDOW0_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B1F4
typedef union {
  struct {
    //
    // cmd_train_ctr_en:[br]
    //                     value that sets the number of DCLK cycles that the DQ samples
    // will be counted. Linear setting. This is broadcast to all bytes  one register
    // per byte. When this field is set to 0 the counter will run until it saturates,
    // or until it the CMD Training Counter Mode field is cleared.[br] 
    //                     wr_level_train_en: [br]
    //                     control when to increment the coutner after the trigger event
    // (DQS OE)[br] 
    //                     rd_level_train_en:[br]
    //                     control when to increment the coutner after the sampling event
    // (rising edge of receive enable) 
    // 
    // Bits[31:0], RW, default = 0x0
    //
    UINT32 cnt_window : 32;
  } Bits;
  UINT32 Data;
} DDRD_N0_TRAIN_CNT_WINDOW0_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TRAIN_CNT_RESULT_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B1F8
typedef union {
  struct {
    //
    // cmd_train_ctr_en:[br]
    //                     Value that indicates the number of logic 1  or 0 values sampled
    // during the Counting Window (based on sample_sel). This is cleared when the CMD
    // Training Counter mode is enabled. This count is the result of the OR of all DQs
    // in the nibble, for those DQs that are not masked off.  Whten the cnt_window is
    // set to 0, the counter will run until it saturates.[br] 
    //                     wr_level_train_en:[br]
    //                     DQ sample count[br]
    //                     rd_level_train_en:[br]
    //                     Receive enable sample count
    // 
    // Bits[31:0], RO/V, default = 0x0
    //
    UINT32 train_cnt : 32;
  } Bits;
  UINT32 Data;
} DDRD_N0_TRAIN_CNT_RESULT_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;

#define DDRD_N0_TRAIN_RESULT0_DDRD1_N0_CH0_DDRD1_N0_MEM_REG_DDR 0x0001B1FC
typedef union {
  struct {
    //
    // Xover Calibration Phase Detected Result
    // 
    // Bits[0:0], RO/V, default = 0x0
    //
    UINT32 xover_cal_pd_result : 1;
    //
    // Per bit even sampler value for senseamp training. It is used for DDR5 sampler
    // and DFE summer VOC training stage 
    // 
    // Bits[4:1], RO/V, default = 0x0
    //
    UINT32 sa_even_sampler : 4;
    //
    // Per bit odd sampler value for senseamp training. It is used only for DDR5 sampler
    // training stage. 
    // 
    // Bits[8:5], RO/V, default = 0x0
    //
    UINT32 sa_odd_sampler : 4;
    //
    // Per bit senseamp train result for DDR4 only
    // 
    // Bits[12:9], RO/V, default = 0x0
    //
    UINT32 sa_ddr4_train_result : 4;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:13], Unknown, default = Unknown
    //
    UINT32 missing_from_register_description : 19;
  } Bits;
  UINT32 Data;
} DDRD_N0_TRAIN_RESULT0_DDRD1_N0_CH0_DDRD1_N0_MEM_STRUCT_DDR;


#endif // _MMRCDDRD1_N0_CH0_DDRD1_N0_MEM_DDR_H_DDR_
