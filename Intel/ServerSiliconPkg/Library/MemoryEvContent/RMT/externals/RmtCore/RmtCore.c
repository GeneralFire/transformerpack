/** @file
  RmtCore.c

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2013 - 2020 Intel Corporation. <BR>

  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.

  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.

  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
**/


#pragma warning (disable : 4366)

#include "ssabios.h"

#include <Library/BitMaskLib.h>
#include "ChkRetStat.h"
#include "InitPlatform.h" // must precede autogenerated_rmtmetadata.h
#include "MarginParam.h"
#include "MemCfg.h"
#include "MemShmoo.h"
#include "MemPointTest.h"
#include "Platform.h"
#include "RMT.h" // for BSSA_TC_MAJOR_VER, BSSA_TC_MINOR_VER, etc.
#include "RmtCore.h"
#include "EvContentInternal.h"

#if FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 1
#include "Rmt1DSweep.h"
#endif

#include <Library/BaseMemoryLib.h>
#include <Library/DebugLib.h>
#include <Library/MemoryEvContentLib.h>
#include <Library/SsaUtilLib.h>
#include <Library/MemoryCoreLib.h>
#include <Library/SysHostPointerLib.h>
#include <Library/MemMcIpLib.h>
#include <Library/MemoryServicesLib.h>
#include <Library/Ddr5CoreLib.h>

// flag to enable BIOS-SSA debug messages
#define ENBL_BIOS_SSA_API_DEBUG_MSGS (0)

// flag to enable function trace debug messages
#define ENBL_FUNCTION_TRACE_DEBUG_MSGS (0)

// flag to enable verbose log messages
#define ENBL_VERBOSE_LOG_MSGS (0)

// flag to enable verbose error messages
#define ENBL_VERBOSE_ERROR_MSGS (0)

// flag to enable results debug messages
#define ENBL_RESULTS_DEBUG_LOG_MSGS (0)

// flag to enable lane plot debug messages
#define ENBL_LANE_PLOT_DEBUG_LOG_MSGS (0)

// flag to enable fixup debug messages
#define ENBL_FIXUP_DEBUG_LOG_MSGS (0)

//
// Limit the DQ margin offset range to +/- 128 ticks.
//
#define DQ_MARGIN_OFFSET_LIMIT 128

/**
  This function is used to get the bitmask value for the given margin group.
  The mask value is used for the *Mask test configuration values.

  @param[in]  MarginGroup  Margin parameter group.

  @retval Bitmask value
**/
UINT16 GetMarginGroupBitmask(
  MRC_GT MarginGroup)
{
  switch (MarginGroup) {
    case RxDqsDelay:
      return 1 << 0;
    case TxDqDelay:
      return 1 << 1;
    case RxSamplerEvenOdd:
    case RxSamplerEven:
    case RxSamplerOdd:
    case RxVref:
      return 1 << 2;
    case TxVref:
      return 1 << 3;
    case DcaDelay:
    case QcaDelay:
    case BcomDelay:
    case CmdAll:
      return 1 << 4;
    case RcdDcaVref:
    case CmdVref:
    case BcomVref:
      return 1 << 5;
    case CtlAll:
    case QcsDelay:
      return 1 << 6;
#if SUPPORT_FOR_DDRT
    case EridDelay:
      return 1 << 7;
    case EridVref:
      return 1 << 8;
#endif
    default:
      return 0;
  }
} // end function GetMarginGroupBitmask

/**
  This function is used to determine whether the given margin group is for
  command/address/control signals (as opposed to data signals).

  @param[in]  MarginGroup  Margin parameter group.

  @retval TRUE/FALSE
**/
static BOOLEAN IsCmdSignalMarginGroup(
  MRC_GT MarginGroup)
{
  switch (MarginGroup) {
    case CmdAll:
    case CtlAll:
    case CmdVref:
    case DcaDelay:
    case RcdDcaVref:
    case DcsDelay:
    case QcaDelay:
    case QcsDelay:
    case DcaDfeVref:
    case BcomDelay:
    case BcomVref:
      return TRUE;
    default:
      return FALSE;
  }
} // end function IsCmdSignalMarginGroup

/**
  This function is used to determine whether the given margin group is
  BCOM signals.

  @param[in]  MarginGroup  Margin parameter group.

  @retval TRUE/FALSE
**/
static
BOOLEAN
IsBcomSignalMarginGroup (
  MRC_GT MarginGroup
  )
{
  switch (MarginGroup) {

    case BcomDelay:
    case BcomVref:
      return TRUE;
    default:
      return FALSE;
  }
} // end function IsBcomSignalMarginGroup

/**
  This function is used to determine whether the given margin group is
  QCA/QCS margin signals which shall be skipped for the DDRT (DCPMM) dimm.

  @param[in]  MarginGroup  Margin parameter group.

  @retval TRUE/FALSE
**/
static
BOOLEAN
IsQcxSignalMarginGroup (
  MRC_GT MarginGroup
  )
{
  switch (MarginGroup) {

    case QcaDelay:
    case QcsDelay:
    case DramCaVref:
    case DramCsVref:

      return TRUE;

    default:
      return FALSE;
  }
} // end function IsQcxSignalMarginGroup

/**
  This function is used to determine whether the given margin group requires
  error recover call back function when sweep. The erroe recover call back
  function typically performs JEDEC Init to recover.

  @param[in]  MarginGroup  Margin parameter group.

  @retval TRUE/FALSE
**/
static
BOOLEAN
IsErrorRecoverRequired (
  MRC_GT MarginGroup
  )
{
  switch (MarginGroup) {

    case DramCaVref:
    case DramCsVref:

      return TRUE;

    default:
      return FALSE;
  }
} // end function IsErrorRecoverRequired

/**
  This function is used to get the step size associated with the given margin
  group.

  @param[in]  pRmtTestCfg  Pointer to RMT test configuration structure.
  @param[in]  IoLevel      I/O level.
  @param[in]  MarginGroup  Margin group.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 GetStepSize(
  IN CONST RMT_CONFIG *pRmtTestCfg,
  IN MRC_LT IoLevel,
  IN MRC_GT MarginGroup)
{
  UINT8 StepSize;

  if (IoLevel != DdrLevel) {
   switch (MarginGroup) {
     case BcomVref:
       StepSize = BCOM_VREF_STEP_SIZE_ENCODED_VALUE;
       break;
     default:
       StepSize = 1;
    }
  } else {
    switch (MarginGroup) {
    case RxDqsDelay:
      StepSize = pRmtTestCfg->RxDqsStepSize;
      break;
    case TxDqDelay:
      StepSize = pRmtTestCfg->TxDqStepSize;
      break;
    case RxVref:
      StepSize = pRmtTestCfg->RxVrefStepSize;
      break;
    case TxVref:
      StepSize = pRmtTestCfg->TxVrefStepSize;
      break;
    case CmdAll:
      StepSize = pRmtTestCfg->CmdAllStepSize;
      break;
    case CmdVref:
      StepSize = pRmtTestCfg->CmdVrefStepSize;
      break;
    case CtlAll:
      StepSize = pRmtTestCfg->CtlAllStepSize;
      break;
#if SUPPORT_FOR_DDRT
    case EridDelay:
      StepSize = pRmtTestCfg->EridDelayStepSize;
      break;
    case EridVref:
      StepSize = pRmtTestCfg->EridVrefStepSize;
      break;
#endif
    default:
      StepSize = 1;
    }
  }

  return StepSize;
} // end function GetStepSize

/**
  This function is used to get a string associated with the traffic mode.

  @param[in]   IoLevel   I/O level.

  @retval   String describing the I/O level.
**/
CONST char*
GetTrafficModeStr (
  TRAFFIC_MODE TrafficMode
  )
{
  switch (TrafficMode) {
    case LoopbackTrafficMode:
      return "Loopback";
    case WritesAndReadsTrafficMode:
      return "WritesAndReads";
    case WriteOnlyTrafficMode:
      return "WriteOnly";
    case ReadOnlyTrafficMode:
      return "ReadOnly";
    case IdleTrafficMode:
      return "Idle";
    case Wr2WrAndRd2RdTrafficMode:
      return "Wr2WrAndRd2RdTurnaround";
    case Rd2WrTrafficMode:
      return "Rd2WrTurnaround";
    case Wr2RdTrafficMode:
      return "Wr2RdTurnaround";
    default:
    return "unknown";
  }
} // end function GetTrafficModeStr

/**
  This function is used to initialize the given memory shmoo test configuration
  structure.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       LaneShmooStopMode  Lane shmoo stop mode.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 InitMemShmooCfg(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN SHMOO_STOP_MODE LaneShmooStopMode)
{
  UINT16 MarginGroupBitmask;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.InitMemShmooCfg(LaneShmooStopMode=%u)\n", LaneShmooStopMode);
#endif

  MarginGroupBitmask = GetMarginGroupBitmask(pCoreTestData->CurrentMarginGroup);

  // initialize the memory shmoo configuration
  ZeroMem (&pCoreTestData->MemShmooCfg, sizeof(pCoreTestData->MemShmooCfg));

  pCoreTestData->MemShmooCfg.IoLevel = pCoreTestData->CurrentIoLevel;
  pCoreTestData->MemShmooCfg.MarginGroup = pCoreTestData->CurrentMarginGroup;
  pCoreTestData->MemShmooCfg.IsDdrT = TRUE; // pCoreTestData->CurrentIsDdrT;

  pCoreTestData->MemShmooCfg.StepSize = GetStepSize(pCoreTestData->pTestCfg,
    pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentMarginGroup);
  pCoreTestData->MemShmooCfg.IncrementalStepSize = 16;

  // RMT uses no guard band - emphasis is on speed
  pCoreTestData->MemShmooCfg.GuardBandSize = 0;

  if (pCoreTestData->pTestCfg->OptimizedShmooBitmask & MarginGroupBitmask) {
    pCoreTestData->MemShmooCfg.EnableOptimizedShmoo = TRUE;
  }

#if SUPPORT_FOR_DDRT
  // For the DDRT test, Cmd/CmdVref/Ctl test, we can't use binary search because it
  // could put the CPGC in a hung state
  if (HasDdrtDevicesValEnabled(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CurrentMemPointTestCfg
#else
    &pCoreTestData->SelectMemPointTestCfg
#endif // !SUPPORT_FOR_EXTENDED_RANGE)
    )) {
    if (IsCmdSignalMarginGroup(pCoreTestData->CurrentMarginGroup)) {
      pCoreTestData->MemShmooCfg.EnableOptimizedShmoo = FALSE;
    }
  }
#endif

  pCoreTestData->MemShmooCfg.LaneShmooStopMode = LaneShmooStopMode;
  pCoreTestData->MemShmooCfg.RankShmooStopMode = AllShmooStopMode;
  pCoreTestData->MemShmooCfg.ChannelShmooStopMode = AllShmooStopMode;
  pCoreTestData->MemShmooCfg.ControllerShmooStopMode = AllShmooStopMode;
  pCoreTestData->MemShmooCfg.SocketShmooStopMode = AllShmooStopMode;

  // This option will stop margin the channle that already statisfy stop condition.
  // for example, during the Cmd margin with DDRT
  pCoreTestData->MemShmooCfg.StopChannelMarginOnStopCond = TRUE;

  pCoreTestData->MemShmooCfg.EnableIncrementalStepping = \
    IsIncrementalSteppingRequired(SsaServicesHandle,
    &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CurrentMemPointTestCfg,
#else
    &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
    pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentMarginGroup);

  if (IsJedecInitAfterErrRequired(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CurrentMemPointTestCfg,
#else
    &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
    pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentMarginGroup)) {
    pCoreTestData->MemShmooCfg.EnableDimmInitAfterErr = TRUE;
    pCoreTestData->MemShmooCfg.DimmInitMode = Jedec;
  }
  else if (IsIoResetAfterErrRequired(SsaServicesHandle,
    &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CurrentMemPointTestCfg,
#else
    &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
    pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentMarginGroup)) {
    pCoreTestData->MemShmooCfg.EnableDimmInitAfterErr = TRUE;
    pCoreTestData->MemShmooCfg.DimmInitMode = IoReset;
  }
  else {
    pCoreTestData->MemShmooCfg.EnableDimmInitAfterErr = FALSE;
  }

  pCoreTestData->MemShmooCfg.DisableInitMarginParam = TRUE;

#if SUPPORT_FOR_EXTENDED_RANGE
  pCoreTestData->MemShmooCfg.EnableExtendedRange = \
    pCoreTestData->pTestCfg->EnableExtendedRange;
#endif // SUPPORT_FOR_EXTENDED_RANGE

#if ENBL_VERBOSE_LOG_MSGS
  LogMemShmooTestCfg(SsaServicesHandle, &pCoreTestData->MemShmooCfg);
#endif
  if (ChkMemShmooTestCfg(SsaServicesHandle, &pCoreTestData->MemShmooCfg,
    pCoreTestData->pTestStat)) {
    return 1;
  }

  return 0;
} // end function InitMemShmooCfg

#if SUPPORT_FOR_EXTENDED_RANGE
/**
  This function is used to initialize the current memory point test
  configuration structure in the given core test data structure based on the
  select memory point test configuration structure, current rank
  combinations index in the given core test data structure, and (when testing
  serialization is selected) the given target socket, controller, and channel.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 InitCurrentMemPointTestCfg(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData)
{
  MEM_POINT_TEST_CONFIG *pMemPointTestCfg = \
    &pCoreTestData->CurrentMemPointTestCfg;
  MEM_POINT_TEST_CONFIG *pSelectMemPointTestCfg = \
    &pCoreTestData->SelectMemPointTestCfg;
  UINT8 Socket, Controller, Channel, Dimm, Rank, ByteGroup;
  BOOLEAN IsSocketToBeTested;
  BOOLEAN IsControllerToBeTested;
  BOOLEAN IsChannelToBeTested;
  UINT8 PairCount;
  DIMM_RANK_PAIR DimmRankPairs[2];
  RANK_TEST_MODE RankTestMode;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "InitCurrentMemPointTestCfg(CurrentRankCombinationIndex=%u)\n",
    pCoreTestData->CurrentRankCombinationIndex);
#endif

  // start by setting everything to 0
  ZeroMem (pMemPointTestCfg, sizeof (*pMemPointTestCfg));

  // IF this is the frontside
  if (pCoreTestData->CurrentIoLevel == DdrLevel) {
#if SUPPORT_FOR_LRDIMM
    // IF the DIMMs are LRDIMMs
    if (pCoreTestData->MemCfg.IsLrDimms) {
      // only test between the first ranks of all DIMMs
      pMemPointTestCfg->TurnaroundsTestMode = OnlyInterDimmTurnarounds;
    }
#endif // SUPPORT_FOR_LRDIMM
  }
  // ELSE this is the backside
  else {
    // only test between the ranks within each DIMM
    pMemPointTestCfg->TurnaroundsTestMode = OnlyIntraDimmTurnarounds;
  }

  // start with the socket bitmask of selected devices
  pMemPointTestCfg->SocketBitmask = \
    pSelectMemPointTestCfg->SocketBitmask;

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // IF this socket is not to be tested THEN skip it
    if ((pMemPointTestCfg->SocketBitmask & (1 << Socket)) == 0) {
      continue;
    }

    IsSocketToBeTested = FALSE;

    // start with the controller bitmask of selected devices
    pMemPointTestCfg->ControllerBitmasks[Socket] = \
      pSelectMemPointTestCfg->ControllerBitmasks[Socket];

    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // IF this controller is not to be tested THEN skip it
      if ((pMemPointTestCfg->ControllerBitmasks[Socket] &
        (1 << Controller)) == 0) {
        continue;
      }

      IsControllerToBeTested = FALSE;

      // start with the channel bitmask of selected devices
      pMemPointTestCfg->ChannelBitmasks[Socket][Controller] = \
        pSelectMemPointTestCfg->ChannelBitmasks[Socket][Controller];

      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // IF this channel is not to be tested THEN skip it
        if ((pMemPointTestCfg->ChannelBitmasks[Socket][Controller] &
          (1 << Channel)) == 0) {
          continue;
        }

        // IF this rank combination is unique for this channel
        if (pCoreTestData->CurrentRankCombinationIndex <
          pCoreTestData->RankCombinationCnts[Socket][Controller][Channel]) {
          // add this channel to the channel validation mask
          pMemPointTestCfg->ChannelValBitmasks[Socket][Controller] |= \
            1 << Channel;
        }

        IsChannelToBeTested = FALSE;

        RankTestMode = \
          pSelectMemPointTestCfg->RankTestModes[Socket][Controller][Channel];
        pMemPointTestCfg->RankTestModes[Socket][Controller][Channel] = \
          RankTestMode;

        PairCount = 2;
        if (GetCpgcPointTestDimmRanks(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          pSelectMemPointTestCfg, pCoreTestData->pCpgcPointTestData, Socket,
          Controller, Channel, &PairCount, &DimmRankPairs[0],
          pCoreTestData->pTestStat)) {
          return 1;
        }

        // IF there's a DIMM A/rank A
        if (PairCount > 0) {
          Dimm = DimmRankPairs[0].Dimm;
          Rank = DimmRankPairs[0].Rank;

          // add them to the memory point test configuration DIMM A/rank A bitmasks
          pMemPointTestCfg->DimmABitmasks[Socket][Controller][Channel] |= \
            1 << Dimm;
          pMemPointTestCfg->RankABitmasks[Socket][Controller][Channel][Dimm] |= \
            1 << Rank;
        } // end if there's a DIMM A/rank A

        // IF we're testing rank-to-rank turnarounds and there's a DIMM B/rank B
        if ((RankTestMode == Turnarounds) && (PairCount > 1)) {
          Dimm = DimmRankPairs[1].Dimm;
          Rank = DimmRankPairs[1].Rank;

          // add them to the memory point test configuration DIMM B/rank B bitmasks
          pMemPointTestCfg->DimmBBitmasks[Socket][Controller][Channel] |= \
            1 << Dimm;
          pMemPointTestCfg->RankBBitmasks[Socket][Controller][Channel][Dimm] |= \
            1 << Rank;
        } // end if we're testing rank-to-rank turnarounds and there's a DIMM B/rank B

        // IF (we're testing singles AND there are DIMM A's to be tested) OR
        // (we're testing rank-to-rank turnarounds AND there are DIMM A's and DIMM B's to be tested)
        if (((RankTestMode == Singles) &&
          (pMemPointTestCfg->DimmABitmasks[Socket][Controller][Channel] != 0)) ||
          ((RankTestMode == Turnarounds) &&
          (pMemPointTestCfg->DimmABitmasks[Socket][Controller][Channel] != 0) &&
          (pMemPointTestCfg->DimmBBitmasks[Socket][Controller][Channel] != 0))) {
          IsSocketToBeTested = TRUE;
          IsControllerToBeTested = TRUE;
          IsChannelToBeTested = TRUE;
        }

        // IF it turns out that there were no ranks to test on this channel
        if (!IsChannelToBeTested) {
          // remove the channel
          pMemPointTestCfg->ChannelBitmasks[Socket][Controller] &= \
            ~(1 << Channel);
          pMemPointTestCfg->ChannelValBitmasks[Socket][Controller] &= \
            ~(1 << Channel);
        }
      } // end for each channel

      // IF it turns out that there were no ranks to test on this controller
      if (!IsControllerToBeTested) {
        // remove the controller
        pMemPointTestCfg->ControllerBitmasks[Socket] &= ~(1 << Controller);
      }
    } // end for each controller

    // IF it turns out that there were no ranks to test on this socket
    if (!IsSocketToBeTested) {
      // remove the socket
      pMemPointTestCfg->SocketBitmask &= ~(1 << Socket);
    }
  } // end for each socket

  // FOR each controller:
  for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
    // FOR each channel:
    for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
      {
        // FOR each byte group:
        for (ByteGroup = 0;
          ByteGroup < (pCoreTestData->SystemInfo.BusWidth / 8);
          ByteGroup++) {
          pMemPointTestCfg->LaneValBitmasks[Controller][Channel][ByteGroup] = \
            0xFF;
        } // end for each byte group
      }

      pMemPointTestCfg->ChunkValBitmasks[Controller][Channel] = \
        ALL_CHUNKS;
    } // end for each channel
  } // end for each controller

#if ENBL_VERBOSE_LOG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "CurrentMemPointTestCfg:\n");
  LogMemPointTestCfg(SsaServicesHandle, &pCoreTestData->SystemInfo,
    pMemPointTestCfg);
#endif
  if (ChkMemPointTestCfg(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg, pMemPointTestCfg, pCoreTestData->pTestStat)) {
    return 1;
  }

  return 0;
} // end function InitCurrentMemPointTestCfg
#endif // SUPPORT_FOR_EXTENDED_RANGE

/**
  This function is used to initialize the select memory point test
  configuration structure based on the given input parameters.

  The MarginGroup input parameter is used to detect the case where the backside
  DQ margin is skipped if the Dimm is not LRDIMM or DDRT.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       IoLevel            I/O level.
  @param[in]       MarginGroup        Margin group.
  @param[in]       RankCombination    Rank combination.
  @param[in]       IsDdrT             Flag indicating that DDR-T devices are being tested.
  @param[in]       InitAsAll          Flag indicating whether to initialize as all devices

  @retval  0  success
  @retval  1  error occurred
**/
UINT8
InitSelectMemPointTestCfg (
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA    *pCoreTestData,
  IN     MRC_LT                IoLevel,
  IN     MRC_GT                MarginGroup,
  IN     RANK_TEST_MODE        RankTestMode,
  IN     BOOLEAN               IsDdrT,
  IN     BOOLEAN               InitAsAll
  )
{
  MEM_POINT_TEST_CONFIG*  pMemPointTestCfg = &pCoreTestData->SelectMemPointTestCfg;
  UINT8                   Socket;
  UINT8                   Controller;
  UINT8                   Channel;
  UINT8                   Dimm;
  UINT8                   ByteGroup;
  BOOLEAN                 IsSocketToBeTested;
  BOOLEAN                 IsControllerToBeTested;
  BOOLEAN                 IsChannelToBeTested;
#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
  MEMORY_TECHNOLOGY_TYPES MemoryTech;
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "InitSelectMemPointTestCfg(IoLevel=%u RankTestMode=%u IsDdrT=%u InitAsAll=%u)\n",
    IoLevel, RankTestMode, IsDdrT, InitAsAll);
#endif

  // start by setting everything to 0
  ZeroMem (pMemPointTestCfg, sizeof(*pMemPointTestCfg));

#if SUPPORT_FOR_TURNAROUNDS
  // set default value
  pMemPointTestCfg->TurnaroundsTestMode = AllRankTurnarounds; //OnlyInterDimmTurnarounds; //OnlyIntraDimmTurnarounds; //AllRankTurnarounds;
  pMemPointTestCfg->TurnaroundsPairMode = pCoreTestData->TurnaroundsPairMode;

  // IF we're doing turnarounds
  if (RankTestMode == Turnarounds) {
    // IF this is the frontside
    if (IoLevel == DdrLevel) {
#if SUPPORT_FOR_LRDIMM
      // IF the DIMMs are LRDIMMs
      if (pCoreTestData->MemCfg.IsLrDimms) {
        // only test between the first ranks of all DIMMs
        pMemPointTestCfg->TurnaroundsTestMode = OnlyInterDimmTurnarounds;
      }
#endif // SUPPORT_FOR_LRDIMM
    }
    // ELSE this is the backside
    else {
      // only test between the ranks within each DIMM
      pMemPointTestCfg->TurnaroundsTestMode = OnlyIntraDimmTurnarounds;
    }
  } // end if we're doing turnarounds
#endif // SUPPORT_FOR_TURNAROUNDS

  // use the given socket bitmask and screen out unpopulated sockets
  pMemPointTestCfg->SocketBitmask = \
    pCoreTestData->pTestCfg->SocketBitmask & \
    pCoreTestData->SystemInfo.SocketBitMask;

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // IF this socket is not to be tested THEN skip it
    if ((pMemPointTestCfg->SocketBitmask & (1 << Socket)) == 0) {
      continue;
    }

    IsSocketToBeTested = FALSE;

    // use the given controller bitmask and screen out unpopulated controllers
    pMemPointTestCfg->ControllerBitmasks[Socket] = \
      pCoreTestData->pTestCfg->ControllerBitmask & \
      pCoreTestData->MemCfg.ControllerBitmasks[Socket];

    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // IF this controller is not to be tested THEN skip it
      if ((pMemPointTestCfg->ControllerBitmasks[Socket] &
        (1 << Controller)) == 0) {
        continue;
      }

      IsControllerToBeTested = FALSE;

      // use the populated channels
      pMemPointTestCfg->ChannelBitmasks[Socket][Controller] = \
        pMemPointTestCfg->ChannelValBitmasks[Socket][Controller] = \
        pCoreTestData->MemCfg.ChannelBitmasks[Socket][Controller];

      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // IF this channel is not to be tested THEN skip it
        if ((pMemPointTestCfg->ChannelBitmasks[Socket][Controller] &
          (1 << Channel)) == 0) {
          continue;
        }

        IsChannelToBeTested = FALSE;

        pMemPointTestCfg->RankTestModes[Socket][Controller][Channel] = RankTestMode;

        // FOR each DIMM:
        for (Dimm = 0; Dimm < MAX_DIMM_CNT; Dimm++) {
          // IF this DIMM is not populated THEN skip it
          if ((pCoreTestData->MemCfg.DimmBitmasks[Socket][Controller][Channel] &
            (1 << Dimm)) == 0) {
            continue;
          }
#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
          MemoryTech = pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm];

#ifdef DDR5_SUPPORT
          //
          // If this is for BCOM margin, skip the Dimm that is not either LRDIMM or DDRT
          //
          if ((IoLevel == LrbufLevel) && IsBcomSignalMarginGroup (MarginGroup) &&
             (pCoreTestData->MemCfg.IsLrDimms == FALSE) && (MemoryTech != SsaMemoryDdrT)) {
              continue;
          }

          //
          // If this is for QCA/QCS margin, skip the DDRT Dimm
          //
          if ((IoLevel == LrbufLevel) && IsQcxSignalMarginGroup (MarginGroup) &&
              (MemoryTech == SsaMemoryDdrT)) {
              continue;
          }
#endif
          //
          // IF this is for backside data margining and non-LRDIMM, non-DDR-T
          // devices THEN skip it
          if ((IoLevel == LrbufLevel) &&
            !IsCmdSignalMarginGroup (MarginGroup) &&
            !pCoreTestData->MemCfg.IsLrDimms &&
            (MemoryTech != SsaMemoryDdrT)) {
              continue;
          }

#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT

          pMemPointTestCfg->DimmABitmasks[Socket][Controller][Channel] |= 1 << Dimm;

#if SUPPORT_FOR_TURNAROUNDS
          if (RankTestMode == Turnarounds) {
            pMemPointTestCfg->DimmBBitmasks[Socket][Controller][Channel] |= 1 << Dimm;
          }
#endif // SUPPORT_FOR_TURNAROUNDS

          IsSocketToBeTested = TRUE;
          IsControllerToBeTested = TRUE;
          IsChannelToBeTested = TRUE;

          // default is to test all ranks that are present
          pMemPointTestCfg->RankABitmasks[Socket][Controller][Channel][Dimm] = \
            (1 << pCoreTestData->MemCfg.RankCounts[Socket][Controller][Channel][Dimm]) - 1;

#if SUPPORT_FOR_DDRT
          // IF we're testing the frontside and the DIMM is a DDR-T
          if ((IoLevel == DdrLevel) && (MemoryTech == SsaMemoryDdrT)) {
            // only test the first rank on this DIMM
            pMemPointTestCfg->RankABitmasks[Socket][Controller][Channel][Dimm] = 1;
          }
#endif // SUPPORT_FOR_DDRT

#if SUPPORT_FOR_TURNAROUNDS
          if (RankTestMode == Turnarounds) {
            pMemPointTestCfg->RankBBitmasks[Socket][Controller][Channel][Dimm] = \
              pMemPointTestCfg->RankABitmasks[Socket][Controller][Channel][Dimm];
          }
#endif // SUPPORT_FOR_TURNAROUNDS
        } // end for each DIMM

#if SUPPORT_FOR_TURNAROUNDS
        // IF we're doing turnarounds and this channel can't do turnarounds
        if ((RankTestMode == Turnarounds) &&
          !CanChannelDoTurnarounds(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg, pMemPointTestCfg,
          IoLevel, Socket, Controller, Channel, IsDdrT)) {
          // remove the channel
          IsChannelToBeTested = FALSE;
        }
#endif // SUPPORT_FOR_TURNAROUNDS

        // IF it turns out that there were no ranks to test on this channel
        if (!IsChannelToBeTested) {
          // remove the channel
          pMemPointTestCfg->ChannelBitmasks[Socket][Controller] &= \
            ~(1 << Channel);
          pMemPointTestCfg->ChannelValBitmasks[Socket][Controller] &= \
            ~(1 << Channel);
        }
      } // end for each channel

      // IF it turns out that there were no ranks to test on this controller
      if (pMemPointTestCfg->ChannelBitmasks[Socket][Controller] == 0) {
        // remove the controller
        pMemPointTestCfg->ControllerBitmasks[Socket] &= ~(1 << Controller);
      }
    } // end for each controller

    // IF it turns out that there were no ranks to test on this socket
    if (!IsSocketToBeTested) {
      // remove the socket
      pMemPointTestCfg->SocketBitmask &= ~(1 << Socket);
    }
  } // end for each socket

  // FOR each controller:
  for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
    // FOR each channel:
    for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
      // FOR each byte group:
      for (ByteGroup = 0; ByteGroup < (pCoreTestData->SystemInfo.BusWidth / 8); ByteGroup++) {
        pMemPointTestCfg->LaneValBitmasks[Controller][Channel][ByteGroup] = 0xFF;
      } // end for each byte group

      pMemPointTestCfg->ChunkValBitmasks[Controller][Channel] = ALL_CHUNKS;
    } // end for each channel
} // end for each controller

#if ENBL_VERBOSE_LOG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "SelectMemPointTestCfg:\n");
  LogMemPointTestCfg(SsaServicesHandle, &pCoreTestData->SystemInfo, pMemPointTestCfg);
#endif
  if (ChkMemPointTestCfg(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg, pMemPointTestCfg, pCoreTestData->pTestStat)) {
    return 1;
  }

  return 0;
} // end function InitSelectMemPointTestCfg

/**
  This function is the margin parameter change handler function.

  This function conforms to the MARGIN_PARAM_CHG_HANDLER typedef in MemShmoo.h.

  @param[in, out]  pClientTestData   Pointer to client test data.
  @param[in]       IoLevel           I/O level.
  @param[in]       MarginGroup       Margin group.
  @param[in]       TestingOffset     Margin parameter offset being tested.
**/
static VOID MarginParamChgHandler(
  IN OUT VOID *pClientTestData,
  IN MRC_LT IoLevel,
  IN MRC_GT MarginGroup,
  IN INT16 TestingOffset)
{
  RMT_CORE_TEST_DATA* pCoreTestData = (RMT_CORE_TEST_DATA*) pClientTestData;

  pCoreTestData->TestingOffset = TestingOffset;
} // end function MarginParamChgHandler

/**
@brief
  This is the post-DIMM-initialization handler function.  The function will be
  called by the MemShmoo code immediately after a DIMM initialization is
  performed.

  This function conforms to the POST_DIMM_INIT_HANDLER function typedef
  published in MemShmoo.h.

  @param[in, out]  SsaServicesHandle      Pointer to SSA services.
  @param[in]       pSystemInfo            Pointer to system information structure.
  @param[in]       pMemCfg                Pointer to memory configuration structure.
  @param[in]       pMemPointTestCfg       Pointer to generic memory point test configuration structure.
  @param[in]       pClientTestCfg         Pointer to client test configuration structure.
  @param[in, out]  pClientTestData        Pointer to client test data structure.
  @param[in]       IsLastRankCombination  Flag indicating that this is the last rank combination.
  @param[out]      pTestStat              Pointer to test status in results metadata structure.

  @retval  0  success
  @retval  1  error occurred
**/
UINT8 PostDimmInitHandler(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN CONST MRC_SYSTEM_INFO *pSystemInfo,
  IN CONST MEM_CFG *pMemCfg,
  IN CONST MEM_POINT_TEST_CONFIG *pMemPointTestCfg,
  IN CONST VOID *pClientTestCfg,
  IN OUT VOID *pClientTestData,
  IN BOOLEAN IsLastRankCombination,
  OUT TEST_STATUS *pTestStat)
{
  RMT_CONFIG* pTestCfg = (RMT_CONFIG*) pClientTestCfg;
  RMT_CORE_TEST_DATA* pCoreTestData = (RMT_CORE_TEST_DATA*) pClientTestData;
  BOOLEAN IsFirstCall, InitDqdbContent, IsLastCall;

  // clean up the CPGC point test
  IsLastCall = FALSE;
  CleanupCpgcPointTest(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg, IsLastCall,
    &pCoreTestData->pCpgcPointTestData);

  // re-initialize the CPGC engine
  IsFirstCall = FALSE;
  InitDqdbContent = FALSE;
  if (SetupCpgcPointTest(SsaServicesHandle, &pCoreTestData->SystemInfo,
    pCoreTestData->pCpgcInfo, &pCoreTestData->MemCfg,
    &pCoreTestData->SelectMemPointTestCfg, &pCoreTestData->CpgcPointTestCfg,
    RmtPointTestResultHandler, pCoreTestData, pCoreTestData->CurrentIoLevel,
    pCoreTestData->CurrentIsDdrT, pTestCfg->TestStatusLogLevel, IsFirstCall,
    InitDqdbContent, &pCoreTestData->pCpgcPointTestData, pTestStat)) {
    return 1;
  }

  // re-initialize the rank programming
  if (SetCpgcPointTestRankCombinationIndex(SsaServicesHandle,
    &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
    &pCoreTestData->SelectMemPointTestCfg, &pCoreTestData->CpgcPointTestCfg,
    pCoreTestData->pCpgcPointTestData,
    pCoreTestData->CurrentRankCombinationIndex,
    TRUE, // need to update HW register setting
    pCoreTestData->pTestStat)) {
    return 1;
  }

  // IF we're currently in the binary search state
  if (GetInBinarySearchState(pCoreTestData->pMemShmooData)) {
    // restore binary search settings
    if (pCoreTestData->SetPointTestInBinarySearchState(SsaServicesHandle,
      &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
      &pCoreTestData->SelectMemPointTestCfg, &pCoreTestData->CpgcPointTestCfg,
      pCoreTestData->pCpgcPointTestData, TRUE, pTestStat)) {
      return 1;
    }
  }

  return 0;
} // end function PostDimmInitHandler

/**
  This function is used to initialize the last pass margin status.

  @param[in, out]  pCoreTestData  Pointer to RMT core test data structure.
**/
static VOID InitMarginStatus(
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData)
{
  ZeroMem (&pCoreTestData->LastPassLaneOffsets, sizeof (pCoreTestData->LastPassLaneOffsets));
  ZeroMem (&pCoreTestData->LastPassFoundMasks, sizeof (pCoreTestData->LastPassFoundMasks));

  // clear the margin parameter limits accumulator
  ZeroMem (&pCoreTestData->LimitOffsets, sizeof (pCoreTestData->LimitOffsets));
} // end function InitMarginStatus

#if SUPPORT_FOR_EXTENDED_RANGE
/*
@brief
  This function is used to fixup extended range results.

  @param[in, out]  SsaServicesHandle   Pointer to SSA services.
  @param[in, out]  pCoreTestData       Pointer to core test data structure.
  @param[in]       ShmooDir            Shmoo direction.
  @param[in]       ResultType          Result type.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 FixupResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN SHMOO_DIRECTION ShmooDir,
  IN RMT_RESULT_TYPE ResultType)
{
  SSA_STATUS RetStat;
  UINT8 Socket, Controller, Channel, DimmA, RankA, DimmB, RankB, Lane;
  UINT8 LaneBitmasks[MAX_BUS_WIDTH / 8];
  UINT16 SettleDelay;
  INT16 MinOffset, MaxOffset;
  UINT16 StepUnit;
  UINT32 EleIdx;
  UINT8 ShmooDirIdx;
  UINT8 MarginGroupArrayIdx;
  UINT8 MarginGroupEleIdx = 0;
  BOOLEAN MarginGroupFound;
  UINT8 ByteGroup;
  RMT_RESULT_COLUMNS *pResultElement;
  UINT8 LimitOffset;
#if ENBL_BIOS_SSA_API_DEBUG_MSGS || ENBL_FIXUP_DEBUG_LOG_MSGS
  CHAR8 *GroupString = NULL;
#endif

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS || ENBL_FIXUP_DEBUG_LOG_MSGS
  if (EFI_ERROR (GetGroupString (pCoreTestData->CurrentMarginGroup, &GroupString))) {
    GroupString = "Unknown group";
  }

  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "FixupResults(ShmooDir=%u ResultType=%u MarginOffset=%u (%a)\n",
    ShmooDir, ResultType, pCoreTestData->CurrentMarginGroup,
    GroupString));
#endif

  // find the MarginGroupArrayIdx and MarginGroupEleIdx for the given MarginGroup value
  MarginGroupFound = FALSE;
  for (MarginGroupArrayIdx = 0; MarginGroupArrayIdx < MARGIN_GROUP_ARRAY_CNT;
    MarginGroupArrayIdx++) {
    for (MarginGroupEleIdx = 0; MarginGroupEleIdx < MARGIN_GROUP_ARRAY_ELE_CNT;
      MarginGroupEleIdx++) {
      if (pCoreTestData->MarginGroups[MarginGroupArrayIdx][MarginGroupEleIdx] ==
        pCoreTestData->CurrentMarginGroup) {
        MarginGroupFound = TRUE;
        break;
      }
    }
    if (MarginGroupFound) {
      break;
    }
  }
  if (!MarginGroupFound || (MarginGroupEleIdx >= MARGIN_GROUP_ARRAY_ELE_CNT)) {
    ProcError(SsaServicesHandle, Failure, __FILE__, __LINE__, pCoreTestData->pTestStat);
    return 1;
  }

  // FOR each result element:
  for (EleIdx = 0; EleIdx < pCoreTestData->ResultElementCount; EleIdx++) {
    pResultElement = &(pCoreTestData->pResultElements[EleIdx]);

    // IF this is not the type of result element we're looking for THEN skip it
    if ((pResultElement->Header.IoLevel != (UINT32) pCoreTestData->CurrentIoLevel) ||
      (pResultElement->Header.ResultType != (UINT32) ResultType)) {
      continue;
    }

    Socket = (UINT8) pResultElement->Header.Socket;
    Controller = (UINT8) pResultElement->Header.Controller;
    Channel = (UINT8) pResultElement->Header.Channel;
    DimmA = (UINT8) pResultElement->Header.DimmA;
    RankA = (UINT8) pResultElement->Header.RankA;
    DimmB = (UINT8) pResultElement->Header.DimmB;
    RankB = (UINT8) pResultElement->Header.RankB;
    Lane = (UINT8) pResultElement->Header.Lane;

#if ENBL_FIXUP_DEBUG_LOG_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "\n"
      "  EleIdx=%u Socket=%u Controller=%u Channel=%u ",
      EleIdx, Socket, Controller, Channel);
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "DimmA=%u RankA=%u DimmB=%u RankB=%u Lane=%d\n",
      DimmA, RankA, DimmB, RankB, Lane);
#endif // ENBL_FIXUP_DEBUG_LOG_MSGS

    //
    if (ResultType == LaneRmtResultType) {
      // set the lane bitmasks to just this lane
      ZeroMem (LaneBitmasks, (MAX_BUS_WIDTH/8) * sizeof (UINT8));

      ByteGroup = Lane / 8;

      LaneBitmasks[ByteGroup] = (1 << (Lane % 8));
    }
    else {
      ZeroMem (LaneBitmasks, (MAX_BUS_WIDTH/8) * sizeof (UINT8));

      ByteGroup = (pCoreTestData->SystemInfo.BusWidth / 8) ;
      SetMem (LaneBitmasks, ByteGroup, 0xFF);

      for (Lane = 0; Lane < (pCoreTestData->SystemInfo.BusWidth % 8); Lane++) {
        LaneBitmasks[ByteGroup] |= 1 << Lane;
      }
    }

#if ENBL_BIOS_SSA_API_DEBUG_MSGS || ENBL_FIXUP_DEBUG_LOG_MSGS
    if (EFI_ERROR (GetGroupString (pCoreTestData->CurrentMarginGroup, &GroupString))) {
      GroupString = "Unknown group";
    }
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "  GetMarginParamLimits(\n"
      "    Socket=%u Controller=%u Channel=%u Dimm=%u Rank=%u\n"
      "    LaneBitmasks=0x",
      Socket, Controller, Channel, DimmA, RankA);
    LogByteArrayAsHex (LaneBitmasks,
      (pCoreTestData->SystemInfo.BusWidth / 8));
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      " IoLevel=%u (%a) MarginGroup=%u (%a)\n",
      pCoreTestData->CurrentIoLevel,
      GetLevelStr (pCoreTestData->CurrentIoLevel),
      pCoreTestData->CurrentMarginGroup,
      GroupString);
#endif
    RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamLimits(
      SsaServicesHandle, Socket, Controller, Channel, DimmA, RankA,
      LaneBitmasks, pCoreTestData->CurrentIoLevel,
      pCoreTestData->CurrentMarginGroup, &MinOffset, &MaxOffset, &SettleDelay,
      &StepUnit);
      if (RetStat == UnsupportedValue){
        continue;
      }
    if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__,
      pCoreTestData->pTestStat)) {
      return 1;
    }

#if ENBL_BIOS_SSA_API_DEBUG_MSGS || ENBL_FIXUP_DEBUG_LOG_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "    MinOffset=%d MaxOffset=%d SettleDelay=%u\n",
      MinOffset, MaxOffset, SettleDelay);
#endif
    // IF the result is for rank-to-rank turnarounds and the ranks are different
    if ((ResultType == TurnaroundRmtResultType) &&
      ((DimmA != DimmB) || (RankA != RankB))) {
      INT16 MinOffsetB, MaxOffsetB;

#if ENBL_BIOS_SSA_API_DEBUG_MSGS || ENBL_FIXUP_DEBUG_LOG_MSGS
      if (EFI_ERROR (GetGroupString (pCoreTestData->CurrentMarginGroup, &GroupString))) {
        GroupString = "Unknown group";
      }
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  GetMarginParamLimits(\n"
        "    Socket=%u Controller=%u Channel=%u Dimm=%u Rank=%u\n"
        "    LaneBitmasks=0x",
        Socket, Controller, Channel, DimmB, RankB);
      LogByteArrayAsHex (LaneBitmasks,
        (pCoreTestData->SystemInfo.BusWidth / 8));
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        " IoLevel=%u (%a) MarginGroup=%u (%a)\n",
        pCoreTestData->CurrentIoLevel,
        GetLevelStr (pCoreTestData->CurrentIoLevel),
        pCoreTestData->CurrentMarginGroup,
        GroupString);
#endif
      RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamLimits(
        SsaServicesHandle, Socket, Controller, Channel, DimmB, RankB,
        LaneBitmasks, pCoreTestData->CurrentIoLevel,
        pCoreTestData->CurrentMarginGroup, &MinOffsetB, &MaxOffsetB,
        &SettleDelay, &StepUnit);
      if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__,
        pCoreTestData->pTestStat)) {
        return 1;
      }

#if ENBL_BIOS_SSA_API_DEBUG_MSGS || ENBL_FIXUP_DEBUG_LOG_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "    MinOffsetB=%d MaxOffsetB=%d SettleDelay=%u\n",
        MinOffsetB, MaxOffsetB, SettleDelay);
#endif
      // IF rank A's minimum offset is outside rank B's minimum offset THEN
      if (MinOffset < MinOffsetB) {
        // use rank B's value
        MinOffset = MinOffsetB;
      }

      // IF rank A's maximum offset is outside rank B's maximum offset THEN
      if (MaxOffset > MaxOffsetB) {
        // use rank B's value
        MaxOffset = MaxOffsetB;
      }
    } // end if the result is for rank-to-rank turnarounds and ...

    // FOR both shmoo directions:
    for (ShmooDirIdx = 0; ShmooDirIdx <= 1; ShmooDirIdx++) {
      // IF this shmoo direction doesn't match the given shmoo direction THEN skip it
      if (((ShmooDir == LoDirection) && (ShmooDirIdx != 0)) ||
        ((ShmooDir == HiDirection) && (ShmooDirIdx != 1))) {
        continue;
      }

      // IF the shmoo direction is the low side
      if (ShmooDirIdx == 0) {
        LimitOffset = (UINT8) ABS(MinOffset);
      }
      else {
        LimitOffset = (UINT8) MaxOffset;
      }

#if ENBL_FIXUP_DEBUG_LOG_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  ShmooDirIdx=%u MarginOffset=%u LimitOffset=%u\n",
        ShmooDirIdx, pResultElement->Margin[MarginGroupEleIdx][ShmooDirIdx], LimitOffset);
#endif // ENBL_FIXUP_DEBUG_LOG_MSGS

      // IF the corresponding margin value is above the limit value
      if (pResultElement->Margin[MarginGroupEleIdx][ShmooDirIdx] > LimitOffset) {
#if ENBL_FIXUP_DEBUG_LOG_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "Fixing up result Index=%u Socket=%u Controller=%u Channel=%u ",
          EleIdx, Socket, Controller, Channel);
        if (ResultType == TurnaroundRmtResultType) {
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "DimmA=%u RankA=%u DimmB=%u RankB=%u:\n",
            DimmA, RankA, DimmB, RankB);
        }
        else {
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "Dimm=%u Rank=%u", DimmA, RankA);

          if (ResultType == LaneRmtResultType) {
            NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
              " Lane=%u:\n", Lane);
          }
          else {
            NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, ":\n");
          }
        }
        if (ShmooDir == 0) {
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            " Offset=%u MinOffset=%u\n",
            pResultElement->Margin[MarginGroupEleIdx][ShmooDirIdx], LimitOffset);
        }
        else {
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            " Offset=%u MaxOffset=%u\n",
            pResultElement->Margin[MarginGroupEleIdx][ShmooDirIdx], LimitOffset);
        }
#endif // ENBL_FIXUP_DEBUG_LOG_MSGS

        // use the limit value instead
        pResultElement->Margin[MarginGroupEleIdx][ShmooDirIdx] = LimitOffset;
      }
    } // end for both shmoo directions
  } // end for each result element

  return 0;
} // end function FixupResults
#endif // SUPPORT_FOR_EXTENDED_RANGE

/**
@brief
  This function performs JEDEC initializations at the end of the test to ensure
  the DIMMs are left in a functional state.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to core test data structure.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 CleanupJedecInit(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData)
{
  UINT8 Socket, Controller;
#if SUPPORT_FOR_DDRT
  PSYSHOST Host = GetSysHostPointer ();
  UINT8 Channel, Dimm;
#endif // SUPPORT_FOR_DDRT
  BOOLEAN IsLastRankCombination;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "CleanupJedecInit()\n");
#endif

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // IF the controller is not enabled for testing THEN skip it
      if (!IsControllerTestingEnabled(SsaServicesHandle,
        &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
        &pCoreTestData->CurrentMemPointTestCfg,
#else
        &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
        Socket, Controller)) {
        continue;
      }

#if ENBL_BIOS_SSA_API_DEBUG_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  IoReset(Socket=%u Controller=%u)\n",
        Socket, Controller);
#endif
      SsaServicesHandle->SsaMemoryConfig->IoReset(SsaServicesHandle,
        Socket, Controller);
    } // end for each controller
  } // end for each socket

#if SUPPORT_FOR_DDRT
  // IF there are DDR-T devices
  if (SSAIsDdrtDimmPresent (Host)) {
    // FOR each socket:
    for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
      // IF the socket is not enabled for testing THEN skip it
      if (!IsSocketTestingEnabled(SsaServicesHandle,
        &pCoreTestData->SystemInfo,
#if SUPPORT_FOR_EXTENDED_RANGE
        &pCoreTestData->CurrentMemPointTestCfg,
#else
        &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
        Socket)) {
        continue;
      }

      // do an AEP IO reset if the dimm is AEP dimm.
      // FOR each controller:
      for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
        // FOR each channel:
        for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
          // IF the channel is not enabled for testing THEN skip it
          if (!IsChannelTestingEnabled(SsaServicesHandle,
            &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
            &pCoreTestData->CurrentMemPointTestCfg,
#else
            &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
            Socket, Controller, Channel)) {
            continue;
          }

          // FOR each DIMM
          for (Dimm = 0; Dimm < MAX_DIMM_CNT; Dimm++) {
            // IF this DIMM isn't DDR-T THEN skip it
            if (((pCoreTestData->MemCfg.DimmBitmasks[Socket][Controller][Channel] & (1 << Dimm)) == 0) ||
              (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm] != SsaMemoryDdrT)) {
              continue;
            }

#if ENBL_BIOS_SSA_API_DEBUG_MSGS || ENBL_DDRT_DEBUG_LOG_MSGS
            NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
              "  AepIoReset(Socket=%u Controller=%u Channel=%u Dimm=%u)\n",
              Socket, Controller, Channel, Dimm);
#endif
            SsaServicesHandle->SsaMemoryDdrtConfig->AepIoReset(
              SsaServicesHandle, Socket, Controller, Channel, Dimm);
          } // end for each DIMM
        } // end for each channel
      } // end for each controller

      // do FIFO train reset
#if ENBL_BIOS_SSA_API_DEBUG_MSGS || ENBL_DDRT_DEBUG_LOG_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  ResetAepFifoTrain(Socket=%u)\n", Socket);
#endif
      SsaServicesHandle->SsaMemoryDdrtConfig->ResetAepFifoTrain(
        SsaServicesHandle, Socket);
    } // end for each socket
  } // end if there are DDR-T devices present
#endif // SUPPORT_FOR_DDRT

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // IF the controller is not enabled for testing THEN skip it
      if (!IsControllerTestingEnabled(SsaServicesHandle,
        &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
        &pCoreTestData->CurrentMemPointTestCfg,
#else
        &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
        Socket, Controller)) {
        continue;
      }
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  JedecReset(Socket=%u Controller=%u)\n",
        Socket, Controller);
#endif
      SsaServicesHandle->SsaMemoryConfig->JedecReset(
        SsaServicesHandle, Socket, Controller);
    } // end for each controller
  } // end for each socket

  // restore the CPGC engine programming after JEDEC init
  IsLastRankCombination = TRUE;
  if (PostDimmInitHandler(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CurrentMemPointTestCfg,
#else
    &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
    pCoreTestData->pTestCfg, pCoreTestData, IsLastRankCombination,
    pCoreTestData->pTestStat)) {
    return 1;
  }

  return 0;
} // end function CleanupJedecInit

/**
  This function is used to run the Margin1D test.

  The ShmooDirCount and pShmooDirs input parameters are to support the fact
  that the backside command margining needs to test the different shmoo
  directions separately.

  @param[in, out]  SsaServicesHandle    Pointer to SSA services.
  @param[in, out]  pCoreTestData        Pointer to RMT core test data.
  @param[in]       LaneShmooStopMode    Lane shmoo stop mode.
  @param[in]       ShmooDirCount        Number of entries in pShmooDirs array.
  @param[in]       pShmooDirs           Pointer to array of shmoo direction values.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 RunRmtMargin1D(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN SHMOO_STOP_MODE LaneShmooStopMode,
  IN UINT8 ShmooDirCount,
  IN CONST SHMOO_DIRECTION *pShmooDirs)
{
  UINT8 ShmooDirIdx;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.RunRmtMargin1D(LaneShmooStopMode=%u)\n",
    LaneShmooStopMode);
#endif
#if SUPPORT_FOR_EXTENDED_RANGE
  if (InitCurrentMemPointTestCfg(SsaServicesHandle, pCoreTestData)) {
    return 1;
  }
#endif // SUPPORT_FOR_EXTENDED_RANGE

#ifdef __STUB__
  // confirm design assumption that DDR is 0 while DDRT is 1 in the RMT core test data
  // UINT8 LimitOffsets[MemTechMax][RmtShmooDirMax]; // 0: DDR; 1: DDRT.
  ASSERT (DDR == 0);
  ASSERT (DDRT == 1);
#endif // __STUB__

  // initialize the shmoo test configuration
  if (InitMemShmooCfg(SsaServicesHandle, pCoreTestData, LaneShmooStopMode)) {
    return 1;
  }

  // setup the shmoo test
  if (SetupMemShmoo(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg, &pCoreTestData->MemShmooCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CurrentMemPointTestCfg,
#else
    &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
    pCoreTestData->GetPointTestDimmRanks,
    pCoreTestData->SetPointTestInBinarySearchState,
    pCoreTestData->RunPointTest, MarginParamChgHandler, NULL,
    PostDimmInitHandler, NULL, pCoreTestData->pTestCfg, pCoreTestData,
    pCoreTestData->pTestCfg->TestStatusLogLevel,
    &pCoreTestData->pMemShmooData, pCoreTestData->pTestStat)) {
    return 1;
  }

  // Save the Min/Max offset per memory technology to CoreTestData, and fill up the
  // metadata later. The pMemShmooData would be invalid once CleanupMemShmoo() is called.
  pCoreTestData->LimitOffsets[DDR][LoRmtShmooDir] = (UINT8)ABS(GetMemShmooMinOffsetByMemoryTech(FALSE, pCoreTestData->pMemShmooData));
  pCoreTestData->LimitOffsets[DDR][HiRmtShmooDir] = (UINT8)ABS(GetMemShmooMaxOffsetByMemoryTech(FALSE, pCoreTestData->pMemShmooData));

#if SUPPORT_FOR_DDRT
  if (HasDdrtDevicesValEnabled(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg, &pCoreTestData->CurrentMemPointTestCfg)) {
    pCoreTestData->LimitOffsets[DDRT][LoRmtShmooDir] = (UINT8)ABS(GetMemShmooMinOffsetByMemoryTech(TRUE, pCoreTestData->pMemShmooData));
    pCoreTestData->LimitOffsets[DDRT][HiRmtShmooDir] = (UINT8)ABS(GetMemShmooMaxOffsetByMemoryTech(TRUE, pCoreTestData->pMemShmooData));
  }
#endif // SUPPORT_FOR_DDRT

  // FOR all the given shmoo directions:
  for (ShmooDirIdx = 0; ShmooDirIdx < ShmooDirCount; ShmooDirIdx++) {
    // we need to run separate Margin1D tests for each shmoo direction so
    // that we can know the shmoo direction and process the results accordingly
    pCoreTestData->MemShmooCfg.ShmooDirection = \
      pCoreTestData->CurrentShmooDirection = \
      pShmooDirs[ShmooDirIdx];

    if (RunMargin1D(SsaServicesHandle, &pCoreTestData->SystemInfo,
      &pCoreTestData->MemCfg, &pCoreTestData->MemShmooCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
      &pCoreTestData->CurrentMemPointTestCfg,
#else
      &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
      &pCoreTestData->CpgcPointTestCfg, pCoreTestData->pMemShmooData,
      pCoreTestData->pCpgcPointTestData, pCoreTestData->pTestStat)) {
      return 1;
    }

    // perform cleanup JEDEC initializations (if required)
    if (IsJedecInitAfterErrRequired( SsaServicesHandle,
      &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
      &pCoreTestData->CurrentMemPointTestCfg,
#else
      &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
      pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentMarginGroup)) {
      if (CleanupJedecInit(SsaServicesHandle, pCoreTestData)) {
        return 1;
      }
    }
  } // end for all the given shmoo directions

  // clean up the shmoo test
  if (CleanupMemShmoo(SsaServicesHandle, &pCoreTestData->SystemInfo,
    &pCoreTestData->MemCfg, &pCoreTestData->MemShmooCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CurrentMemPointTestCfg,
#else
    &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->pMemShmooData, pCoreTestData->pTestStat)) {
    return 1;
  }

  return 0;
} // end function RunRmtMargin1D

//
// These code are applicable only to use generic 1D sweep.
// The PCD is enabled only for the SPR and later products
//
#if FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 1
/**
  This function is used to update the current targted DIMM/RANK of the core test data.
  The info is needed when report test results and set up the 1D sweep

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.

  @retval  0  success
  @retval  1  error occurred
**/
STATIC
UINT8
UpdateTargetedDimmRank (
  IN     SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA    *pCoreTestData
  )
{
  UINT8 Socket;
  UINT8 Controller;
  UINT8 Channel;
  UINT8 PairCount = 1;
  DIMM_RANK_PAIR DimmRankPair;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.UpdateTargetedDimmRank()\n");
#endif


  for (Socket = 0; Socket < MAX_SOCKET; Socket++) {

    for (Controller = 0; Controller < MAX_IMC; Controller++) {

      for (Channel = 0; Channel < MAX_MC_CH; Channel++) {
        // IF this channel is not enabled for validation THEN skip it
        if (!IsChannelTestingEnabled (SsaServicesHandle, &pCoreTestData->SystemInfo,
          &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg,
          Socket, Controller, Channel)) {
          continue;
        }

        if (GetCpgcPointTestDimmRanks (SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg, pCoreTestData->pCpgcPointTestData, Socket,
          Controller, Channel, &PairCount, &DimmRankPair,
          pCoreTestData->pTestStat)) {
          return 1;
        }

        pCoreTestData->DimmRankAs[Socket][Controller][Channel].Dimm = DimmRankPair.Dimm;
        pCoreTestData->DimmRankAs[Socket][Controller][Channel].Rank = DimmRankPair.Rank;
      } // end for each channel
    } // end for each controller
  } // end for each socket

  return 0;
} // end function UpdateTargetedDimmRank

/**
  This function is used to get the current targted DIMM/RANK from the core test data.
  The info is needed to report test results and set up the 1D sweep

  @param[in ]  SsaServicesHandle  Pointer to SSA services.
  @param[in ]  pCoreTestData      Pointer to RMT core test data.
  @param[in ]  Socket             Socket number
  @param[out]  DimmRank           Pointer to the Dimm/rank array

**/
STATIC
VOID
GetTargetedDimmRank (
  IN  SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN  RMT_CORE_TEST_DATA    *pCoreTestData,
  IN  UINT8                  Socket,
  OUT MRC_RT                (*DimmRank)[MAX_CH]
  )
{
  UINT8 Controller;
  UINT8 Channel;
  UINT8 ChannelInSocket;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.GetTargetedDimmRank()\n");
#endif

  ZeroMem (DimmRank, sizeof (*DimmRank));

  for (Controller = 0; Controller < MAX_IMC; Controller++) {

    for (Channel = 0; Channel < MAX_MC_CH; Channel++) {
      // IF this channel is not enabled for validation THEN skip it
      if (!IsChannelTestingEnabled (SsaServicesHandle, &pCoreTestData->SystemInfo,
        &pCoreTestData->MemCfg,
        &pCoreTestData->SelectMemPointTestCfg,
        Socket, Controller, Channel)) {
        continue;
      }

      ChannelInSocket = MAX_MC_CH * Controller + Channel;
      (*DimmRank)[ChannelInSocket].Dimm = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Dimm;
      (*DimmRank)[ChannelInSocket].Rank = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Rank;
    } // end for each channel
  } // end for each controller

} // end function  GetTargetedDimmRank

/**
  This function is used to get the channel mask for the 1D Sweep parameter

  @param[in ]  SsaServicesHandle    Pointer to SSA services.
  @param[in ]  pCoreTestData        Pointer to RMT core test data.
  @param[in ]  Socket               Socket number

  Retval Channel mask
**/
STATIC
UINT32
Get1DSweepChannelMask (
  IN  SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN  RMT_CORE_TEST_DATA    *pCoreTestData,
  IN  UINT8                  Socket
  )
{
  UINT32 ChannelMask;
  UINT8  Controller;
  UINT8  Channel;

  ChannelMask = 0;

  for (Controller = 0; Controller < MAX_IMC; Controller++) {

    for (Channel = 0; Channel < MAX_MC_CH; Channel++) {
      // IF this channel is not enabled for validation THEN skip it
      if (!IsChannelValEnabled (SsaServicesHandle, &pCoreTestData->SystemInfo,
        &pCoreTestData->MemCfg,
        &pCoreTestData->CurrentMemPointTestCfg,
        Socket, Controller, Channel)) {
        continue;
      }

      ChannelMask |= 1 << (MAX_MC_CH * Controller + Channel);
    } // Channel
  } // Controller

  return ChannelMask;
}

/**
  This function is used to initialize the 1D Sweep parameter

  @param[in]       SsaServicesHandle    Pointer to SSA services.
  @param[in]       pCoreTestData        Pointer to RMT core test data.
  @param[in]       LaneShmooStopMode    Lane shmoo stop mode.
  @param[in]       Direction            Shmoo direction.
  @param[out]      CommonParamaters     Pointer to the 1D sweep context information

**/
STATIC
VOID
InitializeRmt1DSweepParameter (
  IN  SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN  RMT_CORE_TEST_DATA    *pCoreTestData,
  IN  UINT8                  Socket,
  IN  SHMOO_STOP_MODE        LaneShmooStopMode,
  IN  SHMOO_DIRECTION        Direction,
  OUT COMMON_1D_PARAMETERS  *CommonParameters
)
{
  UINT32                  ChannelBitMask;
  MRC_RT                  DimmRank[MAX_CH];
  MRC_LT                  Level;
  MRC_GT                  Group;
  MRC_MST                 MemSsType;
  UINT8                   StepSize;
  UINT8                   DitherValue;
  INT16                   OffsetLeft;
  INT16                   OffsetRight;
  INT16                   LimitOffset;
  FLAGS_CATEGORY_OFFSETS  FlagsOffsets;
  FLAGS_CATEGORY_RESULTS  FlagsResults;
  FLAGS_CATEGORY_FSM      FlagsFsm;

  MemSsType = GetSysCpuCsrAccessVar ()->MemSsType[Socket];

  //
  // Get the Channel mask
  //
  ChannelBitMask = Get1DSweepChannelMask (SsaServicesHandle, pCoreTestData, Socket);

  //
  // Get the list of DIMM/RANK
  //
  GetTargetedDimmRank (SsaServicesHandle, pCoreTestData, Socket, &DimmRank);

  //
  // Get margin parameter
  //
  Level = pCoreTestData->CurrentIoLevel;
  Group = pCoreTestData->CurrentMarginGroup;
  StepSize = GetStepSize (pCoreTestData->pTestCfg, pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentMarginGroup);

  DitherValue = 1;

  OffsetLeft = -1;
  OffsetRight = 0;
  LimitOffset = DQ_MARGIN_OFFSET_LIMIT;

  //
  // Flags
  //
  FlagsOffsets = DefaultStartOffset | LimitSearch;
  FlagsResults = ResultsPerBit | ResultsRelative;
  
  //
  // DB DFE Vref can only be tested one bit a time, essentially the result is per byte.
  //
  // There is one and only one bit in each of the byte group responds to the DFE Vref change,
  // because the result is tracked per byte, there is no need to know how the DB nibbles are
  // swapped and how the DQs are swizzled.
  //
  if ((Group >= DbDfeVrefDq0) && (Group <= DbDfeVrefDq7)) {
    FlagsResults = ResultsRelative;
  }

  //
  // Margin to the first error for Cmd/Ctl
  //
  if ((Group == DramCaVref) || (Group == DramCsVref)) {
    FlagsResults |= ResultsPerSubChannel;
  }

  if (Direction == LoDirection) {
    FlagsFsm = LeftSideOnly;
  } else if (Direction == HiDirection) {
    FlagsFsm = RightSideOnly;
  } else {
    FlagsFsm = DefaultFsm; // both side.
  }

  CreateContextParameters (CommonParameters, MemSsType, Socket, ~ChannelBitMask, 0, ALL_SUBCH, DimmRank, Level, Group, gsmCsnDelim,
    StepSize, DitherValue, OffsetLeft, OffsetRight, LimitOffset, FlagsOffsets, FlagsResults, FlagsFsm);
}

/**
  This function to save the 1D Sweep result into RMT core test data

  @param[in ]  SsaServicesHandle    Pointer to SSA services.
  @param[in ]  CommonParamaters     Pointer to the 1D sweep context information
  @param[in ]  pCoreTestData        Pointer to RMT core test data.
  @param[in ]  Socket               Socket number
  @param[in]   Direction            Shmoo direction.
  @param[in]   Results              Pointer to the 1D sweep result structure
**/
STATIC
VOID
Save1DSweepResult (
  IN     SSA_BIOS_SERVICES_PPI   *SsaServicesHandle,
  IN     COMMON_1D_PARAMETERS    *CommonParameters,
  IN OUT RMT_CORE_TEST_DATA      *pCoreTestData,
  IN     UINT8                   Socket,
  IN     SHMOO_DIRECTION         ShmooDir,
  IN     RESULTS_1D              *Results
  )
{
  UINT8             Controller;
  UINT8             Channel;
  UINT8             Bit;
  UINT8             Knob;
  INT16             Margin;
  INT16             MinMarginOfAllKnobs;
  MRC_GT            Group;
  BOOLEAN           IsResultPerByte = FALSE;
  UINT8             DqBitForTest = 0;    // DQ bit index inside a byte group
  UINT8             StrobeLogical;
  struct baseMargin *BitMargin;

  Group = pCoreTestData->CurrentMarginGroup;

  //
  // DB DFE Vref can only be tested one bit a time, essentially the result is per byte. All other signals' results
  // are per bit.
  //
  if ((Group >= DbDfeVrefDq0) && (Group <= DbDfeVrefDq7)) {
    IsResultPerByte = TRUE;
    DqBitForTest = (UINT8)(Group - DbDfeVrefDq0);
  }

  for (Controller = 0; Controller < MAX_IMC; Controller++) {
    for (Channel = 0; Channel < MAX_MC_CH; Channel++) {
      if (!IsChannelValEnabled (SsaServicesHandle, &pCoreTestData->SystemInfo,
        &pCoreTestData->MemCfg,
        &pCoreTestData->CurrentMemPointTestCfg,
        Socket, Controller, Channel)) {
        continue;
      }

      for (Bit =0; Bit < MAX_BITS; Bit++) {

        //
        // IsResultPerByte is TRUE for the DbDfeVrefDq0-7 groups.
        // Only keep the bit corresponds to this DFE VRef group and skip all other bits in the byte group.
        //
        if (IsResultPerByte && ((Bit % MAX_BITS_IN_BYTE) != DqBitForTest)) {
          continue;
        }

        MinMarginOfAllKnobs = MAX_INT16;

        for (Knob = 0; Knob < CommonParameters->KnobsPerGroup; Knob++) {

          if (IsResultPerByte) {
            //
            // For the bit corresponds to the DfeVrefDq0-7 group, find the byte margin and used as its per bit margin
            //
            StrobeLogical = GetLogicalStrobeFromBit (CommonParameters, Bit);
            BitMargin = GetResultPtrAtStrobeLevel (CommonParameters, Knob, (Controller * MAX_MC_CH + Channel), StrobeLogical, Results);

          } else {
            BitMargin = GetResultPtrAtRawBitLevel (CommonParameters, Knob, (Controller * MAX_MC_CH + Channel), Bit, Results);
          }


          if (ShmooDir == LoDirection) {
            Margin = BitMargin->n;
            //
            // Treat margin result as 0 if there was margin eye outside the nominal/trained setting.
            //
            if (Margin > 0) {
              Margin = 0;
            }
            Margin = -1 * Margin; // BSSA use absoulte value.
          } else {
            Margin = BitMargin->p;
            //
            // Treat margin result as 0 if there was margin eye outside the nominal/trained setting.
            //
            if (Margin < 0) {
              Margin = 0;
            }
          }

          if (Margin < MinMarginOfAllKnobs) {
            MinMarginOfAllKnobs = Margin;
          }
        } // Knob

        pCoreTestData->LastPassLaneOffsets[ShmooDir][Socket][Controller][Channel][Bit] = (UINT8) MinMarginOfAllKnobs;
        pCoreTestData->LastPassFoundMasks[ShmooDir][Socket][Controller][Channel][Bit / 8] |= 1 << (Bit % 8);
      } //Bit
    } // Channel
  } // Controller
}

/**
  This function to save the 1D Sweep result into RMT core test data when test run in CA CS training mode

  @param[in ]  SsaServicesHandle    Pointer to SSA services.
  @param[in ]  pCoreTestData        Pointer to RMT core test data.
  @param[in ]  Socket               Socket number
  @param[in]   Direction            Shmoo direction.
  @param[in]   Results              Pointer to the 1D sweep result structure
**/
STATIC
VOID
Save1DSweepResultInCaCsTrainingMode (
  IN     SSA_BIOS_SERVICES_PPI   *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA      *pCoreTestData,
  IN     UINT8                   Socket,
  IN     SHMOO_DIRECTION         ShmooDir,
  IN     struct baseMargin       Margins[MAX_CH][SUB_CH]
  )
{
  UINT8 Controller;
  UINT8 Channel;
  UINT8 SubChannel;
  UINT8 Lane;
  UINT8 NumSubCh;
  UINT8 SubChMaxBit;
  INT16 Margin;

  GetSubChInfo (pCoreTestData->SystemInfo.BusWidth, &NumSubCh, &SubChMaxBit);

  for (Controller = 0; Controller < MAX_IMC; Controller++) {
    for (Channel = 0; Channel < MAX_MC_CH; Channel++) {
      if (!IsChannelValEnabled (SsaServicesHandle, &pCoreTestData->SystemInfo,
        &pCoreTestData->MemCfg,
        &pCoreTestData->CurrentMemPointTestCfg,
        Socket, Controller, Channel)) {
        continue;
      }

      for (SubChannel = 0; SubChannel < NumSubCh; SubChannel++) {
        if (ShmooDir == LoDirection) {
          Margin = -1 * Margins[Controller * MAX_MC_CH + Channel][SubChannel].n; // BSSA use absoulte value.
        } else {
          Margin = Margins[Controller * MAX_MC_CH + Channel][SubChannel].p;
        }

        for (Lane = SubChannel * SubChMaxBit; Lane < (SubChannel + 1) * SubChMaxBit; Lane++) {
          pCoreTestData->LastPassLaneOffsets[ShmooDir][Socket][Controller][Channel][Lane] = (UINT8)Margin;
          pCoreTestData->LastPassFoundMasks[ShmooDir][Socket][Controller][Channel][Lane / 8] |= 1 << (Lane % 8);
        } //Lane
      } //SubChannel
    } // Channel
  } // Controller
}

/**
  This function is used to run the Margin1D test.

  The ShmooDirCount and pShmooDirs input parameters are to support the fact
  that the backside command margining needs to test the different shmoo
  directions separately.

  @param[in, out]  SsaServicesHandle    Pointer to SSA services.
  @param[in, out]  pCoreTestData        Pointer to RMT core test data.
  @param[in]       LaneShmooStopMode    Lane shmoo stop mode.
  @param[in]       ShmooDirCount        Number of entries in pShmooDirs array.
  @param[in]       pShmooDirs           Pointer to array of shmoo direction values.

  @retval  0  success
  @retval  1  error occurred
**/
STATIC
UINT8
RunRmtMargin1DWith1DSweep (
  IN  SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN  RMT_CORE_TEST_DATA    *pCoreTestData,
  IN  SHMOO_STOP_MODE        LaneShmooStopMode,
  IN  UINT8                  ShmooDirCount,
  IN  SHMOO_DIRECTION       *pShmooDirs
  )
{
  UINT8       ShmooDirIdx;
  UINT8       Socket;
  RESULTS_1D  Results;
  Callback1D  Pre1DSweepHandler;
  Callback1D  Post1DSweepHandler;
  Callback1D  ResultProcessor;
  Callback1D  ErrorHandler;
  MRC_LT      MarginGroup;
  RMT_MARGIN_1D_PARAMETER Rmt1DSweep;

  //
  // Used in debug
  //
  //UINT32      PrevDebugLevel;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.RunRmtMargin1DWith1DSweep(LaneShmooStopMode=%u)\n",
    LaneShmooStopMode);
#endif

  if (InitCurrentMemPointTestCfg (SsaServicesHandle, pCoreTestData)) {
    return 1;
  }

  //
  // Initialize RMT specific private data.
  //
  Rmt1DSweep.SsaServicesHandle = SsaServicesHandle;
  Rmt1DSweep.CoreTestData = pCoreTestData;

  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {

    if ((pCoreTestData->CurrentMemPointTestCfg.SocketBitmask & (1 << Socket)) == 0) {
      continue;
    }

    for (ShmooDirIdx = 0; ShmooDirIdx < ShmooDirCount; ShmooDirIdx++) {

      //
      // Initialize 1D sweep context parameter
      //
      InitializeRmt1DSweepParameter (SsaServicesHandle, pCoreTestData, Socket, LaneShmooStopMode,
        pShmooDirs[ShmooDirIdx], &Rmt1DSweep.CommonParameters);

      AllocatePoolForResults1D (&Rmt1DSweep.CommonParameters, &Results);

      //
      // Update callback functions
      //
      Pre1DSweepHandler = RmtPre1DSweep;
      Post1DSweepHandler = RmtPost1DSweep;
      ResultProcessor = ResultProcessingAdvance;
      ErrorHandler = NULL;

      MarginGroup = (&Rmt1DSweep.CommonParameters)->Group;

      if (IsErrorRecoverRequired (MarginGroup)) {
        ErrorHandler = ErrorHandlerAdvanceCmdCtl;
      } 

      //
      // Used in debug. Enable sweep debug log
      //
      //PrevDebugLevel = GetDebugLevel ();
      //(&Rmt1DSweep.CommonParameters)->DebugLevel |= SDBG_SWEEP_L3 | SDBG_SWEEP_L2 | SDBG_SWEEP_L1 |SDBG_SWEEP_L0;
      //SetDebugLevel (SDBG_SWEEP_L3 | SDBG_SWEEP_L2 | SDBG_SWEEP_L1 |SDBG_SWEEP_L0 |PrevDebugLevel);

      ProcessSweep1D (&Rmt1DSweep.CommonParameters, Pre1DSweepHandler, RmtSetupTest, RmtExecuteTest, ErrorHandler, Post1DSweepHandler, ResultProcessor, &Results);

      //
      // Save 1D sweep result to RMT
      //
      Save1DSweepResult (SsaServicesHandle, &Rmt1DSweep.CommonParameters, pCoreTestData, Socket, pShmooDirs[ShmooDirIdx], &Results);

      //
      // Used in debug. Restore debug level
      //
      //SetDebugLevel (PrevDebugLevel);

      ReleaseResources1D (&Rmt1DSweep.CommonParameters, &Results);

    }//ShmooDir
  }// Socket

  return 0;
} // end function RunRmtMargin1DWith1DSweep

/**
  This function returns if the RCD DCA margin test on a given Dimm/Rank can be skipped or not.

  When margining the DcaDealy, RcdDcaVref and DcaDfeVref, only the first rank should be tested because the DCA
  and PAR are only sampled by DCS_0.

  Skip when all the targeted ranks of all the enabled channels are not 0s.

  @param[in]  Group                Margin group
  @param[in]  ChannelBitMask       Enabled channels in bit mask format
  @param[in]  DimmRank             Pointer to the Dimm/rank array

  @retval  TRUE - skip
**/
STATIC
BOOLEAN
SkipRcdDcaForTargetedRank (
  IN MRC_GT   Group,
  IN UINT32   ChannelBitMask,
  IN MRC_RT   (*DimmRank)[MAX_CH]
  )
{
  UINT8   ChannelIndex;
  UINT8   MaxChDdr;
  BOOLEAN Skip = TRUE;

  if ((Group != DcaDelay) && (Group != RcdDcaVref) && (Group != DcaDfeVref) && (Group != BcomDelay) && (Group != BcomVref)) {
    Skip = FALSE;
  }

  if (DimmRank == NULL) {
    Skip = FALSE;
    return Skip;
  }

  MaxChDdr = GetMaxChDdr ();

  for (ChannelIndex = 0; ChannelIndex < MaxChDdr; ChannelIndex++) {
    if (!(ChannelBitMask & (0x1 << ChannelIndex))) {
      continue;
    }
    if ((*DimmRank)[ChannelIndex].Rank == 0) {
      Skip = FALSE;
      break;
    }
  }

  return Skip;
}
/**
  This function runs the Margin1D test for Cmd/Ctl in CA or CS training mode.

  The ShmooDirCount and pShmooDirs input parameters are to support the fact
  that the backside command margining needs to test the different shmoo
  directions separately.

  @param[in, out]  SsaServicesHandle    Pointer to SSA services.
  @param[in, out]  pCoreTestData        Pointer to RMT core test data.
  @param[in]       LaneShmooStopMode    Lane shmoo stop mode.
  @param[in]       ShmooDirCount        Number of entries in pShmooDirs array.
  @param[in]       pShmooDirs           Pointer to array of shmoo direction values.

  @retval  0  success
  @retval  1  error occurred
**/
STATIC
UINT8
RunRmtMargin1DWith1DSweepInCaCsTrainingMode (
  IN  SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN  RMT_CORE_TEST_DATA    *pCoreTestData,
  IN  SHMOO_STOP_MODE        LaneShmooStopMode,
  IN  UINT8                  ShmooDirCount,
  IN  SHMOO_DIRECTION       *pShmooDirs
  )
{
  UINT8                   ShmooDirIdx;
  UINT8                   Socket;
  UINT32                  ChannelBitMask;
  MRC_RT                  DimmRank[MAX_CH];
  MRC_LT                  Level;
  MRC_GT                  Group;
  UINT8                   StepSize;
  struct baseMargin       Margins[MAX_CH][SUB_CH];

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.RunRmtMargin1DWith1DSweepInCaCsTrainingMode(LaneShmooStopMode=%u)\n",
    LaneShmooStopMode);
#endif

  ZeroMem (Margins, sizeof (Margins));

  if (InitCurrentMemPointTestCfg (SsaServicesHandle, pCoreTestData)) {
    return 1;
  }

  //
  // Get margin parameter
  //
  Level = pCoreTestData->CurrentIoLevel;
  Group = pCoreTestData->CurrentMarginGroup;
  StepSize = GetStepSize (pCoreTestData->pTestCfg, pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentMarginGroup);


  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {

    if ((pCoreTestData->CurrentMemPointTestCfg.SocketBitmask & (1 << Socket)) == 0) {
      continue;
    }

    //
    // Get the Channel mask
    //
    ChannelBitMask = Get1DSweepChannelMask (SsaServicesHandle, pCoreTestData, Socket);

    //
    // Get the list of DIMM/RANK
    //
    GetTargetedDimmRank (SsaServicesHandle, pCoreTestData, Socket, &DimmRank);

    //
    // When margin the DcaDealy, RcdDcaVref and DcaDfeVref, only the first rank should be tested because the DCA
    // and PAR are only sampled by DCS_0.
    //
    if (SkipRcdDcaForTargetedRank (Group, ChannelBitMask, &DimmRank)) {
      NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
          "Skip. Only the first rank is tested in CA training mode.\n");
      continue;
    }

    for (ShmooDirIdx = 0; ShmooDirIdx < ShmooDirCount; ShmooDirIdx++) {

      CaCsMarginsWorker (&pCoreTestData->CpgcPointTestCfg, Socket, ~ChannelBitMask, DimmRank, Level, Group, (UINT8)pShmooDirs[ShmooDirIdx], StepSize, Margins);
      Save1DSweepResultInCaCsTrainingMode (SsaServicesHandle, pCoreTestData, Socket, pShmooDirs[ShmooDirIdx], Margins);

    }//ShmooDir
  }// Socket

  return 0;
} // end function RunRmtMargin1DWith1DSweepInCaCsTrainingMode

#endif   // FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 1

/**
  The function is used to get the next result element.  This function also
  zeros the result element content and increments the count of used result
  elements in the RMT core test data structure.

  @param[in, out]  SsaServicesHandle   Pointer to SSA services.
  @param[in, out]  pCoreTestData       Pointer to RMT core test data.
  @param[in]       DefaultMarginValue  Default value for the Margin field values.
  @param[out]      ppElement           Pointer to pointer to result element.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 GetNextResultElement(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN UINT8 DefaultMarginValue,
  OUT RMT_RESULT_COLUMNS **ppElement)
{
  SSA_STATUS RetStat;

#if ENBL_BIOS_SSA_API_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  GetNextResultElement()\n");
#endif
  RetStat = SsaServicesHandle->SsaResultsConfig->GetNextResultElement(
    SsaServicesHandle, ppElement);
  if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__,
    pCoreTestData->pTestStat)) {
    return 1;
  }

  // IF this is the first result element:
  if (pCoreTestData->ResultElementCount == 0) {
    pCoreTestData->pResultElements = *ppElement;
  }

  pCoreTestData->ResultElementCount++;

  ZeroMem (&(*ppElement)->Header, sizeof ((*ppElement)->Header));
  SetMem (&(*ppElement)->Margin, sizeof ((*ppElement)->Margin), DefaultMarginValue);

  return 0;
} // end function GetNextResultElement

/**
  This function is used to find the columnar result element associated with the
  given values.  If the element doesn't exist then NULL is returned.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       ResultType         Result type.
  @param[in]       IoLevel            I/O level.
  @param[in]       IsDdrT             Flag indicating whether result is for DDR-T.
  @param[in]       Socket             Zero based CPU socket number.
  @param[in]       Controller         Zero based memory controller number.
  @param[in]       Channel            Zero based memory channel number.
  @param[in]       DimmA              Zero based first DIMM number.
  @param[in]       RankA              Zero based first DIMM number.
  @param[in]       DimmB              Zero based second DIMM number.
  @param[in]       RankB              Zero based second DIMM number.
  @param[in]       Lane               Zero based lane number.

  @retval  Pointer to the result element or NULL is the element doesn't exist.
**/
static RMT_RESULT_COLUMNS *FindResultElement(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN RMT_RESULT_TYPE ResultType,
  IN MRC_LT IoLevel,
  IN BOOLEAN IsDdrT,
  IN UINT8 Socket,
  IN UINT8 Controller,
  IN UINT8 Channel,
  IN UINT8 DimmA,
  IN UINT8 RankA,
  IN UINT8 DimmB,
  IN UINT8 RankB,
  IN UINT8 Lane)
{
  UINT32 EleIdx;
  RMT_RESULT_COLUMNS *pElement = NULL;
  BOOLEAN ElementFound = FALSE;

  // FOR each result element:
  for (EleIdx = 0; EleIdx < pCoreTestData->ResultElementCount; EleIdx++) {
    pElement = &pCoreTestData->pResultElements[EleIdx];

    // IF this is not the result element we're looking for THEN skip it
    if ((pElement->Header.ResultType != (UINT32) ResultType) ||
      (pElement->Header.IoLevel != (UINT32) IoLevel) ||
      (pElement->Header.IsDdrT != IsDdrT) ||
      (pElement->Header.Socket != Socket) ||
      (pElement->Header.Controller != Controller) ||
      (pElement->Header.Channel != Channel) ||
      (pElement->Header.DimmA != DimmA) ||
      (pElement->Header.RankA != RankA) ||
      (pElement->Header.DimmB != DimmB) ||
      (pElement->Header.RankB != RankB) ||
      (pElement->Header.Lane != Lane)) {
      continue;
    }

    ElementFound = TRUE;

#if ENBL_RESULTS_DEBUG_LOG_MSGS > 1
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "EleIdx=%u ResultType=%u IoLevel=%u IsDdrT=%u Socket=%u Controller=%u",
      EleIdx, ResultType, IoLevel, IsDdrT, Socket, Controller);
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      " Channel=%u DimmA=%u RankA=%u DimmB=%u RankB=%u Lane=%u\n",
     Channel, DimmA, RankA, DimmB, RankB, Lane);
#endif
    break;
  } // end for each result element

  // IF we didn't find an existing result element
  if (!ElementFound) {
    pElement = NULL;
  }

  return pElement;
} // end function FindResultElement

/**
  This function is used to get the columnar result element associated with the
  given values.  If there is no element then one will be allocated.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       ResultType         Result type.
  @param[in]       IoLevel            I/O level.
  @param[in]       IsDdrT             Flag indicating whether result is for DDR-T.
  @param[in]       Socket             Zero based CPU socket number.
  @param[in]       Controller         Zero based memory controller number.
  @param[in]       Channel            Zero based memory channel number.
  @param[in]       DimmA              Zero based first DIMM number.
  @param[in]       RankA              Zero based first DIMM number.
  @param[in]       DimmB              Zero based second DIMM number.
  @param[in]       RankB              Zero based second DIMM number.
  @param[in]       Lane               Zero based lane number.
  @param[in]       DefaultMarginValue  Default value for the Margin field values.
  @param[out]      ppElement          Pointer to pointer to columnar result element.

  @retval  Nothing
**/
static UINT8 GetResultElement(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN RMT_RESULT_TYPE ResultType,
  IN MRC_LT IoLevel,
  IN BOOLEAN IsDdrT,
  IN UINT8 Socket,
  IN UINT8 Controller,
  IN UINT8 Channel,
  IN UINT8 DimmA,
  IN UINT8 RankA,
  IN UINT8 DimmB,
  IN UINT8 RankB,
  IN UINT8 Lane,
  IN UINT8 DefaultMarginValue,
  OUT RMT_RESULT_COLUMNS **ppElement)
{
#if ENBL_RESULTS_DEBUG_LOG_MSGS > 1
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.GetResultElement(ResultType=%u IoLevel=%u IsDdrT=%u",
    ResultType, IoLevel, IsDdrT);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    " Socket=%u Controller=%u Channel=%u DimmA=%u RankA=%u DimmB=%u RankB=%u Lane=%u)\n",
    Socket, Controller, Channel, DimmA, RankA, DimmB, RankB, Lane);
#endif

  *ppElement = FindResultElement(SsaServicesHandle, pCoreTestData, ResultType,
    IoLevel, IsDdrT, Socket, Controller, Channel, DimmA, RankA, DimmB, RankB,
    Lane);

  // IF we didn't find the specified result element
  if (*ppElement == NULL) {
    RMT_RESULT_ROW_HEADER *pHeader;

    if (GetNextResultElement(SsaServicesHandle, pCoreTestData,
      DefaultMarginValue, ppElement)) {
      return 1;
    }

    pCoreTestData->UsedResultEleCount++;

    // initialize the result element header
    pHeader = &(*ppElement)->Header;
    pHeader->ResultType = ResultType;
    pHeader->IoLevel = IoLevel;
    pHeader->IsDdrT = IsDdrT;
    pHeader->Socket = Socket;
    pHeader->Controller = Controller;
    pHeader->Channel = Channel;
    pHeader->DimmA = DimmA;
    pHeader->RankA = RankA;
    pHeader->DimmB = DimmB;
    pHeader->RankB = RankB;
    pHeader->Lane = Lane;

#if ENBL_RESULTS_DEBUG_LOG_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "UsedResultEleCount=%u ResultType=%u IoLevel=%u IsDdrT=%u",
      pCoreTestData->UsedResultEleCount, ResultType, IoLevel, IsDdrT);
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      " Socket=%u Controller=%u Channel=%u DimmA=%u RankA=%u DimmB=%u RankB=%u Lane=%u\n",
      Socket, Controller, Channel, DimmA, RankA, DimmB, RankB, Lane);
#endif
  } // end if we didn't find an existing result element

  return 0;
} // end function GetResultElement

/**
  This function is used to log rank margin results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       IoLevel            I/O level.

  @retval  Nothing
**/
static
VOID
LogRankMarginResults (
  IN SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN RMT_CORE_TEST_DATA    *pCoreTestData,
  IN MRC_LT                IoLevel
  )
{
  UINT8                     Socket;
  UINT8                     Controller;
  UINT8                     Channel;
  UINT8                     Dimm;
  UINT8                     RankCount;
  UINT8                     Rank;
  BOOLEAN                   IsDdrT;
  CONST RMT_RESULT_COLUMNS  *pElement0 = NULL;
  CONST RMT_RESULT_COLUMNS  *pElement1 = NULL;
  CONST RMT_RESULT_COLUMNS  *pElement2 = NULL;
  BOOLEAN                   HeaderPrinted;
#ifndef DDR5_SUPPORT
  SSA_STATUS                RetStat;
  UINT16                    SettleDelay;
  INT16                     MinOffset, MaxOffset;
  UINT16                    StepUnit;
#endif
  UINT8                     LaneBitmasks[MAX_BUS_WIDTH / 8];
  UINT8                     ByteGroup = 0;
  UINT8                     Lane;
  UINT8                     SubCh;
  UINT8                     NumSubCh;
  UINT8                     SubChMaxBit;

  GetSubChInfo (pCoreTestData->SystemInfo.BusWidth, &NumSubCh, &SubChMaxBit);

  // Initialize the metadata to Zero.
  SetMem (LaneBitmasks, (MAX_BUS_WIDTH/8) * sizeof (UINT8), 0);
  // Initialize Metadata to 0xFF till system bus width.
  SetMem (LaneBitmasks, (pCoreTestData->SystemInfo.BusWidth / 8) * sizeof (UINT8), 0xFF);
  for (Lane = 0; Lane < (pCoreTestData->SystemInfo.BusWidth % 8); Lane++) {
    LaneBitmasks[ByteGroup] |= 1 << Lane;
  }

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.LogRankMarginResults()\n");
#endif

#ifdef __STUB__
  ASSERT (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][0] == RxDqsDelay);
  ASSERT (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][1] == TxDqDelay);
#ifdef DDR5_SUPPORT
  ASSERT ((pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxSamplerEvenOdd) ||
          (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxSamplerOdd) ||
          (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxSamplerEven) ||
          (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxVref));
#else
  ASSERT (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxVref);
#endif
  ASSERT (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][3] == TxVref);
  ASSERT (pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP][0] == CmdAll);
  ASSERT (pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP][1] == CmdVref);
  ASSERT (pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP][2] == CtlAll);
#endif // __STUB__

  HeaderPrinted = FALSE;

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // IF this socket is not configured to be tested THEN skip it
    if ((pCoreTestData->pTestCfg->SocketBitmask & pCoreTestData->SystemInfo.SocketBitMask &
      (1 << Socket)) == 0) {
      continue;
    }

    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // IF this controller is not configured to be tested THEN skip it
      if ((pCoreTestData->pTestCfg->ControllerBitmask & pCoreTestData->MemCfg.ControllerBitmasks[Socket] &
        (1 << Controller)) == 0) {
        continue;
      }

      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // FOR each DIMM:
        for (Dimm = 0; Dimm < MAX_DIMM_CNT; Dimm++) {
          if (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm] == SsaMemoryDdrT) {
            IsDdrT = TRUE;
          }
          else {
            IsDdrT = FALSE;
          }

          RankCount = pCoreTestData->MemCfg.RankCounts[Socket][Controller][Channel][Dimm];

          // FOR each rank:
          for (Rank = 0; Rank < RankCount; Rank++) {

            for (SubCh = 0; SubCh < NumSubCh; SubCh++) {

              //
              // Data signals margin results
              //
              pElement0 = FindResultElement (SsaServicesHandle, pCoreTestData,
                Rank0RmtResultType, IoLevel, IsDdrT, Socket, Controller,
                Channel, Dimm, Rank, 0, 0, SubCh * SubChMaxBit);

              //
              // Cmd/Ctl signals margin results
              //
              pElement1 = FindResultElement (SsaServicesHandle, pCoreTestData,
                Rank1RmtResultType, IoLevel, IsDdrT, Socket, Controller,
                Channel, Dimm, Rank, 0, 0, SubCh * SubChMaxBit);

#ifdef DDR5_SUPPORT
              //
              // BCOM signals margin results
              //
              if (IoLevel == LrbufLevel) {
                pElement2 = FindResultElement (SsaServicesHandle, pCoreTestData,
                  Rank3RmtResultType, IoLevel, IsDdrT, Socket, Controller,
                  Channel, Dimm, Rank, 0, 0, SubCh * SubChMaxBit);
              }
#endif

              // IF either result element was found
              if ((pElement0 != NULL) || (pElement1 != NULL) || (pElement2 != NULL)) {
                if (!HeaderPrinted) {
                  HeaderPrinted = TRUE;

                  NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                    "IoLevel=%a\n", GetLevelStr (pCoreTestData->CurrentIoLevel));

                  // print the table heading
                  NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                    "Rank Margin\n");

                  // Add space accomodate subchannel
                  if (NumSubCh > 1) {
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "    ");
                  }

                  NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                    "             RxDqs- RxDqs+  RxV-  RxV+  TxDq-  TxDq+  TxV-  TxV+  ");

                  if (IoLevel == DdrLevel) {
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "Cmd-  Cmd+  CmdV-  CmdV+  Ctl-  Ctl+\n");
                  } else {
#ifndef DDR5_SUPPORT
                    //
                    // DDR4 backside Cmd/Ctl has same number of signals
                    //
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "Cmd-  Cmd+  CmdV-  CmdV+  Ctl-  Ctl+\n");
#else
                    //
                    // DDR5 backside has extra CtlV, BCOM and BcomVref margin resuls
                    //
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "Cmd-  Cmd+  CmdV-  CmdV+  Ctl-  Ctl+  CtlV-  CtlV+  Bcom-  Bcom+  BcomV-  BcomV+\n");
#endif
                  }
                }

                if (pElement0 != NULL) {

                  if (NumSubCh > 1) {
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "N%u.C%u.D%u.SC%u.R%u: %6d %6d %5d %5d %6d %6d %5d %5d ",
                      Socket, ((Controller * MAX_CHANNEL_CNT) + Channel), Dimm, SubCh, Rank,
                      (-1 * pElement0->Margin[0][LoDirection]), pElement0->Margin[0][HiDirection],
                      (-1 * pElement0->Margin[2][LoDirection]), pElement0->Margin[2][HiDirection],
                      (-1 * pElement0->Margin[1][LoDirection]), pElement0->Margin[1][HiDirection],
                      (-1 * pElement0->Margin[3][LoDirection]), pElement0->Margin[3][HiDirection]);
                  } else {
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "N%u.C%u.D%u.R%u: %6d %6d %5d %5d %6d %6d %5d %5d ",
                      Socket, ((Controller * MAX_CHANNEL_CNT) + Channel), Dimm, Rank,
                      (-1 * pElement0->Margin[0][LoDirection]), pElement0->Margin[0][HiDirection],
                      (-1 * pElement0->Margin[2][LoDirection]), pElement0->Margin[2][HiDirection],
                      (-1 * pElement0->Margin[1][LoDirection]), pElement0->Margin[1][HiDirection],
                      (-1 * pElement0->Margin[3][LoDirection]), pElement0->Margin[3][HiDirection]);
                  }
                } // end if the Rank0RmtResultType result element was found

                // IF the Rank1RmtResultType result element was found
                if (pElement1 != NULL) {
                  // IF the Rank0RmtResultType element wasn't found
                  if (pElement0 == NULL) {
                    // print asterisks to indicate that Rank0RmtResultType values wasn't tested
                    if (NumSubCh > 1) {
                      NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                        "N%u.C%u.D%u.SC%u.R%u:      *      *     *     *      *      *     *     * ",
                        Socket, ((Controller * MAX_CHANNEL_CNT) + Channel), Dimm, SubCh, Rank);
                    } else {
                      NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                        "N%u.C%u.D%u.R%u:      *      *     *     *      *      *     *     * ",
                        Socket, ((Controller * MAX_CHANNEL_CNT) + Channel), Dimm, Rank);
                    }
                  }

                  //
                  // print CmdAll results
                  // The MarginGroups[RMT_CMD_SIGNAL_GROUP][0] is the group for the Cmd timing.
                  //
                  if (UseCaCsTrainingMode(IoLevel, pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP][0]) &&
                      (pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP][0] == DcaDelay) &&
                      (Rank != 0)) {
                    // print asterisks to indicate that DcaDelay wasn't tested
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "    *     * ");
                  } else {
#ifndef DDR5_SUPPORT
                    RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamLimits (
                      SsaServicesHandle, Socket, Controller, Channel, Dimm, Rank,
                      LaneBitmasks, IoLevel,
                      CmdAll, &MinOffset, &MaxOffset, &SettleDelay,
                      &StepUnit);
                    if (RetStat == UnsupportedValue) {
                      NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                        "    *     * ");
                    } else
#endif // DDR5_SUPPORT
                    {
                      NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                        "%5d %5d ",
                        (-1 * pElement1->Margin[0][LoDirection]), pElement1->Margin[0][HiDirection]);
                    }
                  }

                  //
                  // print CmdVref results
                  // The MarginGroups[RMT_CMD_SIGNAL_GROUP][1] is the group for the Cmd Vref.
                  // RcdDcaVref and DcsDfeVref are tested only on rank0.
                  //
                  if (pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP][1] == SKIP_TEST) {
                      NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "     *      * ");
                  } else if (UseCaCsTrainingMode(IoLevel, pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP][1]) &&
                      ((pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP][1] == DcaDfeVref) || (pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP][1] == RcdDcaVref)) &&
                      (Rank != 0)) {
                    // print asterisks to indicate that RCdDcaVref or DcaDFeVredf wasn't tested
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "     *      * ");
                  } else {
#ifndef DDR5_SUPPORT
                    RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamLimits (
                      SsaServicesHandle, Socket, Controller, Channel, Dimm, Rank,
                      LaneBitmasks, IoLevel,
                      CmdVref, &MinOffset, &MaxOffset, &SettleDelay,
                      &StepUnit);
                    if (RetStat == UnsupportedValue) {
                      NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                        "     *      * ");
                    } else
#endif // DDR5_SUPPORT
                    {
                      NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                        "%6d %6d ",
                        (-1 * pElement1->Margin[1][LoDirection]), pElement1->Margin[1][HiDirection]);
                    }
                  }

#ifndef DDR5_SUPPORT
                  // IF CtlAll margining is enabled
                  RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamLimits (
                    SsaServicesHandle, Socket, Controller, Channel, Dimm, Rank,
                    LaneBitmasks, IoLevel,
                    CtlAll, &MinOffset, &MaxOffset, &SettleDelay,
                    &StepUnit);
                  if ((pCoreTestData->pTestCfg->EnableCtlAllMargin == FALSE) || (RetStat == UnsupportedValue)) {
                    // print asterisks to indicate that CtlAll wasn't tested
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "    *     *");
                  } else
#endif // DDR5_SUPPORT
                  {
                    // print CtlAll results
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "%5d %5d",
                      (-1 * pElement1->Margin[2][LoDirection]), pElement1->Margin[2][HiDirection]);
                  }

                  //
                  // print backside CtlVref results
                  // The MarginGroups[RMT_CMD_SIGNAL_GROUP][3] is the group for the Ctl Vref.
                  // DramCsVref is the one being margined for the DDR5 RDIMM and LRDIMM
                  //
                  if (IoLevel == LrbufLevel) {
                    if (pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP][3] == SKIP_TEST) {
                      NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                        "     *      * ");
                    } else {
                      {
                        NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                          "%7d%7d ",
                          (-1 * pElement1->Margin[3][LoDirection]), pElement1->Margin[3][HiDirection]);
                      }
                    }
                  } // IoLevel == LrbufLevel

                } else {
                  // ELSE the Rank1RmtResultType result element wasn't found
                  if (pElement0 != NULL) {
                    // print asterisks to indicate that CmdAll, CmdVref, and CtlAll weren't tested
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "    *     *      *      *     *     *");
                  }
                } // end the Rank1RmtResultType

#ifdef DDR5_SUPPORT
                //
                // BCOM margin results
                //
                if (IoLevel == LrbufLevel) {
                  // Print BCOM timing which is the first entry of the BCOM sigbnal group.
                  if ((pElement2 != NULL) && (Rank != 1) && (pCoreTestData->MarginGroups[RMT_BCOM_SIGNAL_GROUP][0] != SKIP_TEST)) {
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "%7d%7d ", (-1 * pElement2->Margin[0][LoDirection]), pElement2->Margin[0][HiDirection]);
                  } else {
                    // print asterisks to indicate that BCOM wasn't tested
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR, "    *       *");
                  } // end the Rank3RmtResultType

                  // Print BCOM Vref which is the second entry of the BCOM sigbnal group.
                  if ((pElement2 != NULL) && (Rank != 1) && (pCoreTestData->MarginGroups[RMT_BCOM_SIGNAL_GROUP][1] != SKIP_TEST)) {
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "%6d %6d ", (-1 * pElement2->Margin[1][LoDirection]), pElement2->Margin[1][HiDirection]);
                  } else {
                    // print asterisks to indicate that BCOM wasn't tested
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR, "      *       *");
                  } // end the Rank3RmtResultType
                }
#endif
                NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR, "\n");
              }

            } // end for subchannel
          } // end for each rank
        } // end for each DIMM
      } // end for each channel
    } // end for each controller
  } // end for each socket

  if (HeaderPrinted) {
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, "\n");
  }
} // end function LogRankMarginResults

#if SUPPORT_FOR_DDRT
/**
  This function is used to log Early Read ID margin results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.

  @retval  Nothing
**/
static VOID LogEridMarginResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData)
{
  MRC_LT IoLevel = DdrLevel;
  UINT8 Socket, Controller, Channel, Dimm, Rank = 0, Lane;
  BOOLEAN IsDdrT = TRUE;
  CONST RMT_RESULT_COLUMNS *pElement;
  BOOLEAN HeaderPrinted;
  BOOLEAN RankDataFound;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.LogEridMarginResults()\n");
#endif

#ifdef __STUB__
  ASSERT (pCoreTestData->MarginGroups[RMT_DDRT_SIGNAL_GROUP][0] == EridDelay);
#endif // __STUB__

  HeaderPrinted = FALSE;

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // IF this socket is not configured to be tested THEN skip it
    if ((pCoreTestData->pTestCfg->SocketBitmask &
      pCoreTestData->SystemInfo.SocketBitMask & (1 << Socket)) == 0) {
      continue;
    }

    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // IF this controller is not configured to be tested THEN skip it
      if ((pCoreTestData->pTestCfg->ControllerBitmask &
        pCoreTestData->MemCfg.ControllerBitmasks[Socket] &
        (1 << Controller)) == 0) {
        continue;
      }

      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // FOR each DIMM:
        for (Dimm = 0; Dimm < MAX_DIMM_CNT; Dimm++) {
          RankDataFound = FALSE;

          pElement = FindResultElement(SsaServicesHandle, pCoreTestData,
            Rank2RmtResultType, IoLevel, IsDdrT, Socket, Controller,
            Channel, Dimm, Rank, 0, 0, 0);

          if (pElement != NULL) {
            RankDataFound = TRUE;

            if (!HeaderPrinted) {
              HeaderPrinted = TRUE;

              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "IoLevel=%a\n", GetLevelStr (pCoreTestData->CurrentIoLevel));

              // print the table heading
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "Early Read ID Margin\n");
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "             Delay- Delay+ Vref- Vref+\n");
            }

            // FOR each Early Read ID lane:
            for (Lane = 0; Lane < 2; Lane++) {
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "N%u.C%u.D%u.L%u: %6d %6d %5d %5d\n",
                Socket, ((Controller * MAX_CHANNEL_CNT) + Channel), Dimm, Lane,
                (-1 * pElement->Margin[Lane][LoDirection]),
                pElement->Margin[Lane][HiDirection],
                (-1 * pElement->Margin[Lane + 2][LoDirection]),
                pElement->Margin[Lane + 2][HiDirection]);
            } // end for each Early Read ID lane
          } // end if the result element was found
        } // end for each DIMM
      } // end for each channel
    } // end for each controller
  } // end for each socket

  if (HeaderPrinted) {
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, "\n");
  }
} // end function LogEridMarginResults
#endif // SUPPORT_FOR_DDRT

/**
  This function is used to log lane margin results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       IoLevel            I/O level.

  @retval  Nothing
**/
static
VOID
LogLaneMarginResults (
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA    *pCoreTestData,
  IN     MRC_LT                IoLevel
  )
{
  UINT8                     Socket;
  UINT8                     Controller;
  UINT8                     Channel;
  UINT8                     Dimm;
  UINT8                     RankCount;
  UINT8                     Rank;
  UINT8                     Lane;
  BOOLEAN                   IsDdrT;
  CONST RMT_RESULT_COLUMNS  *pElement;
  BOOLEAN                   HeaderPrinted;
  UINT8                     SubCh;
  UINT8                     NumSubCh;
  UINT8                     SubChMaxBit;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.LogLaneMarginResults()\n");
#endif

#ifdef __STUB__
  ASSERT (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][0] == RxDqsDelay);
  ASSERT (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][1] == TxDqDelay);
#ifdef DDR5_SUPPORT
  ASSERT ((pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxSamplerEvenOdd) ||
          (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxSamplerOdd) ||
          (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxSamplerEven) ||
          (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxVref));
#else
  ASSERT (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxVref);
#endif
  ASSERT (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][3] == TxVref);
#endif // __STUB__

  GetSubChInfo (pCoreTestData->SystemInfo.BusWidth, &NumSubCh, &SubChMaxBit);

  HeaderPrinted = FALSE;

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // IF this socket is not configured to be tested THEN skip it
    if ((pCoreTestData->pTestCfg->SocketBitmask &
      pCoreTestData->SystemInfo.SocketBitMask & (1 << Socket)) == 0) {
      continue;
    }

    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // IF this controller is not configured to be tested THEN skip it
      if ((pCoreTestData->pTestCfg->ControllerBitmask &
        pCoreTestData->MemCfg.ControllerBitmasks[Socket] &
        (1 << Controller)) == 0) {
        continue;
      }

      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // FOR each DIMM:
        for (Dimm = 0; Dimm < MAX_DIMM_CNT; Dimm++) {
          if (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm] == SsaMemoryDdrT) {
            IsDdrT = TRUE;
          }
          else {
            IsDdrT = FALSE;
          }

          RankCount = pCoreTestData->MemCfg.RankCounts[Socket][Controller][Channel][Dimm];

          // FOR each rank:
          for (Rank = 0; Rank < RankCount; Rank++) {

            for (SubCh = 0; SubCh < NumSubCh; SubCh++) {
              // FOR each lane:
              for (Lane = SubCh * SubChMaxBit; Lane < (SubCh + 1) * SubChMaxBit; Lane++) {
                pElement = FindResultElement (SsaServicesHandle, pCoreTestData,
                  LaneRmtResultType, IoLevel, IsDdrT, Socket, Controller,
                  Channel, Dimm, Rank, 0, 0, Lane);

                if (pElement != NULL) {
                  if (!HeaderPrinted) {
                    HeaderPrinted = TRUE;

                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "IoLevel=%a\n", GetLevelStr (pCoreTestData->CurrentIoLevel));

                    // print the table heading
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "Lane Margin\n");

                    // Add space accomodate subchannel
                    if (NumSubCh > 1) {
                      NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                        "    ");
                    }

                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "                 RxDqs- RxDqs+  RxV-  RxV+  TxDq-  TxDq+  TxV-  TxV+\n");
                  }

                  if (NumSubCh > 1) {
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "N%u.C%u.D%u.SC%u.R%u.L%02u: %6d %6d %5d %5d %6d %6d %5d %5d\n",
                      Socket, ((Controller * MAX_CHANNEL_CNT) + Channel), Dimm, SubCh, Rank, Lane % SubChMaxBit,
                      (-1 * pElement->Margin[0][LoDirection]), pElement->Margin[0][HiDirection],
                      (-1 * pElement->Margin[2][LoDirection]), pElement->Margin[2][HiDirection],
                      (-1 * pElement->Margin[1][LoDirection]), pElement->Margin[1][HiDirection],
                      (-1 * pElement->Margin[3][LoDirection]), pElement->Margin[3][HiDirection]);
                  } else {
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "N%u.C%u.D%u.R%u.L%02u: %6d %6d %5d %5d %6d %6d %5d %5d\n",
                      Socket, ((Controller * MAX_CHANNEL_CNT) + Channel), Dimm, Rank, Lane,
                      (-1 * pElement->Margin[0][LoDirection]), pElement->Margin[0][HiDirection],
                      (-1 * pElement->Margin[2][LoDirection]), pElement->Margin[2][HiDirection],
                      (-1 * pElement->Margin[1][LoDirection]), pElement->Margin[1][HiDirection],
                      (-1 * pElement->Margin[3][LoDirection]), pElement->Margin[3][HiDirection]);
                  }
                } // end if the result element was found
              } // end for each lane
            } // end for subchannel
          } // end for each rank
        } // end for each DIMM
      } // end for each channel
    } // end for each controller
  } // end for each socket

  if (HeaderPrinted) {
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, "\n");
  }
} // end function LogLaneMarginResults

#if SUPPORT_FOR_TURNAROUNDS
/**
  This function is used to log rank-to-rank turnaround margin results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       IoLevel            I/O level.

  @retval  Nothing
**/
static VOID LogTurnaroundMarginResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN MRC_LT IoLevel)
{
  UINT8 Socket, Controller, Channel;
  UINT8 DimmA, RankACount, RankA;
  UINT8 DimmB, RankBCount, RankB;
  BOOLEAN IsDdrT;
  CONST RMT_RESULT_COLUMNS *pElement;
  BOOLEAN HeaderPrinted;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.LogTurnaroundMarginResults()\n");
#endif

#ifdef __STUB__
  ASSERT (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][0] == RxDqsDelay);
  ASSERT (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][1] == TxDqDelay);
#ifdef DDR5_SUPPORT
  ASSERT ((pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxSamplerEvenOdd) ||
          (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxSamplerOdd) ||
          (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxSamplerEven) ||
          (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxVref));
#else
  ASSERT (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxVref);
#endif
  ASSERT (MpCoreTestData->arginGroups[0][3] == TxVref);
#endif // __STUB__

  HeaderPrinted = FALSE;

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // IF this socket is not configured to be tested THEN skip it
    if ((pCoreTestData->pTestCfg->SocketBitmask &
      pCoreTestData->SystemInfo.SocketBitMask & (1 << Socket)) == 0) {
      continue;
    }

    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // IF this controller is not configured to be tested THEN skip it
      if ((pCoreTestData->pTestCfg->ControllerBitmask &
        pCoreTestData->MemCfg.ControllerBitmasks[Socket] &
        (1 << Controller)) == 0) {
        continue;
      }

      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // FOR each DIMM-A:
        for (DimmA = 0; DimmA < MAX_DIMM_CNT; DimmA++) {
          if (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][DimmA] == SsaMemoryDdrT) {
            IsDdrT = TRUE;
          }
          else {
            IsDdrT = FALSE;
          }

          RankACount = pCoreTestData->MemCfg.RankCounts[Socket][Controller][Channel][DimmA];

          // FOR each rank-A:
          for (RankA = 0; RankA < RankACount; RankA++) {
            // FOR each DIMM-B:
            for (DimmB = 0; DimmB < MAX_DIMM_CNT; DimmB++) {
              // IF the DIMM B is not the same type as DIMM A then skip it
              if (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][DimmA] !=
                pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][DimmB]) {
                continue;
              }

              RankBCount = pCoreTestData->MemCfg.RankCounts[Socket][Controller][Channel][DimmB];

              // FOR each rank-B:
              for (RankB = 0; RankB < RankACount; RankB++) {
                // IF the DIMMs and ranks are the same THEN skip it
                if ((DimmA == DimmB) && (RankA == RankB)) {
                  continue;
                }

                pElement = FindResultElement(SsaServicesHandle, pCoreTestData,
                  TurnaroundRmtResultType, IoLevel, IsDdrT, Socket, Controller,
                  Channel, DimmA, RankA, DimmB, RankB, 0);

                if (pElement != NULL) {
                  if (!HeaderPrinted) {
                    HeaderPrinted = TRUE;

                    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                      "IoLevel=%a\n", GetLevelStr (pCoreTestData->CurrentIoLevel));

                    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                      "Turnaround Margin\n");
                    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                      "                   RxDqs- RxDqs+  RxV-  RxV+  TxDq-  TxDq+  TxV-  TxV+\n");
                  }

                  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                    "N%u.C%u.D%u.R%u.D%u.R%u: %6d %6d %5d %5d %6d %6d %5d %5d\n",
                    Socket, ((Controller * MAX_CHANNEL_CNT) + Channel), DimmA, RankA, DimmB, RankB,
                    (-1 * pElement->Margin[0][LoDirection]), pElement->Margin[0][HiDirection],
                    (-1 * pElement->Margin[2][LoDirection]), pElement->Margin[2][HiDirection],
                    (-1 * pElement->Margin[1][LoDirection]), pElement->Margin[1][HiDirection],
                    (-1 * pElement->Margin[3][LoDirection]), pElement->Margin[3][HiDirection]);
                } // end if the result element was found
              } // end for each rank-B
            } // end for each DIMM-B
          } // end for each rank-A
        } // end for each DIMM-A
      } // end for each channel
    } // end for each controller
  } // end for each socket

  if (HeaderPrinted) {
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR, "\n");
  }
} // end function LogTurnaroundMarginResults
#endif // SUPPORT_FOR_TURNAROUNDS

/**
  This function is used to plot lane margin results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       HasDdrtDevices     Flag indicating whether system has any DDR-T devices.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 PlotLaneMarginResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN BOOLEAN HasDdrtDevices)
{
  UINT8 i;
  MRC_LT IoLevel;
  MRC_GT MarginGroup;
  UINT8 MarginGroupIdx;
  UINT8 ByteGroup;
  UINT8 Socket, Controller, Channel, Dimm, RankCount, Rank, Lane;
  CONST RMT_RESULT_COLUMNS *pElement;
  INT16 MinOffset, MaxOffset;
  INT16 LoSideOffset, HiSideOffset;
  INT16 InnerLoSideOffset, OuterLoSideOffset;
  INT16 InnerHiSideOffset, OuterHiSideOffset;
  BOOLEAN LaneElementFound;
  BOOLEAN IsDdrT;
  UINT8 StepSize;
  CHAR8 *GroupString = NULL;
  BOOLEAN HasFoundParamLimit;
  UINT8 SubCh;
  UINT8 NumSubCh;
  UINT8 SubChMaxBit;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.PlotLaneMarginResults(HasDdrtDevices=%u)\n", HasDdrtDevices);
#endif

  GetSubChInfo (pCoreTestData->SystemInfo.BusWidth, &NumSubCh, &SubChMaxBit);

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
#ifdef __STUB__
  // confirm design assumption
  ASSERT (DdrLevel == 0);
  ASSERT (LrbufLevel == 1);
#endif // __STUB__
  // FOR each I/O level:
  for (IoLevel = DdrLevel; IoLevel <= LrbufLevel; IoLevel++) {
    // IF this I/O level is not enabled for testing THEN skip it
    if ((pCoreTestData->pTestCfg->IoLevelBitmask & (1 << IoLevel)) == 0) {
      continue;
    }

    // IF the I/O level is the backside and there are no devices with a
    // backside THEN skip it
    if ((IoLevel == LrbufLevel) &&
      (!IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks) &&
      !pCoreTestData->MemCfg.IsLrDimms && !HasDdrtDevices)) {
      continue;
    }
#else
  {
    IoLevel = 0;
#endif // !(SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT)

    // FOR each margin group:
    for (i = 0; i < MARGIN_GROUP_ARRAY_ELE_CNT; i++) {
      MarginGroup = pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][i];

      if (MarginGroup == MrcGtMax) {
        continue;
      }

#ifdef __STUB__
      ASSERT (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][0] == RxDqsDelay);
      ASSERT (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][1] == TxDqDelay);
#ifdef DDR5_SUPPORT
  ASSERT ((pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxSamplerEvenOdd) ||
          (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxSamplerOdd) ||
          (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxSamplerEven) ||
          (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxVref));
#else
  ASSERT (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][2] == RxVref);
#endif
      ASSERT (pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][3] == TxVref);
#endif // __STUB__
      switch (MarginGroup) {
      case RxDqsDelay:
        MarginGroupIdx = 0;
        break;
      case TxDqDelay:
        MarginGroupIdx = 1;
        break;
      case RxVref:
      case RxSamplerEvenOdd:
      case RxSamplerEven:
      case RxSamplerOdd:
        MarginGroupIdx = 2;
        break;
      case TxVref:
      case DbDfeVrefGroup:
        MarginGroupIdx = 3;
        break;
      default:
        ProcError(SsaServicesHandle, Failure, __FILE__, __LINE__,
          pCoreTestData->pTestStat);
        return 1;
      }

      StepSize = GetStepSize(pCoreTestData->pTestCfg, IoLevel, MarginGroup);

      // FOR each socket:
      for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
        // IF this socket is not configured to be tested THEN skip it
        if ((pCoreTestData->pTestCfg->SocketBitmask &
          pCoreTestData->SystemInfo.SocketBitMask &
          (1 << Socket)) == 0) {
          continue;
        }

        // FOR each controller:
        for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
          // IF this controller is not configured to be tested THEN skip it
          if ((pCoreTestData->pTestCfg->ControllerBitmask &
            pCoreTestData->MemCfg.ControllerBitmasks[Socket] &
            (1 << Controller)) == 0) {
            continue;
          }

          // FOR each channel:
          for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
            // IF this channel is not present THEN skip it
            if ((pCoreTestData->MemCfg.ChannelBitmasks[Socket][Controller] &
              (1 << Channel)) == 0) {
              continue;
            }

            // FOR each DIMM:
            for (Dimm = 0; Dimm < MAX_DIMM_CNT; Dimm++) {
              // IF this DIMM is not present THEN skip it
              if ((pCoreTestData->MemCfg.DimmBitmasks[Socket][Controller][Channel] &
                (1 << Dimm)) == 0) {
                  continue;
              }
#if SUPPORT_FOR_DDRT
              if (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm] ==
                SsaMemoryDdrT) {
                  IsDdrT = TRUE;
              }
              else
#endif // SUPPORT_FOR_DDRT
              {
                IsDdrT = FALSE;
#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
                // IF the I/O level is the backside and this device has no
                // backside THEN skip it
                if ((IoLevel == LrbufLevel) && !pCoreTestData->MemCfg.IsLrDimms &&
                  (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm] != SsaMemoryDdrT)) {
                  continue;
                }
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
              }

              HasFoundParamLimit = FALSE;
              // get the margin parameter limits
              pElement = FindResultElement(SsaServicesHandle, pCoreTestData,
                ParamLimits0ResultType, IoLevel, IsDdrT, 0, 0, 0, 0, 0, 0, 0, 0);

              if (pElement) {
                HasFoundParamLimit = TRUE;
                MinOffset = 0 - (INT16)pElement->Margin[MarginGroupIdx][LoDirection];
                MaxOffset = (INT16)pElement->Margin[MarginGroupIdx][HiDirection];
              }

              RankCount = pCoreTestData->MemCfg.RankCounts[Socket][Controller][Channel][Dimm];

              // FOR each rank:
              for (Rank = 0; Rank < RankCount; Rank++) {

                for (SubCh = 0; SubCh < NumSubCh; SubCh++) {

                  LaneElementFound = FALSE;

                  // get the range of the high and low side offsets
                  InnerLoSideOffset = -512;
                  OuterLoSideOffset = 0;
                  InnerHiSideOffset = 512;
                  OuterHiSideOffset = 0;

                  // FOR each lane:
                  for (Lane = SubCh * SubChMaxBit; Lane < (SubCh + 1) * SubChMaxBit; Lane++) {
                    pElement = FindResultElement (SsaServicesHandle, pCoreTestData,
                      LaneRmtResultType, IoLevel, IsDdrT, Socket, Controller,
                      Channel, Dimm, Rank, 0, 0, Lane);

                    if (pElement != NULL) {
                      LaneElementFound = TRUE;

                      // get the low side margin offset
                      LoSideOffset = 0 - (INT16)pElement->Margin[MarginGroupIdx][LoDirection];
                      HiSideOffset = (INT16)pElement->Margin[MarginGroupIdx][HiDirection];

#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                      NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                        "Lane=%d LoSideOffset=%d HiSideOffset=%d\n",
                        Lane, LoSideOffset, HiSideOffset);
#endif

                      if (LoSideOffset > InnerLoSideOffset) {
                        InnerLoSideOffset = LoSideOffset;

#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                        NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                          "  InnerLoSideOffset=%d\n", InnerLoSideOffset);
#endif
                      }

                      if (LoSideOffset < OuterLoSideOffset) {
                        OuterLoSideOffset = LoSideOffset;

#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                        NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                          "  OuterLoSideOffset=%d\n", OuterLoSideOffset);
#endif
                      }

                      if (HiSideOffset < InnerHiSideOffset) {
                        InnerHiSideOffset = HiSideOffset;

#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                        NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                          "  InnerHiSideOffset=%d\n", InnerHiSideOffset);
#endif
                      }

                      if (HiSideOffset > OuterHiSideOffset) {
                        OuterHiSideOffset = HiSideOffset;

#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                        NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                          "  OuterHiSideOffset=%d\n", OuterHiSideOffset);
#endif
                      }
                    } // end if the result element was found
                  } // end for each lane

                  // IF there were no lane element entries for this rank THEN skip it
                  if (!LaneElementFound) {
                    continue;
                  }

                  if (HasFoundParamLimit) {
#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "MinOffset=%d MaxOffset=%d StepSize=%u\n",
                      MinOffset, MaxOffset, StepSize);
#endif

                    // IF there's room below the lowest offset found
                    if ((OuterLoSideOffset - StepSize) > MinOffset) {
                      // add a row that shows all lanes failing
                      OuterLoSideOffset -= StepSize;

#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                      NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                        "  OuterLoSideOffset=%d\n", OuterLoSideOffset);
#endif
                    }

                    // IF there's room above the highest offset found
                    if ((OuterHiSideOffset + StepSize) < MaxOffset) {
                      // add a row that shows all lanes failing
                      OuterHiSideOffset += StepSize;

#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                      NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                        "  OuterHiSideOffset=%d\n", OuterHiSideOffset);
#endif
                    }
                  } // HasFoundParamLimit

#if ENBL_LANE_PLOT_DEBUG_LOG_MSGS
                  NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                    "OuterLoSideOffset=%d InnerLoSideOffset=%d InnerHiSideOffset=%d OuterHiSideOffset=%d\n",
                    OuterLoSideOffset, InnerLoSideOffset, InnerHiSideOffset, OuterHiSideOffset);
#endif
                  if (EFI_ERROR (GetGroupString (MarginGroup, &GroupString))) {
                    GroupString = "Unknown group";
                  }

                  if (NumSubCh > 1) {
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "\n"
                      "Per bit IoLevel=%a MarginGroup=%a margin for N%u.C%u.D%u.SC%u.R%u\n",
                      GetLevelStr (IoLevel), GroupString,
                      Socket, ((Controller * MAX_CHANNEL_CNT) + Channel), Dimm, SubCh, Rank);
                  } else {
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      "\n"
                      "Per bit IoLevel=%a MarginGroup=%a margin for N%u.C%u.D%u.R%u\n",
                      GetLevelStr (IoLevel), GroupString,
                      Socket, ((Controller * MAX_CHANNEL_CNT) + Channel), Dimm, Rank);
                  }
                  // print column header
                  NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                    "     0------7 8-----15");
                  for (ByteGroup = 2; ByteGroup < (SubChMaxBit / 8); ByteGroup++) {
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                      " %2u----%2u", (ByteGroup * 8), (((ByteGroup + 1) * 8) - 1));
                  }
                  NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                    "\n");

                  // FOR each offset on the high side (from outermost to innermost+1)
                  for (HiSideOffset = OuterHiSideOffset; HiSideOffset > InnerHiSideOffset; HiSideOffset--) {
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR, "%4d", HiSideOffset);

                    // FOR each lane:
                    for (Lane = SubCh * SubChMaxBit; Lane < (SubCh + 1) *SubChMaxBit; Lane++) {
                      if ((Lane % 8) == 0) {
                        // insert space between byte groups
                        NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR, " ");
                      }

                      pElement = FindResultElement (SsaServicesHandle, pCoreTestData,
                        LaneRmtResultType, IoLevel, IsDdrT, Socket, Controller,
                        Channel, Dimm, Rank, 0, 0, Lane);

                      if (pElement != NULL) {
                        // IF the high side first-fail offset is inside the
                        // current offset OR the degenerative case where the
                        // inner offset is the minimum value
                        if ((pElement->Margin[MarginGroupIdx][HiDirection] < HiSideOffset) ||
                          (OuterHiSideOffset == 0)) {
                          NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR, "*");
                        } else {
                          NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR, " ");
                        }
                      } // end if the result element was found
                    } // end for each lane

                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR, "\n");
                  } // end for each offset on the high side

                  // FOR each offset on the low side (from innermost+1 to outermost)
                  for (LoSideOffset = (InnerLoSideOffset - 1); LoSideOffset >= OuterLoSideOffset; LoSideOffset--) {
                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR, "%4d", LoSideOffset);

                    // FOR each lane:
                    for (Lane = SubCh * SubChMaxBit; Lane < (SubCh + 1) * SubChMaxBit; Lane++) {
                      if ((Lane % 8) == 0) {
                        // insert space between byte groups
                        NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR, " ");
                      }

                      pElement = FindResultElement (SsaServicesHandle, pCoreTestData,
                        LaneRmtResultType, IoLevel, IsDdrT, Socket, Controller,
                        Channel, Dimm, Rank, 0, 0, Lane);

                      if (pElement != NULL) {
                        // IF the low side first-fail offset is inside the current offset
                        if ((0 - (INT16)pElement->Margin[MarginGroupIdx][LoDirection]) > LoSideOffset) {
                          NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR, "*");
                        } else {
                          NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR, " ");
                        }
                      } // end if the result element was found
                    } // end for each lane

                    NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR, "\n");
                  } // end for each offset on the low side
                } // end for each subchannel
              } // end for each rank
            } // end for each DIMM
          } // end for each channel
        } // end for each controller
      } // end for each socket
    } // end for each margin group
  } // end for each I/O level

  return 0;
} // end function PlotLaneMarginResults

/**
  This function is used to report margin parameter limit results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data structure.
  @param[in]       ResultType         Result element type.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 ReportParamLimitsResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN RMT_RESULT_TYPE ResultType)
{
  RMT_RESULT_COLUMNS *pElement;
  UINT8 ShmooDir;
  MEM_TECH DdrOrDdrT;

#if SUPPORT_FOR_DDRT
  UINT8 Index;
#endif // SUPPORT_FOR_DDRT

  // Since we run DDR4 and DDRT test together, we need to report the limits of both DDR4 and DDRT
  for (DdrOrDdrT = 0; DdrOrDdrT <=1; DdrOrDdrT++)
  {
    if ((DdrOrDdrT == DDRT) && !HasDdrtDevicesValEnabled(SsaServicesHandle, &pCoreTestData->SystemInfo,
      &pCoreTestData->MemCfg, &pCoreTestData->CurrentMemPointTestCfg)){
      continue;
    }

    // ParamLimits2ResultType is for ERID, it is invalid for DDR
    if ((DdrOrDdrT == DDR) && (ResultType == ParamLimits2ResultType)){
      continue;
    }

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "RmtCore.ReportParamLimitsResults(ResultType=%u CurrentMarginGroupSubIndex=%u IsDdrT=%u)\n",
      ResultType, pCoreTestData->CurrentMarginGroupSubIndex, IsDdrT);
#endif

    if (GetResultElement(SsaServicesHandle, pCoreTestData, ResultType,
      pCoreTestData->CurrentIoLevel, DdrOrDdrT, 0, 0, 0, 0, 0,
      0, 0, 0, 0, &pElement)) {
      return 1;
    }

    // FOR each shmoo direction:
    for (ShmooDir = 0; ShmooDir < RmtShmooDirMax; ShmooDir++) {
      // save the offset limits which are positive number.
      // Compare the new value to existing value, update to save the max value as iterating ranks.
      if (pCoreTestData->LimitOffsets[DdrOrDdrT][ShmooDir] > pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir]) {
        pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir] = \
          pCoreTestData->LimitOffsets[DdrOrDdrT][ShmooDir];
      }

#if ENBL_RESULTS_DEBUG_LOG_MSGS > 1
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  ShmooDir=%u Offset=%u\n",
        ShmooDir, pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir]);
#endif

#if SUPPORT_FOR_DDRT
      // IF this is for Early Read ID margins
      if (ResultType == ParamLimits2ResultType) {
        Index = pCoreTestData->CurrentMarginGroupSubIndex + 1;

        // make sure the index is in range
        if (Index >= (sizeof(pElement->Margin) / sizeof(pElement->Margin[0]))) {
          ProcError(SsaServicesHandle, Failure, __FILE__, __LINE__, pCoreTestData->pTestStat);
          return 1;
        }

        // copy the value in the second lane position as well
        pElement->Margin[Index][ShmooDir] = pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir];
      }
#endif // SUPPORT_FOR_DDRT
    } // end for each shmoo direction
  } // end of DDR and DDRT

  return 0;
} // end function ReportParamLimitsResults

/**
  This function is used to report Early Read ID margin results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 ReportEridMarginResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData)
{
  UINT8 Socket, Controller, Channel, Dimm, Rank, Lane, ShmooDir;
  RMT_RESULT_COLUMNS *pElement;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.ReportEridMarginResults()\n");
#endif

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // IF this channel is not enabled for validation THEN skip it
        if (!IsChannelValEnabled(SsaServicesHandle, &pCoreTestData->SystemInfo,
          &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
          &pCoreTestData->CurrentMemPointTestCfg,
#else
          &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
          Socket, Controller, Channel)) {
          continue;
        }

        // IF this channel has fewer rank combinations than the one we're
        // currently on THEN this is repeat data so skip it
        if (pCoreTestData->RankCombinationCnts[Socket][Controller][Channel] <=
          pCoreTestData->CurrentRankCombinationIndex) {
          continue;
        }

        Dimm = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Dimm;
        Rank = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Rank;

        // IsDdrT field is always TRUE for ERID result
        if (GetResultElement(SsaServicesHandle, pCoreTestData,
          Rank2RmtResultType, pCoreTestData->CurrentIoLevel,
          TRUE, Socket, Controller, Channel, Dimm,
          Rank, 0, 0, 0, 0, &pElement)) {
          return 1;
        }

        // FOR each lane:
        for (Lane = 0; Lane < 2; Lane++) {
          // FOR each shmoo direction:
          for (ShmooDir = 0; ShmooDir < RmtShmooDirMax; ShmooDir++) {
            // save the last pass offsets
            pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex + Lane][ShmooDir] = \
              pCoreTestData->LastPassLaneOffsets[ShmooDir][Socket][Controller][Channel][Lane];

#if ENBL_RESULTS_DEBUG_LOG_MSGS > 1
            NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
              "  Socket=%u Controller=%u Channel=%u Lane=%u ShmooDir=%u Offset=%u\n",
              Socket, Controller, Channel, Lane, ShmooDir,
              pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir]);
#endif
          } // end for each shmoo direction
        } // end for each lane
      } // end for each channel
    } // end for each controller
  } // end for each socket

  return 0;
} // end function ReportEridMarginResults

/**
  This function is used to report lane margin results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 ReportLaneMarginResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData)
{
  UINT8 Socket, Controller, Channel, Dimm, Rank, Lane, ShmooDir;
  RMT_RESULT_COLUMNS *pElement;
  BOOLEAN IsDdrT;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.ReportLaneMarginResults()\n");
#endif

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // IF this channel is not enabled for validation THEN skip it
        if (!IsChannelValEnabled(SsaServicesHandle, &pCoreTestData->SystemInfo,
          &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
          &pCoreTestData->CurrentMemPointTestCfg,
#else
          &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
          Socket, Controller, Channel)) {
          continue;
        }

        // IF this channel has fewer rank combinations than the one we're
        // currently on THEN this is repeat data so skip it
        if (pCoreTestData->RankCombinationCnts[Socket][Controller][Channel] <=
          pCoreTestData->CurrentRankCombinationIndex) {
          continue;
        }

        Dimm = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Dimm;
        Rank = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Rank;

        // The IsDdrT is no longer determined by the pCoreTestData.CurrentIsDdrT because
        // we test DDR and DDRT together.
        // We need to base on the socket, control, dimm to determine the IsDdrT field.
        if (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm] == SsaMemoryDdrT) {
          IsDdrT = TRUE;
        }
        else {
          IsDdrT = FALSE;
        }

        // FOR each lane:
        for (Lane = 0; Lane < pCoreTestData->SystemInfo.BusWidth; Lane++) {
          if (GetResultElement(SsaServicesHandle, pCoreTestData,
            LaneRmtResultType, pCoreTestData->CurrentIoLevel,
            IsDdrT, Socket, Controller, Channel, Dimm,
            Rank, 0, 0, Lane, 0, &pElement)) {
            return 1;
          }

          // FOR each shmoo direction:
          for (ShmooDir = 0; ShmooDir < RmtShmooDirMax; ShmooDir++) {
            // save the last pass offsets
            pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir] = \
              pCoreTestData->LastPassLaneOffsets[ShmooDir][Socket][Controller][Channel][Lane];

#if ENBL_RESULTS_DEBUG_LOG_MSGS > 1
            NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
              "  Socket=%u Controller=%u Channel=%u Lane=%u ShmooDir=%u Offset=%u\n",
              Socket, Controller, Channel, Lane, ShmooDir,
              pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir]);
#endif
          } // end for each shmoo direction
        } // end for each lane
      } // end for each channel
    } // end for each controller
  } // end for each socket

  return 0;
} // end function ReportLaneMarginResults

/**
  This function is used to report rank margin results.

  The ShmooDirCount and pShmooDirs input parameters are to support the fact
  that the backside command margining needs to test the different shmoo
  directions separately.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       ResultType         RMT result element type.
  @param[in]       ShmooDirCount      Number of entries in pShmooDirs array.
  @param[in]       pShmooDirs         Pointer to array of shmoo direction values.

  @retval  0  success
  @retval  1  error occurred
**/
static
UINT8
ReportRankMarginResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA    *pCoreTestData,
  IN RMT_RESULT_TYPE           ResultType,
  IN UINT8                     ShmooDirCount,
  IN CONST SHMOO_DIRECTION     *pShmooDirs
  )
{
  UINT8               Socket;
  UINT8               Controller;
  UINT8               Channel;
  UINT8               Dimm;
  UINT8               Rank;
  UINT8               Lane;
  UINT8               ShmooDirIdx;
  SHMOO_DIRECTION     ShmooDir;
  RMT_RESULT_COLUMNS *pElement;
  UINT8               MinLaneLastPassLaneOffset;
  BOOLEAN             IsDdrT;
  UINT8               NumSubCh;
  UINT8               SubChMaxBit;
  UINT8               SubCh;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.ReportRankMarginResults()\n");
#endif

  GetSubChInfo (pCoreTestData->SystemInfo.BusWidth, &NumSubCh, &SubChMaxBit);

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // IF this channel is not enabled for validation THEN skip it
        if (!IsChannelValEnabled(SsaServicesHandle, &pCoreTestData->SystemInfo,
          &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
          &pCoreTestData->CurrentMemPointTestCfg,
#else
          &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
          Socket, Controller, Channel)) {
          continue;
        }

        // IF this channel has fewer rank combinations than the one we're
        // currently on THEN this is repeat data so skip it
        if (pCoreTestData->RankCombinationCnts[Socket][Controller][Channel] <=
          pCoreTestData->CurrentRankCombinationIndex) {
          continue;
        }

        Dimm = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Dimm;
        Rank = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Rank;

        // The IsDdrT is no longer determined by the pCoreTestData.CurrentIsDdrT because
        // we test DDR and DDRT together.
        // We need to base on the socket, control, dimm to determine the IsDdrT field.
        if (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm] == SsaMemoryDdrT) {
          IsDdrT = TRUE;
        }
        else {
          IsDdrT = FALSE;
        }

        //
        // Break the channel bus into subchannel. DDR4 is treated as one subchannel.
        // We use the lane=0 or =SubChMaxBit to distingush the rank margin result of
        // subchannel 0 or 1.
        // Previously, the lane value is always 0 and not care when reporting rank margin result.
        //
        for (SubCh = 0; SubCh < NumSubCh; SubCh++) {
          //
          // Get the pCoreTestData->pResultElements pointer saved into pElement
          //
          if (GetResultElement (SsaServicesHandle, pCoreTestData, ResultType,
            pCoreTestData->CurrentIoLevel, IsDdrT, Socket,
            Controller, Channel, Dimm, Rank, 0, 0, SubCh * SubChMaxBit, 0, &pElement)) {
            return 1;
          }

          // FOR each shmoo direction:
          for (ShmooDirIdx = 0; ShmooDirIdx < ShmooDirCount; ShmooDirIdx++) {
            ShmooDir = pShmooDirs[ShmooDirIdx];

            // preset the minimum lane last pass offset to the largest value
            MinLaneLastPassLaneOffset = 0xFF;

            // FOR each lane:
            for (Lane = SubCh * SubChMaxBit; Lane < (SubCh + 1) * SubChMaxBit; Lane++) {
              // IF we found a last pass offset for this lane
              if ((pCoreTestData->LastPassFoundMasks[ShmooDir][Socket][Controller][Channel][Lane / 8] &
                (1 << (Lane % 8))) != 0) {
                // IF this lane's last pass offset is less than the current minimum
                if (MinLaneLastPassLaneOffset >
                  pCoreTestData->LastPassLaneOffsets[ShmooDir][Socket][Controller][Channel][Lane]) {
                  // this lane's last pass offset is the new minimum
                  MinLaneLastPassLaneOffset = \
                    pCoreTestData->LastPassLaneOffsets[ShmooDir][Socket][Controller][Channel][Lane];
                }
              }
              // ELSE we didn't find a last pass offset for this lane
              else {
                // the overall last pass offset is the minimum value
                MinLaneLastPassLaneOffset = 0;

                // exit the for lane loop now
                break;
              }
            } // end for each lane

            pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir] = \
              MinLaneLastPassLaneOffset;

#if ENBL_RESULTS_DEBUG_LOG_MSGS > 1
            NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
              "  Socket=%u Controller=%u Channel=%u ShmooDir=%u Offset=%u\n",
              Socket, Controller, Channel, ShmooDir, MinLaneLastPassLaneOffset);
#endif
          } // end for each shmoo direction
        } // end of each subchannel
      } // end for each channel
    } // end for each controller
  } // end for each socket

  return 0;
} // end function ReportRankMarginResults

#if SUPPORT_FOR_TURNAROUNDS
/**
  The function is used to report rank-to-rank turnaround margin results.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 ReportTurnaroundMarginResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData)
{
  UINT8 Socket, Controller, Channel, Lane, DimmA, RankA, DimmB, RankB, ShmooDir;
  RMT_RESULT_COLUMNS *pElement;
  UINT8 MinLaneLastPassLaneOffset;
  BOOLEAN IsDdrT;
#if MULTIPLE_R2R_TRAFFIC_MODES
  UINT8 DefaultMarginValue = 0xFF;
#else
  UINT8 DefaultMarginValue = 0;
#endif

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.ReportTurnaroundMarginResults()\n");
#endif

  // FOR each socket:
  for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
    // FOR each controller:
    for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
      // FOR each channel:
      for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
        // IF this channel is not configured for rank-to-rank turnarounds THEN skip it
#if SUPPORT_FOR_EXTENDED_RANGE
        if (pCoreTestData->CurrentMemPointTestCfg.RankTestModes[Socket]\
          [Controller][Channel] != Turnarounds) {
          continue;
        }
#else
        if (pCoreTestData->SelectMemPointTestCfg.RankTestModes[Socket]\
          [Controller][Channel] != Turnarounds) {
          continue;
        }
#endif // !SUPPORT_FOR_EXTENDED_RANGE

        // IF this channel is not enabled for validation THEN skip it
        if (!IsChannelValEnabled(SsaServicesHandle, &pCoreTestData->SystemInfo,
          &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
          &pCoreTestData->CurrentMemPointTestCfg,
#else
          &pCoreTestData->SelectMemPointTestCfg,
#endif // !SUPPORT_FOR_EXTENDED_RANGE
          Socket, Controller, Channel)) {
          continue;
        }

        // IF this channel has fewer rank combinations than the one we're
        // currently on THEN this is repeat data so skip it
        if (pCoreTestData->RankCombinationCnts[Socket][Controller][Channel] <=
          pCoreTestData->CurrentRankCombinationIndex) {
          continue;
        }

        DimmA = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Dimm;
        RankA = pCoreTestData->DimmRankAs[Socket][Controller][Channel].Rank;
        DimmB = pCoreTestData->DimmRankBs[Socket][Controller][Channel].Dimm;
        RankB = pCoreTestData->DimmRankBs[Socket][Controller][Channel].Rank;

        // The IsDdrT is no longer determined by the pCoreTestData.CurrentIsDdrT because
        // we test DDR and DDRT together.
        // We need to base on the socket, control, dimm to determine the IsDdrT field.
        // Also because DDRT dimm can only pair with DDRT dimm in turnaround test, we can safely
        // determine the dimm type by looking only at DimmA.
        if (pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][DimmA] == SsaMemoryDdrT) {
          IsDdrT = TRUE;
        }
        else {
          IsDdrT = FALSE;
        }

        if (GetResultElement(SsaServicesHandle, pCoreTestData,
          TurnaroundRmtResultType, pCoreTestData->CurrentIoLevel,
          IsDdrT, Socket, Controller, Channel, DimmA,
          RankA, DimmB, RankB, 0, DefaultMarginValue, &pElement)) {
          return 1;
        }

        // FOR each shmoo direction:
        for (ShmooDir = 0; ShmooDir < RmtShmooDirMax; ShmooDir++) {
          // preset the minimum lane last pass offset to the largest value
          MinLaneLastPassLaneOffset = 0xFF;

          // FOR each lane:
          for (Lane = 0; Lane < pCoreTestData->SystemInfo.BusWidth; Lane++) {
            // IF we found a last pass offset for this lane
            if ((pCoreTestData->LastPassFoundMasks[ShmooDir][Socket]\
              [Controller][Channel][Lane / 8] & (1 << (Lane % 8)))!= 0) {
                // IF this lane's last pass offset is less than the current
                // minimum
                if (MinLaneLastPassLaneOffset >
                  pCoreTestData->LastPassLaneOffsets[ShmooDir][Socket]\
                  [Controller][Channel][Lane]) {
                    // this lane's last pass offset is the new minimum
                    MinLaneLastPassLaneOffset = \
                      pCoreTestData->LastPassLaneOffsets[ShmooDir][Socket]\
                      [Controller][Channel][Lane];
                }
            }
            // ELSE we didn't find a last pass offset for this lane
            else {
              // the overall last pass offset is the minimum value
              MinLaneLastPassLaneOffset = 0;

              // exit the for lane loop now
              break;
            }
          } // end for each lane

#if ENBL_RESULTS_DEBUG_LOG_MSGS > 1
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "  Socket=%u Controller=%u Channel=%u ShmooDir=%u Offset=%u\n",
            Socket, Controller, Channel, ShmooDir, MinLaneLastPassLaneOffset);
#endif
#if MULTIPLE_R2R_TRAFFIC_MODES
          // IF the minimum last pass value is less than the current value THEN
          if (MinLaneLastPassLaneOffset < pElement->Margin\
            [pCoreTestData->CurrentMarginGroupSubIndex][ShmooDir]) {
#else
          {
#endif
            pElement->Margin[pCoreTestData->CurrentMarginGroupSubIndex]\
              [ShmooDir] = MinLaneLastPassLaneOffset;
          }
        } // end for each shmoo direction
      } // end for each channel
    } // end for each controller
  } // end for each socket

  return 0;
} // end function ReportTurnaroundMarginResults
#endif // SUPPORT_FOR_TURNAROUNDS

#if SUPPORT_FOR_DDRT
/**
@brief
  The function reset the CADB on-deselect setting and start a point test. It is a
  workaround to an issue that the on_deselect setting of the DDR4 could cause margin
  variation(drop) of the sub-sequentially DDRT test.

  @param[in, out]  SsaServicesHandle      Pointer to SSA services.
  @param[in]       pCoreTestData          Pointer to RMT_CORE_TEST_DATA structure
  @param[out]      pTestStat              Pointer to test status in results metadata structure.

  @retval  0  success
  @retval  1  error occurred
**/
STATIC UINT8
CleanUpWithPointTest (
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN RMT_CORE_TEST_DATA* pCoreTestData,
  OUT TEST_STATUS *pTestStat
  )
{
  UINT8 Controller, Channel;
  CADB_MODE CadbModes_Saved[MAX_CONTROLLER_CNT][MAX_CHANNEL_CNT];
  BOOLEAN HasAnyOnDeselectEnabled = FALSE;
  PSYSHOST Host = GetSysHostPointer ();
#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
    "CleanUpWithPointTest()\n");
#endif

  // Skip if there is no DDRT device involved.
  if (!SSAIsDdrtDimmPresent (Host)) {
    return 0;
  }

  // Save current CADB mode setting
  for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
    for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++){
      CadbModes_Saved[Controller][Channel] = pCoreTestData->CpgcPointTestCfg.CadbModes[Controller][Channel];
      if (pCoreTestData->CpgcPointTestCfg.CadbModes[Controller][Channel] == OnDeselectCadbMode) {
        HasAnyOnDeselectEnabled = TRUE;
      }
    }
  }

  // Skip if OnDeselect was not enabled
  if (!HasAnyOnDeselectEnabled) {
    return 0;
  }

  // Override the cadb on-deselect
  for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
    for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
      if (pCoreTestData->CpgcPointTestCfg.CadbModes[Controller][Channel]!= NormalCadbMode) {
        pCoreTestData->CpgcPointTestCfg.CadbModes[Controller][Channel] = NormalCadbMode;
      }
    }
  }

  // Re-initialize the rank programming which will re-program the CADB control registers.
  if (SetCpgcPointTestRankCombinationIndex (SsaServicesHandle,
    &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
    &pCoreTestData->CurrentMemPointTestCfg, &pCoreTestData->CpgcPointTestCfg,
    pCoreTestData->pCpgcPointTestData,
    pCoreTestData->CurrentRankCombinationIndex,
    TRUE, // need to update HW register setting
    pCoreTestData->pTestStat)) {
    return 1;
  }

  // Do not save the test results. Change the result handler to NULL
  if (ChangeCpgcPointTestResultHandler (SsaServicesHandle, NULL ,pCoreTestData->pCpgcPointTestData)) {
    return 1;
  }
  // Run a point test at the current offset which should be nominal
  if (RunCpgcPointTest (
    SsaServicesHandle, &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CurrentMemPointTestCfg,
#else
    &pCoreTestData->SelectMemPointTestCfg,
#endif  // SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CpgcPointTestCfg, pCoreTestData->pCpgcPointTestData, NULL,
    pTestStat)) {
      return 1;
  }

  // Restore current CADB mode setting. It will take effect when set up the next test rank.
  for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
    for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
      pCoreTestData->CpgcPointTestCfg.CadbModes[Controller][Channel] = CadbModes_Saved[Controller][Channel];
    }
  }

  // Restore the result handler
  if (ChangeCpgcPointTestResultHandler (SsaServicesHandle, RmtPointTestResultHandler ,pCoreTestData->pCpgcPointTestData)) {
    return 1;
  }

  return 0;
} // end function CleanUpWithPointTest
#endif SUPPORT_FOR_DDRT

/**
  This function is used to initialize the common elements in the given results
  metadata structure.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       HasDdrtDevices     Flag indicating whether system has any DDR-T devices.
  @param[in]       ResultEleCnt       Number of result elements.

  @retval  0  success
  @retval  1  error occurred
**/
static UINT8 InitCommonMetadata(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN BOOLEAN HasDdrtDevices,
  IN UINT16 ResultEleCnt)
{
  CONST RMT_CONFIG *pTestCfg = pCoreTestData->pTestCfg;
  RMT_RESULT_METADATA *pMetadata = pCoreTestData->pMetadata;
  MRC_LT IoLevel;
  BOOLEAN IsDdrT;
  UINT8 Socket = 0, Controller = 0, Channel = 0, Dimm = 0;
  UINT8 DdrSocket = 0, DdrController = 0, DdrChannel = 0, DdrDimm = 0;
  BOOLEAN DdrFound = FALSE;
#if SUPPORT_FOR_DDRT
  UINT8 DdrtSocket = 0, DdrtController = 0, DdrtChannel = 0, DdrtDimm = 0;
  BOOLEAN DdrtFound = FALSE;
#endif // SUPPORT_FOR_DDRT
  UINT8 Rank = 0;
  UINT8 LaneMasks[MAX_BUS_WIDTH / 8];
  INT16 MinOffset, MaxOffset;
  UINT16 Delay, StepUnit;
  SSA_STATUS RetStat;
  UINT16 Bitmask;

  pMetadata->EnableCtlAllMargin = pTestCfg->EnableCtlAllMargin;
  pMetadata->SinglesBurstLength = pTestCfg->SinglesBurstLength;
  pMetadata->SinglesLoopCount = pTestCfg->SinglesLoopCount;
  pMetadata->TurnaroundsBurstLength = pTestCfg->TurnaroundsBurstLength;
  pMetadata->TurnaroundsLoopCount = pTestCfg->TurnaroundsLoopCount;
  pMetadata->ScramblerOverrideMode = pTestCfg->ScramblerOverrideMode;

#if SUPPORT_FOR_EXTENDED_RANGE
  pCoreTestData->pMetadata->EnableExtendedRange = \
    pCoreTestData->pTestCfg->EnableExtendedRange;
#endif // SUPPORT_FOR_EXTENDED_RANGE

  SetMem (LaneMasks, sizeof (LaneMasks), 0xFF);

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // find the first available DDR DIMM
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // FOR each socket:
  for (DdrSocket = 0; DdrSocket < MAX_SOCKET_CNT; DdrSocket++) {
    if ((pCoreTestData->SystemInfo.SocketBitMask & (1 << DdrSocket)) == 0) {
      continue;
    }

    // FOR each controller:
    for (DdrController = 0; DdrController < MAX_CONTROLLER_CNT; DdrController++) {
      if ((pCoreTestData->MemCfg.ControllerBitmasks[DdrSocket] &
        (1 << DdrController)) == 0) {
        continue;
      }

      // FOR each channel (while we haven't found a DDR device):
      for (DdrChannel = 0; DdrChannel < MAX_CHANNEL_CNT; DdrChannel++) {
        if ((pCoreTestData->MemCfg.ChannelBitmasks[DdrSocket][DdrController] &
          (1 << DdrChannel)) == 0) {
          continue;
        }

        // FOR each DIMM:
        for (DdrDimm = 0; DdrDimm < MAX_DIMM_CNT; DdrDimm++) {
          if ((pCoreTestData->MemCfg.DimmBitmasks[DdrSocket][DdrController][DdrChannel] &
            (1 << DdrDimm)) == 0) {
            continue;
          }

          // IF the device is not a DDR-T
          if (pCoreTestData->MemCfg.MemoryTech[DdrSocket][DdrController][DdrChannel][DdrDimm] !=
            SsaMemoryDdrT) {
            Bitmask = 1 << ((Controller * MAX_CHANNEL_CNT * MAX_DIMM_CNT) +
              (Channel * MAX_DIMM_CNT) + Dimm);

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
            // IF the system has no devices that support backside command
            // margining or this device supports backside command margining
            // (i.e., if the system has devices support backside command
            // margining then chose a device that support backside command
            // margining so that we can get the information for the
            // step unit info for backside CmdVref)
            if (!IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks) ||
              (pCoreTestData->BacksideCmdBitmasks[Socket] & Bitmask)) {
              DdrFound = TRUE;
              break;
            }
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
          } // end if the device is not a DDR-T
        } // end for each DIMM

        if (DdrFound) {
          break;
        }
      } // end for each controller

      if (DdrFound) {
        break;
      }
    } // end for each controller

    if (DdrFound) {
      break;
    }
  } // end for each socket

#if SUPPORT_FOR_DDRT
  // IF the system has DDR-T devices
  if (HasDdrtDevices) {
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // find the first available DDR-T device
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // FOR each socket:
    for (DdrtSocket = 0; DdrtSocket < MAX_SOCKET_CNT; DdrtSocket++) {
      if ((pCoreTestData->SystemInfo.SocketBitMask & (1 << DdrtSocket)) == 0) {
        continue;
      }

      // FOR each controller:
      for (DdrtController = 0; DdrtController < MAX_CONTROLLER_CNT; DdrtController++) {
        if ((pCoreTestData->MemCfg.ControllerBitmasks[DdrtSocket] &
          (1 << DdrtController)) == 0) {
          continue;
        }

        // FOR each channel (while we haven't found a DDR device):
        for (DdrtChannel = 0; DdrtChannel < MAX_CHANNEL_CNT; DdrtChannel++) {
          if ((pCoreTestData->MemCfg.ChannelBitmasks[DdrtSocket][DdrtController] &
            (1 << DdrtChannel)) == 0) {
            continue;
          }

          // FOR each DIMM:
          for (DdrtDimm = 0; DdrtDimm < MAX_DIMM_CNT; DdrtDimm++) {
            if ((pCoreTestData->MemCfg.DimmBitmasks[DdrtSocket][DdrtController][DdrtChannel] &
              (1 << DdrtDimm)) == 0) {
              continue;
            }

            if (pCoreTestData->MemCfg.MemoryTech[DdrtSocket][DdrtController][DdrtChannel][DdrtDimm] ==
              SsaMemoryDdrT) {
              DdrtFound = TRUE;
              break;
            }
          } // end for each DIMM

          if (DdrtFound) {
            break;
          }
        } // end for each controller

        if (DdrtFound) {
          break;
        }
      } // end for each controller

      if (DdrtFound) {
        break;
      }
    } // end for each socket
  } // end if the system has DDR-T devices
#endif // SUPPORT_FOR_DDRT

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
#ifdef __STUB__
  // confirm design assumption
  ASSERT (DdrLevel == 0);
  ASSERT (LrbufLevel == 1);
#endif // __STUB__
  // FOR each I/O level:
  for (IoLevel = DdrLevel; IoLevel <= LrbufLevel; IoLevel++) {
    // IF this I/O level is not enabled for testing THEN skip it
    if ((pTestCfg->IoLevelBitmask & (1 << IoLevel)) == 0) {
      continue;
    }
#else
  {
    IoLevel = DdrLevel;
#endif
#if SUPPORT_FOR_DDRT
    // FOR non-DDR-T and DDR-T devices:
    for (IsDdrT = 0; IsDdrT <= 1; IsDdrT++) {
      // IF this is for DDR-T devices and the system has no DDR-T devices THEN skip it
      if (IsDdrT && !HasDdrtDevices) {
        continue;
      }
#else
    {
      IsDdrT = FALSE;
#endif // !SUPPORT_FOR_DDRT

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
      // IF the I/O level is the backside and there are no devices with a
      // backside THEN skip it
      if ((IoLevel == LrbufLevel) &&
        (!IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks) &&
        !pCoreTestData->MemCfg.IsLrDimms && !IsDdrT)) {
          continue;
      }
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT

      // IF this is plain DDR
      if (IsDdrT == 0) {
#if SUPPORT_FOR_DDRT
        if (!DdrFound) {
          continue;
        }
#endif // SUPPORT_FOR_DDRT

        Socket = DdrSocket;
        Controller = DdrController;
        Channel = DdrChannel;
        Dimm = DdrDimm;
      }
#if SUPPORT_FOR_DDRT
      // ELSE this is DDR-T
      else {
        if (!DdrtFound) {
          continue;
        }

        Socket = DdrtSocket;
        Controller = DdrtController;
        Channel = DdrtChannel;
        Dimm = DdrtDimm;
      }
#endif // SUPPORT_FOR_DDRT

      // IF this is plain DDR
      if (IsDdrT == 0) {
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "  GetMarginParamLimits(Socket=%u Controller=%u Channel=%u "
          "Dimm=%u Rank=%u IoLevel=%u MarginGroup=%u)\n",
          Socket, Controller, Channel, Dimm, Rank, IoLevel, RxDqsDelay);
#endif
        RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamLimits(
          SsaServicesHandle, Socket, Controller, Channel, Dimm, Rank, LaneMasks,
          IoLevel, RxDqsDelay, &MinOffset, &MaxOffset, &Delay, &StepUnit);
        if (RetStat == Success) {
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "    StepUnit=%d\n", StepUnit);
#endif
          pMetadata->PiStepUnit[IoLevel] = (UINT8) StepUnit;
        }

#if ENBL_BIOS_SSA_API_DEBUG_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "  GetMarginParamLimits(Socket=%u Controller=%u Channel=%u "
          "Dimm=%u Rank=%u IoLevel=%u MarginGroup=%u)\n",
          Socket, Controller, Channel, Dimm, Rank, IoLevel, RxVref);
#endif
        RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamLimits(
          SsaServicesHandle, Socket, Controller, Channel, Dimm, Rank, LaneMasks,
          IoLevel, RxVref, &MinOffset, &MaxOffset, &Delay, &StepUnit);
        if (RetStat == Success) {
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "    StepUnit=%d\n", StepUnit);
#endif
          pMetadata->RxVrefStepUnit[IoLevel] = StepUnit;
        }
      } // end if this is plain DDR

#if ENBL_BIOS_SSA_API_DEBUG_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  GetMarginParamLimits(Socket=%u Controller=%u Channel=%u "
        "Dimm=%u Rank=%u IoLevel=%u MarginGroup=%u)\n",
        Socket, Controller, Channel, Dimm, Rank, IoLevel, TxVref);
#endif
      RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamLimits(
        SsaServicesHandle, Socket, Controller, Channel, Dimm, Rank, LaneMasks,
        IoLevel, TxVref, &MinOffset, &MaxOffset, &Delay, &StepUnit);
      if (RetStat == Success) {
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "    StepUnit=%d\n", StepUnit);
#endif
        pMetadata->TxVrefStepUnit[IsDdrT][IoLevel] = StepUnit;
      }

      // IF rank margining is enabled and either the I/O level is the frontside
      // or the system has devices that support backside command margining
      if (pTestCfg->EnableRankMargin
#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
        &&
        ((IoLevel == DdrLevel) ||
        IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks))
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
        ) {
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "  GetMarginParamLimits(Socket=%u Controller=%u Channel=%u "
          "Dimm=%u Rank=%u IoLevel=%u MarginGroup=%u)\n",
          Socket, Controller, Channel, Dimm, Rank, IoLevel, CmdVref);
#endif
        RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamLimits(
          SsaServicesHandle, Socket, Controller, Channel, Dimm, Rank, LaneMasks,
          IoLevel, CmdVref, &MinOffset, &MaxOffset, &Delay, &StepUnit);
        if (RetStat == Success) {
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "    StepUnit=%d\n", StepUnit);
#endif
          pMetadata->CmdVrefStepUnit[IsDdrT][IoLevel] = StepUnit;
        }
      } // end if rank margining is enabled
    } // end for non-DDR-T and DDR-T devices
  } // end for each I/O level

  pMetadata->BusWidth = pCoreTestData->SystemInfo.BusWidth;
  pMetadata->BusFreq = pCoreTestData->SystemInfo.BusFreq;

  SsaServicesHandle->SsaMemoryConfig->GetMemVoltage(SsaServicesHandle,
    &pMetadata->MemVoltage);

  pMetadata->ResultEleCount = ResultEleCnt;

  return 0;
} // end function InitCommonMetadata

/**
  This function is used to set up the results.  It creates the results buffer
  and gets a pointer to the metadata structure.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       ResultEleCnt       Number of RMT result elements required.
  @param[out]      ppMetadata         Pointer to pointer to results metadata structure.

  @retval  0  success
  @retval  1  error occurred
**/
UINT8 SetupResults(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN UINT32 ResultEleCnt,
  OUT RMT_RESULT_METADATA **ppMetadata)
{
  SSA_STATUS RetStat;
  SSA_STATUS RequestedResultEleCntRetStat;
  UINT32 MetadataSize      = sizeof(RMT_RESULT_METADATA);
  UINT32 ResultElementSize = sizeof(RMT_RESULT_COLUMNS);
  EFI_GUID MetadataGuid = RMT_RESULT_METADATA_GUID;
  EFI_GUID ColumnsGuid = RMT_RESULT_COLUMNS_GUID;
  RMT_RESULT_METADATA *pMetadata;
  TEST_STATUS *pTestStat;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "SetupResults(ResultEleCnt=%u)\n", ResultEleCnt);
#endif

  // --------------------------------------------------------------------------
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  CreateResultBuffer(MetadataSize=%u ResultElementSize=%u ResultEleCnt=%u)\n",
    MetadataSize, ResultElementSize, ResultEleCnt);
#endif
  RequestedResultEleCntRetStat = SsaServicesHandle->SsaResultsConfig->CreateResultBuffer(
    SsaServicesHandle, MetadataSize, ResultElementSize, ResultEleCnt);

  // IF we couldn't create the result buffer with the requested number of result elements
  if (RequestedResultEleCntRetStat != Success) {
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: Unable to create result buffer with requested number of elements (%u).\n",
      ResultEleCnt);

    // IF both frontside and backside margining are enabled OR both per-rank and
    // per-lane results are enabled
    if (((pCoreTestData->pTestCfg->IoLevelBitmask & (1 << DdrLevel)) &&
      (pCoreTestData->pTestCfg->IoLevelBitmask & (1 << LrbufLevel))) ||
      ((pCoreTestData->pTestCfg->EnableRankMargin) &&
      (pCoreTestData->pTestCfg->EnableLaneMargin))) {
      // just return the error - the calling function will disable backside
      // margining and/or per-lane results and try again
      return 1;
    }

    // try again with a single result element so that we can report the error
    ResultEleCnt = 1;
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "  CreateResultBuffer(MetadataSize=%u ResultElementSize=%u ResultsCapacity=%u\n",
      MetadataSize, ResultElementSize, ResultEleCnt);
#endif
    RetStat = SsaServicesHandle->SsaResultsConfig->CreateResultBuffer(
      SsaServicesHandle, MetadataSize, ResultElementSize, ResultEleCnt);
    if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__, NULL)) {
      return 1;
    }
  } // end if we couldn't create the result buffer ...

#if ENBL_BIOS_SSA_API_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  GetMetadata()\n");
#endif
  RetStat = SsaServicesHandle->SsaResultsConfig->GetMetadata(
    SsaServicesHandle, ppMetadata);
  if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__, NULL)) {
    return 1;
  }

  pMetadata = *ppMetadata;

  // zero the metadata
  ZeroMem (pMetadata, sizeof (*pMetadata));

  // set the version information
  pMetadata->MajorVer = BSSA_TC_MAJOR_VER;
  pMetadata->MinorVer = BSSA_TC_MINOR_VER;
  pMetadata->RevVer = BSSA_TC_REV_VER;
  pMetadata->BuildVer = BSSA_TC_BUILD_VER;

  pTestStat = (TEST_STATUS*) &pMetadata->StatusCode;

#if ENBL_BIOS_SSA_API_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  SetMetadataType()\n");
#endif
  RetStat = SsaServicesHandle->SsaResultsConfig->SetMetadataType(
    SsaServicesHandle, &MetadataGuid);
  if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__, pTestStat)) {
    return 1;
  }

#if ENBL_BIOS_SSA_API_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  SetResultElementType()\n");
#endif
  RetStat = SsaServicesHandle->SsaResultsConfig->SetResultElementType(
    SsaServicesHandle, &ColumnsGuid);
  if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__, pTestStat)) {
    return 1;
  }

  // IF we couldn't create the result buffer with the requested number of result elements
  if (RequestedResultEleCntRetStat != Success) {
    RMT_RESULT_COLUMNS *pElement;

    // we need to process the one element so that the columnar GUID shows up in the result
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "  GetNextResultElement()\n");
#endif
    RetStat = SsaServicesHandle->SsaResultsConfig->GetNextResultElement(
      SsaServicesHandle, &pElement);
    if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__, pTestStat)) {
      return 1;
    }

    // just set the element values to all 0's
    ZeroMem (pElement, sizeof (*pElement));
  }

  // complete processing of the return status from the call to
  // CreateResultBuffer with the requested number of result elements
  if (ChkRetStat(SsaServicesHandle, RequestedResultEleCntRetStat, __FILE__,
    __LINE__, pTestStat)) {
    return 1;
  }

  return 0;
} // end function SetupResults

/**
  This function is used to log the RMT test configuration.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in]       pRmtTestCfg        Pointer to RMT test configuration structure.
**/
VOID LogRmtTestCfg(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN CONST RMT_CONFIG *pRmtTestCfg)
{
#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "LogRmtTestCfg()\n");
#endif

  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "\n"
    "RMT Configuration:\n");
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  SocketBitmask=0x%X\n", pRmtTestCfg->SocketBitmask);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  ControllerBitmask=0x%X\n", pRmtTestCfg->ControllerBitmask);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  IoLevelBitmask=0x%X\n", pRmtTestCfg->IoLevelBitmask);

  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EnableRankMargin=%u\n", pRmtTestCfg->EnableRankMargin);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EnableCtlAllMargin=%u\n", pRmtTestCfg->EnableCtlAllMargin);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EnableLaneMargin=%u\n", pRmtTestCfg->EnableLaneMargin);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EnableTurnaroundMargin=%u\n", pRmtTestCfg->EnableTurnaroundMargin);

  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  RxDqsStepSize=%u\n", pRmtTestCfg->RxDqsStepSize);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  TxDqStepSize=%u\n", pRmtTestCfg->TxDqStepSize);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  RxVrefStepSize=%u\n", pRmtTestCfg->RxVrefStepSize);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  TxVrefStepSize=%u\n", pRmtTestCfg->TxVrefStepSize);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  CmdAllStepSize=%u\n", pRmtTestCfg->CmdAllStepSize);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  CmdVrefStepSize=%u\n", pRmtTestCfg->CmdVrefStepSize);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  CtlAllStepSize=%u\n", pRmtTestCfg->CtlAllStepSize);
#if SUPPORT_FOR_DDRT
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EridDelayStepSize=%u\n", pRmtTestCfg->EridDelayStepSize);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EridVrefStepSize=%u\n", pRmtTestCfg->EridVrefStepSize);
#endif

  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  SinglesBurstLength=%u\n", pRmtTestCfg->SinglesBurstLength);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  SinglesLoopCount=%u\n", pRmtTestCfg->SinglesLoopCount);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  SinglesBinarySearchLoopCount=%u\n", pRmtTestCfg->SinglesBinarySearchLoopCount);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  TurnaroundsBurstLength=%u\n", pRmtTestCfg->TurnaroundsBurstLength);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  TurnaroundsLoopCount=%u\n", pRmtTestCfg->TurnaroundsLoopCount);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  TurnaroundsBinarySearchLoopCount=%u\n", pRmtTestCfg->TurnaroundsBinarySearchLoopCount);

  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  OptimizedShmooBitmask=0x%08X\n", pRmtTestCfg->OptimizedShmooBitmask);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  ScramblerOverrideMode=%u\n", pRmtTestCfg->ScramblerOverrideMode);
#if SUPPORT_FOR_EXTENDED_RANGE
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EnableExtendedRange=%u\n", pRmtTestCfg->EnableExtendedRange);
#endif // SUPPORT_FOR_EXTENDED_RANGE
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EnableTestResultLogging=%u\n", pRmtTestCfg->EnableTestResultLogging);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  EnableLaneMarginPlot=%u\n", pRmtTestCfg->EnableLaneMarginPlot);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  TestStatusLogLevel=%u\n", pRmtTestCfg->TestStatusLogLevel);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "\n");
} // end function LogRmtTestCfg

/**
  This function is used to check the RMT test configuration for correctness.
  Some test configuration values may be updated based on their value and the
  given memory configuration.

  @param[in, out]  SsaServicesHandle          Pointer to SSA services.
  @param[in, out]  pCoreTestData              Pointer to RMT core test data.
  @param[in]       MaxIoLevelBitMask          Maximum I/O level bitmask value.
  @param[in]       IsLoopCountExponential     Boolean value indicating whether or not loop count value is exponential.
  @param[in]       MaxLoopCountVal            The maximum loop count value.  If IsLoopCountExponential is TRUE then the MaxLoopCountVal value is the maximum exponent value.
  @param[in]       MaxBurstLengthExponentVal  The maximum burst length exponent value.  For a CPGC engine that doesn't support exponential burst length values, this value should be 0.
  @param[in]       MaxBurstLengthLinearVal    The maximum burst length linear value.  Some CPGC engines use linear for smaller values and exponential (2^n) for larger values.  For a CPGC engine that doesn't support linear burst length values, this value should be 0.
  @param[out]      pTestStat                  Pointer to test status in results metadata structure.

  @retval  0  success
  @retval  1  error occurred
**/
SSA_STATUS ChkRmtTestCfg(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA *pCoreTestData,
  IN UINT8 MaxIoLevelBitMask,
  IN BOOLEAN IsLoopCountExponential,
  IN UINT32 MaxLoopCountVal,
  IN UINT8 MaxBurstLengthExponentVal,
  IN UINT32 MaxBurstLengthLinearVal)
{
  CONST RMT_CONFIG *pTestCfg = pCoreTestData->pTestCfg;
  TEST_STATUS *pTestStat = pCoreTestData->pTestStat;
  UINT8 BurstLengthExponent;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "ChkRmtTestCfg()\n");
#endif

  if ((pTestCfg->IoLevelBitmask == 0) ||
    (pTestCfg->IoLevelBitmask > MaxIoLevelBitMask)) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: IoLevelBitmask value (0x%X) is out of range (0 < val <= 0x%X).\n",
      pTestCfg->IoLevelBitmask, MaxIoLevelBitMask);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (pTestCfg->RxDqsStepSize < 1) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: RxDqsStepSize value (%u) is out of range (1 <= val).\n",
      pTestCfg->RxDqsStepSize);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (pTestCfg->TxDqStepSize < 1) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: TxDqStepSize value (%u) is out of range (1 <= val).\n",
      pTestCfg->TxDqStepSize);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (pTestCfg->RxVrefStepSize < 1) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: RxVrefStepSize value (%u) is out of range (1 <= val).\n",
      pTestCfg->RxVrefStepSize);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (pTestCfg->TxVrefStepSize < 1) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: TxVrefStepSize value (%u) is out of range (1 <= val).\n",
      pTestCfg->TxVrefStepSize);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (pTestCfg->CmdAllStepSize < 1) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: CmdAllStepSize value (%u) is out of range (1 <= val).\n",
      pTestCfg->CmdAllStepSize);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (pTestCfg->CmdVrefStepSize < 1) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: CmdVrefStepSize value (%u) is out of range (1 <= val).\n",
      pTestCfg->CmdVrefStepSize);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (pTestCfg->CtlAllStepSize < 1) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: CtlAllStepSize value (%u) is out of range (1 <= val).\n",
      pTestCfg->CtlAllStepSize);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  BurstLengthExponent = GetHighestBitSetInMask(pTestCfg->SinglesBurstLength, 32);

  if (!((pTestCfg->SinglesBurstLength != 0) &&
        (((pTestCfg->SinglesBurstLength == (1 << BurstLengthExponent)) &&
          ((UINT32) pTestCfg->SinglesBurstLength <= ((UINT32) 1 << MaxBurstLengthExponentVal))) ||
         (((UINT32) pTestCfg->SinglesBurstLength <= MaxBurstLengthLinearVal))))) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
     "ERROR: SinglesBurstLength value (%u) is out of range.\n",
     pTestCfg->SinglesBurstLength);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (!((pTestCfg->SinglesLoopCount != 0) &&
        ((IsLoopCountExponential &&
         (pTestCfg->SinglesLoopCount <= ((UINT32) 1 << MaxLoopCountVal))) ||
        (!IsLoopCountExponential &&
         (pTestCfg->SinglesLoopCount <= MaxLoopCountVal))))) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
     "ERROR: SinglesLoopCount value (%u) is out of range.\n",
     pTestCfg->SinglesLoopCount);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

  if (!((pTestCfg->SinglesBinarySearchLoopCount != 0) &&
    ((IsLoopCountExponential &&
    (pTestCfg->SinglesBinarySearchLoopCount <= ((UINT32) 1 << MaxLoopCountVal))) ||
    (!IsLoopCountExponential &&
    (pTestCfg->SinglesBinarySearchLoopCount <= MaxLoopCountVal))))) {
#if ENBL_VERBOSE_ERROR_MSGS
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "ERROR: SinglesBinarySearchLoopCount value (%u) is out of range.\n",
      pTestCfg->SinglesBinarySearchLoopCount);
#endif
    ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
    return 1;
  }

#if SUPPORT_FOR_TURNAROUNDS
  // IF rank-to-rank turnaround testing is enabled
  if (pTestCfg->EnableTurnaroundMargin) {
    BurstLengthExponent = GetHighestBitSetInMask(pTestCfg->TurnaroundsBurstLength, 32);

    if (!((pTestCfg->TurnaroundsBurstLength != 0) &&
      (((pTestCfg->TurnaroundsBurstLength == (1 << BurstLengthExponent)) &&
      ((UINT32) pTestCfg->TurnaroundsBurstLength <= ((UINT32) 1 << MaxBurstLengthExponentVal))) ||
      (((UINT32) pTestCfg->TurnaroundsBurstLength <= MaxBurstLengthLinearVal))))) {
#if ENBL_VERBOSE_ERROR_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "ERROR: TurnaroundsBurstLength value (%u) is out of range.\n",
        pTestCfg->TurnaroundsBurstLength);
#endif
      ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
      return 1;
    }

    // IF the rank-to-rank turnarounds uses the three special traffic types
    if (pCoreTestData->TurnaroundsPairMode == OrderIndependent) {
      if ((pTestCfg->TurnaroundsBurstLength < 8) || (pTestCfg->TurnaroundsBurstLength > 512)) {
#if ENBL_VERBOSE_ERROR_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "ERROR: TurnaroundsBurstLength value (%u) is out of range.\n",
          pTestCfg->TurnaroundsBurstLength);
#endif
        ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
        return 1;
      }
    } // end if the rank-to-rank turnarounds uses the three special traffic types

    if (!((pTestCfg->TurnaroundsLoopCount != 0) &&
      ((IsLoopCountExponential &&
      (pTestCfg->TurnaroundsLoopCount <= ((UINT32) 1 << MaxLoopCountVal))) ||
      (!IsLoopCountExponential &&
      (pTestCfg->TurnaroundsLoopCount <= MaxLoopCountVal))))) {
#if ENBL_VERBOSE_ERROR_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "ERROR: TurnaroundsLoopCount value (%u) is out of range.\n",
        pTestCfg->TurnaroundsLoopCount);
#endif
      ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
      return 1;
    }

    if (!((pTestCfg->TurnaroundsBinarySearchLoopCount != 0) &&
      ((IsLoopCountExponential &&
      (pTestCfg->TurnaroundsBinarySearchLoopCount <= ((UINT32) 1 << MaxLoopCountVal))) ||
      (!IsLoopCountExponential &&
      (pTestCfg->TurnaroundsBinarySearchLoopCount <= MaxLoopCountVal))))) {
#if ENBL_VERBOSE_ERROR_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "ERROR: TurnaroundsBinarySearchLoopCount value (%u) is out of range.\n",
        pTestCfg->TurnaroundsBinarySearchLoopCount);
#endif
      ProcError(SsaServicesHandle, UnsupportedValue, __FILE__, __LINE__, pTestStat);
      return 1;
    }
  } // end if rank-to-rank turnaround testing is enabled
#endif // SUPPORT_FOR_TURNAROUNDS

  return 0;
} // end function ChkRmtTestCfg

/**
  This function is the memory point test result handler function.

  This function conforms to the MEM_POINT_TEST_RESULT_HANDLER typedef in MemPointTest.h.

  @param[in, out]  SsaServicesHandle     Pointer to SSA services.
  @param[in]       pSystemInfo           Pointer to system information structure.
  @param[in, out]  pVoidTestData         Pointer to client test data.
  @param[in]       Socket                Socket tested.
  @param[in]       Controller            Controller tested.
  @param[in]       Channel               Channel tested.
  @param[in]       DimmRankA             First DIMM+Rank tested.
  @param[in]       DimmRankB             Second DIMM+Rank tested.
  @param[in]       RankCombinationIndex  Rank combination index tested.
  @param[in]       pLaneErrorStatus      Pointer to array of lane error status masks.  Number of array elements is SystemInfo.BusWidth/8
  @param[in]       ErrorCount            Channel error count.
  @param[out]      pTestStat             Pointer to test status in results metadata structure.

  @retval  0  success
  @retval  1  error occurred
**/
UINT8 RmtPointTestResultHandler(
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN CONST MRC_SYSTEM_INFO *pSystemInfo,
  IN OUT VOID *pVoidTestData,
  IN UINT8 Socket,
  IN UINT8 Controller,
  IN UINT8 Channel,
  IN DIMM_RANK_PAIR DimmRankA,
  IN DIMM_RANK_PAIR DimmRankB,
  IN UINT8 RankCombinationIndex,
  IN CONST UINT8 *pLaneErrorStatus,
  IN ERROR_COUNT_32BITS ErrorCount,
  OUT TEST_STATUS *pTestStat)
{
  RMT_CORE_TEST_DATA* pCoreTestData = (RMT_CORE_TEST_DATA*) pVoidTestData;
  UINT8 Lane;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtPointTestResultHandler(Socket=%u Controller=%u Channel=%u\n",
    Socket, Controller, Channel);
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  DimmA=%u RankA=%u DimmB=%u RankB=%u RankCombinationIndex=%u)\n",
    DimmRankA.Dimm, DimmRankA.Rank, DimmRankB.Dimm, DimmRankB.Rank, RankCombinationIndex);
#endif
  // IF this channel isn't actually enabled for validation (can occur if this
  // channel has less than the maximum number of rank combinations and the
  // ExtendedRange feature is enabled )THEN skip it
  if (!IsChannelValEnabled(SsaServicesHandle, pSystemInfo, &pCoreTestData->MemCfg,
#if SUPPORT_FOR_EXTENDED_RANGE
    &pCoreTestData->CurrentMemPointTestCfg,
#else
    &pCoreTestData->SelectMemPointTestCfg,
#endif
    Socket, Controller, Channel)) {
    return 0;
  }

  // save the current rank values (for result reporting)
  pCoreTestData->DimmRankAs[Socket][Controller][Channel] = DimmRankA;
  pCoreTestData->DimmRankBs[Socket][Controller][Channel] = DimmRankB;

  // FOR each lane:
  for (Lane = 0; Lane < pSystemInfo->BusWidth; Lane++) {
    // IF this lane didn't detect errors
    if ((pLaneErrorStatus[Lane / 8] & (1 << (Lane % 8))) == 0) {
      // set the lane's last-pass-found status
      pCoreTestData->LastPassFoundMasks[pCoreTestData->CurrentShmooDirection] \
        [Socket][Controller][Channel][Lane / 8] |= 1 << (Lane % 8);

      // IF the offset we're testing at is greater than the current last pass
      // offset THEN it's the new last pass offset
      if (ABS(pCoreTestData->TestingOffset) >
        pCoreTestData->LastPassLaneOffsets[pCoreTestData->CurrentShmooDirection] \
        [Socket][Controller][Channel][Lane]) {
        pCoreTestData->LastPassLaneOffsets[pCoreTestData->CurrentShmooDirection] \
          [Socket][Controller][Channel][Lane] = \
          (UINT8) ABS(pCoreTestData->TestingOffset);
      }
    } // end else this lane didn't detect errors
  } // end for each lane

  return 0;
} // end function RmtPointTestResultHandler

/**
  The function is used to get the number of RMT columnar result elements
  required.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       HasDdrtDevices     Flag indicating whether system has any DDR-T devices.
  @param[out]      pResultEleCnt      Pointer to where result element count will be placed.

  @retval  0  success
  @retval  1  error occurred
**/
static
UINT8
GetResultEleCnt (
  IN OUT SSA_BIOS_SERVICES_PPI *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA    *pCoreTestData,
  IN     BOOLEAN               HasDdrtDevices,
  OUT    UINT16                *pResultEleCnt
  )
{
  CONST RMT_CONFIG     *pTestCfg = pCoreTestData->pTestCfg;
  UINT8                 Socket, Controller, Channel;
  RANK_COMBINATION_CNTS RankCombinationsCnts;
  BOOLEAN               InitAsAll;
#if SUPPORT_FOR_TURNAROUNDS
  BOOLEAN               CanDoTurnarounds;
#endif // SUPPORT_FOR_TURNAROUNDS
  UINT8                 NumSubCh;
  UINT8                 SubChMaxBit;

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RmtCore.GetResultEleCnt(HasDdrtDevices=%u)\n", HasDdrtDevices);
#endif

  GetSubChInfo (pCoreTestData->SystemInfo.BusWidth, &NumSubCh, &SubChMaxBit);

  *pResultEleCnt = 0;

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
#ifdef __STUB__
  // confirm design assumption
  ASSERT (DdrLevel == 0);
  ASSERT (LrbufLevel == 1);
#endif // __STUB__
  // FOR each I/O level:
  for (pCoreTestData->CurrentIoLevel = DdrLevel;
    pCoreTestData->CurrentIoLevel <= LrbufLevel; pCoreTestData->CurrentIoLevel++) {
    // IF this I/O level is not enabled for testing THEN skip it
    if ((pTestCfg->IoLevelBitmask & (1 << pCoreTestData->CurrentIoLevel)) == 0) {
      continue;
    }
#else
  {
    pCoreTestData->CurrentIoLevel = DdrLevel;
#endif // !(SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT)

// PT can be optimized to remove the #if SUPPORT_FOR_DDRT
#if SUPPORT_FOR_DDRT
    // FOR non-DDR-T and DDR-T devices (they're tested separately because their
    // margin parameters are different and therefore may have different ranges):
    for (pCoreTestData->CurrentIsDdrT = 0; pCoreTestData->CurrentIsDdrT <= 0;
      pCoreTestData->CurrentIsDdrT++) {
#else
    {
      pCoreTestData->CurrentIsDdrT = FALSE;
#endif // !SUPPORT_FOR_DDRT

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
      // IF rank margining is enabled and the I/O level is the backside
      if ((pTestCfg->EnableRankMargin) &&
        (pCoreTestData->CurrentIoLevel == LrbufLevel)) {
        // initialize the bitmask of DIMMs that support backside command
        // margining
        // only use the first two entries if CtlAll margining is not enabled
        UINT8 CmdMarginGroupCount = \
          (pCoreTestData->pTestCfg->EnableCtlAllMargin) ? 3 : 2;

        InitAsAll = FALSE;

        //
        // NOTE:
        // 1. All popuplated DIMMs are selected for both DDR4 and DDR5.
        // 2. For DDR4, only a DIMM with Gen2 RCD supports backside Cmd/Ctl tests
        // 3. All DDR5 RDIMM/LRDIMM support backside Cmd/Ctl tests. IsAnyBacksideCmdBitSet()
        //    always returns TRUE.
        //
        if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel, CmdVref, Singles,
          pCoreTestData->CurrentIsDdrT, InitAsAll)) {
          return 1;
        }

        InitBacksideCmdBitmask(SsaServicesHandle, &pCoreTestData->SystemInfo,
          &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
          pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP], CmdMarginGroupCount,
          pCoreTestData->BacksideCmdBitmasks);
      } // end if rank margining is enabled and the I/O level is the backside
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
      // IF the I/O level is the backside and there are no devices with a
      // backside THEN skip it
      if ((pCoreTestData->CurrentIoLevel == LrbufLevel) &&
        !IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks) &&
        !pCoreTestData->MemCfg.IsLrDimms && !HasDdrtDevices) {
        continue;
      }
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT

#if SUPPORT_FOR_TURNAROUNDS
      //- - - - - - - - -- - - - - - - - - - - - -- - - - - - - - - - - - -- -
      // determine whether at least one channel can do turnarounds
      //- - - - - - - - -- - - - - - - - - - - - -- - - - - - - - - - - - -- -
      InitAsAll = FALSE;
      if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
        pCoreTestData->CurrentIoLevel, MrcGtMax, Turnarounds,
        pCoreTestData->CurrentIsDdrT, InitAsAll)) {
        return 1;
      }

      if (GetRankCombinationsCnts(SsaServicesHandle,
        &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
        &pCoreTestData->SelectMemPointTestCfg, pCoreTestData->CurrentIoLevel,
        pCoreTestData->CurrentIsDdrT, &RankCombinationsCnts, NULL,
        pCoreTestData->pTestStat)) {
        return 1;
      }

      CanDoTurnarounds = FALSE;
      // FOR each socket:
      for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
        // FOR each controller:
        for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
          // FOR each channel:
          for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
            // IF this channel is not enabled for validation THEN skip it
            if (!IsChannelValEnabled(SsaServicesHandle,
              &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
              &pCoreTestData->SelectMemPointTestCfg, Socket, Controller, Channel)) {
              continue;
            }

            if (CanChannelDoTurnarounds(SsaServicesHandle,
              &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
              &pCoreTestData->SelectMemPointTestCfg,
              pCoreTestData->CurrentIoLevel, Socket, Controller, Channel,
              pCoreTestData->CurrentIsDdrT)) {
              CanDoTurnarounds = TRUE;
              break;
            }
          } // end for each channel

          if (CanDoTurnarounds) {
            break;
          }
        } // end for each controller

        if (CanDoTurnarounds) {
          break;
        }
      } // end for each socket
#endif // SUPPORT_FOR_TURNAROUNDS

#if SUPPORT_FOR_TURNAROUNDS
      // IF rank or lane margining is enabled or turnaround margining is
      // enabled and at least one channel can do turnarounds
      if (pTestCfg->EnableRankMargin || pTestCfg->EnableLaneMargin ||
        (pTestCfg->EnableTurnaroundMargin && CanDoTurnarounds)) {
#else
      // IF rank or lane margining is enabled
      if (pTestCfg->EnableRankMargin || pTestCfg->EnableLaneMargin) {
#endif // !SUPPORT_FOR_TURNAROUNDS
        // one element for all ranks for the Tx/Rx margin parameter limits
        // one for DDR and one for DDRT
        *pResultEleCnt += 1;
#if SUPPORT_FOR_DDRT
        *pResultEleCnt += 1;
#endif // SUPPORT_FOR_DDRT
#if ENBL_RESULTS_DEBUG_LOG_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "ResultEleCnt=%u ResultType=%u IoLevel=%u IsDdrT=%u",
          *pResultEleCnt, ParamLimits0ResultType, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT);
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          " Qty=%u\n", 1);
#endif
      } // end if rank or lane margining is enabled ...

#if SUPPORT_FOR_DDRT
      // IF Early Read ID margining is enabled AND there is DDR-T device
      // AND this is for the frontside
      if (GetRmtTestCfgErid (pCoreTestData->pTestCfg) &&
        HasDdrtDevices &&
        (pCoreTestData->CurrentIoLevel == DdrLevel)) {
        // one element for the Early Read ID margin limits
        *pResultEleCnt += 1;

#if ENBL_RESULTS_DEBUG_LOG_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "ResultEleCnt=%u ResultType=%u IoLevel=%u IsDdrT=%u",
          *pResultEleCnt, ParamLimits2ResultType, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT);
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          " Qty=%u\n", 1);
#endif
        InitAsAll = FALSE;
        if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel, MrcGtMax, Singles,
          pCoreTestData->CurrentIsDdrT, InitAsAll)) {
          return 1;
        }

        if (GetRankCombinationsCnts(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT, &RankCombinationsCnts, NULL,
          pCoreTestData->pTestStat)) {
          return 1;
        }

        // FOR each socket:
        for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
          // FOR each controller:
          for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
            // FOR each channel:
            for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
              // IF this channel is not enabled for validation THEN skip it
              if (!IsChannelValEnabled(SsaServicesHandle,
                &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
                &pCoreTestData->SelectMemPointTestCfg, Socket, Controller,
                Channel)) {
                continue;
              }

              // one element for each rank combination for the Early Read
              // ID margin data
              *pResultEleCnt += RankCombinationsCnts[Socket][Controller][Channel] * NumSubCh;

#if ENBL_RESULTS_DEBUG_LOG_MSGS
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "ResultEleCnt=%u ResultType=%u IoLevel=%u IsDdrT=%u",
                *pResultEleCnt, Rank2RmtResultType,
                pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentIsDdrT);
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                " Socket=%u Controller=%u Channel=%u Qty=%u\n",
                Socket, Controller, Channel,
                RankCombinationsCnts[Socket][Controller][Channel]);
#endif
            } // end for each channel
          } // end for each controller
        } // end for each socket
      } // end if Early Read ID margining is enabled AND ...
#endif // SUPPORT_FOR_DDRT

      // IF rank or lane margining is enabled and this is the frontside or
      // there are devices with a backside of Rx/Tx timing and voltage
      if ((pTestCfg->EnableRankMargin || pTestCfg->EnableLaneMargin) &&
        ((pCoreTestData->CurrentIoLevel == DdrLevel) ||
        pCoreTestData->MemCfg.IsLrDimms || HasDdrtDevices)) {
        InitAsAll = FALSE;
        if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel, MrcGtMax, Singles,
          pCoreTestData->CurrentIsDdrT, InitAsAll)) {
          return 1;
        }

        if (GetRankCombinationsCnts(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT, &RankCombinationsCnts, NULL,
          pCoreTestData->pTestStat)) {
          return 1;;
        }

        // FOR each socket:
        for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
          // FOR each controller:
          for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
            // FOR each channel:
            for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
              // IF this channel is not enabled for validation THEN skip it
              if (!IsChannelValEnabled(SsaServicesHandle,
                &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
                &pCoreTestData->SelectMemPointTestCfg, Socket, Controller,
                Channel)) {
                continue;
              }

              // IF rank margining is enabled
              if (pTestCfg->EnableRankMargin) {
                // one element for each rank combination for the Tx/Rx margin data
                *pResultEleCnt += RankCombinationsCnts[Socket][Controller][Channel] * NumSubCh;

#ifdef DDR5_SUPPORT
                //
                // One element for each rank combination for the BCOM margin result
                //
                if (pCoreTestData->CurrentIoLevel == LrbufLevel) {
                  *pResultEleCnt += RankCombinationsCnts[Socket][Controller][Channel] * NumSubCh;
                }
#endif

#if ENBL_RESULTS_DEBUG_LOG_MSGS
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "ResultEleCnt=%u ResultType=%u IoLevel=%u IsDdrT=%u",
                  *pResultEleCnt, Rank0RmtResultType, pCoreTestData->CurrentIoLevel,
                  pCoreTestData->CurrentIsDdrT);
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  " Socket=%u Controller=%u Channel=%u Qty=%u\n",
                  Socket, Controller, Channel,
                  RankCombinationsCnts[Socket][Controller][Channel]);
#endif
              } // end if rank margining is enabled

              // IF lane margining is enabled
              if (pTestCfg->EnableLaneMargin) {
                // one element for each rank combination and each lane
                *pResultEleCnt += \
                  RankCombinationsCnts[Socket][Controller][Channel] * \
                  pCoreTestData->SystemInfo.BusWidth;

#if ENBL_RESULTS_DEBUG_LOG_MSGS >= 1
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "ResultEleCnt=%u ResultType=%u IoLevel=%u IsDdrT=%u",
                  *pResultEleCnt, LaneRmtResultType, pCoreTestData->CurrentIoLevel,
                  pCoreTestData->CurrentIsDdrT);
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  " Socket=%u Controller=%u Channel=%u Qty=%u\n",
                  Socket, Controller, Channel,
                  (RankCombinationsCnts[Socket][Controller][Channel] * \
                  pCoreTestData->SystemInfo.BusWidth));
#endif
              } // end if lane margining is enabled
            } // end for each channel
          } // end for each controller
        } // end for each socket
      } // end if rank or lane margining is enabled and ...

      // IF rank margining is enabled
      if (pTestCfg->EnableRankMargin) {
#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
        // IF we're margining the frontside or the system contains devices
        // that support backside command margining
        if ((pCoreTestData->CurrentIoLevel == DdrLevel) ||
          IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks))
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
        {
          // one element for all ranks for the Cmd/Ctl margin parameter limits
          *pResultEleCnt += 1;
#if SUPPORT_FOR_DDRT
          *pResultEleCnt += 1;
#endif // SUPPORT_FOR_DDRT

#if ENBL_RESULTS_DEBUG_LOG_MSGS
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "ResultEleCnt=%u ResultType=%u IoLevel=%u IsDdrT=%u",
            *pResultEleCnt, ParamLimits1ResultType, pCoreTestData->CurrentIoLevel,
            pCoreTestData->CurrentIsDdrT);
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            " Qty=%u\n", 1);
#endif
        } // end if we're margining the frontside or ...

        InitAsAll = FALSE;
        if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel, CmdVref, Singles,
          pCoreTestData->CurrentIsDdrT, InitAsAll)) {
          return 1;
        }

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
        // IF this is the backside:
        if (pCoreTestData->CurrentIoLevel == LrbufLevel) {
          // remove DIMMs that don't support backside command margining
          RemoveNonBacksideCmdDimms(SsaServicesHandle,
            &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
            pCoreTestData->BacksideCmdBitmasks,
            &pCoreTestData->SelectMemPointTestCfg);
        } // end if this is not the frontside
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT

        if (GetRankCombinationsCnts(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT, &RankCombinationsCnts, NULL,
          pCoreTestData->pTestStat)) {
          return 1;
        }

        // FOR each socket:
        for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
          // FOR each controller:
          for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
            // FOR each channel:
            for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
              // IF this channel is not enabled for validation THEN skip it
              if (!IsChannelValEnabled(SsaServicesHandle,
                &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
                &pCoreTestData->SelectMemPointTestCfg, Socket, Controller,
                Channel)) {
                continue;
              }

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
              // IF we're margining the frontside or the system contains
              // devices that support backside command margining
              if ((pCoreTestData->CurrentIoLevel == DdrLevel) ||
                IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks))
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
              {
                // one element for each rank combination for the Cmd/Ctl margin data
                *pResultEleCnt += RankCombinationsCnts[Socket][Controller][Channel] * NumSubCh;

#if ENBL_RESULTS_DEBUG_LOG_MSGS
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "ResultEleCnt=%u ResultType=%u IoLevel=%u IsDdrT=%u",
                  *pResultEleCnt, Rank1RmtResultType,
                  pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentIsDdrT);
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  " Socket=%u Controller=%u Channel=%u Qty=%u\n",
                  Socket, Controller, Channel,
                  RankCombinationsCnts[Socket][Controller][Channel]);
#endif
              } // end if this is for the frontside or ...
            } // end for each channel
          } // end for each controller
        } // end for each socket
      } // end if rank margining is enabled

#if SUPPORT_FOR_TURNAROUNDS
      // IF rank-to-rank turnaround margining is enabled
      if (pTestCfg->EnableTurnaroundMargin) {
        InitAsAll = FALSE;
        if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel, MrcGtMax, Turnarounds,
          pCoreTestData->CurrentIsDdrT, InitAsAll)) {
          return 1;
        }

        if (GetRankCombinationsCnts(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT, &RankCombinationsCnts, NULL,
          pCoreTestData->pTestStat)) {
          return 1;
        }

        // FOR each socket:
        for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
          // FOR each controller:
          for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
            // FOR each channel:
            for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
              // IF this channel is not enabled for testing THEN skip it
              if (!IsChannelTestingEnabled(SsaServicesHandle,
                &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
                &pCoreTestData->SelectMemPointTestCfg, Socket, Controller,
                Channel)) {
                continue;
              }

              //// IF this channel can't do turnarounds THEN skip it
              //if (!CanChannelDoTurnarounds(&pCoreTestData->SystemInfo,
              //  &pCoreTestData->MemCfg, &pCoreTestData->MemPointTestCfg,
              //  IoLevel, Socket, Controller, Channel)) continue;

              // one element for each rank combination
              *pResultEleCnt += RankCombinationsCnts[Socket][Controller][Channel];

#if ENBL_RESULTS_DEBUG_LOG_MSGS
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "ResultEleCnt=%u ResultType=%u IoLevel=%u IsDdrT=%u",
                *pResultEleCnt, TurnaroundRmtResultType,
                pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentIsDdrT);
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                " Socket=%u Controller=%u Channel=%u Qty=%u\n",
                Socket, Controller, Channel,
                RankCombinationsCnts[Socket][Controller][Channel]);
#endif
            } // end for each channel
          } // end for each controller
        } // end for each socket
      } // end if rank-to-rank turnaround margining is enabled
#endif // SUPPORT_FOR_TURNAROUNDS
    } // end for non-DDR-T and DDR-T devices
  } // end for each I/O level

#if ENBL_RESULTS_DEBUG_LOG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "  ResultEleCnt=%u\n", *pResultEleCnt);
#endif

  return 0;
} // end function GetResultEleCnt

/**
  This function is used to run the RMT test.

  @param[in, out]  SsaServicesHandle  Pointer to SSA services.
  @param[in, out]  pCoreTestData      Pointer to RMT core test data.
  @param[in]       SetupSameRankForDataMargin  Pointer to function to setup point test for same rank traffic for data signal margining.
  @param[in]       SetupSameRankForCmdMargin  Pointer to function to setup point test for same rank traffic for command/address/control signal margining.
  @param[in]       SetupTurnaroundForDataMargin  Pointer to function to setup point test for rank-to-rank turnaround traffic for data signal margining.
  @param[in]       SetupSameRankForEridMargin  Pointer to function to setup point test for same rank traffic for DDR-T Early Read ID signal margining.
  @param[in]       InitSpecificMetadata  Pointer to function to initialize product specific metadata.  A NULL value is acceptable.

  @retval  0  success
  @retval  1  error occurred
**/
UINT8
RunRmt (
  IN OUT SSA_BIOS_SERVICES_PPI                *SsaServicesHandle,
  IN OUT RMT_CORE_TEST_DATA                   *pCoreTestData,
  IN     SETUP_RMT_SAME_RANK_FOR_DATA_MARGIN  SetupSameRankForDataMargin,
  IN     SETUP_RMT_SAME_RANK_FOR_CMD_MARGIN   SetupSameRankForCmdMargin,
#if SUPPORT_FOR_TURNAROUNDS
  IN     SETUP_RMT_TURNAROUND_FOR_DATA_MARGIN SetupTurnaroundForDataMargin,
#endif
#if SUPPORT_FOR_DDRT
  IN     SETUP_RMT_SAME_RANK_FOR_ERID_MARGIN  SetupSameRankForEridMargin,
#endif // SUPPORT_FOR_DDRT
  IN     INIT_SPECIFIC_METADATA               InitSpecificMetadata
  )
{
  CONST RMT_CONFIG          *pTestCfg = pCoreTestData->pTestCfg;
  UINT16                    ResultEleCnt = 0;
  SHMOO_STOP_MODE           LaneShmooStopMode;
  BOOLEAN                   HasDdrtDevices = FALSE;
  UINT8                     Socket;
  SSA_STATUS                RetStat;
  UINT8                     ShmooDirIdx;
  SHMOO_DIRECTION           ShmooDirs[] = { LoDirection, HiDirection };
  UINT8                     ShmooDirCount = sizeof(ShmooDirs) / sizeof(ShmooDirs[0]);
  BOOLEAN                   InitDqdbContent;
  BOOLEAN                   InitAsAll;
  MARGIN_PARAM_SPECIFICITY  Specificity;
  CHAR8                     *GroupString = NULL;
#if FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 1
  MRC_GT                    Group;
  MRC_GT                    GroupSaved;
#endif
#if SUPPORT_FOR_DDRT
  PSYSHOST                  Host = GetSysHostPointer ();
#endif // SUPPORT_FOR_DDRT

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
  SETUP_CLEANUP            SetupCleanup;
  // only use the first two entries if CtlAll margining is not enabled
  UINT8                    CmdMarginGroupCount = (pCoreTestData->pTestCfg->EnableCtlAllMargin) ? 3 : 2;
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT

#if ENBL_FUNCTION_TRACE_DEBUG_MSGS
  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
    "RunRmt()\n");
#endif

  //
  // Initialize the MarginGroups table with porject specific groups.
  //
  InitMarginGroups(DdrLevel, &pCoreTestData->MarginGroups);

#ifdef __STUB__
  // check design assumptions about the uniformity of margin parameter grouping by type
  {
    UINT8 SubIndex;
    MRC_GT MarginGroup;

    // FOR each margin parameter group in the first array:
    for (SubIndex = 0; SubIndex < MARGIN_GROUP_ARRAY_ELE_CNT; SubIndex++) {
      MarginGroup = pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][SubIndex];
      ASSERT ((MarginGroup == MrcGtMax) || !IsCmdSignalMarginGroup(MarginGroup));
      MarginGroup = pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP][SubIndex];
      ASSERT ((MarginGroup == MrcGtMax) || IsCmdSignalMarginGroup(MarginGroup));
#if SUPPORT_FOR_DDRT
      MarginGroup = pCoreTestData->MarginGroups[RMT_DDRT_SIGNAL_GROUP][SubIndex];
      ASSERT ((MarginGroup == MrcGtMax) || !IsCmdSignalMarginGroup(MarginGroup));
#endif // SUPPORT_FOR_DDRT
    }
  }
#endif // __STUB__

#if SUPPORT_FOR_DDRT
  HasDdrtDevices = SSAIsDdrtDimmPresent (Host);
#endif // SUPPORT_FOR_DDRT

  // get the required number of columnar result elements
  if (GetResultEleCnt(SsaServicesHandle, pCoreTestData, HasDdrtDevices,
    &ResultEleCnt)) {
    return 1;
  }

  // setup the results
  if (SetupResults(SsaServicesHandle, pCoreTestData, ResultEleCnt,
    &pCoreTestData->pMetadata)) {
    // IF both frontside and backside margining are enabled OR per-lane results
    // are enabled
    if (((pCoreTestData->pTestCfg->IoLevelBitmask & (1 << DdrLevel)) &&
      (pCoreTestData->pTestCfg->IoLevelBitmask & (1 << LrbufLevel))) ||
      (pCoreTestData->pTestCfg->EnableLaneMargin)) {
      // IF backside margining is enabled
      if (pCoreTestData->pTestCfg->IoLevelBitmask & (1 << LrbufLevel)) {
        // try again with the backside margining disabled
        pCoreTestData->pTestCfg->IoLevelBitmask &= ~(1 << LrbufLevel);

        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "NOTE: Backside margin testing overridden to disabled due to insufficient memory available for results.\n");
      }

      if (GetResultEleCnt(SsaServicesHandle, pCoreTestData, HasDdrtDevices,
        &ResultEleCnt)) {
          return 1;
      }
      if (SetupResults(SsaServicesHandle, pCoreTestData, ResultEleCnt,
        &pCoreTestData->pMetadata)) {
        // IF both per-rank and per-lane results are enabled
        if ((pCoreTestData->pTestCfg->EnableRankMargin) &&
          (pCoreTestData->pTestCfg->EnableLaneMargin)) {
          // try again with per-lane results disabled
          pCoreTestData->pTestCfg->EnableLaneMargin = FALSE;

          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "NOTE: Per-lane margin testing overridden to disabled due to insufficient memory available for results.\n");

          if (GetResultEleCnt(SsaServicesHandle, pCoreTestData, HasDdrtDevices,
            &ResultEleCnt)) {
              return 1;
          }
          if (SetupResults(SsaServicesHandle, pCoreTestData, ResultEleCnt,
            &pCoreTestData->pMetadata)) {
              return 1;
          }
        } // end if per-lane results are enabled
      } // end if SetupResults failed
    } // end if both frontside and backside margining are enabled OR ...
  } // end if SetupResults failed

  pCoreTestData->pTestStat = (TEST_STATUS*) &pCoreTestData->pMetadata->StatusCode;

  // initialize the metadata
  if (InitCommonMetadata(SsaServicesHandle, pCoreTestData, HasDdrtDevices,
    ResultEleCnt)) {
    return 1;
  }

  if (InitSpecificMetadata != NULL) {
    InitSpecificMetadata(SsaServicesHandle, pCoreTestData);
  }

  // initialize the CPGC test configuration to default values
  SetCpgcPointTestCfgDefaults(&pCoreTestData->CpgcPointTestCfg);

  // initialize the DQDB content for all devices that will be participating
  // (SelectMemPointTestCfg is currently configured for all devices - both DDR
  // and DDR-T)
  InitDqdbContent = TRUE;
  if (InitDqdb(SsaServicesHandle, &pCoreTestData->SystemInfo,
    pCoreTestData->pCpgcInfo, &pCoreTestData->MemCfg,
    &pCoreTestData->SelectMemPointTestCfg, &pCoreTestData->CpgcPointTestCfg,
    InitDqdbContent, pCoreTestData->pTestStat)) {
    return 1;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // non command/control signal margining
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
  // FOR each I/O level:
#ifdef __STUB__
  // confirm design assumption
  ASSERT (DdrLevel == 0);
  ASSERT (LrbufLevel == 1);
#endif // __STUB__
  for (pCoreTestData->CurrentIoLevel = DdrLevel;
    pCoreTestData->CurrentIoLevel <= LrbufLevel;
    pCoreTestData->CurrentIoLevel++) {
    // IF this I/O level is not enabled for testing THEN skip it
    if ((pTestCfg->IoLevelBitmask &
      (1 << pCoreTestData->CurrentIoLevel)) == 0) {
      continue;
    }
#else
  {
    pCoreTestData->CurrentIoLevel = DdrLevel;
#endif // !(SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT)

  //
  // Initialize the MarginGroups table by current Iolevel.
  //
  InitMarginGroups(pCoreTestData->CurrentIoLevel, &pCoreTestData->MarginGroups);

#if SUPPORT_FOR_DDRT
    // FOR non-DDR-T and DDR-T devices (they're tested separately because their
    // margin parameters are different and therefore may have different ranges):
    for (pCoreTestData->CurrentIsDdrT = 0;
      pCoreTestData->CurrentIsDdrT <= 0;
      pCoreTestData->CurrentIsDdrT++) {
#else
    {
      pCoreTestData->CurrentIsDdrT = FALSE;
#endif // !SUPPORT_FOR_DDRT

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
      // IF the I/O level is the backside and there are no devices with a
      // back side THEN skip it
      if ((pCoreTestData->CurrentIoLevel == LrbufLevel) && \
        !pCoreTestData->MemCfg.IsLrDimms &&
        !HasDdrtDevices) {
        continue;
      }
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT

      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      // same rank margining
      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

      // IF rank or lane margining is enabled:
      if (pTestCfg->EnableRankMargin || pTestCfg->EnableLaneMargin) {
        LaneShmooStopMode = (pTestCfg->EnableLaneMargin) ? AllShmooStopMode : AnyShmooStopMode;

        // pre-setup for the first margin parameter (so we can get the maximum
        // number of rank combinations)
        if (SetupSameRankForDataMargin(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentIsDdrT,
          pTestCfg->EnableLaneMargin)) {
          return 1;
        }

        // get the rank combination counts
        if (GetRankCombinationsCnts(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT, &pCoreTestData->RankCombinationCnts,
          &pCoreTestData->MaxRankCombinationCnt,
          pCoreTestData->pTestStat)) {
          return 1;
        }

        // IF there are rank combinations to test
        if (pCoreTestData->MaxRankCombinationCnt) {
          // FOR each margin parameter group in the first array:
          for (pCoreTestData->CurrentMarginGroupSubIndex = 0;
            pCoreTestData->CurrentMarginGroupSubIndex < \
            (sizeof(pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP]) / sizeof(pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][0]));
            pCoreTestData->CurrentMarginGroupSubIndex++) {
            pCoreTestData->CurrentMarginGroup = \
              pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][pCoreTestData->CurrentMarginGroupSubIndex];

            // IF the margin group is not valid THEN skip it
            if (pCoreTestData->CurrentMarginGroup == MrcGtMax) {
              continue;
            }
            if (pTestCfg->TestStatusLogLevel >= 1) {
              if (EFI_ERROR (GetGroupString (pCoreTestData->CurrentMarginGroup, &GroupString))) {
                GroupString = "Unknown group";
              }
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "\n"
                "Testing IoLevel=%a MarginGroup=%a\n",
                GetLevelStr (pCoreTestData->CurrentIoLevel),
                GroupString);
            }

            // FOR each rank combination:
            for (pCoreTestData->CurrentRankCombinationIndex = 0;
              pCoreTestData->CurrentRankCombinationIndex <
              pCoreTestData->MaxRankCombinationCnt;
              pCoreTestData->CurrentRankCombinationIndex++) {

              if (pTestCfg->TestStatusLogLevel >= 2) {
                NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                  "\n"
                  "Testing same rank traffic for rank combination %u of %u.\n",
                  (pCoreTestData->CurrentRankCombinationIndex + 1),
                  pCoreTestData->MaxRankCombinationCnt);
              }

              // The "UpdateHwSetting=FALSE", only set up the dimm/rank in the channel test data structure,
              // it need a following call with "UpdateHwSetting=TRUE" to apply to HW.
              // PT should change the API to use an enum: update_local_data_structure, update_hw, both
              if (pCoreTestData->SetPointTestRankCombinationIndex (
                SsaServicesHandle, &pCoreTestData->SystemInfo,
                &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
                &pCoreTestData->CpgcPointTestCfg,
                pCoreTestData->pCpgcPointTestData,
                pCoreTestData->CurrentRankCombinationIndex,
                FALSE,
                pCoreTestData->pTestStat)) {
                return 1;
              }
              if (pCoreTestData->SetPointTestRankCombinationIndex (
                SsaServicesHandle, &pCoreTestData->SystemInfo,
                &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
                &pCoreTestData->CpgcPointTestCfg,
                pCoreTestData->pCpgcPointTestData,
                pCoreTestData->CurrentRankCombinationIndex,
                TRUE,
                pCoreTestData->pTestStat)) {
                return 1;
              }

#if FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 1
              if (UpdateTargetedDimmRank (SsaServicesHandle, pCoreTestData)) {
                return 1;
              }
#endif
              // initialize the last pass margin status
              InitMarginStatus (pCoreTestData);

              // run the series of Margin1D tests
#if FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 1

              //
              // Because the DB DFE Vref monitor can only be enabled one DQ bit a time, we need
              // to margin all 8 bits one by one and merge their results.
              // Each DQ bit has its own margin group which starts from DbDfeVrefDq0 and ends at DbDfeVrefDq7.
              //
              if (pCoreTestData->CurrentMarginGroup == DbDfeVrefGroup) {
                GroupSaved = pCoreTestData->CurrentMarginGroup;

                for (Group = DbDfeVrefDq0; Group <= DbDfeVrefDq7; Group++) {

                  pCoreTestData->CurrentMarginGroup = Group;
                  if (RunRmtMargin1DWith1DSweep (SsaServicesHandle, pCoreTestData,
                    LaneShmooStopMode, ShmooDirCount, &ShmooDirs[0])) {
                    return 1;
                  }
                } // Group

                pCoreTestData->CurrentMarginGroup = GroupSaved;

              } else {
                if (RunRmtMargin1DWith1DSweep (SsaServicesHandle, pCoreTestData,
                  LaneShmooStopMode, ShmooDirCount, &ShmooDirs[0])) {
                  return 1;
                }
              }
#else
              if (RunRmtMargin1D (SsaServicesHandle, pCoreTestData,
                LaneShmooStopMode, ShmooDirCount, &ShmooDirs[0])) {
                return 1;
              }

              // report the margin parameter limits in the test results, update the
              // limit per each rank iteration.
              if (ReportParamLimitsResults(SsaServicesHandle, pCoreTestData,
                ParamLimits0ResultType)) {
                return 1;
              }
#endif // FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 1

              // IF rank margining is enabled
              if (pTestCfg->EnableRankMargin) {
                if (ReportRankMarginResults(SsaServicesHandle, pCoreTestData,
                  Rank0RmtResultType, ShmooDirCount, &ShmooDirs[0])) {
                  return 1;
                }
              }

              // IF lane margining is enabled:
              if (pTestCfg->EnableLaneMargin) {
                if (ReportLaneMarginResults(SsaServicesHandle, pCoreTestData)) {
                  return 1;
                }
              }
            } // end for each each rank combination

#if FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 0
#if SUPPORT_FOR_EXTENDED_RANGE
            // IF extended range and rank margining are enabled
            if (pCoreTestData->pTestCfg->EnableExtendedRange &&
              pCoreTestData->pTestCfg->EnableRankMargin) {
              // fixup the rank margin results
              if (FixupResults(SsaServicesHandle, pCoreTestData,
                LoThenHiDirection, Rank0RmtResultType)) {
                return 1;
              }
            }

            // IF extended range and lane margining are enabled
            if (pCoreTestData->pTestCfg->EnableExtendedRange &&
              pCoreTestData->pTestCfg->EnableLaneMargin) {
              // fixup the lane margin results
              if (FixupResults(SsaServicesHandle, pCoreTestData,
                LoThenHiDirection, LaneRmtResultType)) {
                return 1;
              }
            }
#endif // SUPPORT_FOR_EXTENDED_RANGE
#endif // FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 0

          } // end for each margin parameter group in the first array
        } // end if there are rank combinations to test
      } // end if rank or lane margining is enabled

#if SUPPORT_FOR_DDRT
      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      // Early Read ID margining
      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

      // IF Early Read ID margining is enabled AND this is for DDR-T devices
      // AND this is for the frontside
      if (GetRmtTestCfgErid (pCoreTestData->pTestCfg) &&
        HasDdrtDevices &&
        (pCoreTestData->CurrentIoLevel == DdrLevel)) {

        LaneShmooStopMode = AllShmooStopMode;

        // setup for Early Read ID testing
        if (SetupSameRankForEridMargin(SsaServicesHandle, pCoreTestData)) {
          return 1;
        }

        // get the rank combination counts with the new MemPointTestCfg
        if (GetRankCombinationsCnts(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg,
          pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentIsDdrT,
          &pCoreTestData->RankCombinationCnts,
          &pCoreTestData->MaxRankCombinationCnt,
          pCoreTestData->pTestStat)) {
          return 1;
        }

        // FOR each margin parameter group in the third array:
        for (pCoreTestData->CurrentMarginGroupSubIndex = 0;
          pCoreTestData->CurrentMarginGroupSubIndex <
          (sizeof(pCoreTestData->MarginGroups[RMT_DDRT_SIGNAL_GROUP]) / sizeof(pCoreTestData->MarginGroups[RMT_DDRT_SIGNAL_GROUP][0]));
        pCoreTestData->CurrentMarginGroupSubIndex++) {
          pCoreTestData->CurrentMarginGroup = \
            pCoreTestData->MarginGroups[RMT_DDRT_SIGNAL_GROUP][pCoreTestData->CurrentMarginGroupSubIndex];

          // IF the margin group is not valid THEN skip it
          if (pCoreTestData->CurrentMarginGroup == MrcGtMax) {
            continue;
          }

#if ENBL_BIOS_SSA_API_DEBUG_MSGS
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "  GetMarginParamSpecificity(IoLevel=%u MarginGroup=%u)\n",
            pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentMarginGroup);
#endif
          RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamSpecificity(
            SsaServicesHandle, pCoreTestData->CurrentIoLevel,
            pCoreTestData->CurrentMarginGroup, &Specificity);

          // IF this margin parameter isn't supported THEN skip it
          if (RetStat == UnsupportedValue) {
            continue;
          }

          if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__,
            pCoreTestData->pTestStat)) {
            return 1;
          }

          if (pTestCfg->TestStatusLogLevel >= 1) {
            if (EFI_ERROR (GetGroupString (pCoreTestData->CurrentMarginGroup, &GroupString))) {
              GroupString = "Unknown group";
            }
            NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
              "\n"
              "Testing IoLevel=%a MarginGroup=%a\n",
              GetLevelStr (pCoreTestData->CurrentIoLevel),
              GroupString);
          }

          // FOR each rank combination:
          for (pCoreTestData->CurrentRankCombinationIndex = 0;
            pCoreTestData->CurrentRankCombinationIndex <
            pCoreTestData->MaxRankCombinationCnt;
            pCoreTestData->CurrentRankCombinationIndex++) {
            if (pTestCfg->TestStatusLogLevel >= 2) {
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "\n"
                "Testing same rank traffic for rank combination %u of %u.\n",
                (pCoreTestData->CurrentRankCombinationIndex + 1),
                pCoreTestData->MaxRankCombinationCnt);
            }

            if (pCoreTestData->SetPointTestRankCombinationIndex(
              SsaServicesHandle, &pCoreTestData->SystemInfo,
              &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
              &pCoreTestData->CpgcPointTestCfg,
              pCoreTestData->pCpgcPointTestData,
              pCoreTestData->CurrentRankCombinationIndex,
              FALSE,
              pCoreTestData->pTestStat)) {
              return 1;
            }
            if (pCoreTestData->SetPointTestRankCombinationIndex(
              SsaServicesHandle, &pCoreTestData->SystemInfo,
              &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
              &pCoreTestData->CpgcPointTestCfg,
              pCoreTestData->pCpgcPointTestData,
              pCoreTestData->CurrentRankCombinationIndex,
              TRUE,
              pCoreTestData->pTestStat)) {
                return 1;
            }

            // initialize the last pass margin status
            InitMarginStatus(pCoreTestData);

            // run the series of Margin1D tests
            if (RunRmtMargin1D(SsaServicesHandle, pCoreTestData,
              LaneShmooStopMode, ShmooDirCount, &ShmooDirs[0])) {
              return 1;
            }

            // report the margin parameter limits in the test results, update the
            // limit per each rank iteration.
            if (ReportParamLimitsResults(SsaServicesHandle, pCoreTestData,
              ParamLimits2ResultType)) {
              return 1;
            }

            if (ReportEridMarginResults(SsaServicesHandle, pCoreTestData)) {
              return 1;
            }
          } // end for each rank combination
        } // end for each margin parameter group in the third array
      } // end if Early Read ID margining is enabled and ...
#endif // SUPPORT_FOR_DDRT

#if SUPPORT_FOR_TURNAROUNDS
      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      // rank-to-rank turnaround margining
      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

      // IF rank-to-rank turnaround margining is enabled
      if (pTestCfg->EnableTurnaroundMargin) {
        TRAFFIC_MODE TrafficMode = LoopbackTrafficMode;
#if MULTIPLE_R2R_TRAFFIC_MODES
        TRAFFIC_MODE TrafficModes[] = {
          Wr2WrAndRd2RdTrafficMode,
          Rd2WrTrafficMode,
          Wr2RdTrafficMode
        };
        UINT8 TrafficModeIdx;
#endif // MULTIPLE_R2R_TRAFFIC_MODES
        LaneShmooStopMode = AnyShmooStopMode;

#if MULTIPLE_R2R_TRAFFIC_MODES
        // FOR each rank-to-rank traffic mode:
        for (TrafficModeIdx = 0;
          TrafficModeIdx < (sizeof(TrafficModes) / sizeof(TrafficModes[0]));
          TrafficModeIdx++) {
          TrafficMode = TrafficModes[TrafficModeIdx];
#else
        {
          TrafficMode = LoopbackTrafficMode;
#endif // !MULTIPLE_R2R_TRAFFIC_MODES
          // pre-setup for the first margin parameter (so we can get the maximum
          // number of rank combinations)
          if (SetupTurnaroundForDataMargin(SsaServicesHandle, pCoreTestData,
            pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentIsDdrT,
            TrafficMode)) {
            return 1;
          }

          // get the rank combination counts
          if (GetRankCombinationsCnts(SsaServicesHandle,
            &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
            &pCoreTestData->SelectMemPointTestCfg,
            pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentIsDdrT,
            &pCoreTestData->RankCombinationCnts,
            &pCoreTestData->MaxRankCombinationCnt,
            pCoreTestData->pTestStat)) {
            return 1;
          }

          // IF there are rank combinations to test
          if (pCoreTestData->MaxRankCombinationCnt) {
            // FOR each margin parameter group in the first array:
            for (pCoreTestData->CurrentMarginGroupSubIndex = 0;
              pCoreTestData->CurrentMarginGroupSubIndex < \
              (sizeof(pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP]) / sizeof(pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][0]));
              pCoreTestData->CurrentMarginGroupSubIndex++) {
              pCoreTestData->CurrentMarginGroup = \
                pCoreTestData->MarginGroups[RMT_DATA_SIGNAL_GROUP][pCoreTestData->CurrentMarginGroupSubIndex];

              // IF the margin parameter group is not valid THEN skip it
              if (pCoreTestData->CurrentMarginGroup == MrcGtMax) {
                continue;
              }

              if (pTestCfg->TestStatusLogLevel >= 1) {
                if (EFI_ERROR (GetGroupString (pCoreTestData->CurrentMarginGroup, &GroupString))) {
                  GroupString = "Unknown group";
                }
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "\n"
                  "Testing IoLevel=%a MarginGroup=%a\n",
                  GetLevelStr (pCoreTestData->CurrentIoLevel),
                  GroupString);
              }

              // FOR each rank combination:
              for (pCoreTestData->CurrentRankCombinationIndex = 0;
                pCoreTestData->CurrentRankCombinationIndex <
                pCoreTestData->MaxRankCombinationCnt;
                pCoreTestData->CurrentRankCombinationIndex++) {
                if (pTestCfg->TestStatusLogLevel >= 2) {
                  NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                    "\n"
                    "Testing rank-to-rank turnaround traffic: %a for rank combination %u of %u.\n",
                    GetTrafficModeStr(TrafficMode),
                    (pCoreTestData->CurrentRankCombinationIndex + 1),
                    pCoreTestData->MaxRankCombinationCnt);
                }

                if (pCoreTestData->SetPointTestRankCombinationIndex(
                  SsaServicesHandle, &pCoreTestData->SystemInfo,
                  &pCoreTestData->MemCfg,
                  &pCoreTestData->SelectMemPointTestCfg,
                  &pCoreTestData->CpgcPointTestCfg,
                  pCoreTestData->pCpgcPointTestData,
                  pCoreTestData->CurrentRankCombinationIndex,
                  FALSE,
                  pCoreTestData->pTestStat)) {
                  return 1;
                }
                if (pCoreTestData->SetPointTestRankCombinationIndex(
                  SsaServicesHandle, &pCoreTestData->SystemInfo,
                  &pCoreTestData->MemCfg,
                  &pCoreTestData->SelectMemPointTestCfg,
                  &pCoreTestData->CpgcPointTestCfg,
                  pCoreTestData->pCpgcPointTestData,
                  pCoreTestData->CurrentRankCombinationIndex,
                  TRUE,
                  pCoreTestData->pTestStat)) {
                    return 1;
                }

                // initialize the last pass margin status
                InitMarginStatus(pCoreTestData);

                // run the series of Margin1D tests
                if (RunRmtMargin1D(SsaServicesHandle, pCoreTestData,
                  LaneShmooStopMode, ShmooDirCount, &ShmooDirs[0])) {
                  return 1;
                }

                // IF rank and lane margining are not enabled
                // report the margin parameter limits in the test results, update the
                // limit per each rank iteration.
                if ((!pTestCfg->EnableRankMargin && !pTestCfg->EnableLaneMargin)) {
                  // report the margin parameter limits in the test results
                  if (ReportParamLimitsResults(SsaServicesHandle, pCoreTestData,
                    ParamLimits0ResultType)) {
                    return 1;
                  }
                }

                if (ReportTurnaroundMarginResults(SsaServicesHandle,
                  pCoreTestData)) {
                  return 1;
                }
              } // end for each rank combination

#if SUPPORT_FOR_EXTENDED_RANGE
              // fixup the rank-to-rank turnaround margin results
              if (FixupResults(SsaServicesHandle, pCoreTestData,
                LoThenHiDirection, TurnaroundRmtResultType)) {
                return 1;
              }
#endif // SUPPORT_FOR_EXTENDED_RANGE
            } // end for each margin parameter group in the first array
          } // end if there are rank combinations to test
        } // end for each rank-to-rank traffic mode
      } // end if rank-to-rank turnaround margining is enabled
#endif // SUPPORT_FOR_TURNAROUNDS
    } // end for non-DDR-T and DDR-T devices
  } // end for each I/O level

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // frontside command/control signal margining
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  // IF rank margining and frontside testing are enabled
  if ((pTestCfg->EnableRankMargin) && (pTestCfg->IoLevelBitmask & (1 << DdrLevel))) {
    pCoreTestData->CurrentIoLevel = DdrLevel;

    //
    // Initialize the MarginGroups table by current Iolevel.
    //
    InitMarginGroups(pCoreTestData->CurrentIoLevel, &pCoreTestData->MarginGroups);

    // FOR each socket:
    for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
      // IF this socket is not enabled for testing THEN skip it
      if (((pCoreTestData->SystemInfo.SocketBitMask & (1 << Socket)) == 0) ||
        ((pCoreTestData->pTestCfg->SocketBitmask & (1 << Socket)) == 0)) {
        continue;
      }

      // all command/control margin parameters share a common initialization
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  InitMarginParam(Socket=%u IoLevel=%u MarginGroup=%u SetupCleanup=Setup)\n",
        Socket, pCoreTestData->CurrentIoLevel, CmdAll);
#endif
      RetStat = SsaServicesHandle->SsaMemoryConfig->InitMarginParam(
        SsaServicesHandle, Socket, pCoreTestData->CurrentIoLevel, CmdAll, Setup);
      if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__,
        pCoreTestData->pTestStat)) {
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
        NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
          "  RetStat=%u\n", RetStat);
#endif
        return 1;
      }
    } // end for each socket

#if SUPPORT_FOR_DDRT
    // FOR non-DDR-T and DDR-T devices (they're tested separately because their
    // margin parameters are different and therefore may have different ranges):
    for (pCoreTestData->CurrentIsDdrT = 0;
      pCoreTestData->CurrentIsDdrT <= 0;
      pCoreTestData->CurrentIsDdrT++) {
#else
      {
        pCoreTestData->CurrentIsDdrT = FALSE;
#endif // !SUPPORT_FOR_DDRT

        LaneShmooStopMode = AnyShmooStopMode;

        if (SetupSameRankForCmdMargin(SsaServicesHandle,
          pCoreTestData, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT)) {
          return 1;
        }

        // get the rank combination counts with the new MemPointTestCfg
        if (GetRankCombinationsCnts(SsaServicesHandle,
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg, pCoreTestData->CurrentIoLevel,
          pCoreTestData->CurrentIsDdrT, &pCoreTestData->RankCombinationCnts,
          &pCoreTestData->MaxRankCombinationCnt, pCoreTestData->pTestStat)) {
          return 1;
        }

        // FOR each margin parameter group in the second array:
        for (pCoreTestData->CurrentMarginGroupSubIndex = 0;
          pCoreTestData->CurrentMarginGroupSubIndex < \
          (sizeof(pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP]) / sizeof(pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP][0]));
          pCoreTestData->CurrentMarginGroupSubIndex++) {
          pCoreTestData->CurrentMarginGroup = \
            pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP][pCoreTestData->CurrentMarginGroupSubIndex];

          // IF the margin parameter group is not valid THEN skip it
          if (pCoreTestData->CurrentMarginGroup == MrcGtMax) {
            continue;
          }

          // IF the margin parameter group is CtlAll and CtlAll is not enabled THEN skip it
          if ((pCoreTestData->CurrentMarginGroup == CtlAll) &&
            !pTestCfg->EnableCtlAllMargin) {
            continue;
          }

          if (pTestCfg->TestStatusLogLevel >= 1) {
            if (EFI_ERROR (GetGroupString (pCoreTestData->CurrentMarginGroup, &GroupString))) {
              GroupString = "Unknown group";
            }
            NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
              "\n"
              "Testing IoLevel=%a MarginGroup=%a\n",
              GetLevelStr (pCoreTestData->CurrentIoLevel),
              GroupString);
          }

          // FOR each rank combination:
          for (pCoreTestData->CurrentRankCombinationIndex = 0;
            pCoreTestData->CurrentRankCombinationIndex < \
            pCoreTestData->MaxRankCombinationCnt;
            pCoreTestData->CurrentRankCombinationIndex++) {
            if (pCoreTestData->SetPointTestRankCombinationIndex (
              SsaServicesHandle, &pCoreTestData->SystemInfo,
              &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
              &pCoreTestData->CpgcPointTestCfg,
              pCoreTestData->pCpgcPointTestData,
              pCoreTestData->CurrentRankCombinationIndex,
              FALSE,
              pCoreTestData->pTestStat)) {
              return 1;
            }
            if (pCoreTestData->SetPointTestRankCombinationIndex (
              SsaServicesHandle, &pCoreTestData->SystemInfo,
              &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
              &pCoreTestData->CpgcPointTestCfg,
              pCoreTestData->pCpgcPointTestData,
              pCoreTestData->CurrentRankCombinationIndex,
              TRUE,
              pCoreTestData->pTestStat)) {
              return 1;
            }

            if (pTestCfg->TestStatusLogLevel >= 2) {
              NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                "\n"
                "Testing same rank traffic for rank combination %u of %u.\n",
                (pCoreTestData->CurrentRankCombinationIndex + 1),
                pCoreTestData->MaxRankCombinationCnt);
            }

#if FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 1
            if (UpdateTargetedDimmRank (SsaServicesHandle, pCoreTestData)) {
              return 1;
            }
#endif
            // initialize the last pass margin status
            InitMarginStatus (pCoreTestData);

            // run the series of Margin1D tests
#if FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 1
          if (UseCaCsTrainingMode (pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentMarginGroup)) {
            if (RunRmtMargin1DWith1DSweepInCaCsTrainingMode (SsaServicesHandle, pCoreTestData,
              LaneShmooStopMode, ShmooDirCount, &ShmooDirs[0])) {
              return 1;
            }
          } else {
            if (RunRmtMargin1DWith1DSweep(SsaServicesHandle, pCoreTestData,
              LaneShmooStopMode, ShmooDirCount, &ShmooDirs[0])) {
              return 1;
            }
          }
#else
          if (RunRmtMargin1D (SsaServicesHandle, pCoreTestData,
            LaneShmooStopMode, ShmooDirCount, &ShmooDirs[0])) {
            return 1;
          }

          // report the margin parameter limits in the test results, update the
          // limit per each rank iteration.
          if (ReportParamLimitsResults(SsaServicesHandle, pCoreTestData,
            ParamLimits1ResultType)) {
            return 1;
          }
#endif // FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 1

          if (ReportRankMarginResults(SsaServicesHandle, pCoreTestData,
            Rank1RmtResultType, ShmooDirCount, &ShmooDirs[0])) {
            return 1;
          }
#if SUPPORT_FOR_DDRT
          // Workaround the issue of CADB on-deseclect
          // setting in the DDR4 test could affect the following DDRT test.
          // Run CPGC point test W/O on-deSelect to clean it up.
          if (CleanUpWithPointTest (SsaServicesHandle, pCoreTestData, pCoreTestData->pTestStat)){
            return 1;
          }
#endif // SUPPORT_FOR_DDRT
        } // end for each rank combination

#if FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 0
#if SUPPORT_FOR_EXTENDED_RANGE
        // fixup the command margin results
        if (FixupResults(SsaServicesHandle, pCoreTestData,
          LoThenHiDirection, Rank1RmtResultType)) {
          return 1;
        }
#endif // SUPPORT_FOR_EXTENDED_RANGE
#endif
      } // end for each margin parameter group in the second array
    } // end for non-DDR-T and DDR-T devices

    // FOR each socket:
    for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
      // IF this socket is not enabled for testing THEN skip it
      if (((pCoreTestData->SystemInfo.SocketBitMask & (1 << Socket)) == 0) ||
        ((pCoreTestData->pTestCfg->SocketBitmask & (1 << Socket)) == 0)) {
        continue;
      }

      // all command/control margin parameters share a common initialization
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
      NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
        "  InitMarginParam(Socket=%u IoLevel=%u MarginGroup=%u SetupCleanup=Cleanup)\n",
        Socket, pCoreTestData->CurrentIoLevel, CmdAll);
#endif
      RetStat = SsaServicesHandle->SsaMemoryConfig->InitMarginParam(
        SsaServicesHandle, Socket, pCoreTestData->CurrentIoLevel, CmdAll, Cleanup);
      if (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__,
        pCoreTestData->pTestStat)) {
        return 1;
      }
    } // end for each socket
  } // end if rank margining and frontside testing are enabled

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // backside command/control signal margining
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  // IF rank margining and backside testing are enabled
  if ((pTestCfg->EnableRankMargin) && (pTestCfg->IoLevelBitmask & (1 << LrbufLevel))) {
    BOOLEAN BacksideCmdDevicesExist = FALSE;

    pCoreTestData->CurrentIoLevel = LrbufLevel;

    //
    // Initialize the MarginGroups table by current Iolevel.
    //
    InitMarginGroups(pCoreTestData->CurrentIoLevel, &pCoreTestData->MarginGroups);

#if SUPPORT_FOR_DDRT
    // FOR non-DDR-T and DDR-T devices (they're tested separately because their
    // margin parameters are different and therefore may have different ranges):
    for (pCoreTestData->CurrentIsDdrT = 0;
      pCoreTestData->CurrentIsDdrT <= 1;
      pCoreTestData->CurrentIsDdrT++) {
        // IF this is for DDR-T devices and the system has no DDR-T devices THEN skip it
        if (pCoreTestData->CurrentIsDdrT && !HasDdrtDevices) {
          continue;
        }
#else
    {
      pCoreTestData->CurrentIsDdrT = FALSE;
#endif // !SUPPORT_FOR_DDRT

      // initialize the bitmask of DIMMs that support backside command
      // margining
      InitAsAll =FALSE;
      if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
        pCoreTestData->CurrentIoLevel, CmdVref, Singles,
        pCoreTestData->CurrentIsDdrT, InitAsAll)) {
        return 1;
      }

      InitBacksideCmdBitmask(SsaServicesHandle, &pCoreTestData->SystemInfo,
        &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
        pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP], CmdMarginGroupCount,
        pCoreTestData->BacksideCmdBitmasks);

      // IF there are devices with a command back side
      if (IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks)) {
        BacksideCmdDevicesExist = TRUE;
#if SUPPORT_FOR_DDRT
        break;
#endif // !SUPPORT_FOR_DDRT
      }
    } // end for non-DDR-T and DDR-T devices

    // IF there are devices that support backside command margining
    if (BacksideCmdDevicesExist) {

      // FOR each shmoo direction (backside command margin parameters must have
      // the calls to InitMarginParam performed in a per shmoo direction basis):
      for (ShmooDirIdx = 0; ShmooDirIdx < ShmooDirCount; ShmooDirIdx++) {
        // FOR each socket:
        for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
          // IF this socket is not enabled for testing THEN skip it
          if (((pCoreTestData->SystemInfo.SocketBitMask & (1 << Socket)) == 0) ||
            ((pCoreTestData->pTestCfg->SocketBitmask & (1 << Socket)) == 0)) {
            continue;
          }

          // NOTE: Backside command margining setup/cleanup is different for
          // high and low sides so we're piggybacking the shmoo direction in
          // the Setup/Cleanup parameter.
          SetupCleanup = Setup;
          SetupCleanup |= ShmooDirs[ShmooDirIdx] << 1;

          //
          // Skip backside denormalization for SPR until we need it. Cuurently we don't need
          // it and it has been validated.
          //
#ifndef SPR_PO_FLAG
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "  InitMarginParam(Socket=%u IoLevel=%u MarginGroup=%u SetupCleanup=%u)\n",
            Socket, pCoreTestData->CurrentIoLevel, CmdAll, SetupCleanup);
#endif
          RetStat = SsaServicesHandle->SsaMemoryConfig->InitMarginParam(
            SsaServicesHandle, Socket, pCoreTestData->CurrentIoLevel, CmdAll,
            SetupCleanup);
          // it's ok if the return stat is unsupported
          if (RetStat != UnsupportedValue && ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__,
            pCoreTestData->pTestStat)) {
            return 1;
          }
#endif // SPR_PO_FLAG
        } // end for each socket

#if SUPPORT_FOR_DDRT
        // FOR non-DDR-T and DDR-T devices (they're tested separately because their
        // margin parameters are different and therefore may have different ranges):
        for (pCoreTestData->CurrentIsDdrT = 0;
          pCoreTestData->CurrentIsDdrT <= 0;
          pCoreTestData->CurrentIsDdrT++) {
#else
        {
          pCoreTestData->CurrentIsDdrT = FALSE;
#endif // !SUPPORT_FOR_DDRT

          // initialize the bitmask of DIMMs that support backside command
          // margining
          InitAsAll = FALSE;
          if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
            pCoreTestData->CurrentIoLevel, CmdVref, Singles,
            pCoreTestData->CurrentIsDdrT, InitAsAll)) {
            return 1;
          }

          InitBacksideCmdBitmask(SsaServicesHandle, &pCoreTestData->SystemInfo,
            &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
            pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP], CmdMarginGroupCount,
            pCoreTestData->BacksideCmdBitmasks);

          // IF there are no devices with a command back side THEn skip it
          if (!IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks)) {
            continue;
          }

          LaneShmooStopMode = AnyShmooStopMode;

          if (SetupSameRankForCmdMargin(SsaServicesHandle,
            pCoreTestData, pCoreTestData->CurrentIoLevel,
            pCoreTestData->CurrentIsDdrT)) {
            return 1;
          }

          // get the rank combination counts with the new MemPointTestCfg
          if (GetRankCombinationsCnts(SsaServicesHandle,\
            &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
            &pCoreTestData->SelectMemPointTestCfg,
            pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentIsDdrT,
            &pCoreTestData->RankCombinationCnts,
            &pCoreTestData->MaxRankCombinationCnt,
            pCoreTestData->pTestStat)) {
            return 1;
          }

          // IF there are no rank combinations for this CurrentIsDdrT setting THEN skip it
          if (pCoreTestData->MaxRankCombinationCnt == 0) {
            continue;
          }

          // FOR each margin parameter group in the second array:
          for (pCoreTestData->CurrentMarginGroupSubIndex = 0;
            pCoreTestData->CurrentMarginGroupSubIndex < \
            (sizeof(pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP]) / sizeof(pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP][0]));
            pCoreTestData->CurrentMarginGroupSubIndex++) {
            pCoreTestData->CurrentMarginGroup = \
              pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP][pCoreTestData->CurrentMarginGroupSubIndex];

            // IF the margin parameter group is not valid THEN skip it
            if (pCoreTestData->CurrentMarginGroup == MrcGtMax) {
              continue;
            }

#ifndef DDR5_SUPPORT
            //
            // CmdAll/CtlAll/CmdVref groups are not used for DDR5 CA/CS margin.
            //

            // this one is looping over cmd/ctl/cmdvref, ctlall,
            RetStat = SsaServicesHandle->SsaMemoryConfig->GetMarginParamSpecificity (
              SsaServicesHandle, pCoreTestData->CurrentIoLevel,
              pCoreTestData->CurrentMarginGroup, &Specificity);

            // IF this margin parameter isn't supported THEN skip it
            if ((pCoreTestData->CurrentIoLevel == LrbufLevel) &&
               (RetStat == UnsupportedValue) &&
               ((pCoreTestData->CurrentMarginGroup == CmdAll) ||
               (pCoreTestData->CurrentMarginGroup == CtlAll) ||
               (pCoreTestData->CurrentMarginGroup == CmdVref))) {
                continue;
            }
            // IF the margin parameter group is CtlAll and CtlAll is not enabled THEN skip it
            if ((pCoreTestData->CurrentMarginGroup == CtlAll) &&
              !pTestCfg->EnableCtlAllMargin) {
              continue;
            }
#endif
            if (pTestCfg->TestStatusLogLevel >= 1) {
              if (EFI_ERROR (GetGroupString (pCoreTestData->CurrentMarginGroup, &GroupString))) {
                GroupString = "Unknown group";
              }
              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "\n"
                "Testing IoLevel=%a MarginGroup=%a ShmooDirection=%a\n",
                GetLevelStr (pCoreTestData->CurrentIoLevel),
                GroupString,
                ((ShmooDirs[ShmooDirIdx] == LoDirection) ? "low":"high"));
            }

            // FOR each rank combination:
            for (pCoreTestData->CurrentRankCombinationIndex = 0;
              pCoreTestData->CurrentRankCombinationIndex < \
              pCoreTestData->MaxRankCombinationCnt;
              pCoreTestData->CurrentRankCombinationIndex++) {
              if (pCoreTestData->SetPointTestRankCombinationIndex(
                SsaServicesHandle, &pCoreTestData->SystemInfo,
                &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
                &pCoreTestData->CpgcPointTestCfg,
                pCoreTestData->pCpgcPointTestData,
                pCoreTestData->CurrentRankCombinationIndex,
                FALSE,
                pCoreTestData->pTestStat)) {
                return 1;
              }
              if (pCoreTestData->SetPointTestRankCombinationIndex(
                SsaServicesHandle, &pCoreTestData->SystemInfo,
                &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
                &pCoreTestData->CpgcPointTestCfg,
                pCoreTestData->pCpgcPointTestData,
                pCoreTestData->CurrentRankCombinationIndex,
                TRUE,
                pCoreTestData->pTestStat)) {
                  return 1;
              }
              if (pTestCfg->TestStatusLogLevel >= 2) {
                NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                  "\n"
                  "Testing same rank traffic for rank combination %u of %u\n",
                  (pCoreTestData->CurrentRankCombinationIndex + 1),
                  pCoreTestData->MaxRankCombinationCnt);
              }

#if FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 1
              if (UpdateTargetedDimmRank (SsaServicesHandle, pCoreTestData)) {
                return 1;
              }
#endif

              // initialize the last pass margin status
              InitMarginStatus(pCoreTestData);

              // run the series of Margin1D tests
#if FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 1
              if (UseCaCsTrainingMode (pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentMarginGroup)) {
                if (RunRmtMargin1DWith1DSweepInCaCsTrainingMode (SsaServicesHandle, pCoreTestData,
                  LaneShmooStopMode, 1, &ShmooDirs[ShmooDirIdx])) {
                  return 1;
                }
              } else {
                if (RunRmtMargin1DWith1DSweep(SsaServicesHandle, pCoreTestData,
                  LaneShmooStopMode, 1, &ShmooDirs[ShmooDirIdx])) {
                  return 1;
                }
              }
#else
              if (RunRmtMargin1D (SsaServicesHandle, pCoreTestData,
                LaneShmooStopMode, 1, &ShmooDirs[ShmooDirIdx])) {
                return 1;
              }

              // report the margin parameter limits in the test results, update the
              // limit per each rank iteration.
              if (ReportParamLimitsResults(SsaServicesHandle, pCoreTestData,
                ParamLimits1ResultType)) {
                return 1;
              }
#endif // FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 1

              if (ReportRankMarginResults(SsaServicesHandle, pCoreTestData,
                Rank1RmtResultType, 1, &ShmooDirs[ShmooDirIdx])) {
                return 1;
              }
            } // end for each rank combination

#if FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 0
#if SUPPORT_FOR_EXTENDED_RANGE
            // fixup the command margin results
            if (FixupResults(SsaServicesHandle, pCoreTestData,
              ShmooDirs[ShmooDirIdx], Rank1RmtResultType)) {
              return 1;
            }
#endif // SUPPORT_FOR_EXTENDED_RANGE
#endif
          } // end for each margin parameter group in the second array
        } // end non-DDR-T and DDR-T devices

        // FOR each socket:
        for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
          // IF this socket is not enabled for testing THEN skip it
          if (((pCoreTestData->SystemInfo.SocketBitMask & (1 << Socket)) == 0) ||
            ((pCoreTestData->pTestCfg->SocketBitmask & (1 << Socket)) == 0)) {
              continue;
          }

          // NOTE: Backside command margining setup/cleanup is different for
          // high and low sides so we're piggybacking the shmoo direction in
          // the Setup/Cleanup parameter.
          SetupCleanup = Cleanup;
          SetupCleanup |= ShmooDirs[ShmooDirIdx] << 1;

          //
          // Skip backside denormalization for SPR until it is needed.
          //
#ifndef SPR_PO_FLAG
#if ENBL_BIOS_SSA_API_DEBUG_MSGS
          NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
            "  InitMarginParam(Socket=%u IoLevel=%u MarginGroup=%u SetupCleanup=%u)\n",
            Socket, pCoreTestData->CurrentIoLevel, CmdAll, SetupCleanup);
#endif
          RetStat = SsaServicesHandle->SsaMemoryConfig->InitMarginParam(
            SsaServicesHandle, Socket, pCoreTestData->CurrentIoLevel, CmdAll,
            SetupCleanup);
          // it's ok if the return stat is unsupported
          if ((RetStat != UnsupportedValue) && (ChkRetStat(SsaServicesHandle, RetStat, __FILE__, __LINE__,
            pCoreTestData->pTestStat))) {
            return 1;
          }
#endif // SPR_PO_FLAG
        } // end for each socket
      } // end for each shmoo direction
    } // end if there are devices that support backside command margining
  } // end if rank margining and backside testing are enabled
#endif // SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT

#ifdef DDR5_SUPPORT
#if SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // BCOM signal margining
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  // If rank margining and backside testing are enabled
  if ((pTestCfg->EnableRankMargin) && (pTestCfg->IoLevelBitmask & (1 << LrbufLevel))) {

    pCoreTestData->CurrentIoLevel = LrbufLevel;

    //
    // Initialize the MarginGroups table by current Iolevel.
    //
    InitMarginGroups(pCoreTestData->CurrentIoLevel, &pCoreTestData->MarginGroups);

    // If there are devices that support BCOM margining
    if (pCoreTestData->MemCfg.IsLrDimms || !HasDdrtDevices) {

      for (ShmooDirIdx = 0; ShmooDirIdx < ShmooDirCount; ShmooDirIdx++) {

        pCoreTestData->CurrentIsDdrT = 0;

        //
        // Initialize the bitmask of DIMMs that support BCOM command
        // margining
        //
        InitAsAll = FALSE;

        if (InitSelectMemPointTestCfg (SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel, BcomDelay, Singles,
          pCoreTestData->CurrentIsDdrT, InitAsAll)) {
          return 1;
        }

        //
        // Get the rank combination counts based on the MemPointTestCfg
        //
        if (GetRankCombinationsCnts (SsaServicesHandle, \
          &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
          &pCoreTestData->SelectMemPointTestCfg,
          pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentIsDdrT,
          &pCoreTestData->RankCombinationCnts,
          &pCoreTestData->MaxRankCombinationCnt,
          pCoreTestData->pTestStat)) {
          return 1;
        }

        //
        // Skip if there is no rank for testing
        //
        if (pCoreTestData->MaxRankCombinationCnt == 0) {
          continue;
        }

        // Iterate each margin parameter in the BCOM signal group array:
        for (pCoreTestData->CurrentMarginGroupSubIndex = 0;
          pCoreTestData->CurrentMarginGroupSubIndex < \
          (sizeof (pCoreTestData->MarginGroups[RMT_BCOM_SIGNAL_GROUP]) / sizeof (pCoreTestData->MarginGroups[RMT_BCOM_SIGNAL_GROUP][0]));
          pCoreTestData->CurrentMarginGroupSubIndex++) {
          pCoreTestData->CurrentMarginGroup = \
            pCoreTestData->MarginGroups[RMT_BCOM_SIGNAL_GROUP][pCoreTestData->CurrentMarginGroupSubIndex];

          // If the margin parameter is not valid, then skip it
          if (pCoreTestData->CurrentMarginGroup == SKIP_TEST) {
            continue;
          }

          if (pTestCfg->TestStatusLogLevel >= 1) {
            if (EFI_ERROR (GetGroupString (pCoreTestData->CurrentMarginGroup, &GroupString))) {
              GroupString = "Unknown group";
            }
            NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
              "\n"
              "Testing IoLevel=%a MarginGroup=%a ShmooDirection=%a\n",
              GetLevelStr (pCoreTestData->CurrentIoLevel),
              GroupString,
              ((ShmooDirs[ShmooDirIdx] == LoDirection) ? "low" : "high"));
          }

          // Iterate each rank combination:
          for (pCoreTestData->CurrentRankCombinationIndex = 0;
            pCoreTestData->CurrentRankCombinationIndex < \
            pCoreTestData->MaxRankCombinationCnt;
            pCoreTestData->CurrentRankCombinationIndex++) {
            if (pCoreTestData->SetPointTestRankCombinationIndex (
              SsaServicesHandle, &pCoreTestData->SystemInfo,
              &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
              &pCoreTestData->CpgcPointTestCfg,
              pCoreTestData->pCpgcPointTestData,
              pCoreTestData->CurrentRankCombinationIndex,
              FALSE,
              pCoreTestData->pTestStat)) {
              return 1;
            }

            if (pTestCfg->TestStatusLogLevel >= 2) {
              NORMAL_LOG (SsaServicesHandle, SSA_D_ERROR,
                "\n"
                "Testing same rank traffic for rank combination %u of %u\n",
                (pCoreTestData->CurrentRankCombinationIndex + 1),
                pCoreTestData->MaxRankCombinationCnt);
            }

#if FixedPcdGetBool (PcdSsaUseGeneric1DSweep) == 1
            if (UpdateTargetedDimmRank (SsaServicesHandle, pCoreTestData)) {
              return 1;
            }

            // Initialize the last pass margin status
            InitMarginStatus (pCoreTestData);

            // Run Margin1D tests
            if (UseCaCsTrainingMode (pCoreTestData->CurrentIoLevel, pCoreTestData->CurrentMarginGroup)) {
              if (RunRmtMargin1DWith1DSweepInCaCsTrainingMode (SsaServicesHandle, pCoreTestData,
                LaneShmooStopMode, 1, &ShmooDirs[ShmooDirIdx])) {

                return 1;
              }
            } else {
              if (RunRmtMargin1DWith1DSweep (SsaServicesHandle, pCoreTestData,
                LaneShmooStopMode, 1, &ShmooDirs[ShmooDirIdx])) {
                return 1;
              }
            }

            if (ReportRankMarginResults (SsaServicesHandle, pCoreTestData,
              Rank3RmtResultType, 1, &ShmooDirs[ShmooDirIdx])) {
              return 1;
            }
#endif
          } // end for each rank combination

        } // end for each margin parameter group in the BCOM signal group array
      } // end for each shmoo direction
    } // end if there are devices that support backside command margining
  } // end if rank margining and backside testing are enabled

#endif // SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
#endif // DDR5_SUPPORT

  //
  // Update the number of result element in the metadata section to make it consistent to the final
  // value because the rank limits are not recorded when using 1D sweep.
  // This should be updated even not using 1D sweep.
  //
  pCoreTestData->pMetadata->ResultEleCount = pCoreTestData->ResultElementCount;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // log results
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  if (pTestCfg->EnableTestResultLogging) {
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "\n"
      "* = not tested\n"
      "\n"
      "START_BSSA_RMT\n"
      "\n");

#if SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT
#ifdef __STUB__
    // confirm design assumption
    ASSERT (DdrLevel == 0);
    ASSERT (LrbufLevel == 1);
#endif // __STUB__
    // FOR each I/O level:
    for (pCoreTestData->CurrentIoLevel = DdrLevel;
      pCoreTestData->CurrentIoLevel <= LrbufLevel;
      pCoreTestData->CurrentIoLevel++) {
      // IF this I/O level is not enabled for testing THEN skip it
      if ((pCoreTestData->pTestCfg->IoLevelBitmask &
        (1 << pCoreTestData->CurrentIoLevel)) == 0) {
          continue;
      }

      //
      // Initialize the MarginGroups table by current Iolevel.
      //
      InitMarginGroups(pCoreTestData->CurrentIoLevel, &pCoreTestData->MarginGroups);

      // IF the I/O level is the backside
      if (pCoreTestData->CurrentIoLevel == LrbufLevel) {
        // initialize the bitmask of DIMMs that support backside command
        // margining
        pCoreTestData->CurrentIsDdrT = FALSE;

        InitAsAll = FALSE;
        if (InitSelectMemPointTestCfg(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel, CmdVref, Singles,
          pCoreTestData->CurrentIsDdrT, InitAsAll)) {
            return 1;
        }

        InitBacksideCmdBitmask(SsaServicesHandle, &pCoreTestData->SystemInfo,
          &pCoreTestData->MemCfg, &pCoreTestData->SelectMemPointTestCfg,
          pCoreTestData->MarginGroups[RMT_CMD_SIGNAL_GROUP], CmdMarginGroupCount,
          pCoreTestData->BacksideCmdBitmasks);

        // IF there are no devices with a backside THEN skip it
        if (!IsAnyBacksideCmdBitSet(pCoreTestData->BacksideCmdBitmasks) &&
          !pCoreTestData->MemCfg.IsLrDimms && !HasDdrtDevices) {
          continue;
        }
      } // end if the I/O level is not the frontside
#else
    {
      pCoreTestData->CurrentIoLevel = DdrLevel;
#endif // !(SUPPORT_FOR_RDIMM || SUPPORT_FOR_LRDIMM || SUPPORT_FOR_DDRT)

      if (pTestCfg->EnableRankMargin) {
        LogRankMarginResults(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel);
      } // end if rank margining is enabled

#if SUPPORT_FOR_DDRT
      if (GetRmtTestCfgErid (pCoreTestData->pTestCfg) && HasDdrtDevices &&
        (pCoreTestData->CurrentIoLevel == DdrLevel)) {
          LogEridMarginResults(SsaServicesHandle, pCoreTestData);
      }
#endif
      if (pTestCfg->EnableLaneMargin) {
        LogLaneMarginResults(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel);
      }

#if SUPPORT_FOR_TURNAROUNDS
      if (pTestCfg->EnableTurnaroundMargin) {
        LogTurnaroundMarginResults(SsaServicesHandle, pCoreTestData,
          pCoreTestData->CurrentIoLevel);
      }
#endif // SUPPORT_FOR_TURNAROUNDS
    } // end for each I/O level

    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "STOP_BSSA_RMT\n");

    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "MMA metadata: BusFreq=%u MHz\n", pCoreTestData->SystemInfo.BusFreq);
    NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
      "MMA metadata: MemVoltage=%u mV\n", pCoreTestData->pMetadata->MemVoltage);

    {
      UINT8 Controller, Channel, Dimm;
      UINT8 MemoryTech;
      BOOLEAN Found = FALSE;

      // find the first DIMM
      // FOR each socket:
      for (Socket = 0; Socket < MAX_SOCKET_CNT; Socket++) {
        // FOR each controller:
        for (Controller = 0; Controller < MAX_CONTROLLER_CNT; Controller++) {
          // FOR each channel:
          for (Channel = 0; Channel < MAX_CHANNEL_CNT; Channel++) {
            if (!IsChannelTestingEnabled(SsaServicesHandle,
              &pCoreTestData->SystemInfo, &pCoreTestData->MemCfg,
              &pCoreTestData->SelectMemPointTestCfg, Socket, Controller,
              Channel)) {
              continue;
            }

            // FOR each DIMM:
            for (Dimm = 0; Dimm < MAX_DIMM_CNT; Dimm++) {
              if ((pCoreTestData->SelectMemPointTestCfg.DimmABitmasks[Socket][Controller][Channel] &
                (1 << Dimm)) == 0) {
                continue;
              }

              MemoryTech = pCoreTestData->MemCfg.MemoryTech[Socket][Controller][Channel][Dimm];

#if SUPPORT_FOR_DDRT
              if (MemoryTech == SsaMemoryDdrT) {
                continue;
              }
#endif // SUPPORT_FOR_DDRT

              NORMAL_LOG(SsaServicesHandle, SSA_D_ERROR,
                "MMA metadata: MemoryTech=0x%X\n", MemoryTech);

              Found = TRUE;
              break;
            } // end for each DIMM

            if (Found) {
              break;
            }
          } // end for each channel

          if (Found) {
            break;
          }
        } // end for each controller

        if (Found) {
          break;
        }
      } // end for each socket
    }
  } // end if test result logging is enabled

  if (pTestCfg->EnableLaneMarginPlot) {
    if (pTestCfg->EnableLaneMargin) {
      if (PlotLaneMarginResults(SsaServicesHandle, pCoreTestData,
        HasDdrtDevices)) {
        return 1;
      }
    }
  } // end if lane margin plotting is enabled

  return 0;
} // end function RunRmt

/**
  This function collects the BCOM 1D margin results for EV tests.
  The margin tests are conducted in BCOM training modes.

  @param[in]      TestType          Indicates the test type to be configured. It can use to customize the EV margin test setup
  @param[in]      Socket            Processor socket within the system (0-based)
  @param[in]      ChannelMask       One-hot encoding to mask a channel (0: executes if enabled/populated, 1: skip/masked)
  @param[in]      DimmRank          Structure to specify current dimm and rank under test (0-based)
  @param[in]      Level             Specifies the MRC_LT level (DdrLevel, LrbufLevel, etc)
  @param[in]      Group             Specifies the MRC_GT group that will be under test
  @param[in]      Direction         Specifies the sweep direction: low side only, high side only, or both side
  @param[in]      StepSize          Specifies the StepSize to do the margining
  @param[in]      CountWindow       Count Window Value
  @param[in, out] DcaResults        Pointer to margin results data structure which is indexed as [MAX_CH][SUB_CH]

  @retval MRC_STATUS_SUCCESS
**/
MRC_STATUS
EFIAPI
BcomMargins1DWorker (
  IN     CPGC_POINT_TEST_CONFIG       *CpgcConfig,
  IN     UINT8                        Socket,
  IN     UINT32                       ChannelBitMask,
  IN     MRC_RT                       DimmRank[MAX_CH],
  IN     MRC_LT                       Level,
  IN     MRC_GT                       Group,
  IN     UINT8                        Direction,
  IN     UINT8                        StepSize,
  IN     UINT32                       CountWindow,
  IN OUT struct baseMargin            (*SweepResults)[MAX_CH][SUB_CH]
  )
{
  PSYSHOST          Host;
  MRC_STATUS        Status = MRC_STATUS_SUCCESS;
  UINT8             QcaUcaTrainingStatusSaved;

  Host = GetSysHostPointer();
  QcaUcaTrainingStatusSaved = Host->var.mem.socket[Socket].TrainingStatus.Bits.QcaUcaTrainingDone;
  Host->var.mem.socket[Socket].TrainingStatus.Bits.QcaUcaTrainingDone = 0;

  if (Group == BcomDelay) {
    //
    // Should based on the Cpgc configure to select BCOM specific test type.
    //
    Status = GetBcomTimingMargins (
             BcomTrainingTest,
             Socket,
             ChannelBitMask,
             DimmRank,
             Level,
             Group,
             Direction,
             StepSize,
             CountWindow,
             &(*SweepResults)[0][0]
           );
  } else if (Group== BcomVref) {
      Status = GetBcomVrefMargins (
               BcomTrainingTest,
               Socket,
               ChannelBitMask,
               DimmRank,
               Level,
               Group,
               Direction,
               StepSize,
               CountWindow,
               &(*SweepResults)[0][0]
             );

  }
  Host->var.mem.socket[Socket].TrainingStatus.Bits.QcaUcaTrainingDone = QcaUcaTrainingStatusSaved;

  return Status;
}


/**
  This function collects the BCOM margin results for EV tests.
  The margin tests are conducted in BCOM training modes.

  @param[in]      TestType:         Indicates the test type to be configured. It can use to customize the EV margin test setup
  @param[in]      Socket            Processor socket within the system (0-based)
  @param[in]      ChannelMask       One-hot encoding to mask a channel (0: executes if enabled/populated, 1: skip/masked)
  @param[in]      DimmRank          Structure to specify current dimm and rank under test (0-based)
  @param[in]      Level             Specifies the MRC_LT level (DdrLevel, LrbufLevel, etc)
  @param[in]      Group             Specifies the MRC_GT group that will be under test
  @param[in]      Direction         Specifies the sweep direction: low side only, high side only, or both side
  @param[in]      StepSize          Specifies the StepSize to do the margining
  @param[in, out] DcaResults        Pointer to margin results data structure which is indexed as [MAX_CH][SUB_CH]

  @retval MRC_STATUS_SUCCESS
**/


/**
  This function collects the Cmd/Ctl margin results for EV tests.
  The margin tests are conducted in CA or CS training modes.

  @param[in]      CpgcConfig        Pointer to a CPGC configuration structure. It can be used to customize the EV margin test setup
  @param[in]      Socket            Processor socket within the system (0-based)
  @param[in]      ChannelMask       One-hot encoding to mask a channel (0: executes if enabled/populated, 1: skip/masked)
  @param[in]      DimmRank          Structure to specify current dimm and rank under test (0-based)
  @param[in]      Level             Specifies the MRC_LT level (DdrLevel, LrbufLevel, etc)
  @param[in]      Group             Specifies the MRC_GT group that will be under test
  @param[in]      Direction         Specifies the sweep direction: low side only, high side only, or both side
  @param[in]      StepSize          Specifies the StepSize to do the margining
  @param[in, out] Margins           Pointer to margin results data structure which is indexed as [MAX_CH][SUB_CH]

  @retval MRC_STATUS_SUCCESS
**/
MRC_STATUS
EFIAPI
CaCsMarginsWorker (
  IN     CPGC_POINT_TEST_CONFIG       *CpgcConfig,
  IN     UINT8                        Socket,
  IN     UINT32                       ChannelBitMask,
  IN     MRC_RT                       DimmRank[MAX_CH],
  IN     MRC_LT                       Level,
  IN     MRC_GT                       Group,
  IN     UINT8                        Direction,
  IN     UINT8                        StepSize,
  IN OUT struct baseMargin            Margins[MAX_CH][SUB_CH]
  )
{
  UINT8             SignalIndex;
  UINT8             MaxChDdr;
  UINT8             Channel;
  UINT8             SubChannel;
  struct baseMargin DcaSweepResults[MAX_CH][SUB_CH][RCD_CA_SIGNALS_TO_SWEEP];
  struct baseMargin DcsSweepResults[MAX_CH][SUB_CH];
  struct baseMargin QcaSweepResults[MAX_CH][SUB_CH][BACKSIDE_CA_SIGNALS_TO_SWEEP];
  struct baseMargin QcsSweepResults[MAX_CH][SUB_CH];
  struct baseMargin BcomSweepResults[MAX_CH][SUB_CH];
  MRC_STATUS        Status = MRC_STATUS_SUCCESS;

  MaxChDdr = GetMaxChDdr ();

  if (Level == DdrLevel) {
    // DCA margin
    if ((Group == DcaDelay) || (Group == RcdDcaVref) || (Group == DcaDfeVref)) {

      Status = CaMargins1DWorker (CpgcConfig, Socket, ChannelBitMask, DimmRank, Level, Group, Direction,
        StepSize, DCA_DUTY_CYCLE_COUNTING_WINDOW_VALUE, &DcaSweepResults);

      //
      // Combine margin results of all signals, save the min of positive margin and the max of negative margin.
      //
      if (Status == MRC_STATUS_SUCCESS) {
        for (Channel = 0; Channel < MaxChDdr; Channel++) {
          if (ChannelBitMask & (0x1 << Channel)) {
            continue;
          }
          for (SubChannel = 0; SubChannel < SUB_CH; SubChannel++) {
            Margins[Channel][SubChannel].p = MAX_INT16;
            Margins[Channel][SubChannel].n = MIN_INT16;
            for (SignalIndex = 0; SignalIndex < RCD_CA_SIGNALS_TO_SWEEP; SignalIndex++) {
              if (DcaSweepResults[Channel][SubChannel][SignalIndex].p < Margins[Channel][SubChannel].p) {
                Margins[Channel][SubChannel].p = DcaSweepResults[Channel][SubChannel][SignalIndex].p;
              }
              if (DcaSweepResults[Channel][SubChannel][SignalIndex].n > Margins[Channel][SubChannel].n) {
                Margins[Channel][SubChannel].n = DcaSweepResults[Channel][SubChannel][SignalIndex].n;

                //
                // Ensure the negative direction margin not more than 0 and positive margin not less than 0
                //
                if (Margins[Channel][SubChannel].n > 0) {
                  Margins[Channel][SubChannel].n = 0;
                }

                if (Margins[Channel][SubChannel].p < 0) {
                  Margins[Channel][SubChannel].p = 0;
                }
              }
            } //SignalIndex
          } //SubChannel
        } //Channel
      } // Status = MRC_STATUS_SUCCESS
    } else if (Group == DcsDelay) {
      Status = CsMargins1DWorker (CpgcConfig, Socket, ChannelBitMask, DimmRank, Level, Group, Direction,
        StepSize, CSCA_TF_COUNTING_WINDOW_VALUE, &DcsSweepResults);

      if (Status == MRC_STATUS_SUCCESS) {
        for (Channel = 0; Channel < MaxChDdr; Channel++) {
          if (ChannelBitMask & (0x1 << Channel)) {
            continue;
          }
          for (SubChannel = 0; SubChannel < SUB_CH; SubChannel++) {
            Margins[Channel][SubChannel].p = DcsSweepResults[Channel][SubChannel].p;
            Margins[Channel][SubChannel].n = DcsSweepResults[Channel][SubChannel].n;

            if (Margins[Channel][SubChannel].n > 0) {
              Margins[Channel][SubChannel].n = 0;
            }

            if (Margins[Channel][SubChannel].p < 0) {
              Margins[Channel][SubChannel].p = 0;
            }
          } //SubChannel
        } //Channel
      } // Status = MRC_STATUS_SUCCESS
    }
  } else {
    // QCA margin
    if ((Group == QcaDelay)) {

      Status = QcaMargins1DWorker (CpgcConfig, Socket, ChannelBitMask, DimmRank, Level, Group, Direction,
        StepSize, DQ_COUNTING_WINDOW_VALUE, &QcaSweepResults);

      //
      // Combine margin results of all signals, save the min of positive margin and the max of negative margin.
      //
      if (Status == MRC_STATUS_SUCCESS) {
        for (Channel = 0; Channel < MaxChDdr; Channel++) {
          if (ChannelBitMask & (0x1 << Channel)) {
            continue;
          }
          for (SubChannel = 0; SubChannel < SUB_CH; SubChannel++) {
            Margins[Channel][SubChannel].p = MAX_INT16;
            Margins[Channel][SubChannel].n = MIN_INT16;

            //
            // Only Q0ACA0 - Q0ACA12 were margined. Q0ACA13 was skipped/
            //
            for (SignalIndex = 0; SignalIndex < BACKSIDE_CA_SIGNALS_TO_SWEEP - 1; SignalIndex++) {
              if (QcaSweepResults[Channel][SubChannel][SignalIndex].p < Margins[Channel][SubChannel].p) {
                Margins[Channel][SubChannel].p = QcaSweepResults[Channel][SubChannel][SignalIndex].p;
              }
              if (QcaSweepResults[Channel][SubChannel][SignalIndex].n > Margins[Channel][SubChannel].n) {
                Margins[Channel][SubChannel].n = QcaSweepResults[Channel][SubChannel][SignalIndex].n;

                //
                // Ensure the negative direction margin not more than 0 and positive margin not less than 0
                //
                if (Margins[Channel][SubChannel].n > 0) {
                  Margins[Channel][SubChannel].n = 0;
                }

                if (Margins[Channel][SubChannel].p < 0) {
                  Margins[Channel][SubChannel].p = 0;
                }
              }
            } //SignalIndex
          } //SubChannel
        } //Channel
      } // Status = MRC_STATUS_SUCCESS
    } else if (Group == QcsDelay) {
      Status = QcsMargins1DWorker (CpgcConfig, Socket, ChannelBitMask, DimmRank, Level, Group, Direction,
        StepSize, DQ_COUNTING_WINDOW_VALUE, &QcsSweepResults);

      if (Status == MRC_STATUS_SUCCESS) {
        for (Channel = 0; Channel < MaxChDdr; Channel++) {
          if (ChannelBitMask & (0x1 << Channel)) {
            continue;
          }

          for (SubChannel = 0; SubChannel < SUB_CH; SubChannel++) {
            Margins[Channel][SubChannel].p = QcsSweepResults[Channel][SubChannel].p;
            Margins[Channel][SubChannel].n = QcsSweepResults[Channel][SubChannel].n;

            if (Margins[Channel][SubChannel].n > 0) {
              Margins[Channel][SubChannel].n = 0;
            }

            if (Margins[Channel][SubChannel].p < 0) {
              Margins[Channel][SubChannel].p = 0;
            }
          } //SubChannel
        } //Channel
      } // Status = MRC_STATUS_SUCCESS
    } else if ((Group == BcomDelay) || (Group == BcomVref)) {

      Status = BcomMargins1DWorker (CpgcConfig, Socket, ChannelBitMask, DimmRank, Level, Group, Direction,
        StepSize, DQ_COUNTING_WINDOW_VALUE, &BcomSweepResults);

      //
      // Combine margin results of all signals, save the min of positive margin and the max of negative margin.
      //
      if (Status == MRC_STATUS_SUCCESS) {
        for (Channel = 0; Channel < MaxChDdr; Channel++) {
          if (ChannelBitMask & (0x1 << Channel)) {
            continue;
          }
          for (SubChannel = 0; SubChannel < SUB_CH; SubChannel++) {

            Margins[Channel][SubChannel].p = BcomSweepResults[Channel][SubChannel].p;
            Margins[Channel][SubChannel].n = BcomSweepResults[Channel][SubChannel].n;

            if (Margins[Channel][SubChannel].n > 0) {
              Margins[Channel][SubChannel].n = 0;
            }

            if (Margins[Channel][SubChannel].p < 0) {
              Margins[Channel][SubChannel].p = 0;
            }
          } //SubChannel
        } //Channel
      } // Status = MRC_STATUS_SUCCESS
    }
  } // IoLevel

  return Status;
}

/**
  This function collects the CA 1D margin results for EV tests.
  The margin tests are conducted in CA training modes.

  @param[in]      CpgcConfig        Pointer to a CPGC configuration structure. It can be used to customize the EV margin test setup
  @param[in]      Socket            Processor socket within the system (0-based)
  @param[in]      ChannelMask       One-hot encoding to mask a channel (0: executes if enabled/populated, 1: skip/masked)
  @param[in]      DimmRank          Structure to specify current dimm and rank under test (0-based)
  @param[in]      Level             Specifies the MRC_LT level (DdrLevel, LrbufLevel, etc)
  @param[in]      Group             Specifies the MRC_GT group that will be under test
  @param[in]      Direction         Specifies the sweep direction: low side only, high side only, or both side
  @param[in]      StepSize          Specifies the StepSize to do the margining
  @param[in]      CountWindow       Count Window Value
  @param[in, out] SweepResults      Pointer to margin results data structure which is indexed as [MAX_CH][SUB_CH][Signal]

  @retval MRC_STATUS_SUCCESS
**/
MRC_STATUS
EFIAPI
CaMargins1DWorker (
  IN     CPGC_POINT_TEST_CONFIG       *CpgcConfig,
  IN     UINT8                        Socket,
  IN     UINT32                       ChannelBitMask,
  IN     MRC_RT                       DimmRank[MAX_CH],
  IN     MRC_LT                       Level,
  IN     MRC_GT                       Group,
  IN     UINT8                        Direction,
  IN     UINT8                        StepSize,
  IN     UINT32                       CountWindow,
  IN OUT struct baseMargin            (*SweepResults)[MAX_CH][SUB_CH][RCD_CA_SIGNALS_TO_SWEEP]
  )
{
  PSYSHOST          Host;
  MRC_TT            TestType;
  UINT8             QcaUcaTrainingStatusSaved;
  MRC_STATUS        Status;

  Host = GetSysHostPointer ();

  //
  // Save current QcaUca training status. Then turn it off to force useing smbus to access RCD
  // because we are margin CA bus.
  //
  QcaUcaTrainingStatusSaved = Host->var.mem.socket[Socket].TrainingStatus.Bits.QcaUcaTrainingDone;
  Host->var.mem.socket[Socket].TrainingStatus.Bits.QcaUcaTrainingDone = 0;

  //
  // Should based on the Cpgc configure to select EV CA or CS specific test type.
  // Currently, we don't know what is the BKM pattern yet. Just use the DcaDckDutyCycleTest pattern.
  //
  TestType = DcaDckDutyCycleTest;
  Status = GetDcaMargins (TestType, Socket, ChannelBitMask, DimmRank, Level, Group, Direction, StepSize,
    CountWindow, RCD_CA_SIGNALS_TO_SWEEP, &(*SweepResults)[0][0][0]);

  Host->var.mem.socket[Socket].TrainingStatus.Bits.QcaUcaTrainingDone = QcaUcaTrainingStatusSaved;

  return Status;
}

/**
  This function collects the CS 1D margin results for EV tests.
  The margin tests are conducted in CS training modes.

  @param[in]      CpgcConfig        Pointer to a CPGC configuration structure. It can be used to customize the EV margin test setup
  @param[in]      Socket            Processor socket within the system (0-based)
  @param[in]      ChannelMask       One-hot encoding to mask a channel (0: executes if enabled/populated, 1: skip/masked)
  @param[in]      DimmRank          Structure to specify current dimm and rank under test (0-based)
  @param[in]      Level             Specifies the MRC_LT level (DdrLevel, LrbufLevel, etc)
  @param[in]      Group             Specifies the MRC_GT group that will be under test
  @param[in]      Direction         Specifies the sweep direction: low side only, high side only, or both side
  @param[in]      StepSize          Specifies the StepSize to do the margining
  @param[in]      CountWindow       Count Window Value
  @param[in, out] SweepResults      Pointer to margin results data structure which is indexed as [MAX_CH][SUB_CH]

  @retval MRC_STATUS_SUCCESS
**/
MRC_STATUS
EFIAPI
CsMargins1DWorker (
  IN     CPGC_POINT_TEST_CONFIG       *CpgcConfig,
  IN     UINT8                        Socket,
  IN     UINT32                       ChannelBitMask,
  IN     MRC_RT                       DimmRank[MAX_CH],
  IN     MRC_LT                       Level,
  IN     MRC_GT                       Group,
  IN     UINT8                        Direction,
  IN     UINT8                        StepSize,
  IN     UINT32                       CountWindow,
  IN OUT struct baseMargin            (*SweepResults)[MAX_CH][SUB_CH]
  )
{
  PSYSHOST          Host;
  MRC_TT            TestType;
  UINT8             QcaUcaTrainingStatusSaved;
  MRC_STATUS        Status;

  Host = GetSysHostPointer ();

  //
  // Save current QcaUca training status. Then turn it off to force useing smbus to access RCD
  // because we are margin CA bus.
  //
  QcaUcaTrainingStatusSaved = Host->var.mem.socket[Socket].TrainingStatus.Bits.QcaUcaTrainingDone;
  Host->var.mem.socket[Socket].TrainingStatus.Bits.QcaUcaTrainingDone = 0;

  //
  // TestType is used in the SetupTestDcsWorker to select the pattern. It does not change the CurrentTestType.
  //
  TestType = EarlyCsLoopbackTest;
  Status = GetDcsMargins (TestType, Socket, ChannelBitMask, DimmRank, Level, Group, Direction, StepSize,
    CountWindow, &(*SweepResults)[0][0]);

  Host->var.mem.socket[Socket].TrainingStatus.Bits.QcaUcaTrainingDone = QcaUcaTrainingStatusSaved;

  return Status;
}

/**
  This function collects the QCA 1D margin results for EV tests.
  The margin tests are conducted in CA training modes.

  @param[in]      TestType          Indicates the test type to be configured. It can use to customize the EV margin test setup
  @param[in]      Socket            Processor socket within the system (0-based)
  @param[in]      ChannelMask       One-hot encoding to mask a channel (0: executes if enabled/populated, 1: skip/masked)
  @param[in]      DimmRank          Structure to specify current dimm and rank under test (0-based)
  @param[in]      Level             Specifies the MRC_LT level (DdrLevel, LrbufLevel, etc)
  @param[in]      Group             Specifies the MRC_GT group that will be under test
  @param[in]      Direction         Specifies the sweep direction: low side only, high side only, or both side
  @param[in]      StepSize          Specifies the StepSize to do the margining
  @param[in]      CountWindow       Count Window Value
  @param[in, out] SweepResults      Pointer to margin results data structure which is indexed as [MAX_CH][SUB_CH][Signal]

  @retval MRC_STATUS_SUCCESS
**/
MRC_STATUS
EFIAPI
QcaMargins1DWorker (
  IN     CPGC_POINT_TEST_CONFIG       *CpgcConfig,
  IN     UINT8                        Socket,
  IN     UINT32                       ChannelBitMask,
  IN     MRC_RT                       DimmRank[MAX_CH],
  IN     MRC_LT                       Level,
  IN     MRC_GT                       Group,
  IN     UINT8                        Direction,
  IN     UINT8                        StepSize,
  IN     UINT32                       CountWindow,
  IN OUT struct baseMargin            (*SweepResults)[MAX_CH][SUB_CH][BACKSIDE_CA_SIGNALS_TO_SWEEP]
  )
{
  PSYSHOST          Host;
  MRC_TT            TestType;
  MRC_STATUS        Status;
  UINT8             QcaUcaTrainingStatusSaved;

  Host = GetSysHostPointer ();

  //
  // Save current QcaUca training status. Then turn it off to force useing smbus to access RCD
  // because we are margin CA bus.
  //
  QcaUcaTrainingStatusSaved = Host->var.mem.socket[Socket].TrainingStatus.Bits.QcaUcaTrainingDone;
  Host->var.mem.socket[Socket].TrainingStatus.Bits.QcaUcaTrainingDone = 0;

  //
  // Should based on the Cpgc configure to select EV QCA specific test type.
  // Currently, we don't know what is the BKM pattern yet. Just use the EarlyCaBacksideLoopbackTest pattern.
  //
  TestType = EarlyCaBacksideLoopbackTest;
  Status = GetQcaMargins (TestType, Socket, ChannelBitMask, DimmRank, Level, Group, Direction, StepSize,
    CountWindow, BACKSIDE_CA_SIGNALS_TO_SWEEP - 1, &(*SweepResults)[0][0][0]);

  Host->var.mem.socket[Socket].TrainingStatus.Bits.QcaUcaTrainingDone = QcaUcaTrainingStatusSaved;

  return Status;
}

/**
  This function collects the QCS 1D margin results for EV tests.
  The margin tests are conducted in DRAM CS training modes.

  @param[in]      TestType          Indicates the test type to be configured. It can use to customize the EV margin test setup
  @param[in]      Socket            Processor socket within the system (0-based)
  @param[in]      ChannelMask       One-hot encoding to mask a channel (0: executes if enabled/populated, 1: skip/masked)
  @param[in]      DimmRank          Structure to specify current dimm and rank under test (0-based)
  @param[in]      Level             Specifies the MRC_LT level (DdrLevel, LrbufLevel, etc)
  @param[in]      Group             Specifies the MRC_GT group that will be under test
  @param[in]      Direction         Specifies the sweep direction: low side only, high side only, or both side
  @param[in]      StepSize          Specifies the StepSize to do the margining
  @param[in]      CountWindow       Count Window Value
  @param[in, out] SweepResults      Pointer to margin results data structure which is indexed as [MAX_CH][SUB_CH]

  @retval MRC_STATUS_SUCCESS
**/
MRC_STATUS
EFIAPI
QcsMargins1DWorker (
  IN     CPGC_POINT_TEST_CONFIG       *CpgcConfig,
  IN     UINT8                        Socket,
  IN     UINT32                       ChannelBitMask,
  IN     MRC_RT                       DimmRank[MAX_CH],
  IN     MRC_LT                       Level,
  IN     MRC_GT                       Group,
  IN     UINT8                        Direction,
  IN     UINT8                        StepSize,
  IN     UINT32                       CountWindow,
  IN OUT struct baseMargin (*SweepResults)[MAX_CH][SUB_CH]
  )
{
  PSYSHOST          Host;
  MRC_TT            TestType;
  MRC_STATUS        Status;
  UINT8             QcaUcaTrainingStatusSaved;

  Host = GetSysHostPointer ();

  //
  // Save current QcaUca training status. Then turn it off to force useing smbus to access RCD
  // because we are margin CA bus.
  //
  QcaUcaTrainingStatusSaved = Host->var.mem.socket[Socket].TrainingStatus.Bits.QcaUcaTrainingDone;
  Host->var.mem.socket[Socket].TrainingStatus.Bits.QcaUcaTrainingDone = 0;

  //
  // Should based on the Cpgc configure to select EV QCA specific test type.
  // Currently, we don't know what is the BKM pattern yet. Just use the EarlyCaBacksideLoopbackTest pattern.
  //
  TestType = EarlyCsBacksideLoopbackTest;
  Status = GetQcsMargins (TestType, Socket, ChannelBitMask, DimmRank, Level, Group, Direction, StepSize,
    CountWindow, &(*SweepResults)[0][0]);

  Host->var.mem.socket[Socket].TrainingStatus.Bits.QcaUcaTrainingDone = QcaUcaTrainingStatusSaved;

  return Status;
} //QcsMargins1DWorker

/**
  This function returns if a margin group should be margined in in CA or CS training modes.

  @param[in]      Level             Specifies the MRC_LT level (DdrLevel, LrbufLevel, etc)
  @param[in]      Group             Specifies the MRC_GT group that will be under test

  @retval TRUE or FALSE
**/
BOOLEAN
EFIAPI
UseCaCsTrainingMode (
  IN     MRC_LT                       Level,
  IN     MRC_GT                       Group
  )
{
  switch (Group) {
    case DcaDelay:
    case RcdDcaVref:
    case DcsDelay:
    case QcaDelay:
    case QcsDelay:
    case BcomDelay:
    case BcomVref:
#if FixedPcdGetBool (PcdRmtMarginInCaCsTm) == 1
      return TRUE;
#else
      return FALSE;
#endif
    case DcaDfeVref:
      // It has to use training mode because the Vref monitor is in non-functional data path.
      return TRUE;
    default:
      return FALSE;
  }
}
// end file RmtCore.c
