
/** @file
  MC_DDRIOMC.h

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2007 - 2020 Intel Corporation. <BR>
  
  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.
  
  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.
  
  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
  
  This file contains Silicon register definitions.
  
  This is a generated file; please do not modify it directly.
  
**/

/* The following security policy groups are used by registers in this file:     */

/* SPRA0 Security Policy Groups:                                                */
/* MEMIO_BOOT                                                                   */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI  */
/*    | PM_PCS_SAI | DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |   */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | UNCORE_PMA_SAI                          */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRB0 Security Policy Groups:                                                */
/* MEMIO_BOOT                                                                   */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI  */
/*    | PM_PCS_SAI | DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |   */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | UNCORE_PMA_SAI                          */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRHBM Security Policy Groups:                                               */
/* MEMIO_BOOT                                                                   */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI  */
/*    | PM_PCS_SAI | DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |   */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | UNCORE_PMA_SAI                          */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRC0 Security Policy Groups:                                                */
/* MEMIO_BOOT                                                                   */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI  */
/*    | PM_PCS_SAI | DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |   */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | UNCORE_PMA_SAI                          */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRMCC Security Policy Groups:                                               */
/* MEMIO_BOOT                                                                   */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI  */
/*    | PM_PCS_SAI | DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |   */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | UNCORE_PMA_SAI                          */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRUCC Security Policy Groups:                                               */
/* MEMIO_BOOT                                                                   */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI  */
/*    | PM_PCS_SAI | DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |   */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | UNCORE_PMA_SAI                          */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */


#ifndef _MC_DDRIOMC_h
#define _MC_DDRIOMC_h
#include <Base.h>

/* DDRCC_CTL0_BIT_0_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a800)                                                      */
/*      SPRB0 (0x2001a800)                                                      */
/*      SPRHBM (0x2001a800)                                                     */
/*      SPRC0 (0x2001a800)                                                      */
/*      SPRMCC (0x2001a800)                                                     */
/*      SPRUCC (0x2001a800)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_0_MC_DDRIOMC_REG 0x0822A800

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_0_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_1_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a804)                                                      */
/*      SPRB0 (0x2001a804)                                                      */
/*      SPRHBM (0x2001a804)                                                     */
/*      SPRC0 (0x2001a804)                                                      */
/*      SPRMCC (0x2001a804)                                                     */
/*      SPRUCC (0x2001a804)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_1_MC_DDRIOMC_REG 0x0822A804

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_1_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_2_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a808)                                                      */
/*      SPRB0 (0x2001a808)                                                      */
/*      SPRHBM (0x2001a808)                                                     */
/*      SPRC0 (0x2001a808)                                                      */
/*      SPRMCC (0x2001a808)                                                     */
/*      SPRUCC (0x2001a808)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_2_MC_DDRIOMC_REG 0x0822A808

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_2_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_3_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a80c)                                                      */
/*      SPRB0 (0x2001a80c)                                                      */
/*      SPRHBM (0x2001a80c)                                                     */
/*      SPRC0 (0x2001a80c)                                                      */
/*      SPRMCC (0x2001a80c)                                                     */
/*      SPRUCC (0x2001a80c)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_3_MC_DDRIOMC_REG 0x0822A80C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_3_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_4_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a810)                                                      */
/*      SPRB0 (0x2001a810)                                                      */
/*      SPRHBM (0x2001a810)                                                     */
/*      SPRC0 (0x2001a810)                                                      */
/*      SPRMCC (0x2001a810)                                                     */
/*      SPRUCC (0x2001a810)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_4_MC_DDRIOMC_REG 0x0822A810

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_4_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_5_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a814)                                                      */
/*      SPRB0 (0x2001a814)                                                      */
/*      SPRHBM (0x2001a814)                                                     */
/*      SPRC0 (0x2001a814)                                                      */
/*      SPRMCC (0x2001a814)                                                     */
/*      SPRUCC (0x2001a814)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_5_MC_DDRIOMC_REG 0x0822A814

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_5_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_6_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a818)                                                      */
/*      SPRB0 (0x2001a818)                                                      */
/*      SPRHBM (0x2001a818)                                                     */
/*      SPRC0 (0x2001a818)                                                      */
/*      SPRMCC (0x2001a818)                                                     */
/*      SPRUCC (0x2001a818)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_6_MC_DDRIOMC_REG 0x0822A818

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_6_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_7_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a81c)                                                      */
/*      SPRB0 (0x2001a81c)                                                      */
/*      SPRHBM (0x2001a81c)                                                     */
/*      SPRC0 (0x2001a81c)                                                      */
/*      SPRMCC (0x2001a81c)                                                     */
/*      SPRUCC (0x2001a81c)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_7_MC_DDRIOMC_REG 0x0822A81C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_7_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_8_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a820)                                                      */
/*      SPRB0 (0x2001a820)                                                      */
/*      SPRHBM (0x2001a820)                                                     */
/*      SPRC0 (0x2001a820)                                                      */
/*      SPRMCC (0x2001a820)                                                     */
/*      SPRUCC (0x2001a820)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_8_MC_DDRIOMC_REG 0x0822A820

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_8_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_9_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a824)                                                      */
/*      SPRB0 (0x2001a824)                                                      */
/*      SPRHBM (0x2001a824)                                                     */
/*      SPRC0 (0x2001a824)                                                      */
/*      SPRMCC (0x2001a824)                                                     */
/*      SPRUCC (0x2001a824)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_9_MC_DDRIOMC_REG 0x0822A824

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_9_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_10_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a828)                                                      */
/*      SPRB0 (0x2001a828)                                                      */
/*      SPRHBM (0x2001a828)                                                     */
/*      SPRC0 (0x2001a828)                                                      */
/*      SPRMCC (0x2001a828)                                                     */
/*      SPRUCC (0x2001a828)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_10_MC_DDRIOMC_REG 0x0822A828

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_10_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_11_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a82c)                                                      */
/*      SPRB0 (0x2001a82c)                                                      */
/*      SPRHBM (0x2001a82c)                                                     */
/*      SPRC0 (0x2001a82c)                                                      */
/*      SPRMCC (0x2001a82c)                                                     */
/*      SPRUCC (0x2001a82c)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_11_MC_DDRIOMC_REG 0x0822A82C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_11_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_12_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a830)                                                      */
/*      SPRB0 (0x2001a830)                                                      */
/*      SPRHBM (0x2001a830)                                                     */
/*      SPRC0 (0x2001a830)                                                      */
/*      SPRMCC (0x2001a830)                                                     */
/*      SPRUCC (0x2001a830)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_12_MC_DDRIOMC_REG 0x0822A830

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_12_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_13_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a834)                                                      */
/*      SPRB0 (0x2001a834)                                                      */
/*      SPRHBM (0x2001a834)                                                     */
/*      SPRC0 (0x2001a834)                                                      */
/*      SPRMCC (0x2001a834)                                                     */
/*      SPRUCC (0x2001a834)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_13_MC_DDRIOMC_REG 0x0822A834

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_13_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_14_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a838)                                                      */
/*      SPRB0 (0x2001a838)                                                      */
/*      SPRHBM (0x2001a838)                                                     */
/*      SPRC0 (0x2001a838)                                                      */
/*      SPRMCC (0x2001a838)                                                     */
/*      SPRUCC (0x2001a838)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_14_MC_DDRIOMC_REG 0x0822A838

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_14_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_15_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a83c)                                                      */
/*      SPRB0 (0x2001a83c)                                                      */
/*      SPRHBM (0x2001a83c)                                                     */
/*      SPRC0 (0x2001a83c)                                                      */
/*      SPRMCC (0x2001a83c)                                                     */
/*      SPRUCC (0x2001a83c)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_15_MC_DDRIOMC_REG 0x0822A83C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_15_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_16_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a840)                                                      */
/*      SPRB0 (0x2001a840)                                                      */
/*      SPRHBM (0x2001a840)                                                     */
/*      SPRC0 (0x2001a840)                                                      */
/*      SPRMCC (0x2001a840)                                                     */
/*      SPRUCC (0x2001a840)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_16_MC_DDRIOMC_REG 0x0822A840

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_16_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_17_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a844)                                                      */
/*      SPRB0 (0x2001a844)                                                      */
/*      SPRHBM (0x2001a844)                                                     */
/*      SPRC0 (0x2001a844)                                                      */
/*      SPRMCC (0x2001a844)                                                     */
/*      SPRUCC (0x2001a844)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_17_MC_DDRIOMC_REG 0x0822A844

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_17_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_18_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a848)                                                      */
/*      SPRB0 (0x2001a848)                                                      */
/*      SPRHBM (0x2001a848)                                                     */
/*      SPRC0 (0x2001a848)                                                      */
/*      SPRMCC (0x2001a848)                                                     */
/*      SPRUCC (0x2001a848)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_18_MC_DDRIOMC_REG 0x0822A848

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_18_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_19_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a84c)                                                      */
/*      SPRB0 (0x2001a84c)                                                      */
/*      SPRHBM (0x2001a84c)                                                     */
/*      SPRC0 (0x2001a84c)                                                      */
/*      SPRMCC (0x2001a84c)                                                     */
/*      SPRUCC (0x2001a84c)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_19_MC_DDRIOMC_REG 0x0822A84C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_19_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_20_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a850)                                                      */
/*      SPRB0 (0x2001a850)                                                      */
/*      SPRHBM (0x2001a850)                                                     */
/*      SPRC0 (0x2001a850)                                                      */
/*      SPRMCC (0x2001a850)                                                     */
/*      SPRUCC (0x2001a850)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_20_MC_DDRIOMC_REG 0x0822A850

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_20_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL0_BIT_21_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a854)                                                      */
/*      SPRB0 (0x2001a854)                                                      */
/*      SPRHBM (0x2001a854)                                                     */
/*      SPRC0 (0x2001a854)                                                      */
/*      SPRMCC (0x2001a854)                                                     */
/*      SPRUCC (0x2001a854)                                                     */
/* Register default value on SPRA0: 0x00490000                                  */
/* Register default value on SPRB0: 0x00490000                                  */
/* Register default value on SPRHBM: 0x00490000                                 */
/* Register default value on SPRC0: 0x00490000                                  */
/* Register default value on SPRMCC: 0x00490000                                 */
/* Register default value on SPRUCC: 0x00490000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL0_BIT_21_MC_DDRIOMC_REG 0x0822A854

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly : 9;

                            /* Bits[8:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               CMD delay control. The range is 0 to 8 UI with
                               step size of clkpi/128.[br] This field is added
                               with cmd_dly_adj to allow BIOS for margining
                               sweep (signed numer -128 to 127). [br] The final
                               delay - [br] 8:7 - is used for logic delay[br]
                               6:0 - The lower 7 bit is added with
                               cmd_piref_offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the cmd pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] Note: we
                               have 2 DLL in CMD fub, which generate 4 piref
                               clocks. Please refer to ddrcc_piref_offset0
                               register definition for piref assignment for
                               each bit[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_pie_offset : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the cmd_pio_code. The
                               result is the cmd pi even code (cmd_pie_code) to
                               DLL. Default value is 64.
                            */
    UINT32 io_dir : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               IO direction control during normal function
                               mode. This bit is used to qualify the DDRINTF
                               command output enable (TX) and received data
                               (RX).[br] 0: CMD IO is used for RX [br] 1: CMD
                               IO is used for TX [br] Note: This signal need to
                               be qualify by IO direction valid control.[br]
                               Note: For ACIO, both RX/TX are enabled by ACIO
                               control.
                            */
    UINT32 io_pwrdn_pull_low : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               IO Analog Power Down Pull low control. This
                               control determines the IO behavior (pull low or
                               tri-state) when analog power domain is down (C6
                               or S3)[br] 0: tri-state[br] 1: pull low (cke for
                               DDR4 or CS for DDR5)
                            */
    UINT32 pi_n_clk_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               PI N clock enable control. For IO that doesn't
                               require to have the PI N clock on. BIOS can set
                               the corresponding bit to 0 to save power. For
                               example DDRT REQ, alert input don't require PI N
                               clock to receive the data. They are recive on
                               the DCLK.
                            */
    UINT32 io_dis : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable this IO if this CMD IO pin is
                               not used.[br] Currently use case is for DDR5
                               RDIMM. We only pin out 7 of the IOs. The other 7
                               IOs are not pinout.
                            */
    UINT32 odt_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ODT enable to Command buf. */
    UINT32 rx_unsample_path_sel : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               0: sampled path - ERID (DDRT), REQ (DDRT2)[br]
                               1: unsampled path - ALERT, REQ (DDRT), ERR
                               (DDRT/DDRT2), RSP_A/RSP_B (DDR5)
                            */
    UINT32 cs_para_sel : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               0: this bit uses CA parameter for ca_imode_en,
                               ca_imode_eq_code, ca_txeq_1st_tap and
                               ca_txeq_2nd_tap.[br] 1: this bit uses CS
                               parameter for cs_imode_en, cs_imode_eq_code,
                               cs_txeq_1st_tap and cs_txeq_2nd_tap
                            */
    UINT32 rxfifo_ptr_ctl : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* RX FIFO pointer separation control */
    UINT32 sa_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Sense Amplifier enable to Command buf. */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_ui : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Transmit Unit Interval. [br] Bit 1: Set to 1 if
                               TX UI is 0.5 Dclk [br] Bit 0: Set to 1 if TX UI
                               is 2 DCLK. [br] - DDR5 RDIMM CMD bit (CA7) (1N
                               mode) : 2'b10 (0.5 Dclk) [br] - DDR5 UDIMM CMD
                               bit (CA14) (1N mode) : 2'b00 (1 Dclk) [br] -
                               DDR5 RDIMM CMD bit (CA7) (2N mode) : 2'b00 (1
                               Dclk) [br] - DDR5 UDIMM CMD bit (CA14) (2N mode)
                               : 2'b01 (2 Dclk) [br] - DDR5 CTL bit : 2'b00 (1
                               Dclk) [br] - DDR4 CMD/CTL bit (1N mode) : 2'b00
                               (1 Dclk) [br] - DDR4 CMD bit (2N mode) : 2'b01
                               (2 Dclk)
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL0_BIT_21_MC_DDRIOMC_STRUCT;

/* DDRCC_RXVREF_CTL_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a858)                                                      */
/*      SPRB0 (0x2001a858)                                                      */
/*      SPRHBM (0x2001a858)                                                     */
/*      SPRC0 (0x2001a858)                                                      */
/*      SPRMCC (0x2001a858)                                                     */
/*      SPRUCC (0x2001a858)                                                     */
/* Register default value on SPRA0: 0x0000BFA0                                  */
/* Register default value on SPRB0: 0x0000BFA0                                  */
/* Register default value on SPRHBM: 0x0000BFA0                                 */
/* Register default value on SPRC0: 0x0000BFA0                                  */
/* Register default value on SPRMCC: 0x0000BFA0                                 */
/* Register default value on SPRUCC: 0x0000BFA0                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* RX VREF Control Register
*/


#define DDRCC_RXVREF_CTL_MC_DDRIOMC_REG 0x0822A858

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rx_vref_ctl0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000A0*/

                            /*
                               RX Vref control 0 with step size is
                               vccddr_hv/256. Default is 62.5% vccddr_hv.[br]
                               These control is applied for cc bit 0 to 11[br]
                               Note: This vref is intended to use for alert_n
                            */
    UINT32 rx_vref_ctl1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000BF*/

                            /*
                               RX Vref control 1 with step size is
                               vccddr_hv/256. Default is 75% vccddr_hv.[br]
                               These control is applied for cc bit 12 to 21[br]
                               Note: This vref is intended to use for
                               REQ/ERR/RSP_A/RSP_B
                            */
    UINT32 rsvd : 14;

                            /* Bits[29:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_RXVREF_CTL_MC_DDRIOMC_STRUCT;

/* DDRCC_COMP_LA0_MC_DDRIOMC_REG supported on:                                  */
/*      SPRA0 (0x2001a85c)                                                      */
/*      SPRB0 (0x2001a85c)                                                      */
/*      SPRHBM (0x2001a85c)                                                     */
/*      SPRC0 (0x2001a85c)                                                      */
/*      SPRMCC (0x2001a85c)                                                     */
/*      SPRUCC (0x2001a85c)                                                     */
/* Register default value on SPRA0: 0x00000408                                  */
/* Register default value on SPRB0: 0x00000408                                  */
/* Register default value on SPRHBM: 0x00000408                                 */
/* Register default value on SPRC0: 0x00000408                                  */
/* Register default value on SPRMCC: 0x00000408                                 */
/* Register default value on SPRUCC: 0x00000408                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Late Action Register for RCOMP DRV UP/DN. It is updated either by COMP training FSM or SW. The promotion from late acton register to effective register is controlled by COMP FSM after quiescent request is granted from MC.
*/


#define DDRCC_COMP_LA0_MC_DDRIOMC_REG 0x0822A85C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rcomp_drv_up : 5;

                            /* Bits[4:0], Access Type=RW/V, default=0x00000008*/

                            /*
                               CMD Rcomp Drive Up Comp Value. It is trained by
                               COMP FSM.[br] This value is added with
                               rcomp_drv_up_adj (signed number. Range is -8 to
                               7) before send it to the cmdbuf.[br] Note: HW
                               checks for overflow and underflow.
                            */
    UINT32 rsvd : 2;

                            /* Bits[6:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rcomp_drv_dn : 5;

                            /* Bits[11:7], Access Type=RW/V, default=0x00000008*/

                            /*
                               CMD Rcomp Drive Down Comp Value. It is trained
                               by COMP FSM.[br] This value is added with
                               rcomp_drv_dn_adj (signed number. Range is -8 to
                               7) before send it to the cmdbuf.[br] Note: HW
                               checks for overflow and underflow.
                            */
    UINT32 rsvd_12 : 20;

                            /* Bits[31:12], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_COMP_LA0_MC_DDRIOMC_STRUCT;

/* DDRCC_COMP_LA1_MC_DDRIOMC_REG supported on:                                  */
/*      SPRA0 (0x2001a860)                                                      */
/*      SPRB0 (0x2001a860)                                                      */
/*      SPRHBM (0x2001a860)                                                     */
/*      SPRC0 (0x2001a860)                                                      */
/*      SPRMCC (0x2001a860)                                                     */
/*      SPRUCC (0x2001a860)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Late Action Register for SCOMP, and TCO COMP. It is updated by BIOS. The promotion from late acton register to effective register is controlled by COMP FSM after quiescent request is granted from MC.
*/


#define DDRCC_COMP_LA1_MC_DDRIOMC_REG 0x0822A860

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tco_comp : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               CMD TCO Comp Value. It is program by BIOS but it
                               is not trained.[br] 0/64: fastest rise & fall
                               delay[br] 0->31: increasing fall delay[br]
                               64->95: increasing rise delay[br] Other values
                               are not used (32-63 & 96-127).[br] To get
                               monotonic increasing sweep of dutycycle, sweep
                               from (95 to 65, 0 to 31)
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 scomp : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000000*/

                            /*
                               CMD Slew Rate Comp Value. It is trained by BIOS.
                               [br] 0 is fastest slew rate, 31 is slowest slew
                               rate. [br] The SCOMP Up/Down Code are generated
                               from the following equation:[br] SCOMP Up
                               code[lb]4:0[rb] = scomp[lb]4:0[rb] +
                               scomp_up_adj[lb]3:0[rb];[br] SCOMP Down
                               code[lb]4:0[rb] = scomp[lb]4:0[rb] +
                               scomp_dn_adj[lb]3:0[rb];[br] Note : both SCOMP
                               up Adjust (scomp_up_adj) and SCOMP down adjust
                               (scomp_dn_adj) are signed valued. The adjust
                               range is -8 to 7[br] Note: HW checks for
                               overflow and underflow.
                            */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_COMP_LA1_MC_DDRIOMC_STRUCT;

/* DDRCC_COMP_OFFSET_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a864)                                                      */
/*      SPRB0 (0x2001a864)                                                      */
/*      SPRHBM (0x2001a864)                                                     */
/*      SPRC0 (0x2001a864)                                                      */
/*      SPRMCC (0x2001a864)                                                     */
/*      SPRUCC (0x2001a864)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* COMP offset values add on to SCOMP, RCOMP DRV up/down, and TCO COMP
*/


#define DDRCC_COMP_OFFSET_MC_DDRIOMC_REG 0x0822A864

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rcomp_drv_up_adj : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               Signed number add to rcomp_drv_up to generate
                               the RCOMP Drive up code. The adjust range is -8
                               to 7.
                            */
    UINT32 rsvd : 1;

                            /* Bits[4:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rcomp_drv_dn_adj : 4;

                            /* Bits[8:5], Access Type=RW, default=0x00000000*/

                            /*
                               Signed number add to rcomp_drv_dn to generate
                               the RCOMP Drive down code. The adjust range is
                               -8 to 7.
                            */
    UINT32 rsvd_9 : 11;

                            /* Bits[19:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 scomp_up_adj : 4;

                            /* Bits[23:20], Access Type=RW, default=0x00000000*/

                            /*
                               Signed number add to scomp to generate the SCOMP
                               Up Code. The adjust range is -8 to 7.
                            */
    UINT32 rsvd_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 scomp_dn_adj : 4;

                            /* Bits[28:25], Access Type=RW, default=0x00000000*/

                            /*
                               Signed number add to scomp to generate the SCOMP
                               Down Code. The adjust range is -8 to 7.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_COMP_OFFSET_MC_DDRIOMC_STRUCT;

/* DDRCC_VSSHI_CTL_MC_DDRIOMC_REG supported on:                                 */
/*      SPRA0 (0x2001a868)                                                      */
/*      SPRB0 (0x2001a868)                                                      */
/*      SPRHBM (0x2001a868)                                                     */
/*      SPRC0 (0x2001a868)                                                      */
/*      SPRMCC (0x2001a868)                                                     */
/*      SPRUCC (0x2001a868)                                                     */
/* Register default value on SPRA0: 0x00000118                                  */
/* Register default value on SPRB0: 0x00000118                                  */
/* Register default value on SPRHBM: 0x00000118                                 */
/* Register default value on SPRC0: 0x00000118                                  */
/* Register default value on SPRMCC: 0x00000118                                 */
/* Register default value on SPRUCC: 0x00000118                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* VSSHI Control Register
*/


#define DDRCC_VSSHI_CTL_MC_DDRIOMC_REG 0x0822A868

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vsshi_target_code : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000018*/

                            /*
                               VSSHI target code to vsshi vref control. Step
                               size for 10nm VssHi is vccddr_hv/256.[br] Code
                               should be programmed according to analog_tuning
                               field in dll status register:[br] DDR5/T2
                               DDR4/T[br] 3'd3: 0x45 0x55[br] 3'd1,3'd2: 0x3a
                               0x4a[br] 3'd0: 0x2e 0x40[br] Note: the vref_ctrl
                               MSB (Bit 7) is hardtie to 0 inside VSSHI. Only
                               the lower 7-bit is controlled by this field.
                            */
    UINT32 vsshi_bias_ctl : 2;

                            /* Bits[8:7], Access Type=RW, default=0x00000002*/

                            /*
                               Vsshi Bias Current trim.[br] The field should be
                               programmed according to analog_tuning field.[br]
                               00: min current (if analog_tuning=3d3, fast
                               skew)[br] 01: mid current (if
                               analog_tuning=3d1/3d2, typ skew)[br] 11: max
                               current (if analog_tuning=3d0, slow skew)
                            */
    UINT32 vsshi_pulldown_en : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* Pull VSSHI to VSS */
    UINT32 vsshi_close_loop : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Operates VssHi in Close loop mode */
    UINT32 rsvd : 19;

                            /* Bits[29:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 vsshi_tmr_ext : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Double the timer for VSSHI settle time. Use for
                               failsafe in case settle time was
                               underestimated.[br] 0: 8K+1K=9K Dclk cycles[br]
                               1: 16K+2K=18K Dclk cycles[br] Doubles the VSSHI
                               settle time counter in case hard-coded value is
                               not adequate
                            */
    UINT32 vsshi_dclk_gate_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate DCLK for VSSHI
                               control logic. Default is disable clock gating.
                            */

  } Bits;
  UINT32 Data;

} DDRCC_VSSHI_CTL_MC_DDRIOMC_STRUCT;



/* DDRCC_DLL_CSR_0_MC_DDRIOMC_REG supported on:                                 */
/*      SPRA0 (0x2001a874)                                                      */
/*      SPRB0 (0x2001a874)                                                      */
/*      SPRHBM (0x2001a874)                                                     */
/*      SPRC0 (0x2001a874)                                                      */
/*      SPRMCC (0x2001a874)                                                     */
/*      SPRUCC (0x2001a874)                                                     */
/* Register default value on SPRA0: 0x28000000                                  */
/* Register default value on SPRB0: 0x28000000                                  */
/* Register default value on SPRHBM: 0x28000000                                 */
/* Register default value on SPRC0: 0x28000000                                  */
/* Register default value on SPRMCC: 0x28000000                                 */
/* Register default value on SPRUCC: 0x28000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per DLL Control and Status Register
*/


#define DDRCC_DLL_CSR_0_MC_DDRIOMC_REG 0x0822A874

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 detrm_lock : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /* DLL Deterministic Lock Status */
    UINT32 raw_lock : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /* DLL Raw Lock Status Sticky bit. */
    UINT32 lock_timeout : 1;

                            /* Bits[2:2], Access Type=RO/V, default=0x00000000*/

                            /* DLL Lock timeout. */
    UINT32 dll_reset : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000000*/

                            /* DLL Reset. */
    UINT32 adcout : 10;

                            /* Bits[13:4], Access Type=RO/V, default=0x00000000*/

                            /* DLL ADC out. */
    UINT32 long_lock : 1;

                            /* Bits[14:14], Access Type=RO/V, default=0x00000000*/

                            /* DLL Long Lock Status. */
    UINT32 detlock_earlylockstky : 1;

                            /* Bits[15:15], Access Type=RO/V, default=0x00000000*/

                            /* Detect lock CBB early lock sticky output */
    UINT32 weak_lock : 1;

                            /* Bits[16:16], Access Type=RO/V, default=0x00000000*/

                            /* DLL Weak Lock Status. */
    UINT32 adc_done : 1;

                            /* Bits[17:17], Access Type=RO/V, default=0x00000000*/

                            /* DLL ADC done. */
    UINT32 pilags : 1;

                            /* Bits[18:18], Access Type=RO/V, default=0x00000000*/

                            /*
                               DLL output of PiDFx FSM to indciate Pi lags. In
                               order to read this debug register, clock gating
                               must be disabled.
                            */
    UINT32 openloop : 1;

                            /* Bits[19:19], Access Type=RO/V, default=0x00000000*/

                            /* MDLL open loop output */
    UINT32 lockrst_b : 1;

                            /* Bits[20:20], Access Type=RO/V, default=0x00000000*/

                            /* Detect lock CBB lock reset output */
    UINT32 analog_tuning : 3;

                            /* Bits[23:21], Access Type=RO/V, default=0x00000000*/

                            /*
                               BIOS should configure certain analog components
                               based on the value of this register.[br] Details
                               will be found in the description of any CSR that
                               relies on this value
                            */
    UINT32 rsvd : 3;

                            /* Bits[26:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 flybyclk_sel : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000001*/

                            /*
                               Bypasses flyby clock and selects H-tree clock
                               when disbled
                            */
    UINT32 iofreq_range : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000002*/

                            /*
                               BIOS program this IO Frequency range field based
                               on PLL freq; It is half of the DRAM transfer
                               rate. For example DDR 4800. The PLL freq is
                               2400.[br] 2b00: 933MHz - 1333MHz (i.e. 1867MT/s
                               to 2667MT/s)[br] 2b01: 1467MHz 1600MHz (i.e.
                               2933MT/s to 3200MT/s)[br] 2b10: 1800MHz 2000MHz
                               (i.e. 3600MT/s to 4000MT/s)[br] 2b11: 2200MHz
                               2400MHz, or above (i.e. 4400MT/s to 4800MT/s)
                            */
    UINT32 rsvd_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dll_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS must enable DLL when program the IO freq
                               range.
                            */

  } Bits;
  UINT32 Data;

} DDRCC_DLL_CSR_0_MC_DDRIOMC_STRUCT;

/* DDRCC_DLL_CSR_1_MC_DDRIOMC_REG supported on:                                 */
/*      SPRA0 (0x2001a878)                                                      */
/*      SPRB0 (0x2001a878)                                                      */
/*      SPRHBM (0x2001a878)                                                     */
/*      SPRC0 (0x2001a878)                                                      */
/*      SPRMCC (0x2001a878)                                                     */
/*      SPRUCC (0x2001a878)                                                     */
/* Register default value on SPRA0: 0x28000000                                  */
/* Register default value on SPRB0: 0x28000000                                  */
/* Register default value on SPRHBM: 0x28000000                                 */
/* Register default value on SPRC0: 0x28000000                                  */
/* Register default value on SPRMCC: 0x28000000                                 */
/* Register default value on SPRUCC: 0x28000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per DLL Control and Status Register
*/


#define DDRCC_DLL_CSR_1_MC_DDRIOMC_REG 0x0822A878

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 detrm_lock : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /* DLL Deterministic Lock Status */
    UINT32 raw_lock : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /* DLL Raw Lock Status Sticky bit. */
    UINT32 lock_timeout : 1;

                            /* Bits[2:2], Access Type=RO/V, default=0x00000000*/

                            /* DLL Lock timeout. */
    UINT32 dll_reset : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000000*/

                            /* DLL Reset. */
    UINT32 adcout : 10;

                            /* Bits[13:4], Access Type=RO/V, default=0x00000000*/

                            /* DLL ADC out. */
    UINT32 long_lock : 1;

                            /* Bits[14:14], Access Type=RO/V, default=0x00000000*/

                            /* DLL Long Lock Status. */
    UINT32 detlock_earlylockstky : 1;

                            /* Bits[15:15], Access Type=RO/V, default=0x00000000*/

                            /* Detect lock CBB early lock sticky output */
    UINT32 weak_lock : 1;

                            /* Bits[16:16], Access Type=RO/V, default=0x00000000*/

                            /* DLL Weak Lock Status. */
    UINT32 adc_done : 1;

                            /* Bits[17:17], Access Type=RO/V, default=0x00000000*/

                            /* DLL ADC done. */
    UINT32 pilags : 1;

                            /* Bits[18:18], Access Type=RO/V, default=0x00000000*/

                            /*
                               DLL output of PiDFx FSM to indciate Pi lags. In
                               order to read this debug register, clock gating
                               must be disabled.
                            */
    UINT32 openloop : 1;

                            /* Bits[19:19], Access Type=RO/V, default=0x00000000*/

                            /* MDLL open loop output */
    UINT32 lockrst_b : 1;

                            /* Bits[20:20], Access Type=RO/V, default=0x00000000*/

                            /* Detect lock CBB lock reset output */
    UINT32 analog_tuning : 3;

                            /* Bits[23:21], Access Type=RO/V, default=0x00000000*/

                            /*
                               BIOS should configure certain analog components
                               based on the value of this register.[br] Details
                               will be found in the description of any CSR that
                               relies on this value
                            */
    UINT32 rsvd : 3;

                            /* Bits[26:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 flybyclk_sel : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000001*/

                            /*
                               Bypasses flyby clock and selects H-tree clock
                               when disbled
                            */
    UINT32 iofreq_range : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000002*/

                            /*
                               BIOS program this IO Frequency range field based
                               on PLL freq; It is half of the DRAM transfer
                               rate. For example DDR 4800. The PLL freq is
                               2400.[br] 2b00: 933MHz - 1333MHz (i.e. 1867MT/s
                               to 2667MT/s)[br] 2b01: 1467MHz 1600MHz (i.e.
                               2933MT/s to 3200MT/s)[br] 2b10: 1800MHz 2000MHz
                               (i.e. 3600MT/s to 4000MT/s)[br] 2b11: 2200MHz
                               2400MHz, or above (i.e. 4400MT/s to 4800MT/s)
                            */
    UINT32 rsvd_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dll_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS must enable DLL when program the IO freq
                               range.
                            */

  } Bits;
  UINT32 Data;

} DDRCC_DLL_CSR_1_MC_DDRIOMC_STRUCT;

/* DDRCC_TRAIN_OFFSET0_MC_DDRIOMC_REG supported on:                             */
/*      SPRA0 (0x2001a87c)                                                      */
/*      SPRB0 (0x2001a87c)                                                      */
/*      SPRHBM (0x2001a87c)                                                     */
/*      SPRC0 (0x2001a87c)                                                      */
/*      SPRMCC (0x2001a87c)                                                     */
/*      SPRUCC (0x2001a87c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Training offset control CMD delay
*/


#define DDRCC_TRAIN_OFFSET0_MC_DDRIOMC_REG 0x0822A87C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_dly_adj : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               CMD delay adjust value. It is added to all per
                               bit command delay. It is used by BIOS for
                               margining sweep. The adjust range is -128 to
                               127. The expected usage model is BIOS broadcast
                               the same adjust value to all the command fubs.
                            */
    UINT32 rsvd : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_TRAIN_OFFSET0_MC_DDRIOMC_STRUCT;

/* DDRCC_PIREF_OFFSET0_0_MC_DDRIOMC_REG supported on:                           */
/*      SPRA0 (0x2001a880)                                                      */
/*      SPRB0 (0x2001a880)                                                      */
/*      SPRHBM (0x2001a880)                                                     */
/*      SPRC0 (0x2001a880)                                                      */
/*      SPRMCC (0x2001a880)                                                     */
/*      SPRUCC (0x2001a880)                                                     */
/* Register default value on SPRA0: 0x3F002000                                  */
/* Register default value on SPRB0: 0x3F002000                                  */
/* Register default value on SPRHBM: 0x3F002000                                 */
/* Register default value on SPRC0: 0x3F002000                                  */
/* Register default value on SPRMCC: 0x3F002000                                 */
/* Register default value on SPRUCC: 0x3F002000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* PIREF offset for PI N clocks[br]
                 reg 3: DLL 1 - piref for IO[lb]21:16[rb][br]
                 reg 2: DLL 1 - piref for IO[lb]15:12[rb][br]
                 reg 1: DLL 0 - piref for IO[lb]11:6[rb][br]
                 reg 0: DLL 0 - piref for IO[lb]5:0[rb]
*/


#define DDRCC_PIREF_OFFSET0_0_MC_DDRIOMC_REG 0x0822A880

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 piref_train_pio_code : 7;

                            /* Bits[6:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               It is the train PI odd code to align the PIREF
                               odd clock to the failing edge of DCLK with data
                               propagation delay after xover training. [br]
                               This value is added with a signed
                               piref_setup_adj (default value is 63) to
                               generate the piref_pio_code to DLL. The xover
                               input is driven from a failing edge of DCLK
                               flop. [br] By moving the piref odd clock to the
                               right by 63 ticks, we will have 63 pi tick of
                               setup margin.[br] This field can be programed by
                               BIOS or HW cal FSM.
                            */
    UINT32 piref_pie_offset : 7;

                            /* Bits[13:7], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the piref_pio_code. The
                               result is the piref pi even code
                               (piref_pie_code) to DLL. Default value is 64.
                            */
    UINT32 cmd_piref_offset : 7;

                            /* Bits[20:14], Access Type=RW/V, default=0x00000000*/

                            /*
                               This cmd piref offset is added with a signed
                               piref_setup_adj (default value is 63). [br] The
                               result is added to each cmd_dly[6:0], so each
                               cmd pi odd code to the DLL is relative to the
                               piref odd clock.[br] This field can be programed
                               by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 3;

                            /* Bits[23:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 piref_setup_adj : 7;

                            /* Bits[30:24], Access Type=RW/V, default=0x0000003F*/

                            /*
                               A singed number for piref setup adjust. Range is
                               -64 to 63. [br] The xover input is driven from a
                               inverted DCLK flop. This conrol allows BIOS to
                               adjust the setup time to the input of the xover
                               piref odd clock flop. [br] Default value is 63.
                               [br] It means after xover training to align the
                               piref odd clock to the dclk. The piref odd clock
                               is moved to the right by 63 ticks, and we will
                               have 63 pi tick of setup margin. [br] HW will
                               add this value to all the pi codes before send
                               to DLL.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_PIREF_OFFSET0_0_MC_DDRIOMC_STRUCT;

/* DDRCC_PIREF_OFFSET0_1_MC_DDRIOMC_REG supported on:                           */
/*      SPRA0 (0x2001a884)                                                      */
/*      SPRB0 (0x2001a884)                                                      */
/*      SPRHBM (0x2001a884)                                                     */
/*      SPRC0 (0x2001a884)                                                      */
/*      SPRMCC (0x2001a884)                                                     */
/*      SPRUCC (0x2001a884)                                                     */
/* Register default value on SPRA0: 0x3F002000                                  */
/* Register default value on SPRB0: 0x3F002000                                  */
/* Register default value on SPRHBM: 0x3F002000                                 */
/* Register default value on SPRC0: 0x3F002000                                  */
/* Register default value on SPRMCC: 0x3F002000                                 */
/* Register default value on SPRUCC: 0x3F002000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* PIREF offset for PI N clocks[br]
                 reg 3: DLL 1 - piref for IO[lb]21:16[rb][br]
                 reg 2: DLL 1 - piref for IO[lb]15:12[rb][br]
                 reg 1: DLL 0 - piref for IO[lb]11:6[rb][br]
                 reg 0: DLL 0 - piref for IO[lb]5:0[rb]
*/


#define DDRCC_PIREF_OFFSET0_1_MC_DDRIOMC_REG 0x0822A884

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 piref_train_pio_code : 7;

                            /* Bits[6:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               It is the train PI odd code to align the PIREF
                               odd clock to the failing edge of DCLK with data
                               propagation delay after xover training. [br]
                               This value is added with a signed
                               piref_setup_adj (default value is 63) to
                               generate the piref_pio_code to DLL. The xover
                               input is driven from a failing edge of DCLK
                               flop. [br] By moving the piref odd clock to the
                               right by 63 ticks, we will have 63 pi tick of
                               setup margin.[br] This field can be programed by
                               BIOS or HW cal FSM.
                            */
    UINT32 piref_pie_offset : 7;

                            /* Bits[13:7], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the piref_pio_code. The
                               result is the piref pi even code
                               (piref_pie_code) to DLL. Default value is 64.
                            */
    UINT32 cmd_piref_offset : 7;

                            /* Bits[20:14], Access Type=RW/V, default=0x00000000*/

                            /*
                               This cmd piref offset is added with a signed
                               piref_setup_adj (default value is 63). [br] The
                               result is added to each cmd_dly[6:0], so each
                               cmd pi odd code to the DLL is relative to the
                               piref odd clock.[br] This field can be programed
                               by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 3;

                            /* Bits[23:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 piref_setup_adj : 7;

                            /* Bits[30:24], Access Type=RW/V, default=0x0000003F*/

                            /*
                               A singed number for piref setup adjust. Range is
                               -64 to 63. [br] The xover input is driven from a
                               inverted DCLK flop. This conrol allows BIOS to
                               adjust the setup time to the input of the xover
                               piref odd clock flop. [br] Default value is 63.
                               [br] It means after xover training to align the
                               piref odd clock to the dclk. The piref odd clock
                               is moved to the right by 63 ticks, and we will
                               have 63 pi tick of setup margin. [br] HW will
                               add this value to all the pi codes before send
                               to DLL.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_PIREF_OFFSET0_1_MC_DDRIOMC_STRUCT;

/* DDRCC_PIREF_OFFSET0_2_MC_DDRIOMC_REG supported on:                           */
/*      SPRA0 (0x2001a888)                                                      */
/*      SPRB0 (0x2001a888)                                                      */
/*      SPRHBM (0x2001a888)                                                     */
/*      SPRC0 (0x2001a888)                                                      */
/*      SPRMCC (0x2001a888)                                                     */
/*      SPRUCC (0x2001a888)                                                     */
/* Register default value on SPRA0: 0x3F002000                                  */
/* Register default value on SPRB0: 0x3F002000                                  */
/* Register default value on SPRHBM: 0x3F002000                                 */
/* Register default value on SPRC0: 0x3F002000                                  */
/* Register default value on SPRMCC: 0x3F002000                                 */
/* Register default value on SPRUCC: 0x3F002000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* PIREF offset for PI N clocks[br]
                 reg 3: DLL 1 - piref for IO[lb]21:16[rb][br]
                 reg 2: DLL 1 - piref for IO[lb]15:12[rb][br]
                 reg 1: DLL 0 - piref for IO[lb]11:6[rb][br]
                 reg 0: DLL 0 - piref for IO[lb]5:0[rb]
*/


#define DDRCC_PIREF_OFFSET0_2_MC_DDRIOMC_REG 0x0822A888

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 piref_train_pio_code : 7;

                            /* Bits[6:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               It is the train PI odd code to align the PIREF
                               odd clock to the failing edge of DCLK with data
                               propagation delay after xover training. [br]
                               This value is added with a signed
                               piref_setup_adj (default value is 63) to
                               generate the piref_pio_code to DLL. The xover
                               input is driven from a failing edge of DCLK
                               flop. [br] By moving the piref odd clock to the
                               right by 63 ticks, we will have 63 pi tick of
                               setup margin.[br] This field can be programed by
                               BIOS or HW cal FSM.
                            */
    UINT32 piref_pie_offset : 7;

                            /* Bits[13:7], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the piref_pio_code. The
                               result is the piref pi even code
                               (piref_pie_code) to DLL. Default value is 64.
                            */
    UINT32 cmd_piref_offset : 7;

                            /* Bits[20:14], Access Type=RW/V, default=0x00000000*/

                            /*
                               This cmd piref offset is added with a signed
                               piref_setup_adj (default value is 63). [br] The
                               result is added to each cmd_dly[6:0], so each
                               cmd pi odd code to the DLL is relative to the
                               piref odd clock.[br] This field can be programed
                               by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 3;

                            /* Bits[23:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 piref_setup_adj : 7;

                            /* Bits[30:24], Access Type=RW/V, default=0x0000003F*/

                            /*
                               A singed number for piref setup adjust. Range is
                               -64 to 63. [br] The xover input is driven from a
                               inverted DCLK flop. This conrol allows BIOS to
                               adjust the setup time to the input of the xover
                               piref odd clock flop. [br] Default value is 63.
                               [br] It means after xover training to align the
                               piref odd clock to the dclk. The piref odd clock
                               is moved to the right by 63 ticks, and we will
                               have 63 pi tick of setup margin. [br] HW will
                               add this value to all the pi codes before send
                               to DLL.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_PIREF_OFFSET0_2_MC_DDRIOMC_STRUCT;

/* DDRCC_PIREF_OFFSET0_3_MC_DDRIOMC_REG supported on:                           */
/*      SPRA0 (0x2001a88c)                                                      */
/*      SPRB0 (0x2001a88c)                                                      */
/*      SPRHBM (0x2001a88c)                                                     */
/*      SPRC0 (0x2001a88c)                                                      */
/*      SPRMCC (0x2001a88c)                                                     */
/*      SPRUCC (0x2001a88c)                                                     */
/* Register default value on SPRA0: 0x3F002000                                  */
/* Register default value on SPRB0: 0x3F002000                                  */
/* Register default value on SPRHBM: 0x3F002000                                 */
/* Register default value on SPRC0: 0x3F002000                                  */
/* Register default value on SPRMCC: 0x3F002000                                 */
/* Register default value on SPRUCC: 0x3F002000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* PIREF offset for PI N clocks[br]
                 reg 3: DLL 1 - piref for IO[lb]21:16[rb][br]
                 reg 2: DLL 1 - piref for IO[lb]15:12[rb][br]
                 reg 1: DLL 0 - piref for IO[lb]11:6[rb][br]
                 reg 0: DLL 0 - piref for IO[lb]5:0[rb]
*/


#define DDRCC_PIREF_OFFSET0_3_MC_DDRIOMC_REG 0x0822A88C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 piref_train_pio_code : 7;

                            /* Bits[6:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               It is the train PI odd code to align the PIREF
                               odd clock to the failing edge of DCLK with data
                               propagation delay after xover training. [br]
                               This value is added with a signed
                               piref_setup_adj (default value is 63) to
                               generate the piref_pio_code to DLL. The xover
                               input is driven from a failing edge of DCLK
                               flop. [br] By moving the piref odd clock to the
                               right by 63 ticks, we will have 63 pi tick of
                               setup margin.[br] This field can be programed by
                               BIOS or HW cal FSM.
                            */
    UINT32 piref_pie_offset : 7;

                            /* Bits[13:7], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is added to the piref_pio_code. The
                               result is the piref pi even code
                               (piref_pie_code) to DLL. Default value is 64.
                            */
    UINT32 cmd_piref_offset : 7;

                            /* Bits[20:14], Access Type=RW/V, default=0x00000000*/

                            /*
                               This cmd piref offset is added with a signed
                               piref_setup_adj (default value is 63). [br] The
                               result is added to each cmd_dly[6:0], so each
                               cmd pi odd code to the DLL is relative to the
                               piref odd clock.[br] This field can be programed
                               by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 3;

                            /* Bits[23:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 piref_setup_adj : 7;

                            /* Bits[30:24], Access Type=RW/V, default=0x0000003F*/

                            /*
                               A singed number for piref setup adjust. Range is
                               -64 to 63. [br] The xover input is driven from a
                               inverted DCLK flop. This conrol allows BIOS to
                               adjust the setup time to the input of the xover
                               piref odd clock flop. [br] Default value is 63.
                               [br] It means after xover training to align the
                               piref odd clock to the dclk. The piref odd clock
                               is moved to the right by 63 ticks, and we will
                               have 63 pi tick of setup margin. [br] HW will
                               add this value to all the pi codes before send
                               to DLL.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_PIREF_OFFSET0_3_MC_DDRIOMC_STRUCT;

/* DDRCC_RX_CTL0_MC_DDRIOMC_REG supported on:                                   */
/*      SPRA0 (0x2001a890)                                                      */
/*      SPRB0 (0x2001a890)                                                      */
/*      SPRHBM (0x2001a890)                                                     */
/*      SPRC0 (0x2001a890)                                                      */
/*      SPRMCC (0x2001a890)                                                     */
/*      SPRUCC (0x2001a890)                                                     */
/* Register default value on SPRA0: 0x07C0900B                                  */
/* Register default value on SPRB0: 0x07C0900B                                  */
/* Register default value on SPRHBM: 0x07C0900B                                 */
/* Register default value on SPRC0: 0x07C09003                                  */
/* Register default value on SPRMCC: 0x07C09003                                 */
/* Register default value on SPRUCC: 0x07C09003                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* RX control 0 Register
*/


#define DDRCC_RX_CTL0_MC_DDRIOMC_REG 0x0822A890

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 odt_seg_en : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000003*/

                            /*
                               Control number of ODT segment enable for cmd
                               buf.
                            */
    UINT32 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rx_combiner_alert_mode : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000001*/

                            /*
                               Force the Rx amplifier combiner to a lower
                               static power state during Alert and DDR-T
                               modes,[br] which reduces FiSH temperatures and
                               helps RV.
                            */
    UINT32 rsvd_4 : 6;

                            /* Bits[9:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rx_path_ungate : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               SW set this bit to 1 to ungate the DDRIO to MC
                               RX data path.
                            */
    UINT32 rxgainfuse_ovrd : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Repurposed for force local receiver bias on for
                               DQbuf.[br] When set to 1, it will keep the local
                               bias mirror always enabled.[br] When set to 0,
                               local bias gets enabled with senseamp_enable.
                            */
    UINT32 rxbias_vcm_ctl : 2;

                            /* Bits[13:12], Access Type=RW, default=0x00000001*/

                            /*
                               Rx summer output common mode control[br] 0:
                               0.25*vccddra[br] 1: 0.3*vccddra (default)[br] 2:
                               0.35*vccddra[br] 3: 0.4*vccddra
                            */
    UINT32 rsvd_14 : 1;

                            /* Bits[14:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxbias_rxgain_ctl : 2;

                            /* Bits[16:15], Access Type=RW, default=0x00000001*/

                            /*
                               00 1.5x (default for CMD/CLK)[br] 01 2x[br] 10 -
                               2.5x (default for DQ)[br] 11 3x
                            */
    UINT32 rsvd_17 : 5;

                            /* Bits[21:17], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 odt_static_leg_cfg : 5;

                            /* Bits[26:22], Access Type=RW, default=0x0000001F*/

                            /*
                               Sets number of ODT static legs. First 3 MSB bits
                               has weight of 4, 4th MSB has weight of 2 and LSB
                               bit has weight of 1. [br] Default of 0x1F has 15
                               static legs enabled.[br] Static leg training
                               starts with 0x1F (all 15 legs enabled)
                            */
    UINT32 rsvd_27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_RX_CTL0_MC_DDRIOMC_STRUCT;

/* DDRCC_RX_CTL1_MC_DDRIOMC_REG supported on:                                   */
/*      SPRA0 (0x2001a894)                                                      */
/*      SPRB0 (0x2001a894)                                                      */
/*      SPRHBM (0x2001a894)                                                     */
/*      SPRC0 (0x2001a894)                                                      */
/*      SPRMCC (0x2001a894)                                                     */
/*      SPRUCC (0x2001a894)                                                     */
/* Register default value on SPRA0: 0x00000040                                  */
/* Register default value on SPRB0: 0x00000040                                  */
/* Register default value on SPRHBM: 0x00000040                                 */
/* Register default value on SPRC0: 0x00000040                                  */
/* Register default value on SPRMCC: 0x00000040                                 */
/* Register default value on SPRUCC: 0x00000040                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* RX control 1 Register
*/


#define DDRCC_RX_CTL1_MC_DDRIOMC_REG 0x0822A894

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 6;

                            /* Bits[5:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rx_offset_en : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /* enable offset control in cmd buf and RX BIAS */
    UINT32 rsvd_7 : 22;

                            /* Bits[28:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_RX_CTL1_MC_DDRIOMC_STRUCT;

/* DDRCC_TX_CTL0_MC_DDRIOMC_REG supported on:                                   */
/*      SPRA0 (0x2001a89c)                                                      */
/*      SPRB0 (0x2001a89c)                                                      */
/*      SPRHBM (0x2001a89c)                                                     */
/*      SPRC0 (0x2001a89c)                                                      */
/*      SPRMCC (0x2001a89c)                                                     */
/*      SPRUCC (0x2001a89c)                                                     */
/* Register default value on SPRA0: 0x800000DF                                  */
/* Register default value on SPRB0: 0x800000DF                                  */
/* Register default value on SPRHBM: 0x800000DF                                 */
/* Register default value on SPRC0: 0x800000DF                                  */
/* Register default value on SPRMCC: 0x800000DF                                 */
/* Register default value on SPRUCC: 0x800000DF                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* TX control 0 Register
*/


#define DDRCC_TX_CTL0_MC_DDRIOMC_REG 0x0822A89C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 drv_static_leg_cfg : 5;

                            /* Bits[4:0], Access Type=RW, default=0x0000001F*/

                            /*
                               Sets number of CmdCtl driver (Ron) static legs.
                               [br] First 3 MSB bits has weight of 4, 4th MSB
                               has weight of 2 and LSB bit has weight of 1.
                               [br] Hardware default of 0x1F has 15 static legs
                               enabled. [br] Static leg training starts with
                               0x1F (all 15 legs enabled)
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 data_seg_en : 2;

                            /* Bits[7:6], Access Type=RW, default=0x00000003*/

                            /*
                               Control number of drive segment enable for CMD
                               buf. Also, it is used by COMP to TXEQ logic to
                               generate the EQCODE.
                            */
    UINT32 rsvd_8 : 2;

                            /* Bits[9:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cs_imode_en : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               CS Enable Imode EQ per byte lane. [br] 0: Imode
                               completely off [br] 1: Imode enabled (Xtalk
                               cancellation OR swing boost selected by ImodeCfg
                            */
    UINT32 ca_imode_en : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               CA Enable Imode EQ per byte lane. [br] 0: Imode
                               completely off [br] 1: Imode enabled (Xtalk
                               cancellation OR swing boost selected by ImodeCfg
                            */
    UINT32 cs_eq_post2_sign : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               CS 2nd tap equalization sign bit[br] 0: +ve
                               equalization[br] 1: -ve equalization
                            */
    UINT32 ca_eq_post2_sign : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               CA 2nd tap equalization sign bit[br] 0: +ve
                               equalization[br] 1: -ve equalization
                            */
    UINT32 cs_eq_post2_sel : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               CS 2nd tap selection:[br] 0 txeq_2nd_tap used
                               for 2nd post cursor tap[br] 1 txeq_2nd_tap used
                               for extending range of 1st tap.
                            */
    UINT32 ca_eq_post2_sel : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               CA 2nd tap selection:[br] 0 txeq_2nd_tap used
                               for 2nd post cursor tap[br] 1 txeq_2nd_tap used
                               for extending range of 1st tap.
                            */
    UINT32 cs_imode_eq_code : 6;

                            /* Bits[21:16], Access Type=RW, default=0x00000000*/

                            /*
                               CS Binary Imode Coefficient, sets Imode current
                               strength.[br] (used for either Xtalk
                               cancellation or swing boost)[br] Imode
                               coefficient, sets Imode current. Sweep values:
                               (0-15, 40-42, 48-63) for a linear increase of
                               current from 0 to max.
                            */
    UINT32 rsvd_22 : 1;

                            /* Bits[22:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ca_imode_eq_code : 6;

                            /* Bits[28:23], Access Type=RW, default=0x00000000*/

                            /*
                               CA Binary Imode Coefficient, sets Imode current
                               strength.[br] (used for either Xtalk
                               cancellation or swing boost)[br] Imode
                               coefficient, sets Imode current. Sweep values:
                               (0-15, 40-42, 48-63) for a linear increase of
                               current from 0 to max.
                            */
    UINT32 rsvd_29 : 1;

                            /* Bits[29:29], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_serializer_pwradj : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to extend the pulse width of the pulsed
                               clocks to the Tx serializers.[br] No need skew
                               based settings, value of 1 seems to work across
                               PVT.[br] May need to set to 0 for slow silicon
                               if we see issues in post silicon.
                            */
    UINT32 scomp_tco_bypass_dis : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               0 : CMD BUF bypass SCOMP and TCO delay in the
                               transmitter.
                            */

  } Bits;
  UINT32 Data;

} DDRCC_TX_CTL0_MC_DDRIOMC_STRUCT;

/* DDRCC_TX_CTL1_MC_DDRIOMC_REG supported on:                                   */
/*      SPRA0 (0x2001a8a0)                                                      */
/*      SPRB0 (0x2001a8a0)                                                      */
/*      SPRHBM (0x2001a8a0)                                                     */
/*      SPRC0 (0x2001a8a0)                                                      */
/*      SPRMCC (0x2001a8a0)                                                     */
/*      SPRUCC (0x2001a8a0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* TX control 1 Register
*/


#define DDRCC_TX_CTL1_MC_DDRIOMC_REG 0x0822A8A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 io_dir_valid : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set by BIOS to indicate the io_dir control field
                               is valid.[br] - if this bit is not set, force
                               the receive data to 0[br] - it is used by the
                               command buf CBB to latch the io_pwrdn_pull_low
                               siganl when set to 1 by BIOS. That sequential is
                               power by always on power (s3localvcc), so when
                               analog power is down, the buf use it to
                               determine to either pull low or tri-state the
                               IO.
                            */
    UINT32 cs_txeq_1st_tap : 6;

                            /* Bits[6:1], Access Type=RW, default=0x00000000*/

                            /*
                               CS TxEQ 1st tap coefficient.The following list
                               all the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_1st_tap: 0,1,2,3,4,5,6,
                               7,12,13,14,15,28,29,30,31,60,61,62,63
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ca_txeq_1st_tap : 6;

                            /* Bits[13:8], Access Type=RW, default=0x00000000*/

                            /*
                               CA TxEQ 1st tap coefficient.The following list
                               all the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_1st_tap: 0,1,2,3,4,5,6,
                               7,12,13,14,15,28,29,30,31,60,61,62,63
                            */
    UINT32 rsvd_14 : 1;

                            /* Bits[14:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cs_txeq_2nd_tap : 4;

                            /* Bits[18:15], Access Type=RW, default=0x00000000*/

                            /*
                               CS TxEQ 2nd tap coefficient.The following list
                               all the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_2nd_tap:
                               0,1,2,3,4,5,6,7,12,13,14,15
                            */
    UINT32 rsvd_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ca_txeq_2nd_tap : 4;

                            /* Bits[23:20], Access Type=RW, default=0x00000000*/

                            /*
                               CA TxEQ 2nd tap coefficient.The following list
                               all the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_2nd_tap:
                               0,1,2,3,4,5,6,7,12,13,14,15
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_TX_CTL1_MC_DDRIOMC_STRUCT;

/* DDRCC_DFX_CTL0_MC_DDRIOMC_REG supported on:                                  */
/*      SPRA0 (0x2001a8a8)                                                      */
/*      SPRB0 (0x2001a8a8)                                                      */
/*      SPRHBM (0x2001a8a8)                                                     */
/*      SPRC0 (0x2001a8a8)                                                      */
/*      SPRMCC (0x2001a8a8)                                                     */
/*      SPRUCC (0x2001a8a8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* DFX Control 0 Register
*/


#define DDRCC_DFX_CTL0_MC_DDRIOMC_REG 0x0822A8A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd_0 : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tmr_test_mode : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Simulation-only control to shorten VSSHI and LDO
                               timers
                            */
    UINT32 sr_vref_dis : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               0 - No Vref power saving in Self Refresh. The
                               cmd Vref generators is enabled by
                               rx_vref_en.[br] 1 - The cmd Vref generators are
                               switched off while in Self Refresh regardless
                               the setting of rx_vref_en.
                            */
    UINT32 ckepd_vref_dis : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               0 - No Vref power saving in CKE power down. All
                               CMDCTL Vref generators is enabled by
                               rx_vref_en.[br] 1 - CMDCTL Vref generators are
                               switched off while in CKE power down regardless
                               the setting of rx_vref_en.
                            */
    UINT32 rsvd_6 : 4;

                            /* Bits[9:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rx_voc_pass_gate_en : 22;

                            /* Bits[31:10], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit VOC RX pass gate enable for VOC training
                               and NTL testing.
                            */

  } Bits;
  UINT32 Data;

} DDRCC_DFX_CTL0_MC_DDRIOMC_STRUCT;

/* DDRCC_HW_TRAIN_CTL0_MC_DDRIOMC_REG supported on:                             */
/*      SPRA0 (0x2001a8ac)                                                      */
/*      SPRB0 (0x2001a8ac)                                                      */
/*      SPRHBM (0x2001a8ac)                                                     */
/*      SPRC0 (0x2001a8ac)                                                      */
/*      SPRMCC (0x2001a8ac)                                                     */
/*      SPRUCC (0x2001a8ac)                                                     */
/* Register default value on SPRA0: 0x00002000                                  */
/* Register default value on SPRB0: 0x00002000                                  */
/* Register default value on SPRHBM: 0x00002000                                 */
/* Register default value on SPRC0: 0x00002000                                  */
/* Register default value on SPRMCC: 0x00002000                                 */
/* Register default value on SPRUCC: 0x00002000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* HW Training Control 0 Register
*/


#define DDRCC_HW_TRAIN_CTL0_MC_DDRIOMC_REG 0x0822A8AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 xover_stage_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Set to 1 to enable xover training stage */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_summer_offset_stage_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable DFE summer offset training
                               stage for all bits.
                            */
    UINT32 rsvd_3 : 2;

                            /* Bits[4:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd_5 : 2;

                            /* Bits[6:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 settling_time_x2 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to double the analog settling time.
                               [br] The default settling time for each stage
                               are [br] Xover : 32 Dclk for first iteration, 24
                               Dclk for subsequent [br] DFE summer offset : 24
                               Dclk [br] Txpiclk : 24 Dclk [br] Loop Delay: 8
                               Dclk
                            */
    UINT32 sample_cnt : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000000*/

                            /*
                               Number of Sample to evaluate for each iteration
                               step. It applied for all training stages. [br]
                               0: 16[br] 1: 32[br] 2: 64[br] 3: 2 (Should only
                               used to speed up digital simulation)
                            */
    UINT32 sample_thresh : 6;

                            /* Bits[15:10], Access Type=RW, default=0x00000008*/

                            /* Sample threshold value for voting logic. */
    UINT32 rsvd_16 : 2;

                            /* Bits[17:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd_18 : 10;

                            /* Bits[27:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 hw_cal_en : 4;

                            /* Bits[31:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               HW calibation enable control per FSM (cmd has
                               4). Set to 1 to enable the HW calibration. [br]
                               They are 4 HW calibration stages that SW can
                               request HW to perform. It is defined in bit 0 to
                               4 in this register. [br] HW cal FSM will self
                               clear this bit when all the enabled calibration
                               stages are completed. [br] For BIOS training,
                               XOVER, sampler offset, and DFE summer offset
                               training can be enabled by SW.[br] For ACIO
                               testing, all 4 stages can be enabled by SW.
                            */

  } Bits;
  UINT32 Data;

} DDRCC_HW_TRAIN_CTL0_MC_DDRIOMC_STRUCT;

/* DDRCC_HWCAL_STS0_0_MC_DDRIOMC_REG supported on:                              */
/*      SPRA0 (0x2001a8b0)                                                      */
/*      SPRB0 (0x2001a8b0)                                                      */
/*      SPRHBM (0x2001a8b0)                                                     */
/*      SPRC0 (0x2001a8b0)                                                      */
/*      SPRMCC (0x2001a8b0)                                                     */
/*      SPRUCC (0x2001a8b0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* HW calibration status 0 Register[br]
                 reg 3: DLL 1 - piref for IO[lb]21:16[rb][br]
                 reg 2: DLL 1 - piref for IO[lb]15:12[rb][br]
                 reg 1: DLL 0 - piref for IO[lb]11:6[rb][br]
                 reg 0: DLL 0 - piref for IO[lb]5:0[rb]
*/


#define DDRCC_HWCAL_STS0_0_MC_DDRIOMC_REG 0x0822A8B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 xover_err : 1;

                            /* Bits[0:0], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Set to 1 by HW to indicate xover training is
                               failed. SW must clear this bit to 0 when enable
                               HW calibration.
                            */
    UINT32 dfe_summer_offset_err : 1;

                            /* Bits[1:1], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Set to 1 by HW to indicate dfe summer offset
                               training is failed for any bit within this piref
                               group. SW must clear this bit to 0 when enable
                               HW calibration.
                            */
    UINT32 rsvd_2 : 14;

                            /* Bits[15:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_HWCAL_STS0_0_MC_DDRIOMC_STRUCT;

/* DDRCC_HWCAL_STS0_1_MC_DDRIOMC_REG supported on:                              */
/*      SPRA0 (0x2001a8b4)                                                      */
/*      SPRB0 (0x2001a8b4)                                                      */
/*      SPRHBM (0x2001a8b4)                                                     */
/*      SPRC0 (0x2001a8b4)                                                      */
/*      SPRMCC (0x2001a8b4)                                                     */
/*      SPRUCC (0x2001a8b4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* HW calibration status 0 Register[br]
                 reg 3: DLL 1 - piref for IO[lb]21:16[rb][br]
                 reg 2: DLL 1 - piref for IO[lb]15:12[rb][br]
                 reg 1: DLL 0 - piref for IO[lb]11:6[rb][br]
                 reg 0: DLL 0 - piref for IO[lb]5:0[rb]
*/


#define DDRCC_HWCAL_STS0_1_MC_DDRIOMC_REG 0x0822A8B4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 xover_err : 1;

                            /* Bits[0:0], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Set to 1 by HW to indicate xover training is
                               failed. SW must clear this bit to 0 when enable
                               HW calibration.
                            */
    UINT32 dfe_summer_offset_err : 1;

                            /* Bits[1:1], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Set to 1 by HW to indicate dfe summer offset
                               training is failed for any bit within this piref
                               group. SW must clear this bit to 0 when enable
                               HW calibration.
                            */
    UINT32 rsvd_2 : 14;

                            /* Bits[15:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_HWCAL_STS0_1_MC_DDRIOMC_STRUCT;

/* DDRCC_HWCAL_STS0_2_MC_DDRIOMC_REG supported on:                              */
/*      SPRA0 (0x2001a8b8)                                                      */
/*      SPRB0 (0x2001a8b8)                                                      */
/*      SPRHBM (0x2001a8b8)                                                     */
/*      SPRC0 (0x2001a8b8)                                                      */
/*      SPRMCC (0x2001a8b8)                                                     */
/*      SPRUCC (0x2001a8b8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* HW calibration status 0 Register[br]
                 reg 3: DLL 1 - piref for IO[lb]21:16[rb][br]
                 reg 2: DLL 1 - piref for IO[lb]15:12[rb][br]
                 reg 1: DLL 0 - piref for IO[lb]11:6[rb][br]
                 reg 0: DLL 0 - piref for IO[lb]5:0[rb]
*/


#define DDRCC_HWCAL_STS0_2_MC_DDRIOMC_REG 0x0822A8B8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 xover_err : 1;

                            /* Bits[0:0], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Set to 1 by HW to indicate xover training is
                               failed. SW must clear this bit to 0 when enable
                               HW calibration.
                            */
    UINT32 dfe_summer_offset_err : 1;

                            /* Bits[1:1], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Set to 1 by HW to indicate dfe summer offset
                               training is failed for any bit within this piref
                               group. SW must clear this bit to 0 when enable
                               HW calibration.
                            */
    UINT32 rsvd_2 : 14;

                            /* Bits[15:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_HWCAL_STS0_2_MC_DDRIOMC_STRUCT;

/* DDRCC_HWCAL_STS0_3_MC_DDRIOMC_REG supported on:                              */
/*      SPRA0 (0x2001a8bc)                                                      */
/*      SPRB0 (0x2001a8bc)                                                      */
/*      SPRHBM (0x2001a8bc)                                                     */
/*      SPRC0 (0x2001a8bc)                                                      */
/*      SPRMCC (0x2001a8bc)                                                     */
/*      SPRUCC (0x2001a8bc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* HW calibration status 0 Register[br]
                 reg 3: DLL 1 - piref for IO[lb]21:16[rb][br]
                 reg 2: DLL 1 - piref for IO[lb]15:12[rb][br]
                 reg 1: DLL 0 - piref for IO[lb]11:6[rb][br]
                 reg 0: DLL 0 - piref for IO[lb]5:0[rb]
*/


#define DDRCC_HWCAL_STS0_3_MC_DDRIOMC_REG 0x0822A8BC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 xover_err : 1;

                            /* Bits[0:0], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Set to 1 by HW to indicate xover training is
                               failed. SW must clear this bit to 0 when enable
                               HW calibration.
                            */
    UINT32 dfe_summer_offset_err : 1;

                            /* Bits[1:1], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Set to 1 by HW to indicate dfe summer offset
                               training is failed for any bit within this piref
                               group. SW must clear this bit to 0 when enable
                               HW calibration.
                            */
    UINT32 rsvd_2 : 14;

                            /* Bits[15:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_HWCAL_STS0_3_MC_DDRIOMC_STRUCT;





/* DDRCC_TRAIN_CTL1_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a8d4)                                                      */
/*      SPRB0 (0x2001a8d4)                                                      */
/*      SPRHBM (0x2001a8d4)                                                     */
/*      SPRC0 (0x2001a8d4)                                                      */
/*      SPRMCC (0x2001a8d4)                                                     */
/*      SPRUCC (0x2001a8d4)                                                     */
/* Register default value on SPRA0: 0x18000000                                  */
/* Register default value on SPRB0: 0x18000000                                  */
/* Register default value on SPRHBM: 0x18000000                                 */
/* Register default value on SPRC0: 0x18000000                                  */
/* Register default value on SPRMCC: 0x18000000                                 */
/* Register default value on SPRUCC: 0x18000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Train Control 1 Register
*/


#define DDRCC_TRAIN_CTL1_MC_DDRIOMC_REG 0x0822A8D4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_train_ctr_en : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enables the Command Training Counter mode
                               (receivers, ODT needs to be enabled separately
                               before setting this bit), resets the sample
                               counter and starts the counting of the samples.
                               One of these per nibble that is used for
                               feedback (i.e. all DQ nibble and the fub with
                               the ALERT_n feedback. DQ nibbles can be set with
                               broadcast). The value of this field remains at 1
                               until after the Counting Window expires, then
                               returns to 0. Can be polled to determine when
                               the counting has completed. When the Counting
                               Window field is set to 0, this field will not
                               return to 0. In that case, this field must be
                               set to 0 to disable.[br] When the CS Assertion
                               Trigger Enable is set, the counting window start
                               is delayed until the first CS Assertion event
                               but this delay only applies for the ALERT_n,
                               RSP_A, and RSP_B signals. This does not apply to
                               the DQ counters.
                            */
    UINT32 ddrt2_req_train_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Set to 1 to enable DDR-T2 Request training */
    UINT32 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rx_path_fb_en : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable sample path and unsample path
                               feedback results. [br] Note: It is used for SW
                               SA training and SW ACIO txpiclk training.
                            */
    UINT32 xover_cal : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit to 1 will prepare data fub in a
                               state to allow BIOS only to perform Xover
                               calibraton training. - enable all the DCLK And
                               PI clocks. (may remove clock gating function)
                            */
    UINT32 vref_highz : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Tri-state the vref_hv output. Set to 1 for NTL
                               and Rx Summer Offset Cal.
                            */
    UINT32 rsvd_7 : 5;

                            /* Bits[11:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddr4 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               For SPR, 2 Channel DDR-MC sub-system. It can
                               either operate in DDR4/DDR-T or DDR5/DDR-T2. It
                               doesn't support DDR4/DDR-T mix with
                               DDR5/DDR-T2.[br] Setting this bit to 1 indicate
                               it is operating in DDR4/DDR-T. 0 inidate it is
                               operating in DDR5/DDR-T2.
                            */
    UINT32 rsvd_13 : 1;

                            /* Bits[13:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 compeff_clk_gate_en : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate effective register
                               update CLK for power saving. Default is disable
                               clock gating.[br] Note: Clock gating must be
                               disable during any training steps. BIOS can
                               enable clock gating for power saving after all
                               the training steps are done.
                            */
    UINT32 bclk_gate_en : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable BCLK gating for Burnin/ADC
                               counter and DLL lock timer for power saving.
                            */
    UINT32 rsvd_16 : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pi_clk_gate_en : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate all PI N clocks
                               for power saving. Default is disable clock
                               gating. [br] Note: Clock gating must be disable
                               during any training steps. BIOS can enable clock
                               gating for power saving after all the training
                               steps are done.
                            */
    UINT32 piref_clk_gate_en : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate PI REF clock for
                               power saving. Default is disable clock gating.
                               [br] Note: Clock gating must be disable during
                               any training steps. BIOS can enable clock gating
                               for power saving after all the training steps
                               are done.
                            */
    UINT32 tx_clk_gate_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate TX CLK for
                               transmit path logics. Default is disable clock
                               gating.[br] Note: Clock gating must be disable
                               during any training steps. BIOS can enable clock
                               gating for power saving after all the training
                               steps are done.
                            */
    UINT32 rx_clk_gate_en : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate RX CLK for receive
                               path logics. Default is disable clock gating.
                               [br] Note: Clock gating must be disable during
                               any training steps. BIOS can enable clock gating
                               for power saving after all the training steps
                               are done.
                            */
    UINT32 train_clk_gate_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate CLK for training
                               related logic (BIOS or HW training logics).
                               Default is disable clock gating. [br] Note:
                               Clock gating must be disable during any training
                               steps. BIOS can enable clock gating for power
                               saving after all the training steps are done.
                            */
    UINT32 csr_clk_gate_en : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate CSR CLK. Default
                               is disable clock gating. [br] Note: Clock gating
                               must be disable during any training steps. BIOS
                               can enable clock gating for power saving after
                               all the training steps are done.
                            */
    UINT32 rsvd_23 : 2;

                            /* Bits[24:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 force_strong_odt_on : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Force all the CMD IO strong ODT on. When set, it
                               always enable one segment for ODT regardless of
                               the state of drive enable. [br] The intend use
                               case is for ACIO with burnin
                            */
    UINT32 force_txon : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /* Forces all the CMD transmitter driver on. */
    UINT32 force_odt_on : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000001*/

                            /*
                               Force all the CMD IO weak ODT on. The weak ODT
                               is ignored when drive enable is asserted. [br]
                               Note: For ACIO, ODT is provided by different DDR
                               channel.
                            */
    UINT32 force_rxbias_on : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000001*/

                            /* Force Rx Bias and Rx Bias Vref On */
    UINT32 force_sa_on : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Force Senseamp on. Use for overclocking support
                               where we may not be able to hit the fast exit
                               latency.
                            */
    UINT32 rx_vref_en : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               Per Vref control to enable RX Vref.[br] Bit 0:
                               signal index 0-11 [br] Bit 1: signal index 12-21
                            */

  } Bits;
  UINT32 Data;

} DDRCC_TRAIN_CTL1_MC_DDRIOMC_STRUCT;

/* DDRCC_TRAIN_CTL2_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a8d8)                                                      */
/*      SPRB0 (0x2001a8d8)                                                      */
/*      SPRHBM (0x2001a8d8)                                                     */
/*      SPRC0 (0x2001a8d8)                                                      */
/*      SPRMCC (0x2001a8d8)                                                     */
/*      SPRUCC (0x2001a8d8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Train Control 2 Register
*/


#define DDRCC_TRAIN_CTL2_MC_DDRIOMC_REG 0x0822A8D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 train_cnt_io_sel0 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Select which IO to count during DCS and DCA
                               training. The count result is stored in
                               ddr_train_cnt_result0 register 0.[br] Note: The
                               current supporting mode is counting only ALERT_n
                               or counting on both RSP_A and RSP_B signals.
                            */
    UINT32 train_cnt_io_sel1 : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000000*/

                            /*
                               Select which IO to count during DCS and DCA
                               training. The count result is stored in
                               ddr_train_cnt_result0 register 1.[br] Note: The
                               current supporting mode is counting only ALERT_n
                               or counting on both RSP_A and RSP_B signals.
                            */
    UINT32 csa_trigger_en : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, the counting window does not
                               start until the first CS assertion (any CS
                               assertion). This trigger only applies for the
                               counters associated with the ALERT_n, RSP_A, and
                               RSP_B signals. This does not apply to the DQ
                               counters.
                            */
    UINT32 sample_sel : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Determines if the command training counter will
                               count 1 or 0.[br] 0: count 1[br] 1: count 0
                            */
    UINT32 dll0_top_xover_cal_mux_sel : 5;

                            /* Bits[16:12], Access Type=RW, default=0x00000000*/

                            /*
                               Select which xover phase detect output for DLL0
                               Top piref calibration. Legal value is 0 to 17.
                            */
    UINT32 dll0_bot_xover_cal_mux_sel : 5;

                            /* Bits[21:17], Access Type=RW, default=0x00000000*/

                            /*
                               Select which xover phase detect output for DLL0
                               Bottom piref calibration. Legal value is 0 to
                               17.
                            */
    UINT32 dll1_top_xover_cal_mux_sel : 5;

                            /* Bits[26:22], Access Type=RW, default=0x00000000*/

                            /*
                               Select which xover phase detect output for DLL1
                               Top piref calibration. Legal value is 0 to 11.
                            */
    UINT32 dll1_bot_xover_cal_mux_sel : 5;

                            /* Bits[31:27], Access Type=RW, default=0x00000000*/

                            /*
                               Select which xover phase detect output for DLL1
                               Bottom piref calibration. Legal value is 0 to
                               17.
                            */

  } Bits;
  UINT32 Data;

} DDRCC_TRAIN_CTL2_MC_DDRIOMC_STRUCT;

/* DDRCC_TRAIN_CNT_WINDOW0_MC_DDRIOMC_REG supported on:                         */
/*      SPRA0 (0x2001a8dc)                                                      */
/*      SPRB0 (0x2001a8dc)                                                      */
/*      SPRHBM (0x2001a8dc)                                                     */
/*      SPRC0 (0x2001a8dc)                                                      */
/*      SPRMCC (0x2001a8dc)                                                     */
/*      SPRUCC (0x2001a8dc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Training Counting Window 0 Register
*/


#define DDRCC_TRAIN_CNT_WINDOW0_MC_DDRIOMC_REG 0x0822A8DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cnt_window : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               value that sets the number of DCLK cycles that
                               the selected CMDCTL input samples will be
                               counted. Linear setting. This is broadcast to
                               all the CMDCTL fub. When this field is set to 0
                               the counter will run until it saturates, or
                               until it the CMD Training Counter Mode field is
                               cleared.
                            */

  } Bits;
  UINT32 Data;

} DDRCC_TRAIN_CNT_WINDOW0_MC_DDRIOMC_STRUCT;

/* DDRCC_TRAIN_CNT_RESULT_0_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001a8e0)                                                      */
/*      SPRB0 (0x2001a8e0)                                                      */
/*      SPRHBM (0x2001a8e0)                                                     */
/*      SPRC0 (0x2001a8e0)                                                      */
/*      SPRMCC (0x2001a8e0)                                                     */
/*      SPRUCC (0x2001a8e0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Sample counter result for CMD Training Counter Mode
*/


#define DDRCC_TRAIN_CNT_RESULT_0_MC_DDRIOMC_REG 0x0822A8E0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 train_cnt : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Value that indicates the number of logic 1 or 0
                               values sampled during the Counting Window (based
                               on sample_sel). This is cleared when the CMD
                               Training Counter mode is enabled.. Whten the
                               cnt_window is set to 0, the counter will run
                               until it saturates.
                            */

  } Bits;
  UINT32 Data;

} DDRCC_TRAIN_CNT_RESULT_0_MC_DDRIOMC_STRUCT;

/* DDRCC_TRAIN_CNT_RESULT_1_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001a8e4)                                                      */
/*      SPRB0 (0x2001a8e4)                                                      */
/*      SPRHBM (0x2001a8e4)                                                     */
/*      SPRC0 (0x2001a8e4)                                                      */
/*      SPRMCC (0x2001a8e4)                                                     */
/*      SPRUCC (0x2001a8e4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Sample counter result for CMD Training Counter Mode
*/


#define DDRCC_TRAIN_CNT_RESULT_1_MC_DDRIOMC_REG 0x0822A8E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 train_cnt : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Value that indicates the number of logic 1 or 0
                               values sampled during the Counting Window (based
                               on sample_sel). This is cleared when the CMD
                               Training Counter mode is enabled.. Whten the
                               cnt_window is set to 0, the counter will run
                               until it saturates.
                            */

  } Bits;
  UINT32 Data;

} DDRCC_TRAIN_CNT_RESULT_1_MC_DDRIOMC_STRUCT;

/* DDRCC_TRAIN_RESULT0_MC_DDRIOMC_REG supported on:                             */
/*      SPRA0 (0x2001a8e8)                                                      */
/*      SPRB0 (0x2001a8e8)                                                      */
/*      SPRHBM (0x2001a8e8)                                                     */
/*      SPRC0 (0x2001a8e8)                                                      */
/*      SPRMCC (0x2001a8e8)                                                     */
/*      SPRUCC (0x2001a8e8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Training Result 0 Register
*/


#define DDRCC_TRAIN_RESULT0_MC_DDRIOMC_REG 0x0822A8E8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 xover_cal_pd_result : 4;

                            /* Bits[3:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Xover Calibration Phase Detected Result[br] Bit
                               3 : DLL 1 - piref for IO[lb]21:16[rb][br] Bit 2
                               : DLL 1 - piref for IO[lb]15:12[rb][br] Bit 1 :
                               DLL 0 - piref for IO[lb]11:6[rb][br] Bit 0 : DLL
                               0 - piref for IO[lb]5:0[rb]
                            */
    UINT32 sa_train_result : 22;

                            /* Bits[25:4], Access Type=RO/V, default=0x00000000*/

                            /*
                               Per bit senseamp train result[br] Note: SW must
                               set the ddrcc_train_ctl1.rx_path_fb_en to 1
                               before reading this fields.
                            */
    UINT32 rsvd : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_TRAIN_RESULT0_MC_DDRIOMC_STRUCT;

/* DDRCC_TRAIN_RESULT1_MC_DDRIOMC_REG supported on:                             */
/*      SPRA0 (0x2001a8ec)                                                      */
/*      SPRB0 (0x2001a8ec)                                                      */
/*      SPRHBM (0x2001a8ec)                                                     */
/*      SPRC0 (0x2001a8ec)                                                      */
/*      SPRMCC (0x2001a8ec)                                                     */
/*      SPRUCC (0x2001a8ec)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc0_type/ddrcc0_ch0/ddrcc0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Training Result 1 Register
*/


#define DDRCC_TRAIN_RESULT1_MC_DDRIOMC_REG 0x0822A8EC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rx_even_sample_path_fb : 22;

                            /* Bits[21:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               RX even sample path feedback. It is used in SW
                               ACIO loopback txpiclk stage training. [br] Note:
                               SW must set the ddrcc_train_ctl1.rx_path_fb_en
                               to 1 before reading this fields.
                            */
    UINT32 rsvd : 10;

                            /* Bits[31:22], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_TRAIN_RESULT1_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_0_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a900)                                                      */
/*      SPRB0 (0x2001a900)                                                      */
/*      SPRHBM (0x2001a900)                                                     */
/*      SPRC0 (0x2001a900)                                                      */
/*      SPRMCC (0x2001a900)                                                     */
/*      SPRUCC (0x2001a900)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_0_MC_DDRIOMC_REG 0x0822A900

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_0_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_1_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a904)                                                      */
/*      SPRB0 (0x2001a904)                                                      */
/*      SPRHBM (0x2001a904)                                                     */
/*      SPRC0 (0x2001a904)                                                      */
/*      SPRMCC (0x2001a904)                                                     */
/*      SPRUCC (0x2001a904)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_1_MC_DDRIOMC_REG 0x0822A904

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_1_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_2_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a908)                                                      */
/*      SPRB0 (0x2001a908)                                                      */
/*      SPRHBM (0x2001a908)                                                     */
/*      SPRC0 (0x2001a908)                                                      */
/*      SPRMCC (0x2001a908)                                                     */
/*      SPRUCC (0x2001a908)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_2_MC_DDRIOMC_REG 0x0822A908

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_2_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_3_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a90c)                                                      */
/*      SPRB0 (0x2001a90c)                                                      */
/*      SPRHBM (0x2001a90c)                                                     */
/*      SPRC0 (0x2001a90c)                                                      */
/*      SPRMCC (0x2001a90c)                                                     */
/*      SPRUCC (0x2001a90c)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_3_MC_DDRIOMC_REG 0x0822A90C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_3_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_4_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a910)                                                      */
/*      SPRB0 (0x2001a910)                                                      */
/*      SPRHBM (0x2001a910)                                                     */
/*      SPRC0 (0x2001a910)                                                      */
/*      SPRMCC (0x2001a910)                                                     */
/*      SPRUCC (0x2001a910)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_4_MC_DDRIOMC_REG 0x0822A910

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_4_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_5_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a914)                                                      */
/*      SPRB0 (0x2001a914)                                                      */
/*      SPRHBM (0x2001a914)                                                     */
/*      SPRC0 (0x2001a914)                                                      */
/*      SPRMCC (0x2001a914)                                                     */
/*      SPRUCC (0x2001a914)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_5_MC_DDRIOMC_REG 0x0822A914

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_5_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_6_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a918)                                                      */
/*      SPRB0 (0x2001a918)                                                      */
/*      SPRHBM (0x2001a918)                                                     */
/*      SPRC0 (0x2001a918)                                                      */
/*      SPRMCC (0x2001a918)                                                     */
/*      SPRUCC (0x2001a918)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_6_MC_DDRIOMC_REG 0x0822A918

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_6_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_7_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a91c)                                                      */
/*      SPRB0 (0x2001a91c)                                                      */
/*      SPRHBM (0x2001a91c)                                                     */
/*      SPRC0 (0x2001a91c)                                                      */
/*      SPRMCC (0x2001a91c)                                                     */
/*      SPRUCC (0x2001a91c)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_7_MC_DDRIOMC_REG 0x0822A91C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_7_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_8_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a920)                                                      */
/*      SPRB0 (0x2001a920)                                                      */
/*      SPRHBM (0x2001a920)                                                     */
/*      SPRC0 (0x2001a920)                                                      */
/*      SPRMCC (0x2001a920)                                                     */
/*      SPRUCC (0x2001a920)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_8_MC_DDRIOMC_REG 0x0822A920

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_8_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_9_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001a924)                                                      */
/*      SPRB0 (0x2001a924)                                                      */
/*      SPRHBM (0x2001a924)                                                     */
/*      SPRC0 (0x2001a924)                                                      */
/*      SPRMCC (0x2001a924)                                                     */
/*      SPRUCC (0x2001a924)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_9_MC_DDRIOMC_REG 0x0822A924

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_9_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_10_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a928)                                                      */
/*      SPRB0 (0x2001a928)                                                      */
/*      SPRHBM (0x2001a928)                                                     */
/*      SPRC0 (0x2001a928)                                                      */
/*      SPRMCC (0x2001a928)                                                     */
/*      SPRUCC (0x2001a928)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_10_MC_DDRIOMC_REG 0x0822A928

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_10_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_11_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a92c)                                                      */
/*      SPRB0 (0x2001a92c)                                                      */
/*      SPRHBM (0x2001a92c)                                                     */
/*      SPRC0 (0x2001a92c)                                                      */
/*      SPRMCC (0x2001a92c)                                                     */
/*      SPRUCC (0x2001a92c)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_11_MC_DDRIOMC_REG 0x0822A92C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_11_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_12_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a930)                                                      */
/*      SPRB0 (0x2001a930)                                                      */
/*      SPRHBM (0x2001a930)                                                     */
/*      SPRC0 (0x2001a930)                                                      */
/*      SPRMCC (0x2001a930)                                                     */
/*      SPRUCC (0x2001a930)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_12_MC_DDRIOMC_REG 0x0822A930

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_12_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_13_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a934)                                                      */
/*      SPRB0 (0x2001a934)                                                      */
/*      SPRHBM (0x2001a934)                                                     */
/*      SPRC0 (0x2001a934)                                                      */
/*      SPRMCC (0x2001a934)                                                     */
/*      SPRUCC (0x2001a934)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_13_MC_DDRIOMC_REG 0x0822A934

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_13_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_14_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a938)                                                      */
/*      SPRB0 (0x2001a938)                                                      */
/*      SPRHBM (0x2001a938)                                                     */
/*      SPRC0 (0x2001a938)                                                      */
/*      SPRMCC (0x2001a938)                                                     */
/*      SPRUCC (0x2001a938)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_14_MC_DDRIOMC_REG 0x0822A938

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_14_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_15_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a93c)                                                      */
/*      SPRB0 (0x2001a93c)                                                      */
/*      SPRHBM (0x2001a93c)                                                     */
/*      SPRC0 (0x2001a93c)                                                      */
/*      SPRMCC (0x2001a93c)                                                     */
/*      SPRUCC (0x2001a93c)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_15_MC_DDRIOMC_REG 0x0822A93C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_15_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_16_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a940)                                                      */
/*      SPRB0 (0x2001a940)                                                      */
/*      SPRHBM (0x2001a940)                                                     */
/*      SPRC0 (0x2001a940)                                                      */
/*      SPRMCC (0x2001a940)                                                     */
/*      SPRUCC (0x2001a940)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_16_MC_DDRIOMC_REG 0x0822A940

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_16_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_17_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a944)                                                      */
/*      SPRB0 (0x2001a944)                                                      */
/*      SPRHBM (0x2001a944)                                                     */
/*      SPRC0 (0x2001a944)                                                      */
/*      SPRMCC (0x2001a944)                                                     */
/*      SPRUCC (0x2001a944)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_17_MC_DDRIOMC_REG 0x0822A944

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_17_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_18_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a948)                                                      */
/*      SPRB0 (0x2001a948)                                                      */
/*      SPRHBM (0x2001a948)                                                     */
/*      SPRC0 (0x2001a948)                                                      */
/*      SPRMCC (0x2001a948)                                                     */
/*      SPRUCC (0x2001a948)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_18_MC_DDRIOMC_REG 0x0822A948

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_18_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_19_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a94c)                                                      */
/*      SPRB0 (0x2001a94c)                                                      */
/*      SPRHBM (0x2001a94c)                                                     */
/*      SPRC0 (0x2001a94c)                                                      */
/*      SPRMCC (0x2001a94c)                                                     */
/*      SPRUCC (0x2001a94c)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_19_MC_DDRIOMC_REG 0x0822A94C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_19_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_20_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a950)                                                      */
/*      SPRB0 (0x2001a950)                                                      */
/*      SPRHBM (0x2001a950)                                                     */
/*      SPRC0 (0x2001a950)                                                      */
/*      SPRMCC (0x2001a950)                                                     */
/*      SPRUCC (0x2001a950)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_20_MC_DDRIOMC_REG 0x0822A950

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_20_MC_DDRIOMC_STRUCT;

/* DDRCC_CTL1_BIT_21_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001a954)                                                      */
/*      SPRB0 (0x2001a954)                                                      */
/*      SPRHBM (0x2001a954)                                                     */
/*      SPRC0 (0x2001a954)                                                      */
/*      SPRMCC (0x2001a954)                                                     */
/*      SPRUCC (0x2001a954)                                                     */
/* Register default value on SPRA0: 0x0000001E                                  */
/* Register default value on SPRB0: 0x0000001E                                  */
/* Register default value on SPRHBM: 0x0000001E                                 */
/* Register default value on SPRC0: 0x0000001E                                  */
/* Register default value on SPRMCC: 0x0000001E                                 */
/* Register default value on SPRUCC: 0x0000001E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* CMD Pi Settings
*/


#define DDRCC_CTL1_BIT_21_MC_DDRIOMC_REG 0x0822A954

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61,62,63=not used)[br] This field can be
                               programed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_CTL1_BIT_21_MC_DDRIOMC_STRUCT;

/* DDRCC_DLL_CTL0_MC_DDRIOMC_REG supported on:                                  */
/*      SPRA0 (0x2001a958)                                                      */
/*      SPRB0 (0x2001a958)                                                      */
/*      SPRHBM (0x2001a958)                                                     */
/*      SPRC0 (0x2001a958)                                                      */
/*      SPRMCC (0x2001a958)                                                     */
/*      SPRUCC (0x2001a958)                                                     */
/* Register default value on SPRA0: 0x00001E24                                  */
/* Register default value on SPRB0: 0x00001E24                                  */
/* Register default value on SPRHBM: 0x00001E24                                 */
/* Register default value on SPRC0: 0x00001E24                                  */
/* Register default value on SPRMCC: 0x00001E24                                 */
/* Register default value on SPRUCC: 0x00001E24                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrcc1_type/ddrcc1_ch0/ddrcc1_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* DLL Control 0 Register
*/


#define DDRCC_DLL_CTL0_MC_DDRIOMC_REG 0x0822A958

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dll_discharge_tmr : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000024*/

                            /*
                               BIOS must program this DLL discharge timer based
                               on the analog tuning value and hclk freq before
                               enable the DLL. The default value is based on
                               hclk is 1200 MHz and discharge time is 30ns.
                            */
    UINT32 rsvd : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dll_lock_tmr : 7;

                            /* Bits[13:7], Access Type=RW, default=0x0000003C*/

                            /*
                               BIOS must program this DLL lock timer based on
                               the analog tuning value and hclk freq before
                               enable the DLL. The default value is based on
                               hclk is 1200 MHz and lock time is 50ns.
                            */
    UINT32 rsvd_14 : 18;

                            /* Bits[31:14], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRCC_DLL_CTL0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL0_RANK_0_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b000)                                                      */
/*      SPRB0 (0x2001b000)                                                      */
/*      SPRHBM (0x2001b000)                                                     */
/*      SPRC0 (0x2001b000)                                                      */
/*      SPRMCC (0x2001b000)                                                     */
/*      SPRUCC (0x2001b000)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for x8 Deive, RX DQ, DQSP/N and Receive enable Delay
*/


#define DDRD_N0_RX_CTL0_RANK_0_MC_DDRIOMC_REG 0x0822B000

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rcven_dly : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Receive Enable Delay. The range is 0 to 16UI
                               with step size clkpi/128.[br] DDR4 range is <
                               10UI. (max of 4 logic delay) [br] DDR5 range is
                               < 16UI. (max of 7 logic delay) [br] 10:7 - It is
                               used for logic delay.[br] 6:0 - The lower 7 bit
                               is added with rcven_piref_offset and
                               piref_setup_adj, so the programed value is
                               relative to the piref clock. The result is sent
                               to the rcven crossover logic and DLL.[br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rxdqsp_dly : 8;

                            /* Bits[18:11], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by RX DQS deskew logic to delay DQS_P
                               to match the earlest arrival DQ.[br] The per bit
                               range is 0 to 1.375 dclk with step size
                               clkpi/128. [br] The per bit calculation is [br]
                               rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit
                               delay) + rxrt_dqs_dly_adj (singed number for rx
                               retraining. Range is -64 to 63) + rxdqs_dly_adj
                               (signed number for BIOS margining sweep. Range
                               is -128 to 127)[br] Note: BIOS must make sure
                               the total delay not more than 1.375 dclk.
                            */
    UINT32 rxdqsn_dly : 8;

                            /* Bits[26:19], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by RX DQS deskew logic to delay DQS_N
                               to match the earlest arrival DQ.[br] The per bit
                               range is 0 to 1.375 dclk with step size
                               clkpi/128. [br] The per bit calculation is [br]
                               rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit
                               delay) + rxrt_dqs_dly_adj (singed number for rx
                               retraining. Range is -64 to 63) + rxdqs_dly_adj
                               (signed number for BIOS margining sweep. Range
                               is -128 to 127)[br] Note: BIOS must make sure
                               the total delay not more than 1.375 dclk.
                            */
    UINT32 rxdq_dly : 3;

                            /* Bits[29:27], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by the RX deskew CBB. Normal usage
                               (when DFE is disabled) adds delay to the DQ
                               path, when DQ is earlier than DQS. This control
                               only apply for DDR4.[br] 0: 1/16 UI offset,[br]
                               1: 3/16 UI offset,[br] 2: 5/16 UI offset,[br] 3:
                               7/16 UI offset,[br] 4: 9/16 UI offset,[br] 5:
                               11/16 UI offset,[br] 6,7: 13/16 UI offset.[br]
                               When DFE is enabled, adds delay on the DFE
                               feedback path (after the DFE sampler).[br] 0: 0
                               offset (bypass),[br] 1: 2/16 UI offset,[br] 2:
                               4/16 UI offset,[br] 3: 6/16 UI offset,[br] 4:
                               8/16 UI offset,[br] 5: 10/16 UI offset,[br] 6,7:
                               12/16 UI offset).
                            */
    UINT32 rsvd : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rx_strobe_inv : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* RX Strobe Inversion for DFE */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL0_RANK_0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL0_RANK_1_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b004)                                                      */
/*      SPRB0 (0x2001b004)                                                      */
/*      SPRHBM (0x2001b004)                                                     */
/*      SPRC0 (0x2001b004)                                                      */
/*      SPRMCC (0x2001b004)                                                     */
/*      SPRUCC (0x2001b004)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for x8 Deive, RX DQ, DQSP/N and Receive enable Delay
*/


#define DDRD_N0_RX_CTL0_RANK_1_MC_DDRIOMC_REG 0x0822B004

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rcven_dly : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Receive Enable Delay. The range is 0 to 16UI
                               with step size clkpi/128.[br] DDR4 range is <
                               10UI. (max of 4 logic delay) [br] DDR5 range is
                               < 16UI. (max of 7 logic delay) [br] 10:7 - It is
                               used for logic delay.[br] 6:0 - The lower 7 bit
                               is added with rcven_piref_offset and
                               piref_setup_adj, so the programed value is
                               relative to the piref clock. The result is sent
                               to the rcven crossover logic and DLL.[br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rxdqsp_dly : 8;

                            /* Bits[18:11], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by RX DQS deskew logic to delay DQS_P
                               to match the earlest arrival DQ.[br] The per bit
                               range is 0 to 1.375 dclk with step size
                               clkpi/128. [br] The per bit calculation is [br]
                               rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit
                               delay) + rxrt_dqs_dly_adj (singed number for rx
                               retraining. Range is -64 to 63) + rxdqs_dly_adj
                               (signed number for BIOS margining sweep. Range
                               is -128 to 127)[br] Note: BIOS must make sure
                               the total delay not more than 1.375 dclk.
                            */
    UINT32 rxdqsn_dly : 8;

                            /* Bits[26:19], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by RX DQS deskew logic to delay DQS_N
                               to match the earlest arrival DQ.[br] The per bit
                               range is 0 to 1.375 dclk with step size
                               clkpi/128. [br] The per bit calculation is [br]
                               rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit
                               delay) + rxrt_dqs_dly_adj (singed number for rx
                               retraining. Range is -64 to 63) + rxdqs_dly_adj
                               (signed number for BIOS margining sweep. Range
                               is -128 to 127)[br] Note: BIOS must make sure
                               the total delay not more than 1.375 dclk.
                            */
    UINT32 rxdq_dly : 3;

                            /* Bits[29:27], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by the RX deskew CBB. Normal usage
                               (when DFE is disabled) adds delay to the DQ
                               path, when DQ is earlier than DQS. This control
                               only apply for DDR4.[br] 0: 1/16 UI offset,[br]
                               1: 3/16 UI offset,[br] 2: 5/16 UI offset,[br] 3:
                               7/16 UI offset,[br] 4: 9/16 UI offset,[br] 5:
                               11/16 UI offset,[br] 6,7: 13/16 UI offset.[br]
                               When DFE is enabled, adds delay on the DFE
                               feedback path (after the DFE sampler).[br] 0: 0
                               offset (bypass),[br] 1: 2/16 UI offset,[br] 2:
                               4/16 UI offset,[br] 3: 6/16 UI offset,[br] 4:
                               8/16 UI offset,[br] 5: 10/16 UI offset,[br] 6,7:
                               12/16 UI offset).
                            */
    UINT32 rsvd : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rx_strobe_inv : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* RX Strobe Inversion for DFE */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL0_RANK_1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL0_RANK_2_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b008)                                                      */
/*      SPRB0 (0x2001b008)                                                      */
/*      SPRHBM (0x2001b008)                                                     */
/*      SPRC0 (0x2001b008)                                                      */
/*      SPRMCC (0x2001b008)                                                     */
/*      SPRUCC (0x2001b008)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for x8 Deive, RX DQ, DQSP/N and Receive enable Delay
*/


#define DDRD_N0_RX_CTL0_RANK_2_MC_DDRIOMC_REG 0x0822B008

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rcven_dly : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Receive Enable Delay. The range is 0 to 16UI
                               with step size clkpi/128.[br] DDR4 range is <
                               10UI. (max of 4 logic delay) [br] DDR5 range is
                               < 16UI. (max of 7 logic delay) [br] 10:7 - It is
                               used for logic delay.[br] 6:0 - The lower 7 bit
                               is added with rcven_piref_offset and
                               piref_setup_adj, so the programed value is
                               relative to the piref clock. The result is sent
                               to the rcven crossover logic and DLL.[br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rxdqsp_dly : 8;

                            /* Bits[18:11], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by RX DQS deskew logic to delay DQS_P
                               to match the earlest arrival DQ.[br] The per bit
                               range is 0 to 1.375 dclk with step size
                               clkpi/128. [br] The per bit calculation is [br]
                               rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit
                               delay) + rxrt_dqs_dly_adj (singed number for rx
                               retraining. Range is -64 to 63) + rxdqs_dly_adj
                               (signed number for BIOS margining sweep. Range
                               is -128 to 127)[br] Note: BIOS must make sure
                               the total delay not more than 1.375 dclk.
                            */
    UINT32 rxdqsn_dly : 8;

                            /* Bits[26:19], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by RX DQS deskew logic to delay DQS_N
                               to match the earlest arrival DQ.[br] The per bit
                               range is 0 to 1.375 dclk with step size
                               clkpi/128. [br] The per bit calculation is [br]
                               rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit
                               delay) + rxrt_dqs_dly_adj (singed number for rx
                               retraining. Range is -64 to 63) + rxdqs_dly_adj
                               (signed number for BIOS margining sweep. Range
                               is -128 to 127)[br] Note: BIOS must make sure
                               the total delay not more than 1.375 dclk.
                            */
    UINT32 rxdq_dly : 3;

                            /* Bits[29:27], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by the RX deskew CBB. Normal usage
                               (when DFE is disabled) adds delay to the DQ
                               path, when DQ is earlier than DQS. This control
                               only apply for DDR4.[br] 0: 1/16 UI offset,[br]
                               1: 3/16 UI offset,[br] 2: 5/16 UI offset,[br] 3:
                               7/16 UI offset,[br] 4: 9/16 UI offset,[br] 5:
                               11/16 UI offset,[br] 6,7: 13/16 UI offset.[br]
                               When DFE is enabled, adds delay on the DFE
                               feedback path (after the DFE sampler).[br] 0: 0
                               offset (bypass),[br] 1: 2/16 UI offset,[br] 2:
                               4/16 UI offset,[br] 3: 6/16 UI offset,[br] 4:
                               8/16 UI offset,[br] 5: 10/16 UI offset,[br] 6,7:
                               12/16 UI offset).
                            */
    UINT32 rsvd : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rx_strobe_inv : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* RX Strobe Inversion for DFE */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL0_RANK_2_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL0_RANK_3_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b00c)                                                      */
/*      SPRB0 (0x2001b00c)                                                      */
/*      SPRHBM (0x2001b00c)                                                     */
/*      SPRC0 (0x2001b00c)                                                      */
/*      SPRMCC (0x2001b00c)                                                     */
/*      SPRUCC (0x2001b00c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for x8 Deive, RX DQ, DQSP/N and Receive enable Delay
*/


#define DDRD_N0_RX_CTL0_RANK_3_MC_DDRIOMC_REG 0x0822B00C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rcven_dly : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Receive Enable Delay. The range is 0 to 16UI
                               with step size clkpi/128.[br] DDR4 range is <
                               10UI. (max of 4 logic delay) [br] DDR5 range is
                               < 16UI. (max of 7 logic delay) [br] 10:7 - It is
                               used for logic delay.[br] 6:0 - The lower 7 bit
                               is added with rcven_piref_offset and
                               piref_setup_adj, so the programed value is
                               relative to the piref clock. The result is sent
                               to the rcven crossover logic and DLL.[br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rxdqsp_dly : 8;

                            /* Bits[18:11], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by RX DQS deskew logic to delay DQS_P
                               to match the earlest arrival DQ.[br] The per bit
                               range is 0 to 1.375 dclk with step size
                               clkpi/128. [br] The per bit calculation is [br]
                               rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit
                               delay) + rxrt_dqs_dly_adj (singed number for rx
                               retraining. Range is -64 to 63) + rxdqs_dly_adj
                               (signed number for BIOS margining sweep. Range
                               is -128 to 127)[br] Note: BIOS must make sure
                               the total delay not more than 1.375 dclk.
                            */
    UINT32 rxdqsn_dly : 8;

                            /* Bits[26:19], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by RX DQS deskew logic to delay DQS_N
                               to match the earlest arrival DQ.[br] The per bit
                               range is 0 to 1.375 dclk with step size
                               clkpi/128. [br] The per bit calculation is [br]
                               rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit
                               delay) + rxrt_dqs_dly_adj (singed number for rx
                               retraining. Range is -64 to 63) + rxdqs_dly_adj
                               (signed number for BIOS margining sweep. Range
                               is -128 to 127)[br] Note: BIOS must make sure
                               the total delay not more than 1.375 dclk.
                            */
    UINT32 rxdq_dly : 3;

                            /* Bits[29:27], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by the RX deskew CBB. Normal usage
                               (when DFE is disabled) adds delay to the DQ
                               path, when DQ is earlier than DQS. This control
                               only apply for DDR4.[br] 0: 1/16 UI offset,[br]
                               1: 3/16 UI offset,[br] 2: 5/16 UI offset,[br] 3:
                               7/16 UI offset,[br] 4: 9/16 UI offset,[br] 5:
                               11/16 UI offset,[br] 6,7: 13/16 UI offset.[br]
                               When DFE is enabled, adds delay on the DFE
                               feedback path (after the DFE sampler).[br] 0: 0
                               offset (bypass),[br] 1: 2/16 UI offset,[br] 2:
                               4/16 UI offset,[br] 3: 6/16 UI offset,[br] 4:
                               8/16 UI offset,[br] 5: 10/16 UI offset,[br] 6,7:
                               12/16 UI offset).
                            */
    UINT32 rsvd : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rx_strobe_inv : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* RX Strobe Inversion for DFE */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL0_RANK_3_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL0_RANK_4_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b010)                                                      */
/*      SPRB0 (0x2001b010)                                                      */
/*      SPRHBM (0x2001b010)                                                     */
/*      SPRC0 (0x2001b010)                                                      */
/*      SPRMCC (0x2001b010)                                                     */
/*      SPRUCC (0x2001b010)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for x8 Deive, RX DQ, DQSP/N and Receive enable Delay
*/


#define DDRD_N0_RX_CTL0_RANK_4_MC_DDRIOMC_REG 0x0822B010

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rcven_dly : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Receive Enable Delay. The range is 0 to 16UI
                               with step size clkpi/128.[br] DDR4 range is <
                               10UI. (max of 4 logic delay) [br] DDR5 range is
                               < 16UI. (max of 7 logic delay) [br] 10:7 - It is
                               used for logic delay.[br] 6:0 - The lower 7 bit
                               is added with rcven_piref_offset and
                               piref_setup_adj, so the programed value is
                               relative to the piref clock. The result is sent
                               to the rcven crossover logic and DLL.[br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rxdqsp_dly : 8;

                            /* Bits[18:11], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by RX DQS deskew logic to delay DQS_P
                               to match the earlest arrival DQ.[br] The per bit
                               range is 0 to 1.375 dclk with step size
                               clkpi/128. [br] The per bit calculation is [br]
                               rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit
                               delay) + rxrt_dqs_dly_adj (singed number for rx
                               retraining. Range is -64 to 63) + rxdqs_dly_adj
                               (signed number for BIOS margining sweep. Range
                               is -128 to 127)[br] Note: BIOS must make sure
                               the total delay not more than 1.375 dclk.
                            */
    UINT32 rxdqsn_dly : 8;

                            /* Bits[26:19], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by RX DQS deskew logic to delay DQS_N
                               to match the earlest arrival DQ.[br] The per bit
                               range is 0 to 1.375 dclk with step size
                               clkpi/128. [br] The per bit calculation is [br]
                               rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit
                               delay) + rxrt_dqs_dly_adj (singed number for rx
                               retraining. Range is -64 to 63) + rxdqs_dly_adj
                               (signed number for BIOS margining sweep. Range
                               is -128 to 127)[br] Note: BIOS must make sure
                               the total delay not more than 1.375 dclk.
                            */
    UINT32 rxdq_dly : 3;

                            /* Bits[29:27], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by the RX deskew CBB. Normal usage
                               (when DFE is disabled) adds delay to the DQ
                               path, when DQ is earlier than DQS. This control
                               only apply for DDR4.[br] 0: 1/16 UI offset,[br]
                               1: 3/16 UI offset,[br] 2: 5/16 UI offset,[br] 3:
                               7/16 UI offset,[br] 4: 9/16 UI offset,[br] 5:
                               11/16 UI offset,[br] 6,7: 13/16 UI offset.[br]
                               When DFE is enabled, adds delay on the DFE
                               feedback path (after the DFE sampler).[br] 0: 0
                               offset (bypass),[br] 1: 2/16 UI offset,[br] 2:
                               4/16 UI offset,[br] 3: 6/16 UI offset,[br] 4:
                               8/16 UI offset,[br] 5: 10/16 UI offset,[br] 6,7:
                               12/16 UI offset).
                            */
    UINT32 rsvd : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rx_strobe_inv : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* RX Strobe Inversion for DFE */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL0_RANK_4_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL0_RANK_5_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b014)                                                      */
/*      SPRB0 (0x2001b014)                                                      */
/*      SPRHBM (0x2001b014)                                                     */
/*      SPRC0 (0x2001b014)                                                      */
/*      SPRMCC (0x2001b014)                                                     */
/*      SPRUCC (0x2001b014)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for x8 Deive, RX DQ, DQSP/N and Receive enable Delay
*/


#define DDRD_N0_RX_CTL0_RANK_5_MC_DDRIOMC_REG 0x0822B014

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rcven_dly : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Receive Enable Delay. The range is 0 to 16UI
                               with step size clkpi/128.[br] DDR4 range is <
                               10UI. (max of 4 logic delay) [br] DDR5 range is
                               < 16UI. (max of 7 logic delay) [br] 10:7 - It is
                               used for logic delay.[br] 6:0 - The lower 7 bit
                               is added with rcven_piref_offset and
                               piref_setup_adj, so the programed value is
                               relative to the piref clock. The result is sent
                               to the rcven crossover logic and DLL.[br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rxdqsp_dly : 8;

                            /* Bits[18:11], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by RX DQS deskew logic to delay DQS_P
                               to match the earlest arrival DQ.[br] The per bit
                               range is 0 to 1.375 dclk with step size
                               clkpi/128. [br] The per bit calculation is [br]
                               rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit
                               delay) + rxrt_dqs_dly_adj (singed number for rx
                               retraining. Range is -64 to 63) + rxdqs_dly_adj
                               (signed number for BIOS margining sweep. Range
                               is -128 to 127)[br] Note: BIOS must make sure
                               the total delay not more than 1.375 dclk.
                            */
    UINT32 rxdqsn_dly : 8;

                            /* Bits[26:19], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by RX DQS deskew logic to delay DQS_N
                               to match the earlest arrival DQ.[br] The per bit
                               range is 0 to 1.375 dclk with step size
                               clkpi/128. [br] The per bit calculation is [br]
                               rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit
                               delay) + rxrt_dqs_dly_adj (singed number for rx
                               retraining. Range is -64 to 63) + rxdqs_dly_adj
                               (signed number for BIOS margining sweep. Range
                               is -128 to 127)[br] Note: BIOS must make sure
                               the total delay not more than 1.375 dclk.
                            */
    UINT32 rxdq_dly : 3;

                            /* Bits[29:27], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by the RX deskew CBB. Normal usage
                               (when DFE is disabled) adds delay to the DQ
                               path, when DQ is earlier than DQS. This control
                               only apply for DDR4.[br] 0: 1/16 UI offset,[br]
                               1: 3/16 UI offset,[br] 2: 5/16 UI offset,[br] 3:
                               7/16 UI offset,[br] 4: 9/16 UI offset,[br] 5:
                               11/16 UI offset,[br] 6,7: 13/16 UI offset.[br]
                               When DFE is enabled, adds delay on the DFE
                               feedback path (after the DFE sampler).[br] 0: 0
                               offset (bypass),[br] 1: 2/16 UI offset,[br] 2:
                               4/16 UI offset,[br] 3: 6/16 UI offset,[br] 4:
                               8/16 UI offset,[br] 5: 10/16 UI offset,[br] 6,7:
                               12/16 UI offset).
                            */
    UINT32 rsvd : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rx_strobe_inv : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* RX Strobe Inversion for DFE */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL0_RANK_5_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL0_RANK_6_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b018)                                                      */
/*      SPRB0 (0x2001b018)                                                      */
/*      SPRHBM (0x2001b018)                                                     */
/*      SPRC0 (0x2001b018)                                                      */
/*      SPRMCC (0x2001b018)                                                     */
/*      SPRUCC (0x2001b018)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for x8 Deive, RX DQ, DQSP/N and Receive enable Delay
*/


#define DDRD_N0_RX_CTL0_RANK_6_MC_DDRIOMC_REG 0x0822B018

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rcven_dly : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Receive Enable Delay. The range is 0 to 16UI
                               with step size clkpi/128.[br] DDR4 range is <
                               10UI. (max of 4 logic delay) [br] DDR5 range is
                               < 16UI. (max of 7 logic delay) [br] 10:7 - It is
                               used for logic delay.[br] 6:0 - The lower 7 bit
                               is added with rcven_piref_offset and
                               piref_setup_adj, so the programed value is
                               relative to the piref clock. The result is sent
                               to the rcven crossover logic and DLL.[br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rxdqsp_dly : 8;

                            /* Bits[18:11], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by RX DQS deskew logic to delay DQS_P
                               to match the earlest arrival DQ.[br] The per bit
                               range is 0 to 1.375 dclk with step size
                               clkpi/128. [br] The per bit calculation is [br]
                               rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit
                               delay) + rxrt_dqs_dly_adj (singed number for rx
                               retraining. Range is -64 to 63) + rxdqs_dly_adj
                               (signed number for BIOS margining sweep. Range
                               is -128 to 127)[br] Note: BIOS must make sure
                               the total delay not more than 1.375 dclk.
                            */
    UINT32 rxdqsn_dly : 8;

                            /* Bits[26:19], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by RX DQS deskew logic to delay DQS_N
                               to match the earlest arrival DQ.[br] The per bit
                               range is 0 to 1.375 dclk with step size
                               clkpi/128. [br] The per bit calculation is [br]
                               rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit
                               delay) + rxrt_dqs_dly_adj (singed number for rx
                               retraining. Range is -64 to 63) + rxdqs_dly_adj
                               (signed number for BIOS margining sweep. Range
                               is -128 to 127)[br] Note: BIOS must make sure
                               the total delay not more than 1.375 dclk.
                            */
    UINT32 rxdq_dly : 3;

                            /* Bits[29:27], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by the RX deskew CBB. Normal usage
                               (when DFE is disabled) adds delay to the DQ
                               path, when DQ is earlier than DQS. This control
                               only apply for DDR4.[br] 0: 1/16 UI offset,[br]
                               1: 3/16 UI offset,[br] 2: 5/16 UI offset,[br] 3:
                               7/16 UI offset,[br] 4: 9/16 UI offset,[br] 5:
                               11/16 UI offset,[br] 6,7: 13/16 UI offset.[br]
                               When DFE is enabled, adds delay on the DFE
                               feedback path (after the DFE sampler).[br] 0: 0
                               offset (bypass),[br] 1: 2/16 UI offset,[br] 2:
                               4/16 UI offset,[br] 3: 6/16 UI offset,[br] 4:
                               8/16 UI offset,[br] 5: 10/16 UI offset,[br] 6,7:
                               12/16 UI offset).
                            */
    UINT32 rsvd : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rx_strobe_inv : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* RX Strobe Inversion for DFE */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL0_RANK_6_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL0_RANK_7_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b01c)                                                      */
/*      SPRB0 (0x2001b01c)                                                      */
/*      SPRHBM (0x2001b01c)                                                     */
/*      SPRC0 (0x2001b01c)                                                      */
/*      SPRMCC (0x2001b01c)                                                     */
/*      SPRUCC (0x2001b01c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for x8 Deive, RX DQ, DQSP/N and Receive enable Delay
*/


#define DDRD_N0_RX_CTL0_RANK_7_MC_DDRIOMC_REG 0x0822B01C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rcven_dly : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Receive Enable Delay. The range is 0 to 16UI
                               with step size clkpi/128.[br] DDR4 range is <
                               10UI. (max of 4 logic delay) [br] DDR5 range is
                               < 16UI. (max of 7 logic delay) [br] 10:7 - It is
                               used for logic delay.[br] 6:0 - The lower 7 bit
                               is added with rcven_piref_offset and
                               piref_setup_adj, so the programed value is
                               relative to the piref clock. The result is sent
                               to the rcven crossover logic and DLL.[br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rxdqsp_dly : 8;

                            /* Bits[18:11], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by RX DQS deskew logic to delay DQS_P
                               to match the earlest arrival DQ.[br] The per bit
                               range is 0 to 1.375 dclk with step size
                               clkpi/128. [br] The per bit calculation is [br]
                               rxdqp_dly + rxdqsp_dly[lb]0..3[rb] (perbit
                               delay) + rxrt_dqs_dly_adj (singed number for rx
                               retraining. Range is -64 to 63) + rxdqs_dly_adj
                               (signed number for BIOS margining sweep. Range
                               is -128 to 127)[br] Note: BIOS must make sure
                               the total delay not more than 1.375 dclk.
                            */
    UINT32 rxdqsn_dly : 8;

                            /* Bits[26:19], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by RX DQS deskew logic to delay DQS_N
                               to match the earlest arrival DQ.[br] The per bit
                               range is 0 to 1.375 dclk with step size
                               clkpi/128. [br] The per bit calculation is [br]
                               rxdqsn_dly + rxdqsn_dly[lb]3..0[rb] (perbit
                               delay) + rxrt_dqs_dly_adj (singed number for rx
                               retraining. Range is -64 to 63) + rxdqs_dly_adj
                               (signed number for BIOS margining sweep. Range
                               is -128 to 127)[br] Note: BIOS must make sure
                               the total delay not more than 1.375 dclk.
                            */
    UINT32 rxdq_dly : 3;

                            /* Bits[29:27], Access Type=RW, default=0x00000000*/

                            /*
                               It is used by the RX deskew CBB. Normal usage
                               (when DFE is disabled) adds delay to the DQ
                               path, when DQ is earlier than DQS. This control
                               only apply for DDR4.[br] 0: 1/16 UI offset,[br]
                               1: 3/16 UI offset,[br] 2: 5/16 UI offset,[br] 3:
                               7/16 UI offset,[br] 4: 9/16 UI offset,[br] 5:
                               11/16 UI offset,[br] 6,7: 13/16 UI offset.[br]
                               When DFE is enabled, adds delay on the DFE
                               feedback path (after the DFE sampler).[br] 0: 0
                               offset (bypass),[br] 1: 2/16 UI offset,[br] 2:
                               4/16 UI offset,[br] 3: 6/16 UI offset,[br] 4:
                               8/16 UI offset,[br] 5: 10/16 UI offset,[br] 6,7:
                               12/16 UI offset).
                            */
    UINT32 rsvd : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rx_strobe_inv : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* RX Strobe Inversion for DFE */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL0_RANK_7_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL1_RANK_0_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b020)                                                      */
/*      SPRB0 (0x2001b020)                                                      */
/*      SPRHBM (0x2001b020)                                                     */
/*      SPRC0 (0x2001b020)                                                      */
/*      SPRMCC (0x2001b020)                                                     */
/*      SPRUCC (0x2001b020)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for RX EQ, RX DQSN delay for DQ0-3
*/


#define DDRD_N0_RX_CTL1_RANK_0_MC_DDRIOMC_REG 0x0822B020

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxdqsn_dly0 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ0. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly1 : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ1. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly2 : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ2. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly3 : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ3. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ctle_cap_en : 2;

                            /* Bits[26:25], Access Type=RW, default=0x00000000*/

                            /* CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C. */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ctle_res_en : 3;

                            /* Bits[30:28], Access Type=RW, default=0x00000000*/

                            /*
                               CTLE Resistor Enable (Controls DC gain). 0 =
                               lowest DC gain (max peaking)[br] Res: 0-3R,
                               1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3,
                               7=R/4[br] where R is ~500 Ohms and depends on
                               process.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL1_RANK_0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL1_RANK_1_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b024)                                                      */
/*      SPRB0 (0x2001b024)                                                      */
/*      SPRHBM (0x2001b024)                                                     */
/*      SPRC0 (0x2001b024)                                                      */
/*      SPRMCC (0x2001b024)                                                     */
/*      SPRUCC (0x2001b024)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for RX EQ, RX DQSN delay for DQ0-3
*/


#define DDRD_N0_RX_CTL1_RANK_1_MC_DDRIOMC_REG 0x0822B024

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxdqsn_dly0 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ0. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly1 : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ1. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly2 : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ2. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly3 : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ3. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ctle_cap_en : 2;

                            /* Bits[26:25], Access Type=RW, default=0x00000000*/

                            /* CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C. */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ctle_res_en : 3;

                            /* Bits[30:28], Access Type=RW, default=0x00000000*/

                            /*
                               CTLE Resistor Enable (Controls DC gain). 0 =
                               lowest DC gain (max peaking)[br] Res: 0-3R,
                               1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3,
                               7=R/4[br] where R is ~500 Ohms and depends on
                               process.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL1_RANK_1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL1_RANK_2_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b028)                                                      */
/*      SPRB0 (0x2001b028)                                                      */
/*      SPRHBM (0x2001b028)                                                     */
/*      SPRC0 (0x2001b028)                                                      */
/*      SPRMCC (0x2001b028)                                                     */
/*      SPRUCC (0x2001b028)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for RX EQ, RX DQSN delay for DQ0-3
*/


#define DDRD_N0_RX_CTL1_RANK_2_MC_DDRIOMC_REG 0x0822B028

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxdqsn_dly0 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ0. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly1 : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ1. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly2 : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ2. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly3 : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ3. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ctle_cap_en : 2;

                            /* Bits[26:25], Access Type=RW, default=0x00000000*/

                            /* CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C. */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ctle_res_en : 3;

                            /* Bits[30:28], Access Type=RW, default=0x00000000*/

                            /*
                               CTLE Resistor Enable (Controls DC gain). 0 =
                               lowest DC gain (max peaking)[br] Res: 0-3R,
                               1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3,
                               7=R/4[br] where R is ~500 Ohms and depends on
                               process.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL1_RANK_2_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL1_RANK_3_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b02c)                                                      */
/*      SPRB0 (0x2001b02c)                                                      */
/*      SPRHBM (0x2001b02c)                                                     */
/*      SPRC0 (0x2001b02c)                                                      */
/*      SPRMCC (0x2001b02c)                                                     */
/*      SPRUCC (0x2001b02c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for RX EQ, RX DQSN delay for DQ0-3
*/


#define DDRD_N0_RX_CTL1_RANK_3_MC_DDRIOMC_REG 0x0822B02C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxdqsn_dly0 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ0. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly1 : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ1. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly2 : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ2. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly3 : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ3. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ctle_cap_en : 2;

                            /* Bits[26:25], Access Type=RW, default=0x00000000*/

                            /* CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C. */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ctle_res_en : 3;

                            /* Bits[30:28], Access Type=RW, default=0x00000000*/

                            /*
                               CTLE Resistor Enable (Controls DC gain). 0 =
                               lowest DC gain (max peaking)[br] Res: 0-3R,
                               1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3,
                               7=R/4[br] where R is ~500 Ohms and depends on
                               process.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL1_RANK_3_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL1_RANK_4_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b030)                                                      */
/*      SPRB0 (0x2001b030)                                                      */
/*      SPRHBM (0x2001b030)                                                     */
/*      SPRC0 (0x2001b030)                                                      */
/*      SPRMCC (0x2001b030)                                                     */
/*      SPRUCC (0x2001b030)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for RX EQ, RX DQSN delay for DQ0-3
*/


#define DDRD_N0_RX_CTL1_RANK_4_MC_DDRIOMC_REG 0x0822B030

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxdqsn_dly0 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ0. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly1 : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ1. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly2 : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ2. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly3 : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ3. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ctle_cap_en : 2;

                            /* Bits[26:25], Access Type=RW, default=0x00000000*/

                            /* CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C. */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ctle_res_en : 3;

                            /* Bits[30:28], Access Type=RW, default=0x00000000*/

                            /*
                               CTLE Resistor Enable (Controls DC gain). 0 =
                               lowest DC gain (max peaking)[br] Res: 0-3R,
                               1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3,
                               7=R/4[br] where R is ~500 Ohms and depends on
                               process.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL1_RANK_4_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL1_RANK_5_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b034)                                                      */
/*      SPRB0 (0x2001b034)                                                      */
/*      SPRHBM (0x2001b034)                                                     */
/*      SPRC0 (0x2001b034)                                                      */
/*      SPRMCC (0x2001b034)                                                     */
/*      SPRUCC (0x2001b034)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for RX EQ, RX DQSN delay for DQ0-3
*/


#define DDRD_N0_RX_CTL1_RANK_5_MC_DDRIOMC_REG 0x0822B034

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxdqsn_dly0 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ0. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly1 : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ1. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly2 : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ2. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly3 : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ3. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ctle_cap_en : 2;

                            /* Bits[26:25], Access Type=RW, default=0x00000000*/

                            /* CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C. */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ctle_res_en : 3;

                            /* Bits[30:28], Access Type=RW, default=0x00000000*/

                            /*
                               CTLE Resistor Enable (Controls DC gain). 0 =
                               lowest DC gain (max peaking)[br] Res: 0-3R,
                               1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3,
                               7=R/4[br] where R is ~500 Ohms and depends on
                               process.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL1_RANK_5_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL1_RANK_6_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b038)                                                      */
/*      SPRB0 (0x2001b038)                                                      */
/*      SPRHBM (0x2001b038)                                                     */
/*      SPRC0 (0x2001b038)                                                      */
/*      SPRMCC (0x2001b038)                                                     */
/*      SPRUCC (0x2001b038)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for RX EQ, RX DQSN delay for DQ0-3
*/


#define DDRD_N0_RX_CTL1_RANK_6_MC_DDRIOMC_REG 0x0822B038

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxdqsn_dly0 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ0. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly1 : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ1. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly2 : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ2. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly3 : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ3. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ctle_cap_en : 2;

                            /* Bits[26:25], Access Type=RW, default=0x00000000*/

                            /* CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C. */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ctle_res_en : 3;

                            /* Bits[30:28], Access Type=RW, default=0x00000000*/

                            /*
                               CTLE Resistor Enable (Controls DC gain). 0 =
                               lowest DC gain (max peaking)[br] Res: 0-3R,
                               1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3,
                               7=R/4[br] where R is ~500 Ohms and depends on
                               process.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL1_RANK_6_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL1_RANK_7_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b03c)                                                      */
/*      SPRB0 (0x2001b03c)                                                      */
/*      SPRHBM (0x2001b03c)                                                     */
/*      SPRC0 (0x2001b03c)                                                      */
/*      SPRMCC (0x2001b03c)                                                     */
/*      SPRUCC (0x2001b03c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for RX EQ, RX DQSN delay for DQ0-3
*/


#define DDRD_N0_RX_CTL1_RANK_7_MC_DDRIOMC_REG 0x0822B03C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxdqsn_dly0 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ0. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly1 : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ1. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly2 : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ2. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsn_dly3 : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsn delay control to add on to
                               rxdqsn_dly to delay DQS_N to match on DQ3. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ctle_cap_en : 2;

                            /* Bits[26:25], Access Type=RW, default=0x00000000*/

                            /* CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C. */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ctle_res_en : 3;

                            /* Bits[30:28], Access Type=RW, default=0x00000000*/

                            /*
                               CTLE Resistor Enable (Controls DC gain). 0 =
                               lowest DC gain (max peaking)[br] Res: 0-3R,
                               1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3,
                               7=R/4[br] where R is ~500 Ohms and depends on
                               process.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL1_RANK_7_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL2_RANK_0_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b040)                                                      */
/*      SPRB0 (0x2001b040)                                                      */
/*      SPRHBM (0x2001b040)                                                     */
/*      SPRC0 (0x2001b040)                                                      */
/*      SPRMCC (0x2001b040)                                                     */
/*      SPRUCC (0x2001b040)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control For DFE, RX DQSP delay for DQ0-3
*/


#define DDRD_N0_RX_CTL2_RANK_0_MC_DDRIOMC_REG 0x0822B040

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxdqsp_dly0 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ0. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly1 : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ1. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly2 : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ2. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly3 : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ3. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL2_RANK_0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL2_RANK_1_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b044)                                                      */
/*      SPRB0 (0x2001b044)                                                      */
/*      SPRHBM (0x2001b044)                                                     */
/*      SPRC0 (0x2001b044)                                                      */
/*      SPRMCC (0x2001b044)                                                     */
/*      SPRUCC (0x2001b044)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control For DFE, RX DQSP delay for DQ0-3
*/


#define DDRD_N0_RX_CTL2_RANK_1_MC_DDRIOMC_REG 0x0822B044

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxdqsp_dly0 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ0. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly1 : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ1. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly2 : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ2. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly3 : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ3. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL2_RANK_1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL2_RANK_2_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b048)                                                      */
/*      SPRB0 (0x2001b048)                                                      */
/*      SPRHBM (0x2001b048)                                                     */
/*      SPRC0 (0x2001b048)                                                      */
/*      SPRMCC (0x2001b048)                                                     */
/*      SPRUCC (0x2001b048)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control For DFE, RX DQSP delay for DQ0-3
*/


#define DDRD_N0_RX_CTL2_RANK_2_MC_DDRIOMC_REG 0x0822B048

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxdqsp_dly0 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ0. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly1 : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ1. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly2 : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ2. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly3 : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ3. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL2_RANK_2_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL2_RANK_3_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b04c)                                                      */
/*      SPRB0 (0x2001b04c)                                                      */
/*      SPRHBM (0x2001b04c)                                                     */
/*      SPRC0 (0x2001b04c)                                                      */
/*      SPRMCC (0x2001b04c)                                                     */
/*      SPRUCC (0x2001b04c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control For DFE, RX DQSP delay for DQ0-3
*/


#define DDRD_N0_RX_CTL2_RANK_3_MC_DDRIOMC_REG 0x0822B04C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxdqsp_dly0 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ0. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly1 : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ1. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly2 : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ2. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly3 : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ3. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL2_RANK_3_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL2_RANK_4_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b050)                                                      */
/*      SPRB0 (0x2001b050)                                                      */
/*      SPRHBM (0x2001b050)                                                     */
/*      SPRC0 (0x2001b050)                                                      */
/*      SPRMCC (0x2001b050)                                                     */
/*      SPRUCC (0x2001b050)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control For DFE, RX DQSP delay for DQ0-3
*/


#define DDRD_N0_RX_CTL2_RANK_4_MC_DDRIOMC_REG 0x0822B050

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxdqsp_dly0 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ0. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly1 : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ1. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly2 : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ2. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly3 : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ3. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL2_RANK_4_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL2_RANK_5_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b054)                                                      */
/*      SPRB0 (0x2001b054)                                                      */
/*      SPRHBM (0x2001b054)                                                     */
/*      SPRC0 (0x2001b054)                                                      */
/*      SPRMCC (0x2001b054)                                                     */
/*      SPRUCC (0x2001b054)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control For DFE, RX DQSP delay for DQ0-3
*/


#define DDRD_N0_RX_CTL2_RANK_5_MC_DDRIOMC_REG 0x0822B054

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxdqsp_dly0 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ0. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly1 : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ1. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly2 : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ2. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly3 : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ3. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL2_RANK_5_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL2_RANK_6_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b058)                                                      */
/*      SPRB0 (0x2001b058)                                                      */
/*      SPRHBM (0x2001b058)                                                     */
/*      SPRC0 (0x2001b058)                                                      */
/*      SPRMCC (0x2001b058)                                                     */
/*      SPRUCC (0x2001b058)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control For DFE, RX DQSP delay for DQ0-3
*/


#define DDRD_N0_RX_CTL2_RANK_6_MC_DDRIOMC_REG 0x0822B058

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxdqsp_dly0 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ0. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly1 : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ1. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly2 : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ2. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly3 : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ3. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL2_RANK_6_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL2_RANK_7_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b05c)                                                      */
/*      SPRB0 (0x2001b05c)                                                      */
/*      SPRHBM (0x2001b05c)                                                     */
/*      SPRC0 (0x2001b05c)                                                      */
/*      SPRMCC (0x2001b05c)                                                     */
/*      SPRUCC (0x2001b05c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control For DFE, RX DQSP delay for DQ0-3
*/


#define DDRD_N0_RX_CTL2_RANK_7_MC_DDRIOMC_REG 0x0822B05C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxdqsp_dly0 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ0. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly1 : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ1. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly2 : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ2. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_dly3 : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Per bit rxdqsp delay control to add on to
                               rxdqsp_dly to delay DQS_P to match on DQ3. [br]
                               The range is 0 to 0.25 dclk with step size
                               clkpi/128. [br] Note: BIOS must make sure the
                               total delay not more than 1.375 dclk.
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL2_RANK_7_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DFE_COEFF_OFFSET0_RANK_0_MC_DDRIOMC_REG supported on:                */
/*      SPRA0 (0x2001b060)                                                      */
/*      SPRB0 (0x2001b060)                                                      */
/*      SPRHBM (0x2001b060)                                                     */
/*      SPRC0 (0x2001b060)                                                      */
/*      SPRMCC (0x2001b060)                                                     */
/*      SPRUCC (0x2001b060)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank DFE per bit offset0 (Only for DDR5, so suuport up to 4 rank)
*/


#define DDRD_N0_DFE_COEFF_OFFSET0_RANK_0_MC_DDRIOMC_REG 0x0822B060

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfe_c1_offset0 : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C1 offset for DQ0. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c1_offset1 : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C1 offset for DQ1. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c1_offset2 : 3;

                            /* Bits[8:6], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C1 offset for DQ2. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c1_offset3 : 3;

                            /* Bits[11:9], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C1 offset for DQ3. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c2_offset0 : 3;

                            /* Bits[14:12], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C2 offset for DQ0. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c2_offset1 : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C2 offset for DQ1. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c2_offset2 : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C2 offset for DQ2. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c2_offset3 : 3;

                            /* Bits[23:21], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C2 offset for DQ3. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFE_COEFF_OFFSET0_RANK_0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DFE_COEFF_OFFSET0_RANK_1_MC_DDRIOMC_REG supported on:                */
/*      SPRA0 (0x2001b064)                                                      */
/*      SPRB0 (0x2001b064)                                                      */
/*      SPRHBM (0x2001b064)                                                     */
/*      SPRC0 (0x2001b064)                                                      */
/*      SPRMCC (0x2001b064)                                                     */
/*      SPRUCC (0x2001b064)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank DFE per bit offset0 (Only for DDR5, so suuport up to 4 rank)
*/


#define DDRD_N0_DFE_COEFF_OFFSET0_RANK_1_MC_DDRIOMC_REG 0x0822B064

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfe_c1_offset0 : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C1 offset for DQ0. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c1_offset1 : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C1 offset for DQ1. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c1_offset2 : 3;

                            /* Bits[8:6], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C1 offset for DQ2. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c1_offset3 : 3;

                            /* Bits[11:9], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C1 offset for DQ3. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c2_offset0 : 3;

                            /* Bits[14:12], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C2 offset for DQ0. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c2_offset1 : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C2 offset for DQ1. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c2_offset2 : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C2 offset for DQ2. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c2_offset3 : 3;

                            /* Bits[23:21], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C2 offset for DQ3. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFE_COEFF_OFFSET0_RANK_1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DFE_COEFF_OFFSET0_RANK_2_MC_DDRIOMC_REG supported on:                */
/*      SPRA0 (0x2001b068)                                                      */
/*      SPRB0 (0x2001b068)                                                      */
/*      SPRHBM (0x2001b068)                                                     */
/*      SPRC0 (0x2001b068)                                                      */
/*      SPRMCC (0x2001b068)                                                     */
/*      SPRUCC (0x2001b068)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank DFE per bit offset0 (Only for DDR5, so suuport up to 4 rank)
*/


#define DDRD_N0_DFE_COEFF_OFFSET0_RANK_2_MC_DDRIOMC_REG 0x0822B068

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfe_c1_offset0 : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C1 offset for DQ0. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c1_offset1 : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C1 offset for DQ1. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c1_offset2 : 3;

                            /* Bits[8:6], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C1 offset for DQ2. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c1_offset3 : 3;

                            /* Bits[11:9], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C1 offset for DQ3. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c2_offset0 : 3;

                            /* Bits[14:12], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C2 offset for DQ0. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c2_offset1 : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C2 offset for DQ1. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c2_offset2 : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C2 offset for DQ2. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c2_offset3 : 3;

                            /* Bits[23:21], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C2 offset for DQ3. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFE_COEFF_OFFSET0_RANK_2_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DFE_COEFF_OFFSET0_RANK_3_MC_DDRIOMC_REG supported on:                */
/*      SPRA0 (0x2001b06c)                                                      */
/*      SPRB0 (0x2001b06c)                                                      */
/*      SPRHBM (0x2001b06c)                                                     */
/*      SPRC0 (0x2001b06c)                                                      */
/*      SPRMCC (0x2001b06c)                                                     */
/*      SPRUCC (0x2001b06c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank DFE per bit offset0 (Only for DDR5, so suuport up to 4 rank)
*/


#define DDRD_N0_DFE_COEFF_OFFSET0_RANK_3_MC_DDRIOMC_REG 0x0822B06C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfe_c1_offset0 : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C1 offset for DQ0. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c1_offset1 : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C1 offset for DQ1. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c1_offset2 : 3;

                            /* Bits[8:6], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C1 offset for DQ2. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c1_offset3 : 3;

                            /* Bits[11:9], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C1 offset for DQ3. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c2_offset0 : 3;

                            /* Bits[14:12], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C2 offset for DQ0. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c2_offset1 : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C2 offset for DQ1. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c2_offset2 : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C2 offset for DQ2. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c2_offset3 : 3;

                            /* Bits[23:21], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C2 offset for DQ3. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFE_COEFF_OFFSET0_RANK_3_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DFE_COEFF_OFFSET1_RANK_0_MC_DDRIOMC_REG supported on:                */
/*      SPRA0 (0x2001b070)                                                      */
/*      SPRB0 (0x2001b070)                                                      */
/*      SPRHBM (0x2001b070)                                                     */
/*      SPRC0 (0x2001b070)                                                      */
/*      SPRMCC (0x2001b070)                                                     */
/*      SPRUCC (0x2001b070)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank DFE per bit offset1 (Only for DDR5, so suuport up to 4 rank)
*/


#define DDRD_N0_DFE_COEFF_OFFSET1_RANK_0_MC_DDRIOMC_REG 0x0822B070

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfe_c3_offset0 : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C3 offset for DQ0. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c3_offset1 : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C3 offset for DQ1. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c3_offset2 : 3;

                            /* Bits[8:6], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C3 offset for DQ2. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c3_offset3 : 3;

                            /* Bits[11:9], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C3 offset for DQ3. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c4_offset0 : 3;

                            /* Bits[14:12], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C4 offset for DQ0. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c4_offset1 : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C4 offset for DQ1. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c4_offset2 : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C4 offset for DQ2. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c4_offset3 : 3;

                            /* Bits[23:21], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C4 offset for DQ3. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFE_COEFF_OFFSET1_RANK_0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DFE_COEFF_OFFSET1_RANK_1_MC_DDRIOMC_REG supported on:                */
/*      SPRA0 (0x2001b074)                                                      */
/*      SPRB0 (0x2001b074)                                                      */
/*      SPRHBM (0x2001b074)                                                     */
/*      SPRC0 (0x2001b074)                                                      */
/*      SPRMCC (0x2001b074)                                                     */
/*      SPRUCC (0x2001b074)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank DFE per bit offset1 (Only for DDR5, so suuport up to 4 rank)
*/


#define DDRD_N0_DFE_COEFF_OFFSET1_RANK_1_MC_DDRIOMC_REG 0x0822B074

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfe_c3_offset0 : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C3 offset for DQ0. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c3_offset1 : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C3 offset for DQ1. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c3_offset2 : 3;

                            /* Bits[8:6], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C3 offset for DQ2. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c3_offset3 : 3;

                            /* Bits[11:9], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C3 offset for DQ3. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c4_offset0 : 3;

                            /* Bits[14:12], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C4 offset for DQ0. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c4_offset1 : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C4 offset for DQ1. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c4_offset2 : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C4 offset for DQ2. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c4_offset3 : 3;

                            /* Bits[23:21], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C4 offset for DQ3. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFE_COEFF_OFFSET1_RANK_1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DFE_COEFF_OFFSET1_RANK_2_MC_DDRIOMC_REG supported on:                */
/*      SPRA0 (0x2001b078)                                                      */
/*      SPRB0 (0x2001b078)                                                      */
/*      SPRHBM (0x2001b078)                                                     */
/*      SPRC0 (0x2001b078)                                                      */
/*      SPRMCC (0x2001b078)                                                     */
/*      SPRUCC (0x2001b078)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank DFE per bit offset1 (Only for DDR5, so suuport up to 4 rank)
*/


#define DDRD_N0_DFE_COEFF_OFFSET1_RANK_2_MC_DDRIOMC_REG 0x0822B078

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfe_c3_offset0 : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C3 offset for DQ0. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c3_offset1 : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C3 offset for DQ1. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c3_offset2 : 3;

                            /* Bits[8:6], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C3 offset for DQ2. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c3_offset3 : 3;

                            /* Bits[11:9], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C3 offset for DQ3. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c4_offset0 : 3;

                            /* Bits[14:12], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C4 offset for DQ0. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c4_offset1 : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C4 offset for DQ1. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c4_offset2 : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C4 offset for DQ2. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c4_offset3 : 3;

                            /* Bits[23:21], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C4 offset for DQ3. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFE_COEFF_OFFSET1_RANK_2_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DFE_COEFF_OFFSET1_RANK_3_MC_DDRIOMC_REG supported on:                */
/*      SPRA0 (0x2001b07c)                                                      */
/*      SPRB0 (0x2001b07c)                                                      */
/*      SPRHBM (0x2001b07c)                                                     */
/*      SPRC0 (0x2001b07c)                                                      */
/*      SPRMCC (0x2001b07c)                                                     */
/*      SPRUCC (0x2001b07c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank DFE per bit offset1 (Only for DDR5, so suuport up to 4 rank)
*/


#define DDRD_N0_DFE_COEFF_OFFSET1_RANK_3_MC_DDRIOMC_REG 0x0822B07C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfe_c3_offset0 : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C3 offset for DQ0. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c3_offset1 : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C3 offset for DQ1. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c3_offset2 : 3;

                            /* Bits[8:6], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C3 offset for DQ2. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c3_offset3 : 3;

                            /* Bits[11:9], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C3 offset for DQ3. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c4_offset0 : 3;

                            /* Bits[14:12], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C4 offset for DQ0. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c4_offset1 : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C4 offset for DQ1. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c4_offset2 : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C4 offset for DQ2. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 dfe_c4_offset3 : 3;

                            /* Bits[23:21], Access Type=RW, default=0x00000000*/

                            /*
                               DFE C4 offset for DQ3. It is a positive
                               adjustment. BIOS will train to min value.
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFE_COEFF_OFFSET1_RANK_3_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL0_RANK_0_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b080)                                                      */
/*      SPRB0 (0x2001b080)                                                      */
/*      SPRHBM (0x2001b080)                                                     */
/*      SPRC0 (0x2001b080)                                                      */
/*      SPRMCC (0x2001b080)                                                     */
/*      SPRUCC (0x2001b080)                                                     */
/* Register default value on SPRA0: 0x00020000                                  */
/* Register default value on SPRB0: 0x00020000                                  */
/* Register default value on SPRHBM: 0x00020000                                 */
/* Register default value on SPRC0: 0x00020000                                  */
/* Register default value on SPRMCC: 0x00020000                                 */
/* Register default value on SPRUCC: 0x00020000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for 1st/2nd TX EQ Tap, TXDQS delay
*/


#define DDRD_N0_TX_CTL0_RANK_0_MC_DDRIOMC_REG 0x0822B080

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdqs_dly : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQS delay control. The range is 0 to 16 UI
                               with step size of clkpi/128. [br] DDR4 range is
                               < 10UI. (max of 4 logic delay) [br] DDR5 range
                               is < 16UI. (max of 7 logic delay) [br] 10:7 - It
                               is used for logic delay.[br] 6:0 - The lower 7
                               bit is added with txdqs_piref_offset and
                               piref_setup_adj, so the programed value is
                               relative to the piref clock. Then The result is
                               the txdqs pi odd code (txdqs_pio_code) that sent
                               to the txdqs crossover logic and DLL. Note: bit
                               6 (MSB) is inverted before the addition, so the
                               delay see by BIOS is linear.[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdqs_pie_offset : 7;

                            /* Bits[17:11], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdqs_pio_code . The
                               result is the txdqs pi even code
                               (txdqs_pie_code) to DLL.. Default value is 64.
                            */
    UINT32 rsvd : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txeq_2nd_tap : 4;

                            /* Bits[22:19], Access Type=RW, default=0x00000000*/

                            /*
                               TxEQ 2nd tap coefficient.The following list all
                               the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_2nd_tap:
                               0,1,2,3,4,5,6,7,12,13,14,15
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txeq_1st_tap : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000000*/

                            /*
                               TxEQ 1st tap coefficient. The following list all
                               the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_1st_tap: 0,1,2,3,4,5,6,
                               7,12,13,14,15,28,29,30,31,60,61,62,63
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL0_RANK_0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL0_RANK_1_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b084)                                                      */
/*      SPRB0 (0x2001b084)                                                      */
/*      SPRHBM (0x2001b084)                                                     */
/*      SPRC0 (0x2001b084)                                                      */
/*      SPRMCC (0x2001b084)                                                     */
/*      SPRUCC (0x2001b084)                                                     */
/* Register default value on SPRA0: 0x00020000                                  */
/* Register default value on SPRB0: 0x00020000                                  */
/* Register default value on SPRHBM: 0x00020000                                 */
/* Register default value on SPRC0: 0x00020000                                  */
/* Register default value on SPRMCC: 0x00020000                                 */
/* Register default value on SPRUCC: 0x00020000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for 1st/2nd TX EQ Tap, TXDQS delay
*/


#define DDRD_N0_TX_CTL0_RANK_1_MC_DDRIOMC_REG 0x0822B084

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdqs_dly : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQS delay control. The range is 0 to 16 UI
                               with step size of clkpi/128. [br] DDR4 range is
                               < 10UI. (max of 4 logic delay) [br] DDR5 range
                               is < 16UI. (max of 7 logic delay) [br] 10:7 - It
                               is used for logic delay.[br] 6:0 - The lower 7
                               bit is added with txdqs_piref_offset and
                               piref_setup_adj, so the programed value is
                               relative to the piref clock. Then The result is
                               the txdqs pi odd code (txdqs_pio_code) that sent
                               to the txdqs crossover logic and DLL. Note: bit
                               6 (MSB) is inverted before the addition, so the
                               delay see by BIOS is linear.[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdqs_pie_offset : 7;

                            /* Bits[17:11], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdqs_pio_code . The
                               result is the txdqs pi even code
                               (txdqs_pie_code) to DLL.. Default value is 64.
                            */
    UINT32 rsvd : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txeq_2nd_tap : 4;

                            /* Bits[22:19], Access Type=RW, default=0x00000000*/

                            /*
                               TxEQ 2nd tap coefficient.The following list all
                               the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_2nd_tap:
                               0,1,2,3,4,5,6,7,12,13,14,15
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txeq_1st_tap : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000000*/

                            /*
                               TxEQ 1st tap coefficient. The following list all
                               the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_1st_tap: 0,1,2,3,4,5,6,
                               7,12,13,14,15,28,29,30,31,60,61,62,63
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL0_RANK_1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL0_RANK_2_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b088)                                                      */
/*      SPRB0 (0x2001b088)                                                      */
/*      SPRHBM (0x2001b088)                                                     */
/*      SPRC0 (0x2001b088)                                                      */
/*      SPRMCC (0x2001b088)                                                     */
/*      SPRUCC (0x2001b088)                                                     */
/* Register default value on SPRA0: 0x00020000                                  */
/* Register default value on SPRB0: 0x00020000                                  */
/* Register default value on SPRHBM: 0x00020000                                 */
/* Register default value on SPRC0: 0x00020000                                  */
/* Register default value on SPRMCC: 0x00020000                                 */
/* Register default value on SPRUCC: 0x00020000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for 1st/2nd TX EQ Tap, TXDQS delay
*/


#define DDRD_N0_TX_CTL0_RANK_2_MC_DDRIOMC_REG 0x0822B088

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdqs_dly : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQS delay control. The range is 0 to 16 UI
                               with step size of clkpi/128. [br] DDR4 range is
                               < 10UI. (max of 4 logic delay) [br] DDR5 range
                               is < 16UI. (max of 7 logic delay) [br] 10:7 - It
                               is used for logic delay.[br] 6:0 - The lower 7
                               bit is added with txdqs_piref_offset and
                               piref_setup_adj, so the programed value is
                               relative to the piref clock. Then The result is
                               the txdqs pi odd code (txdqs_pio_code) that sent
                               to the txdqs crossover logic and DLL. Note: bit
                               6 (MSB) is inverted before the addition, so the
                               delay see by BIOS is linear.[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdqs_pie_offset : 7;

                            /* Bits[17:11], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdqs_pio_code . The
                               result is the txdqs pi even code
                               (txdqs_pie_code) to DLL.. Default value is 64.
                            */
    UINT32 rsvd : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txeq_2nd_tap : 4;

                            /* Bits[22:19], Access Type=RW, default=0x00000000*/

                            /*
                               TxEQ 2nd tap coefficient.The following list all
                               the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_2nd_tap:
                               0,1,2,3,4,5,6,7,12,13,14,15
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txeq_1st_tap : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000000*/

                            /*
                               TxEQ 1st tap coefficient. The following list all
                               the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_1st_tap: 0,1,2,3,4,5,6,
                               7,12,13,14,15,28,29,30,31,60,61,62,63
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL0_RANK_2_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL0_RANK_3_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b08c)                                                      */
/*      SPRB0 (0x2001b08c)                                                      */
/*      SPRHBM (0x2001b08c)                                                     */
/*      SPRC0 (0x2001b08c)                                                      */
/*      SPRMCC (0x2001b08c)                                                     */
/*      SPRUCC (0x2001b08c)                                                     */
/* Register default value on SPRA0: 0x00020000                                  */
/* Register default value on SPRB0: 0x00020000                                  */
/* Register default value on SPRHBM: 0x00020000                                 */
/* Register default value on SPRC0: 0x00020000                                  */
/* Register default value on SPRMCC: 0x00020000                                 */
/* Register default value on SPRUCC: 0x00020000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for 1st/2nd TX EQ Tap, TXDQS delay
*/


#define DDRD_N0_TX_CTL0_RANK_3_MC_DDRIOMC_REG 0x0822B08C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdqs_dly : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQS delay control. The range is 0 to 16 UI
                               with step size of clkpi/128. [br] DDR4 range is
                               < 10UI. (max of 4 logic delay) [br] DDR5 range
                               is < 16UI. (max of 7 logic delay) [br] 10:7 - It
                               is used for logic delay.[br] 6:0 - The lower 7
                               bit is added with txdqs_piref_offset and
                               piref_setup_adj, so the programed value is
                               relative to the piref clock. Then The result is
                               the txdqs pi odd code (txdqs_pio_code) that sent
                               to the txdqs crossover logic and DLL. Note: bit
                               6 (MSB) is inverted before the addition, so the
                               delay see by BIOS is linear.[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdqs_pie_offset : 7;

                            /* Bits[17:11], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdqs_pio_code . The
                               result is the txdqs pi even code
                               (txdqs_pie_code) to DLL.. Default value is 64.
                            */
    UINT32 rsvd : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txeq_2nd_tap : 4;

                            /* Bits[22:19], Access Type=RW, default=0x00000000*/

                            /*
                               TxEQ 2nd tap coefficient.The following list all
                               the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_2nd_tap:
                               0,1,2,3,4,5,6,7,12,13,14,15
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txeq_1st_tap : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000000*/

                            /*
                               TxEQ 1st tap coefficient. The following list all
                               the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_1st_tap: 0,1,2,3,4,5,6,
                               7,12,13,14,15,28,29,30,31,60,61,62,63
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL0_RANK_3_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL0_RANK_4_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b090)                                                      */
/*      SPRB0 (0x2001b090)                                                      */
/*      SPRHBM (0x2001b090)                                                     */
/*      SPRC0 (0x2001b090)                                                      */
/*      SPRMCC (0x2001b090)                                                     */
/*      SPRUCC (0x2001b090)                                                     */
/* Register default value on SPRA0: 0x00020000                                  */
/* Register default value on SPRB0: 0x00020000                                  */
/* Register default value on SPRHBM: 0x00020000                                 */
/* Register default value on SPRC0: 0x00020000                                  */
/* Register default value on SPRMCC: 0x00020000                                 */
/* Register default value on SPRUCC: 0x00020000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for 1st/2nd TX EQ Tap, TXDQS delay
*/


#define DDRD_N0_TX_CTL0_RANK_4_MC_DDRIOMC_REG 0x0822B090

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdqs_dly : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQS delay control. The range is 0 to 16 UI
                               with step size of clkpi/128. [br] DDR4 range is
                               < 10UI. (max of 4 logic delay) [br] DDR5 range
                               is < 16UI. (max of 7 logic delay) [br] 10:7 - It
                               is used for logic delay.[br] 6:0 - The lower 7
                               bit is added with txdqs_piref_offset and
                               piref_setup_adj, so the programed value is
                               relative to the piref clock. Then The result is
                               the txdqs pi odd code (txdqs_pio_code) that sent
                               to the txdqs crossover logic and DLL. Note: bit
                               6 (MSB) is inverted before the addition, so the
                               delay see by BIOS is linear.[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdqs_pie_offset : 7;

                            /* Bits[17:11], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdqs_pio_code . The
                               result is the txdqs pi even code
                               (txdqs_pie_code) to DLL.. Default value is 64.
                            */
    UINT32 rsvd : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txeq_2nd_tap : 4;

                            /* Bits[22:19], Access Type=RW, default=0x00000000*/

                            /*
                               TxEQ 2nd tap coefficient.The following list all
                               the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_2nd_tap:
                               0,1,2,3,4,5,6,7,12,13,14,15
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txeq_1st_tap : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000000*/

                            /*
                               TxEQ 1st tap coefficient. The following list all
                               the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_1st_tap: 0,1,2,3,4,5,6,
                               7,12,13,14,15,28,29,30,31,60,61,62,63
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL0_RANK_4_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL0_RANK_5_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b094)                                                      */
/*      SPRB0 (0x2001b094)                                                      */
/*      SPRHBM (0x2001b094)                                                     */
/*      SPRC0 (0x2001b094)                                                      */
/*      SPRMCC (0x2001b094)                                                     */
/*      SPRUCC (0x2001b094)                                                     */
/* Register default value on SPRA0: 0x00020000                                  */
/* Register default value on SPRB0: 0x00020000                                  */
/* Register default value on SPRHBM: 0x00020000                                 */
/* Register default value on SPRC0: 0x00020000                                  */
/* Register default value on SPRMCC: 0x00020000                                 */
/* Register default value on SPRUCC: 0x00020000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for 1st/2nd TX EQ Tap, TXDQS delay
*/


#define DDRD_N0_TX_CTL0_RANK_5_MC_DDRIOMC_REG 0x0822B094

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdqs_dly : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQS delay control. The range is 0 to 16 UI
                               with step size of clkpi/128. [br] DDR4 range is
                               < 10UI. (max of 4 logic delay) [br] DDR5 range
                               is < 16UI. (max of 7 logic delay) [br] 10:7 - It
                               is used for logic delay.[br] 6:0 - The lower 7
                               bit is added with txdqs_piref_offset and
                               piref_setup_adj, so the programed value is
                               relative to the piref clock. Then The result is
                               the txdqs pi odd code (txdqs_pio_code) that sent
                               to the txdqs crossover logic and DLL. Note: bit
                               6 (MSB) is inverted before the addition, so the
                               delay see by BIOS is linear.[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdqs_pie_offset : 7;

                            /* Bits[17:11], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdqs_pio_code . The
                               result is the txdqs pi even code
                               (txdqs_pie_code) to DLL.. Default value is 64.
                            */
    UINT32 rsvd : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txeq_2nd_tap : 4;

                            /* Bits[22:19], Access Type=RW, default=0x00000000*/

                            /*
                               TxEQ 2nd tap coefficient.The following list all
                               the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_2nd_tap:
                               0,1,2,3,4,5,6,7,12,13,14,15
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txeq_1st_tap : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000000*/

                            /*
                               TxEQ 1st tap coefficient. The following list all
                               the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_1st_tap: 0,1,2,3,4,5,6,
                               7,12,13,14,15,28,29,30,31,60,61,62,63
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL0_RANK_5_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL0_RANK_6_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b098)                                                      */
/*      SPRB0 (0x2001b098)                                                      */
/*      SPRHBM (0x2001b098)                                                     */
/*      SPRC0 (0x2001b098)                                                      */
/*      SPRMCC (0x2001b098)                                                     */
/*      SPRUCC (0x2001b098)                                                     */
/* Register default value on SPRA0: 0x00020000                                  */
/* Register default value on SPRB0: 0x00020000                                  */
/* Register default value on SPRHBM: 0x00020000                                 */
/* Register default value on SPRC0: 0x00020000                                  */
/* Register default value on SPRMCC: 0x00020000                                 */
/* Register default value on SPRUCC: 0x00020000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for 1st/2nd TX EQ Tap, TXDQS delay
*/


#define DDRD_N0_TX_CTL0_RANK_6_MC_DDRIOMC_REG 0x0822B098

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdqs_dly : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQS delay control. The range is 0 to 16 UI
                               with step size of clkpi/128. [br] DDR4 range is
                               < 10UI. (max of 4 logic delay) [br] DDR5 range
                               is < 16UI. (max of 7 logic delay) [br] 10:7 - It
                               is used for logic delay.[br] 6:0 - The lower 7
                               bit is added with txdqs_piref_offset and
                               piref_setup_adj, so the programed value is
                               relative to the piref clock. Then The result is
                               the txdqs pi odd code (txdqs_pio_code) that sent
                               to the txdqs crossover logic and DLL. Note: bit
                               6 (MSB) is inverted before the addition, so the
                               delay see by BIOS is linear.[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdqs_pie_offset : 7;

                            /* Bits[17:11], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdqs_pio_code . The
                               result is the txdqs pi even code
                               (txdqs_pie_code) to DLL.. Default value is 64.
                            */
    UINT32 rsvd : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txeq_2nd_tap : 4;

                            /* Bits[22:19], Access Type=RW, default=0x00000000*/

                            /*
                               TxEQ 2nd tap coefficient.The following list all
                               the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_2nd_tap:
                               0,1,2,3,4,5,6,7,12,13,14,15
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txeq_1st_tap : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000000*/

                            /*
                               TxEQ 1st tap coefficient. The following list all
                               the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_1st_tap: 0,1,2,3,4,5,6,
                               7,12,13,14,15,28,29,30,31,60,61,62,63
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL0_RANK_6_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL0_RANK_7_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b09c)                                                      */
/*      SPRB0 (0x2001b09c)                                                      */
/*      SPRHBM (0x2001b09c)                                                     */
/*      SPRC0 (0x2001b09c)                                                      */
/*      SPRMCC (0x2001b09c)                                                     */
/*      SPRUCC (0x2001b09c)                                                     */
/* Register default value on SPRA0: 0x00020000                                  */
/* Register default value on SPRB0: 0x00020000                                  */
/* Register default value on SPRHBM: 0x00020000                                 */
/* Register default value on SPRC0: 0x00020000                                  */
/* Register default value on SPRMCC: 0x00020000                                 */
/* Register default value on SPRUCC: 0x00020000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for 1st/2nd TX EQ Tap, TXDQS delay
*/


#define DDRD_N0_TX_CTL0_RANK_7_MC_DDRIOMC_REG 0x0822B09C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdqs_dly : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQS delay control. The range is 0 to 16 UI
                               with step size of clkpi/128. [br] DDR4 range is
                               < 10UI. (max of 4 logic delay) [br] DDR5 range
                               is < 16UI. (max of 7 logic delay) [br] 10:7 - It
                               is used for logic delay.[br] 6:0 - The lower 7
                               bit is added with txdqs_piref_offset and
                               piref_setup_adj, so the programed value is
                               relative to the piref clock. Then The result is
                               the txdqs pi odd code (txdqs_pio_code) that sent
                               to the txdqs crossover logic and DLL. Note: bit
                               6 (MSB) is inverted before the addition, so the
                               delay see by BIOS is linear.[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdqs_pie_offset : 7;

                            /* Bits[17:11], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdqs_pio_code . The
                               result is the txdqs pi even code
                               (txdqs_pie_code) to DLL.. Default value is 64.
                            */
    UINT32 rsvd : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txeq_2nd_tap : 4;

                            /* Bits[22:19], Access Type=RW, default=0x00000000*/

                            /*
                               TxEQ 2nd tap coefficient.The following list all
                               the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_2nd_tap:
                               0,1,2,3,4,5,6,7,12,13,14,15
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txeq_1st_tap : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000000*/

                            /*
                               TxEQ 1st tap coefficient. The following list all
                               the legal programming values. During TxEQ
                               training BIOS should sweep the following codes
                               in accending order: txeq_1st_tap: 0,1,2,3,4,5,6,
                               7,12,13,14,15,28,29,30,31,60,61,62,63
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL0_RANK_7_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL1_RANK_0_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b0a0)                                                      */
/*      SPRB0 (0x2001b0a0)                                                      */
/*      SPRHBM (0x2001b0a0)                                                     */
/*      SPRC0 (0x2001b0a0)                                                      */
/*      SPRMCC (0x2001b0a0)                                                     */
/*      SPRUCC (0x2001b0a0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for PXC delta, TXDQ delay for DQ0-1
*/


#define DDRD_N0_TX_CTL1_RANK_0_MC_DDRIOMC_REG 0x0822B0A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_dly0 : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 0 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdq_dly1 : 11;

                            /* Bits[21:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 1 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 pxc_delta0 : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ0 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta1 : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ1 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta2 : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ2 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta3 : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ3 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL1_RANK_0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL1_RANK_1_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b0a4)                                                      */
/*      SPRB0 (0x2001b0a4)                                                      */
/*      SPRHBM (0x2001b0a4)                                                     */
/*      SPRC0 (0x2001b0a4)                                                      */
/*      SPRMCC (0x2001b0a4)                                                     */
/*      SPRUCC (0x2001b0a4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for PXC delta, TXDQ delay for DQ0-1
*/


#define DDRD_N0_TX_CTL1_RANK_1_MC_DDRIOMC_REG 0x0822B0A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_dly0 : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 0 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdq_dly1 : 11;

                            /* Bits[21:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 1 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 pxc_delta0 : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ0 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta1 : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ1 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta2 : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ2 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta3 : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ3 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL1_RANK_1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL1_RANK_2_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b0a8)                                                      */
/*      SPRB0 (0x2001b0a8)                                                      */
/*      SPRHBM (0x2001b0a8)                                                     */
/*      SPRC0 (0x2001b0a8)                                                      */
/*      SPRMCC (0x2001b0a8)                                                     */
/*      SPRUCC (0x2001b0a8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for PXC delta, TXDQ delay for DQ0-1
*/


#define DDRD_N0_TX_CTL1_RANK_2_MC_DDRIOMC_REG 0x0822B0A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_dly0 : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 0 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdq_dly1 : 11;

                            /* Bits[21:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 1 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 pxc_delta0 : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ0 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta1 : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ1 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta2 : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ2 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta3 : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ3 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL1_RANK_2_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL1_RANK_3_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b0ac)                                                      */
/*      SPRB0 (0x2001b0ac)                                                      */
/*      SPRHBM (0x2001b0ac)                                                     */
/*      SPRC0 (0x2001b0ac)                                                      */
/*      SPRMCC (0x2001b0ac)                                                     */
/*      SPRUCC (0x2001b0ac)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for PXC delta, TXDQ delay for DQ0-1
*/


#define DDRD_N0_TX_CTL1_RANK_3_MC_DDRIOMC_REG 0x0822B0AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_dly0 : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 0 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdq_dly1 : 11;

                            /* Bits[21:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 1 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 pxc_delta0 : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ0 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta1 : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ1 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta2 : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ2 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta3 : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ3 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL1_RANK_3_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL1_RANK_4_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b0b0)                                                      */
/*      SPRB0 (0x2001b0b0)                                                      */
/*      SPRHBM (0x2001b0b0)                                                     */
/*      SPRC0 (0x2001b0b0)                                                      */
/*      SPRMCC (0x2001b0b0)                                                     */
/*      SPRUCC (0x2001b0b0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for PXC delta, TXDQ delay for DQ0-1
*/


#define DDRD_N0_TX_CTL1_RANK_4_MC_DDRIOMC_REG 0x0822B0B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_dly0 : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 0 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdq_dly1 : 11;

                            /* Bits[21:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 1 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 pxc_delta0 : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ0 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta1 : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ1 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta2 : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ2 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta3 : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ3 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL1_RANK_4_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL1_RANK_5_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b0b4)                                                      */
/*      SPRB0 (0x2001b0b4)                                                      */
/*      SPRHBM (0x2001b0b4)                                                     */
/*      SPRC0 (0x2001b0b4)                                                      */
/*      SPRMCC (0x2001b0b4)                                                     */
/*      SPRUCC (0x2001b0b4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for PXC delta, TXDQ delay for DQ0-1
*/


#define DDRD_N0_TX_CTL1_RANK_5_MC_DDRIOMC_REG 0x0822B0B4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_dly0 : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 0 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdq_dly1 : 11;

                            /* Bits[21:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 1 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 pxc_delta0 : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ0 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta1 : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ1 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta2 : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ2 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta3 : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ3 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL1_RANK_5_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL1_RANK_6_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b0b8)                                                      */
/*      SPRB0 (0x2001b0b8)                                                      */
/*      SPRHBM (0x2001b0b8)                                                     */
/*      SPRC0 (0x2001b0b8)                                                      */
/*      SPRMCC (0x2001b0b8)                                                     */
/*      SPRUCC (0x2001b0b8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for PXC delta, TXDQ delay for DQ0-1
*/


#define DDRD_N0_TX_CTL1_RANK_6_MC_DDRIOMC_REG 0x0822B0B8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_dly0 : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 0 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdq_dly1 : 11;

                            /* Bits[21:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 1 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 pxc_delta0 : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ0 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta1 : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ1 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta2 : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ2 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta3 : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ3 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL1_RANK_6_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL1_RANK_7_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b0bc)                                                      */
/*      SPRB0 (0x2001b0bc)                                                      */
/*      SPRHBM (0x2001b0bc)                                                     */
/*      SPRC0 (0x2001b0bc)                                                      */
/*      SPRMCC (0x2001b0bc)                                                     */
/*      SPRUCC (0x2001b0bc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for PXC delta, TXDQ delay for DQ0-1
*/


#define DDRD_N0_TX_CTL1_RANK_7_MC_DDRIOMC_REG 0x0822B0BC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_dly0 : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 0 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdq_dly1 : 11;

                            /* Bits[21:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 1 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 pxc_delta0 : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ0 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta1 : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ1 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta2 : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ2 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 pxc_delta3 : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               PXC delta for DQ3 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL1_RANK_7_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL2_RANK_0_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b0c0)                                                      */
/*      SPRB0 (0x2001b0c0)                                                      */
/*      SPRHBM (0x2001b0c0)                                                     */
/*      SPRC0 (0x2001b0c0)                                                      */
/*      SPRMCC (0x2001b0c0)                                                     */
/*      SPRUCC (0x2001b0c0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for DDJC delta, TXDQ delay for DQ2-3
*/


#define DDRD_N0_TX_CTL2_RANK_0_MC_DDRIOMC_REG 0x0822B0C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_dly2 : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 2 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdq_dly3 : 11;

                            /* Bits[21:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 3 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 ddjc_delta0 : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ0 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta1 : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ1 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta2 : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ2 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta3 : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ3 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL2_RANK_0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL2_RANK_1_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b0c4)                                                      */
/*      SPRB0 (0x2001b0c4)                                                      */
/*      SPRHBM (0x2001b0c4)                                                     */
/*      SPRC0 (0x2001b0c4)                                                      */
/*      SPRMCC (0x2001b0c4)                                                     */
/*      SPRUCC (0x2001b0c4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for DDJC delta, TXDQ delay for DQ2-3
*/


#define DDRD_N0_TX_CTL2_RANK_1_MC_DDRIOMC_REG 0x0822B0C4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_dly2 : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 2 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdq_dly3 : 11;

                            /* Bits[21:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 3 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 ddjc_delta0 : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ0 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta1 : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ1 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta2 : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ2 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta3 : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ3 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL2_RANK_1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL2_RANK_2_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b0c8)                                                      */
/*      SPRB0 (0x2001b0c8)                                                      */
/*      SPRHBM (0x2001b0c8)                                                     */
/*      SPRC0 (0x2001b0c8)                                                      */
/*      SPRMCC (0x2001b0c8)                                                     */
/*      SPRUCC (0x2001b0c8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for DDJC delta, TXDQ delay for DQ2-3
*/


#define DDRD_N0_TX_CTL2_RANK_2_MC_DDRIOMC_REG 0x0822B0C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_dly2 : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 2 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdq_dly3 : 11;

                            /* Bits[21:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 3 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 ddjc_delta0 : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ0 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta1 : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ1 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta2 : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ2 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta3 : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ3 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL2_RANK_2_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL2_RANK_3_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b0cc)                                                      */
/*      SPRB0 (0x2001b0cc)                                                      */
/*      SPRHBM (0x2001b0cc)                                                     */
/*      SPRC0 (0x2001b0cc)                                                      */
/*      SPRMCC (0x2001b0cc)                                                     */
/*      SPRUCC (0x2001b0cc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for DDJC delta, TXDQ delay for DQ2-3
*/


#define DDRD_N0_TX_CTL2_RANK_3_MC_DDRIOMC_REG 0x0822B0CC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_dly2 : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 2 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdq_dly3 : 11;

                            /* Bits[21:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 3 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 ddjc_delta0 : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ0 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta1 : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ1 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta2 : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ2 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta3 : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ3 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL2_RANK_3_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL2_RANK_4_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b0d0)                                                      */
/*      SPRB0 (0x2001b0d0)                                                      */
/*      SPRHBM (0x2001b0d0)                                                     */
/*      SPRC0 (0x2001b0d0)                                                      */
/*      SPRMCC (0x2001b0d0)                                                     */
/*      SPRUCC (0x2001b0d0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for DDJC delta, TXDQ delay for DQ2-3
*/


#define DDRD_N0_TX_CTL2_RANK_4_MC_DDRIOMC_REG 0x0822B0D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_dly2 : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 2 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdq_dly3 : 11;

                            /* Bits[21:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 3 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 ddjc_delta0 : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ0 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta1 : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ1 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta2 : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ2 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta3 : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ3 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL2_RANK_4_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL2_RANK_5_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b0d4)                                                      */
/*      SPRB0 (0x2001b0d4)                                                      */
/*      SPRHBM (0x2001b0d4)                                                     */
/*      SPRC0 (0x2001b0d4)                                                      */
/*      SPRMCC (0x2001b0d4)                                                     */
/*      SPRUCC (0x2001b0d4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for DDJC delta, TXDQ delay for DQ2-3
*/


#define DDRD_N0_TX_CTL2_RANK_5_MC_DDRIOMC_REG 0x0822B0D4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_dly2 : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 2 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdq_dly3 : 11;

                            /* Bits[21:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 3 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 ddjc_delta0 : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ0 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta1 : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ1 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta2 : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ2 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta3 : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ3 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL2_RANK_5_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL2_RANK_6_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b0d8)                                                      */
/*      SPRB0 (0x2001b0d8)                                                      */
/*      SPRHBM (0x2001b0d8)                                                     */
/*      SPRC0 (0x2001b0d8)                                                      */
/*      SPRMCC (0x2001b0d8)                                                     */
/*      SPRUCC (0x2001b0d8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for DDJC delta, TXDQ delay for DQ2-3
*/


#define DDRD_N0_TX_CTL2_RANK_6_MC_DDRIOMC_REG 0x0822B0D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_dly2 : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 2 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdq_dly3 : 11;

                            /* Bits[21:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 3 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 ddjc_delta0 : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ0 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta1 : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ1 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta2 : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ2 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta3 : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ3 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL2_RANK_6_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL2_RANK_7_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b0dc)                                                      */
/*      SPRB0 (0x2001b0dc)                                                      */
/*      SPRHBM (0x2001b0dc)                                                     */
/*      SPRC0 (0x2001b0dc)                                                      */
/*      SPRMCC (0x2001b0dc)                                                     */
/*      SPRUCC (0x2001b0dc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for DDJC delta, TXDQ delay for DQ2-3
*/


#define DDRD_N0_TX_CTL2_RANK_7_MC_DDRIOMC_REG 0x0822B0DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_dly2 : 11;

                            /* Bits[10:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 2 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 txdq_dly3 : 11;

                            /* Bits[21:11], Access Type=RW/V, default=0x00000000*/

                            /*
                               Write DQ 3 delay control. The range is 0 to 16
                               UI with step size of clkpi/128.[br] DDR4 range
                               is < 10UI. (max of 4 logic delay) [br] DDR5
                               range is < 16UI. (max of 7 logic delay) [br]
                               This field is added with txdq_dly_adj to allow
                               BIOS for margining sweep (signed numer -128 to
                               127). It, also, adds with txrt_dq_dly_adj for tx
                               retraning (signed numer -64 to 63).[br] The
                               final delay - [br] 10:7 - is used for logic
                               delay[br] 6:0 - The lower 7 bit is added with
                               txdq_piref offset and piref_setup_adj, so the
                               programmed value is relative to the piref clock.
                               The result is the txdq pi odd code. [br] Note:
                               bit 6 (MSB) is inverted before the addition, so
                               the delay see by BIOS is linear.[br] This field
                               can be programmed by BIOS or HW cal FSM.
                            */
    UINT32 ddjc_delta0 : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ0 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta1 : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ1 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta2 : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ2 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 ddjc_delta3 : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               DDJC delta for DQ3 inside the nibble.[br] Note:
                               BIOS msut make sure the combine DDJC and PXC
                               delta value doesnt overflow or underflow the
                               analog logic support range.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL2_RANK_7_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_RETRAIN_RANK_0_MC_DDRIOMC_REG supported on:                       */
/*      SPRA0 (0x2001b0e0)                                                      */
/*      SPRB0 (0x2001b0e0)                                                      */
/*      SPRHBM (0x2001b0e0)                                                     */
/*      SPRC0 (0x2001b0e0)                                                      */
/*      SPRMCC (0x2001b0e0)                                                     */
/*      SPRUCC (0x2001b0e0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank TX Retrain
*/


#define DDRD_N0_TX_RETRAIN_RANK_0_MC_DDRIOMC_REG 0x0822B0E0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txrt_dq_dly_adj : 7;

                            /* Bits[6:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Tx Retraining DQ delay adjust value for all the
                               DQ bits. This field is updated by tx retraining
                               HW logic. The adjust range is -64 to 63
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txrt_init_picode : 10;

                            /* Bits[17:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               This is the initial MRC training unmatch DRAM
                               reciever delay in PI ticks with 1 fractional bit
                               (bit 0). It is used by HW logic to calculate the
                               txrt_dq_dly_adj for each retraining.[br] Note:
                               The attribte is RW/V to allow SW to write to
                               this field but we don't have any use case yet.
                            */
    UINT32 rsvd_18 : 12;

                            /* Bits[29:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txrt_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               TX retrain enable. It should be set for DDR5 and
                               not LRDIMM type to enable TX retraining.
                            */
    UINT32 txrt_adj_byte_sel : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Selects between the local byte or the adjacent
                               byte to generate the RO count for tx retraining
                               calculation. Used for x16 devices.[br] Note:
                               This control doesn't apply for ECC byte.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_RETRAIN_RANK_0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_RETRAIN_RANK_1_MC_DDRIOMC_REG supported on:                       */
/*      SPRA0 (0x2001b0e4)                                                      */
/*      SPRB0 (0x2001b0e4)                                                      */
/*      SPRHBM (0x2001b0e4)                                                     */
/*      SPRC0 (0x2001b0e4)                                                      */
/*      SPRMCC (0x2001b0e4)                                                     */
/*      SPRUCC (0x2001b0e4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank TX Retrain
*/


#define DDRD_N0_TX_RETRAIN_RANK_1_MC_DDRIOMC_REG 0x0822B0E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txrt_dq_dly_adj : 7;

                            /* Bits[6:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Tx Retraining DQ delay adjust value for all the
                               DQ bits. This field is updated by tx retraining
                               HW logic. The adjust range is -64 to 63
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txrt_init_picode : 10;

                            /* Bits[17:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               This is the initial MRC training unmatch DRAM
                               reciever delay in PI ticks with 1 fractional bit
                               (bit 0). It is used by HW logic to calculate the
                               txrt_dq_dly_adj for each retraining.[br] Note:
                               The attribte is RW/V to allow SW to write to
                               this field but we don't have any use case yet.
                            */
    UINT32 rsvd_18 : 12;

                            /* Bits[29:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txrt_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               TX retrain enable. It should be set for DDR5 and
                               not LRDIMM type to enable TX retraining.
                            */
    UINT32 txrt_adj_byte_sel : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Selects between the local byte or the adjacent
                               byte to generate the RO count for tx retraining
                               calculation. Used for x16 devices.[br] Note:
                               This control doesn't apply for ECC byte.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_RETRAIN_RANK_1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_RETRAIN_RANK_2_MC_DDRIOMC_REG supported on:                       */
/*      SPRA0 (0x2001b0e8)                                                      */
/*      SPRB0 (0x2001b0e8)                                                      */
/*      SPRHBM (0x2001b0e8)                                                     */
/*      SPRC0 (0x2001b0e8)                                                      */
/*      SPRMCC (0x2001b0e8)                                                     */
/*      SPRUCC (0x2001b0e8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank TX Retrain
*/


#define DDRD_N0_TX_RETRAIN_RANK_2_MC_DDRIOMC_REG 0x0822B0E8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txrt_dq_dly_adj : 7;

                            /* Bits[6:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Tx Retraining DQ delay adjust value for all the
                               DQ bits. This field is updated by tx retraining
                               HW logic. The adjust range is -64 to 63
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txrt_init_picode : 10;

                            /* Bits[17:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               This is the initial MRC training unmatch DRAM
                               reciever delay in PI ticks with 1 fractional bit
                               (bit 0). It is used by HW logic to calculate the
                               txrt_dq_dly_adj for each retraining.[br] Note:
                               The attribte is RW/V to allow SW to write to
                               this field but we don't have any use case yet.
                            */
    UINT32 rsvd_18 : 12;

                            /* Bits[29:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txrt_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               TX retrain enable. It should be set for DDR5 and
                               not LRDIMM type to enable TX retraining.
                            */
    UINT32 txrt_adj_byte_sel : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Selects between the local byte or the adjacent
                               byte to generate the RO count for tx retraining
                               calculation. Used for x16 devices.[br] Note:
                               This control doesn't apply for ECC byte.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_RETRAIN_RANK_2_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_RETRAIN_RANK_3_MC_DDRIOMC_REG supported on:                       */
/*      SPRA0 (0x2001b0ec)                                                      */
/*      SPRB0 (0x2001b0ec)                                                      */
/*      SPRHBM (0x2001b0ec)                                                     */
/*      SPRC0 (0x2001b0ec)                                                      */
/*      SPRMCC (0x2001b0ec)                                                     */
/*      SPRUCC (0x2001b0ec)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank TX Retrain
*/


#define DDRD_N0_TX_RETRAIN_RANK_3_MC_DDRIOMC_REG 0x0822B0EC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txrt_dq_dly_adj : 7;

                            /* Bits[6:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Tx Retraining DQ delay adjust value for all the
                               DQ bits. This field is updated by tx retraining
                               HW logic. The adjust range is -64 to 63
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txrt_init_picode : 10;

                            /* Bits[17:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               This is the initial MRC training unmatch DRAM
                               reciever delay in PI ticks with 1 fractional bit
                               (bit 0). It is used by HW logic to calculate the
                               txrt_dq_dly_adj for each retraining.[br] Note:
                               The attribte is RW/V to allow SW to write to
                               this field but we don't have any use case yet.
                            */
    UINT32 rsvd_18 : 12;

                            /* Bits[29:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txrt_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               TX retrain enable. It should be set for DDR5 and
                               not LRDIMM type to enable TX retraining.
                            */
    UINT32 txrt_adj_byte_sel : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Selects between the local byte or the adjacent
                               byte to generate the RO count for tx retraining
                               calculation. Used for x16 devices.[br] Note:
                               This control doesn't apply for ECC byte.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_RETRAIN_RANK_3_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_RETRAIN_RANK_4_MC_DDRIOMC_REG supported on:                       */
/*      SPRA0 (0x2001b0f0)                                                      */
/*      SPRB0 (0x2001b0f0)                                                      */
/*      SPRHBM (0x2001b0f0)                                                     */
/*      SPRC0 (0x2001b0f0)                                                      */
/*      SPRMCC (0x2001b0f0)                                                     */
/*      SPRUCC (0x2001b0f0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank TX Retrain
*/


#define DDRD_N0_TX_RETRAIN_RANK_4_MC_DDRIOMC_REG 0x0822B0F0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txrt_dq_dly_adj : 7;

                            /* Bits[6:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Tx Retraining DQ delay adjust value for all the
                               DQ bits. This field is updated by tx retraining
                               HW logic. The adjust range is -64 to 63
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txrt_init_picode : 10;

                            /* Bits[17:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               This is the initial MRC training unmatch DRAM
                               reciever delay in PI ticks with 1 fractional bit
                               (bit 0). It is used by HW logic to calculate the
                               txrt_dq_dly_adj for each retraining.[br] Note:
                               The attribte is RW/V to allow SW to write to
                               this field but we don't have any use case yet.
                            */
    UINT32 rsvd_18 : 12;

                            /* Bits[29:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txrt_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               TX retrain enable. It should be set for DDR5 and
                               not LRDIMM type to enable TX retraining.
                            */
    UINT32 txrt_adj_byte_sel : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Selects between the local byte or the adjacent
                               byte to generate the RO count for tx retraining
                               calculation. Used for x16 devices.[br] Note:
                               This control doesn't apply for ECC byte.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_RETRAIN_RANK_4_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_RETRAIN_RANK_5_MC_DDRIOMC_REG supported on:                       */
/*      SPRA0 (0x2001b0f4)                                                      */
/*      SPRB0 (0x2001b0f4)                                                      */
/*      SPRHBM (0x2001b0f4)                                                     */
/*      SPRC0 (0x2001b0f4)                                                      */
/*      SPRMCC (0x2001b0f4)                                                     */
/*      SPRUCC (0x2001b0f4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank TX Retrain
*/


#define DDRD_N0_TX_RETRAIN_RANK_5_MC_DDRIOMC_REG 0x0822B0F4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txrt_dq_dly_adj : 7;

                            /* Bits[6:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Tx Retraining DQ delay adjust value for all the
                               DQ bits. This field is updated by tx retraining
                               HW logic. The adjust range is -64 to 63
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txrt_init_picode : 10;

                            /* Bits[17:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               This is the initial MRC training unmatch DRAM
                               reciever delay in PI ticks with 1 fractional bit
                               (bit 0). It is used by HW logic to calculate the
                               txrt_dq_dly_adj for each retraining.[br] Note:
                               The attribte is RW/V to allow SW to write to
                               this field but we don't have any use case yet.
                            */
    UINT32 rsvd_18 : 12;

                            /* Bits[29:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txrt_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               TX retrain enable. It should be set for DDR5 and
                               not LRDIMM type to enable TX retraining.
                            */
    UINT32 txrt_adj_byte_sel : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Selects between the local byte or the adjacent
                               byte to generate the RO count for tx retraining
                               calculation. Used for x16 devices.[br] Note:
                               This control doesn't apply for ECC byte.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_RETRAIN_RANK_5_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_RETRAIN_RANK_6_MC_DDRIOMC_REG supported on:                       */
/*      SPRA0 (0x2001b0f8)                                                      */
/*      SPRB0 (0x2001b0f8)                                                      */
/*      SPRHBM (0x2001b0f8)                                                     */
/*      SPRC0 (0x2001b0f8)                                                      */
/*      SPRMCC (0x2001b0f8)                                                     */
/*      SPRUCC (0x2001b0f8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank TX Retrain
*/


#define DDRD_N0_TX_RETRAIN_RANK_6_MC_DDRIOMC_REG 0x0822B0F8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txrt_dq_dly_adj : 7;

                            /* Bits[6:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Tx Retraining DQ delay adjust value for all the
                               DQ bits. This field is updated by tx retraining
                               HW logic. The adjust range is -64 to 63
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txrt_init_picode : 10;

                            /* Bits[17:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               This is the initial MRC training unmatch DRAM
                               reciever delay in PI ticks with 1 fractional bit
                               (bit 0). It is used by HW logic to calculate the
                               txrt_dq_dly_adj for each retraining.[br] Note:
                               The attribte is RW/V to allow SW to write to
                               this field but we don't have any use case yet.
                            */
    UINT32 rsvd_18 : 12;

                            /* Bits[29:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txrt_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               TX retrain enable. It should be set for DDR5 and
                               not LRDIMM type to enable TX retraining.
                            */
    UINT32 txrt_adj_byte_sel : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Selects between the local byte or the adjacent
                               byte to generate the RO count for tx retraining
                               calculation. Used for x16 devices.[br] Note:
                               This control doesn't apply for ECC byte.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_RETRAIN_RANK_6_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_RETRAIN_RANK_7_MC_DDRIOMC_REG supported on:                       */
/*      SPRA0 (0x2001b0fc)                                                      */
/*      SPRB0 (0x2001b0fc)                                                      */
/*      SPRHBM (0x2001b0fc)                                                     */
/*      SPRC0 (0x2001b0fc)                                                      */
/*      SPRMCC (0x2001b0fc)                                                     */
/*      SPRUCC (0x2001b0fc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd0_type/ddrd0_n0_ch0/ddrd0_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank TX Retrain
*/


#define DDRD_N0_TX_RETRAIN_RANK_7_MC_DDRIOMC_REG 0x0822B0FC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txrt_dq_dly_adj : 7;

                            /* Bits[6:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Tx Retraining DQ delay adjust value for all the
                               DQ bits. This field is updated by tx retraining
                               HW logic. The adjust range is -64 to 63
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txrt_init_picode : 10;

                            /* Bits[17:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               This is the initial MRC training unmatch DRAM
                               reciever delay in PI ticks with 1 fractional bit
                               (bit 0). It is used by HW logic to calculate the
                               txrt_dq_dly_adj for each retraining.[br] Note:
                               The attribte is RW/V to allow SW to write to
                               this field but we don't have any use case yet.
                            */
    UINT32 rsvd_18 : 12;

                            /* Bits[29:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txrt_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               TX retrain enable. It should be set for DDR5 and
                               not LRDIMM type to enable TX retraining.
                            */
    UINT32 txrt_adj_byte_sel : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Selects between the local byte or the adjacent
                               byte to generate the RO count for tx retraining
                               calculation. Used for x16 devices.[br] Note:
                               This control doesn't apply for ECC byte.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_RETRAIN_RANK_7_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TXDQ_PIE_OFFSET_RANK_0_MC_DDRIOMC_REG supported on:                  */
/*      SPRA0 (0x2001b100)                                                      */
/*      SPRB0 (0x2001b100)                                                      */
/*      SPRHBM (0x2001b100)                                                     */
/*      SPRC0 (0x2001b100)                                                      */
/*      SPRMCC (0x2001b100)                                                     */
/*      SPRUCC (0x2001b100)                                                     */
/* Register default value on SPRA0: 0x08102040                                  */
/* Register default value on SPRB0: 0x08102040                                  */
/* Register default value on SPRHBM: 0x08102040                                 */
/* Register default value on SPRC0: 0x08102040                                  */
/* Register default value on SPRMCC: 0x08102040                                 */
/* Register default value on SPRUCC: 0x08102040                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank TXDQ PI Even offset
*/


#define DDRD_N0_TXDQ_PIE_OFFSET_RANK_0_MC_DDRIOMC_REG 0x0822B100

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_pie_offset0 : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code0. The
                               result is the txdq0 pi even code
                               (txdq_pie_code0) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset1 : 7;

                            /* Bits[13:7], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code1. The
                               result is the txdq1 pi even code
                               (txdq_pie_code1) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset2 : 7;

                            /* Bits[20:14], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code2. The
                               result is the txdq2 pi even code
                               (txdq_pie_code2) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset3 : 7;

                            /* Bits[27:21], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code3. The
                               result is the txdq3 pi even code
                               (txdq_pie_code3) to DLL.. Default value is 64.
                            */
    UINT32 rsvd : 3;

                            /* Bits[30:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 x8_device : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* x8 device enable */

  } Bits;
  UINT32 Data;

} DDRD_N0_TXDQ_PIE_OFFSET_RANK_0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TXDQ_PIE_OFFSET_RANK_1_MC_DDRIOMC_REG supported on:                  */
/*      SPRA0 (0x2001b104)                                                      */
/*      SPRB0 (0x2001b104)                                                      */
/*      SPRHBM (0x2001b104)                                                     */
/*      SPRC0 (0x2001b104)                                                      */
/*      SPRMCC (0x2001b104)                                                     */
/*      SPRUCC (0x2001b104)                                                     */
/* Register default value on SPRA0: 0x08102040                                  */
/* Register default value on SPRB0: 0x08102040                                  */
/* Register default value on SPRHBM: 0x08102040                                 */
/* Register default value on SPRC0: 0x08102040                                  */
/* Register default value on SPRMCC: 0x08102040                                 */
/* Register default value on SPRUCC: 0x08102040                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank TXDQ PI Even offset
*/


#define DDRD_N0_TXDQ_PIE_OFFSET_RANK_1_MC_DDRIOMC_REG 0x0822B104

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_pie_offset0 : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code0. The
                               result is the txdq0 pi even code
                               (txdq_pie_code0) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset1 : 7;

                            /* Bits[13:7], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code1. The
                               result is the txdq1 pi even code
                               (txdq_pie_code1) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset2 : 7;

                            /* Bits[20:14], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code2. The
                               result is the txdq2 pi even code
                               (txdq_pie_code2) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset3 : 7;

                            /* Bits[27:21], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code3. The
                               result is the txdq3 pi even code
                               (txdq_pie_code3) to DLL.. Default value is 64.
                            */
    UINT32 rsvd : 3;

                            /* Bits[30:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 x8_device : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* x8 device enable */

  } Bits;
  UINT32 Data;

} DDRD_N0_TXDQ_PIE_OFFSET_RANK_1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TXDQ_PIE_OFFSET_RANK_2_MC_DDRIOMC_REG supported on:                  */
/*      SPRA0 (0x2001b108)                                                      */
/*      SPRB0 (0x2001b108)                                                      */
/*      SPRHBM (0x2001b108)                                                     */
/*      SPRC0 (0x2001b108)                                                      */
/*      SPRMCC (0x2001b108)                                                     */
/*      SPRUCC (0x2001b108)                                                     */
/* Register default value on SPRA0: 0x08102040                                  */
/* Register default value on SPRB0: 0x08102040                                  */
/* Register default value on SPRHBM: 0x08102040                                 */
/* Register default value on SPRC0: 0x08102040                                  */
/* Register default value on SPRMCC: 0x08102040                                 */
/* Register default value on SPRUCC: 0x08102040                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank TXDQ PI Even offset
*/


#define DDRD_N0_TXDQ_PIE_OFFSET_RANK_2_MC_DDRIOMC_REG 0x0822B108

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_pie_offset0 : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code0. The
                               result is the txdq0 pi even code
                               (txdq_pie_code0) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset1 : 7;

                            /* Bits[13:7], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code1. The
                               result is the txdq1 pi even code
                               (txdq_pie_code1) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset2 : 7;

                            /* Bits[20:14], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code2. The
                               result is the txdq2 pi even code
                               (txdq_pie_code2) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset3 : 7;

                            /* Bits[27:21], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code3. The
                               result is the txdq3 pi even code
                               (txdq_pie_code3) to DLL.. Default value is 64.
                            */
    UINT32 rsvd : 3;

                            /* Bits[30:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 x8_device : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* x8 device enable */

  } Bits;
  UINT32 Data;

} DDRD_N0_TXDQ_PIE_OFFSET_RANK_2_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TXDQ_PIE_OFFSET_RANK_3_MC_DDRIOMC_REG supported on:                  */
/*      SPRA0 (0x2001b10c)                                                      */
/*      SPRB0 (0x2001b10c)                                                      */
/*      SPRHBM (0x2001b10c)                                                     */
/*      SPRC0 (0x2001b10c)                                                      */
/*      SPRMCC (0x2001b10c)                                                     */
/*      SPRUCC (0x2001b10c)                                                     */
/* Register default value on SPRA0: 0x08102040                                  */
/* Register default value on SPRB0: 0x08102040                                  */
/* Register default value on SPRHBM: 0x08102040                                 */
/* Register default value on SPRC0: 0x08102040                                  */
/* Register default value on SPRMCC: 0x08102040                                 */
/* Register default value on SPRUCC: 0x08102040                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank TXDQ PI Even offset
*/


#define DDRD_N0_TXDQ_PIE_OFFSET_RANK_3_MC_DDRIOMC_REG 0x0822B10C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_pie_offset0 : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code0. The
                               result is the txdq0 pi even code
                               (txdq_pie_code0) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset1 : 7;

                            /* Bits[13:7], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code1. The
                               result is the txdq1 pi even code
                               (txdq_pie_code1) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset2 : 7;

                            /* Bits[20:14], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code2. The
                               result is the txdq2 pi even code
                               (txdq_pie_code2) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset3 : 7;

                            /* Bits[27:21], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code3. The
                               result is the txdq3 pi even code
                               (txdq_pie_code3) to DLL.. Default value is 64.
                            */
    UINT32 rsvd : 3;

                            /* Bits[30:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 x8_device : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* x8 device enable */

  } Bits;
  UINT32 Data;

} DDRD_N0_TXDQ_PIE_OFFSET_RANK_3_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TXDQ_PIE_OFFSET_RANK_4_MC_DDRIOMC_REG supported on:                  */
/*      SPRA0 (0x2001b110)                                                      */
/*      SPRB0 (0x2001b110)                                                      */
/*      SPRHBM (0x2001b110)                                                     */
/*      SPRC0 (0x2001b110)                                                      */
/*      SPRMCC (0x2001b110)                                                     */
/*      SPRUCC (0x2001b110)                                                     */
/* Register default value on SPRA0: 0x08102040                                  */
/* Register default value on SPRB0: 0x08102040                                  */
/* Register default value on SPRHBM: 0x08102040                                 */
/* Register default value on SPRC0: 0x08102040                                  */
/* Register default value on SPRMCC: 0x08102040                                 */
/* Register default value on SPRUCC: 0x08102040                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank TXDQ PI Even offset
*/


#define DDRD_N0_TXDQ_PIE_OFFSET_RANK_4_MC_DDRIOMC_REG 0x0822B110

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_pie_offset0 : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code0. The
                               result is the txdq0 pi even code
                               (txdq_pie_code0) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset1 : 7;

                            /* Bits[13:7], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code1. The
                               result is the txdq1 pi even code
                               (txdq_pie_code1) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset2 : 7;

                            /* Bits[20:14], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code2. The
                               result is the txdq2 pi even code
                               (txdq_pie_code2) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset3 : 7;

                            /* Bits[27:21], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code3. The
                               result is the txdq3 pi even code
                               (txdq_pie_code3) to DLL.. Default value is 64.
                            */
    UINT32 rsvd : 3;

                            /* Bits[30:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 x8_device : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* x8 device enable */

  } Bits;
  UINT32 Data;

} DDRD_N0_TXDQ_PIE_OFFSET_RANK_4_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TXDQ_PIE_OFFSET_RANK_5_MC_DDRIOMC_REG supported on:                  */
/*      SPRA0 (0x2001b114)                                                      */
/*      SPRB0 (0x2001b114)                                                      */
/*      SPRHBM (0x2001b114)                                                     */
/*      SPRC0 (0x2001b114)                                                      */
/*      SPRMCC (0x2001b114)                                                     */
/*      SPRUCC (0x2001b114)                                                     */
/* Register default value on SPRA0: 0x08102040                                  */
/* Register default value on SPRB0: 0x08102040                                  */
/* Register default value on SPRHBM: 0x08102040                                 */
/* Register default value on SPRC0: 0x08102040                                  */
/* Register default value on SPRMCC: 0x08102040                                 */
/* Register default value on SPRUCC: 0x08102040                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank TXDQ PI Even offset
*/


#define DDRD_N0_TXDQ_PIE_OFFSET_RANK_5_MC_DDRIOMC_REG 0x0822B114

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_pie_offset0 : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code0. The
                               result is the txdq0 pi even code
                               (txdq_pie_code0) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset1 : 7;

                            /* Bits[13:7], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code1. The
                               result is the txdq1 pi even code
                               (txdq_pie_code1) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset2 : 7;

                            /* Bits[20:14], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code2. The
                               result is the txdq2 pi even code
                               (txdq_pie_code2) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset3 : 7;

                            /* Bits[27:21], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code3. The
                               result is the txdq3 pi even code
                               (txdq_pie_code3) to DLL.. Default value is 64.
                            */
    UINT32 rsvd : 3;

                            /* Bits[30:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 x8_device : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* x8 device enable */

  } Bits;
  UINT32 Data;

} DDRD_N0_TXDQ_PIE_OFFSET_RANK_5_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TXDQ_PIE_OFFSET_RANK_6_MC_DDRIOMC_REG supported on:                  */
/*      SPRA0 (0x2001b118)                                                      */
/*      SPRB0 (0x2001b118)                                                      */
/*      SPRHBM (0x2001b118)                                                     */
/*      SPRC0 (0x2001b118)                                                      */
/*      SPRMCC (0x2001b118)                                                     */
/*      SPRUCC (0x2001b118)                                                     */
/* Register default value on SPRA0: 0x08102040                                  */
/* Register default value on SPRB0: 0x08102040                                  */
/* Register default value on SPRHBM: 0x08102040                                 */
/* Register default value on SPRC0: 0x08102040                                  */
/* Register default value on SPRMCC: 0x08102040                                 */
/* Register default value on SPRUCC: 0x08102040                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank TXDQ PI Even offset
*/


#define DDRD_N0_TXDQ_PIE_OFFSET_RANK_6_MC_DDRIOMC_REG 0x0822B118

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_pie_offset0 : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code0. The
                               result is the txdq0 pi even code
                               (txdq_pie_code0) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset1 : 7;

                            /* Bits[13:7], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code1. The
                               result is the txdq1 pi even code
                               (txdq_pie_code1) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset2 : 7;

                            /* Bits[20:14], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code2. The
                               result is the txdq2 pi even code
                               (txdq_pie_code2) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset3 : 7;

                            /* Bits[27:21], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code3. The
                               result is the txdq3 pi even code
                               (txdq_pie_code3) to DLL.. Default value is 64.
                            */
    UINT32 rsvd : 3;

                            /* Bits[30:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 x8_device : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* x8 device enable */

  } Bits;
  UINT32 Data;

} DDRD_N0_TXDQ_PIE_OFFSET_RANK_6_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TXDQ_PIE_OFFSET_RANK_7_MC_DDRIOMC_REG supported on:                  */
/*      SPRA0 (0x2001b11c)                                                      */
/*      SPRB0 (0x2001b11c)                                                      */
/*      SPRHBM (0x2001b11c)                                                     */
/*      SPRC0 (0x2001b11c)                                                      */
/*      SPRMCC (0x2001b11c)                                                     */
/*      SPRUCC (0x2001b11c)                                                     */
/* Register default value on SPRA0: 0x08102040                                  */
/* Register default value on SPRB0: 0x08102040                                  */
/* Register default value on SPRHBM: 0x08102040                                 */
/* Register default value on SPRC0: 0x08102040                                  */
/* Register default value on SPRMCC: 0x08102040                                 */
/* Register default value on SPRUCC: 0x08102040                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank TXDQ PI Even offset
*/


#define DDRD_N0_TXDQ_PIE_OFFSET_RANK_7_MC_DDRIOMC_REG 0x0822B11C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txdq_pie_offset0 : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code0. The
                               result is the txdq0 pi even code
                               (txdq_pie_code0) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset1 : 7;

                            /* Bits[13:7], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code1. The
                               result is the txdq1 pi even code
                               (txdq_pie_code1) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset2 : 7;

                            /* Bits[20:14], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code2. The
                               result is the txdq2 pi even code
                               (txdq_pie_code2) to DLL.. Default value is 64.
                            */
    UINT32 txdq_pie_offset3 : 7;

                            /* Bits[27:21], Access Type=RW, default=0x00000040*/

                            /*
                               This offset is add to the txdq_pio_code3. The
                               result is the txdq3 pi even code
                               (txdq_pie_code3) to DLL.. Default value is 64.
                            */
    UINT32 rsvd : 3;

                            /* Bits[30:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 x8_device : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* x8 device enable */

  } Bits;
  UINT32 Data;

} DDRD_N0_TXDQ_PIE_OFFSET_RANK_7_MC_DDRIOMC_STRUCT;

/* DDRD_N0_SA_OFFSET_RANK_0_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001b120)                                                      */
/*      SPRB0 (0x2001b120)                                                      */
/*      SPRHBM (0x2001b120)                                                     */
/*      SPRC0 (0x2001b120)                                                      */
/*      SPRMCC (0x2001b120)                                                     */
/*      SPRUCC (0x2001b120)                                                     */
/* Register default value on SPRA0: 0x03C78F1E                                  */
/* Register default value on SPRB0: 0x03C78F1E                                  */
/* Register default value on SPRHBM: 0x03C78F1E                                 */
/* Register default value on SPRC0: 0x03C78F1E                                  */
/* Register default value on SPRMCC: 0x03C78F1E                                 */
/* Register default value on SPRUCC: 0x03C78F1E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for RX DQSN/P Select and Senseamp offset for DQ0-3
*/


#define DDRD_N0_SA_OFFSET_RANK_0_MC_DDRIOMC_REG 0x0822B120

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset0 : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset1 : 6;

                            /* Bits[12:7], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_13 : 1;

                            /* Bits[13:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset2 : 6;

                            /* Bits[19:14], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_20 : 1;

                            /* Bits[20:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset3 : 6;

                            /* Bits[26:21], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_sel : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               selects which skewed DQS P for post receive
                               enable counter clock in the RX Deskew logic. For
                               proper operation, always pick latest DQS P.
                            */
    UINT32 rxdqsn_sel : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               selects which skewed DQS N for post receive
                               enable counter clock in the RX Deskew logic. For
                               proper operation, always pick latest DQS N.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_SA_OFFSET_RANK_0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_SA_OFFSET_RANK_1_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001b124)                                                      */
/*      SPRB0 (0x2001b124)                                                      */
/*      SPRHBM (0x2001b124)                                                     */
/*      SPRC0 (0x2001b124)                                                      */
/*      SPRMCC (0x2001b124)                                                     */
/*      SPRUCC (0x2001b124)                                                     */
/* Register default value on SPRA0: 0x03C78F1E                                  */
/* Register default value on SPRB0: 0x03C78F1E                                  */
/* Register default value on SPRHBM: 0x03C78F1E                                 */
/* Register default value on SPRC0: 0x03C78F1E                                  */
/* Register default value on SPRMCC: 0x03C78F1E                                 */
/* Register default value on SPRUCC: 0x03C78F1E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for RX DQSN/P Select and Senseamp offset for DQ0-3
*/


#define DDRD_N0_SA_OFFSET_RANK_1_MC_DDRIOMC_REG 0x0822B124

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset0 : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset1 : 6;

                            /* Bits[12:7], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_13 : 1;

                            /* Bits[13:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset2 : 6;

                            /* Bits[19:14], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_20 : 1;

                            /* Bits[20:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset3 : 6;

                            /* Bits[26:21], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_sel : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               selects which skewed DQS P for post receive
                               enable counter clock in the RX Deskew logic. For
                               proper operation, always pick latest DQS P.
                            */
    UINT32 rxdqsn_sel : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               selects which skewed DQS N for post receive
                               enable counter clock in the RX Deskew logic. For
                               proper operation, always pick latest DQS N.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_SA_OFFSET_RANK_1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_SA_OFFSET_RANK_2_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001b128)                                                      */
/*      SPRB0 (0x2001b128)                                                      */
/*      SPRHBM (0x2001b128)                                                     */
/*      SPRC0 (0x2001b128)                                                      */
/*      SPRMCC (0x2001b128)                                                     */
/*      SPRUCC (0x2001b128)                                                     */
/* Register default value on SPRA0: 0x03C78F1E                                  */
/* Register default value on SPRB0: 0x03C78F1E                                  */
/* Register default value on SPRHBM: 0x03C78F1E                                 */
/* Register default value on SPRC0: 0x03C78F1E                                  */
/* Register default value on SPRMCC: 0x03C78F1E                                 */
/* Register default value on SPRUCC: 0x03C78F1E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for RX DQSN/P Select and Senseamp offset for DQ0-3
*/


#define DDRD_N0_SA_OFFSET_RANK_2_MC_DDRIOMC_REG 0x0822B128

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset0 : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset1 : 6;

                            /* Bits[12:7], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_13 : 1;

                            /* Bits[13:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset2 : 6;

                            /* Bits[19:14], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_20 : 1;

                            /* Bits[20:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset3 : 6;

                            /* Bits[26:21], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_sel : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               selects which skewed DQS P for post receive
                               enable counter clock in the RX Deskew logic. For
                               proper operation, always pick latest DQS P.
                            */
    UINT32 rxdqsn_sel : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               selects which skewed DQS N for post receive
                               enable counter clock in the RX Deskew logic. For
                               proper operation, always pick latest DQS N.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_SA_OFFSET_RANK_2_MC_DDRIOMC_STRUCT;

/* DDRD_N0_SA_OFFSET_RANK_3_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001b12c)                                                      */
/*      SPRB0 (0x2001b12c)                                                      */
/*      SPRHBM (0x2001b12c)                                                     */
/*      SPRC0 (0x2001b12c)                                                      */
/*      SPRMCC (0x2001b12c)                                                     */
/*      SPRUCC (0x2001b12c)                                                     */
/* Register default value on SPRA0: 0x03C78F1E                                  */
/* Register default value on SPRB0: 0x03C78F1E                                  */
/* Register default value on SPRHBM: 0x03C78F1E                                 */
/* Register default value on SPRC0: 0x03C78F1E                                  */
/* Register default value on SPRMCC: 0x03C78F1E                                 */
/* Register default value on SPRUCC: 0x03C78F1E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for RX DQSN/P Select and Senseamp offset for DQ0-3
*/


#define DDRD_N0_SA_OFFSET_RANK_3_MC_DDRIOMC_REG 0x0822B12C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset0 : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset1 : 6;

                            /* Bits[12:7], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_13 : 1;

                            /* Bits[13:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset2 : 6;

                            /* Bits[19:14], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_20 : 1;

                            /* Bits[20:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset3 : 6;

                            /* Bits[26:21], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_sel : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               selects which skewed DQS P for post receive
                               enable counter clock in the RX Deskew logic. For
                               proper operation, always pick latest DQS P.
                            */
    UINT32 rxdqsn_sel : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               selects which skewed DQS N for post receive
                               enable counter clock in the RX Deskew logic. For
                               proper operation, always pick latest DQS N.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_SA_OFFSET_RANK_3_MC_DDRIOMC_STRUCT;

/* DDRD_N0_SA_OFFSET_RANK_4_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001b130)                                                      */
/*      SPRB0 (0x2001b130)                                                      */
/*      SPRHBM (0x2001b130)                                                     */
/*      SPRC0 (0x2001b130)                                                      */
/*      SPRMCC (0x2001b130)                                                     */
/*      SPRUCC (0x2001b130)                                                     */
/* Register default value on SPRA0: 0x03C78F1E                                  */
/* Register default value on SPRB0: 0x03C78F1E                                  */
/* Register default value on SPRHBM: 0x03C78F1E                                 */
/* Register default value on SPRC0: 0x03C78F1E                                  */
/* Register default value on SPRMCC: 0x03C78F1E                                 */
/* Register default value on SPRUCC: 0x03C78F1E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for RX DQSN/P Select and Senseamp offset for DQ0-3
*/


#define DDRD_N0_SA_OFFSET_RANK_4_MC_DDRIOMC_REG 0x0822B130

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset0 : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset1 : 6;

                            /* Bits[12:7], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_13 : 1;

                            /* Bits[13:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset2 : 6;

                            /* Bits[19:14], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_20 : 1;

                            /* Bits[20:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset3 : 6;

                            /* Bits[26:21], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_sel : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               selects which skewed DQS P for post receive
                               enable counter clock in the RX Deskew logic. For
                               proper operation, always pick latest DQS P.
                            */
    UINT32 rxdqsn_sel : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               selects which skewed DQS N for post receive
                               enable counter clock in the RX Deskew logic. For
                               proper operation, always pick latest DQS N.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_SA_OFFSET_RANK_4_MC_DDRIOMC_STRUCT;

/* DDRD_N0_SA_OFFSET_RANK_5_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001b134)                                                      */
/*      SPRB0 (0x2001b134)                                                      */
/*      SPRHBM (0x2001b134)                                                     */
/*      SPRC0 (0x2001b134)                                                      */
/*      SPRMCC (0x2001b134)                                                     */
/*      SPRUCC (0x2001b134)                                                     */
/* Register default value on SPRA0: 0x03C78F1E                                  */
/* Register default value on SPRB0: 0x03C78F1E                                  */
/* Register default value on SPRHBM: 0x03C78F1E                                 */
/* Register default value on SPRC0: 0x03C78F1E                                  */
/* Register default value on SPRMCC: 0x03C78F1E                                 */
/* Register default value on SPRUCC: 0x03C78F1E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for RX DQSN/P Select and Senseamp offset for DQ0-3
*/


#define DDRD_N0_SA_OFFSET_RANK_5_MC_DDRIOMC_REG 0x0822B134

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset0 : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset1 : 6;

                            /* Bits[12:7], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_13 : 1;

                            /* Bits[13:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset2 : 6;

                            /* Bits[19:14], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_20 : 1;

                            /* Bits[20:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset3 : 6;

                            /* Bits[26:21], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_sel : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               selects which skewed DQS P for post receive
                               enable counter clock in the RX Deskew logic. For
                               proper operation, always pick latest DQS P.
                            */
    UINT32 rxdqsn_sel : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               selects which skewed DQS N for post receive
                               enable counter clock in the RX Deskew logic. For
                               proper operation, always pick latest DQS N.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_SA_OFFSET_RANK_5_MC_DDRIOMC_STRUCT;

/* DDRD_N0_SA_OFFSET_RANK_6_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001b138)                                                      */
/*      SPRB0 (0x2001b138)                                                      */
/*      SPRHBM (0x2001b138)                                                     */
/*      SPRC0 (0x2001b138)                                                      */
/*      SPRMCC (0x2001b138)                                                     */
/*      SPRUCC (0x2001b138)                                                     */
/* Register default value on SPRA0: 0x03C78F1E                                  */
/* Register default value on SPRB0: 0x03C78F1E                                  */
/* Register default value on SPRHBM: 0x03C78F1E                                 */
/* Register default value on SPRC0: 0x03C78F1E                                  */
/* Register default value on SPRMCC: 0x03C78F1E                                 */
/* Register default value on SPRUCC: 0x03C78F1E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for RX DQSN/P Select and Senseamp offset for DQ0-3
*/


#define DDRD_N0_SA_OFFSET_RANK_6_MC_DDRIOMC_REG 0x0822B138

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset0 : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset1 : 6;

                            /* Bits[12:7], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_13 : 1;

                            /* Bits[13:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset2 : 6;

                            /* Bits[19:14], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_20 : 1;

                            /* Bits[20:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset3 : 6;

                            /* Bits[26:21], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_sel : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               selects which skewed DQS P for post receive
                               enable counter clock in the RX Deskew logic. For
                               proper operation, always pick latest DQS P.
                            */
    UINT32 rxdqsn_sel : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               selects which skewed DQS N for post receive
                               enable counter clock in the RX Deskew logic. For
                               proper operation, always pick latest DQS N.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_SA_OFFSET_RANK_6_MC_DDRIOMC_STRUCT;

/* DDRD_N0_SA_OFFSET_RANK_7_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001b13c)                                                      */
/*      SPRB0 (0x2001b13c)                                                      */
/*      SPRHBM (0x2001b13c)                                                     */
/*      SPRC0 (0x2001b13c)                                                      */
/*      SPRMCC (0x2001b13c)                                                     */
/*      SPRUCC (0x2001b13c)                                                     */
/* Register default value on SPRA0: 0x03C78F1E                                  */
/* Register default value on SPRB0: 0x03C78F1E                                  */
/* Register default value on SPRHBM: 0x03C78F1E                                 */
/* Register default value on SPRC0: 0x03C78F1E                                  */
/* Register default value on SPRMCC: 0x03C78F1E                                 */
/* Register default value on SPRUCC: 0x03C78F1E                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank Control for RX DQSN/P Select and Senseamp offset for DQ0-3
*/


#define DDRD_N0_SA_OFFSET_RANK_7_MC_DDRIOMC_REG 0x0822B13C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sa_offset0 : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset1 : 6;

                            /* Bits[12:7], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_13 : 1;

                            /* Bits[13:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset2 : 6;

                            /* Bits[19:14], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max -ve offset, 30=no offset, 60=max +ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_20 : 1;

                            /* Bits[20:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sa_offset3 : 6;

                            /* Bits[26:21], Access Type=RW/V, default=0x0000001E*/

                            /*
                               Rxamp (summer) offset Control. Mid code is 30.
                               (0=max +ve offset, 30=no offset, 60=max -ve
                               offset, 61, 62, 63=not used)[br] This field can
                               be programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxdqsp_sel : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               selects which skewed DQS P for post receive
                               enable counter clock in the RX Deskew logic. For
                               proper operation, always pick latest DQS P.
                            */
    UINT32 rxdqsn_sel : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               selects which skewed DQS N for post receive
                               enable counter clock in the RX Deskew logic. For
                               proper operation, always pick latest DQS N.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_SA_OFFSET_RANK_7_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DFE_COEFF_RANK_0_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001b140)                                                      */
/*      SPRB0 (0x2001b140)                                                      */
/*      SPRHBM (0x2001b140)                                                     */
/*      SPRC0 (0x2001b140)                                                      */
/*      SPRMCC (0x2001b140)                                                     */
/*      SPRUCC (0x2001b140)                                                     */
/* Register default value on SPRA0: 0x00084188                                  */
/* Register default value on SPRB0: 0x00084188                                  */
/* Register default value on SPRHBM: 0x00084188                                 */
/* Register default value on SPRC0: 0x00084188                                  */
/* Register default value on SPRMCC: 0x00084188                                 */
/* Register default value on SPRUCC: 0x00084188                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank DFE Coefficient
*/


#define DDRD_N0_DFE_COEFF_RANK_0_MC_DDRIOMC_REG 0x0822B140

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfe_coeff1 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 1st post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -120mV to +35mV in 5mV
                               steps.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff2 : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000006*/

                            /*
                               DFE 2nd post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -40mV to +35mV in 5mV steps
                            */
    UINT32 rsvd_10 : 1;

                            /* Bits[10:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff3 : 4;

                            /* Bits[14:11], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 3rd post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -40mV to +35mV in 5 mV steps
                            */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff4 : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 4th post cursor tap coefficient. (In DDR4
                               mode this is the floating tap coefficient).[br]
                               -40mV to +35mV in 5mV steps
                            */
    UINT32 rsvd_20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFE_COEFF_RANK_0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DFE_COEFF_RANK_1_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001b144)                                                      */
/*      SPRB0 (0x2001b144)                                                      */
/*      SPRHBM (0x2001b144)                                                     */
/*      SPRC0 (0x2001b144)                                                      */
/*      SPRMCC (0x2001b144)                                                     */
/*      SPRUCC (0x2001b144)                                                     */
/* Register default value on SPRA0: 0x00084188                                  */
/* Register default value on SPRB0: 0x00084188                                  */
/* Register default value on SPRHBM: 0x00084188                                 */
/* Register default value on SPRC0: 0x00084188                                  */
/* Register default value on SPRMCC: 0x00084188                                 */
/* Register default value on SPRUCC: 0x00084188                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank DFE Coefficient
*/


#define DDRD_N0_DFE_COEFF_RANK_1_MC_DDRIOMC_REG 0x0822B144

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfe_coeff1 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 1st post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -120mV to +35mV in 5mV
                               steps.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff2 : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000006*/

                            /*
                               DFE 2nd post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -40mV to +35mV in 5mV steps
                            */
    UINT32 rsvd_10 : 1;

                            /* Bits[10:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff3 : 4;

                            /* Bits[14:11], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 3rd post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -40mV to +35mV in 5 mV steps
                            */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff4 : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 4th post cursor tap coefficient. (In DDR4
                               mode this is the floating tap coefficient).[br]
                               -40mV to +35mV in 5mV steps
                            */
    UINT32 rsvd_20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFE_COEFF_RANK_1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DFE_COEFF_RANK_2_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001b148)                                                      */
/*      SPRB0 (0x2001b148)                                                      */
/*      SPRHBM (0x2001b148)                                                     */
/*      SPRC0 (0x2001b148)                                                      */
/*      SPRMCC (0x2001b148)                                                     */
/*      SPRUCC (0x2001b148)                                                     */
/* Register default value on SPRA0: 0x00084188                                  */
/* Register default value on SPRB0: 0x00084188                                  */
/* Register default value on SPRHBM: 0x00084188                                 */
/* Register default value on SPRC0: 0x00084188                                  */
/* Register default value on SPRMCC: 0x00084188                                 */
/* Register default value on SPRUCC: 0x00084188                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank DFE Coefficient
*/


#define DDRD_N0_DFE_COEFF_RANK_2_MC_DDRIOMC_REG 0x0822B148

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfe_coeff1 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 1st post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -120mV to +35mV in 5mV
                               steps.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff2 : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000006*/

                            /*
                               DFE 2nd post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -40mV to +35mV in 5mV steps
                            */
    UINT32 rsvd_10 : 1;

                            /* Bits[10:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff3 : 4;

                            /* Bits[14:11], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 3rd post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -40mV to +35mV in 5 mV steps
                            */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff4 : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 4th post cursor tap coefficient. (In DDR4
                               mode this is the floating tap coefficient).[br]
                               -40mV to +35mV in 5mV steps
                            */
    UINT32 rsvd_20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFE_COEFF_RANK_2_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DFE_COEFF_RANK_3_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001b14c)                                                      */
/*      SPRB0 (0x2001b14c)                                                      */
/*      SPRHBM (0x2001b14c)                                                     */
/*      SPRC0 (0x2001b14c)                                                      */
/*      SPRMCC (0x2001b14c)                                                     */
/*      SPRUCC (0x2001b14c)                                                     */
/* Register default value on SPRA0: 0x00084188                                  */
/* Register default value on SPRB0: 0x00084188                                  */
/* Register default value on SPRHBM: 0x00084188                                 */
/* Register default value on SPRC0: 0x00084188                                  */
/* Register default value on SPRMCC: 0x00084188                                 */
/* Register default value on SPRUCC: 0x00084188                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank DFE Coefficient
*/


#define DDRD_N0_DFE_COEFF_RANK_3_MC_DDRIOMC_REG 0x0822B14C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfe_coeff1 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 1st post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -120mV to +35mV in 5mV
                               steps.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff2 : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000006*/

                            /*
                               DFE 2nd post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -40mV to +35mV in 5mV steps
                            */
    UINT32 rsvd_10 : 1;

                            /* Bits[10:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff3 : 4;

                            /* Bits[14:11], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 3rd post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -40mV to +35mV in 5 mV steps
                            */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff4 : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 4th post cursor tap coefficient. (In DDR4
                               mode this is the floating tap coefficient).[br]
                               -40mV to +35mV in 5mV steps
                            */
    UINT32 rsvd_20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFE_COEFF_RANK_3_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DFE_COEFF_RANK_4_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001b150)                                                      */
/*      SPRB0 (0x2001b150)                                                      */
/*      SPRHBM (0x2001b150)                                                     */
/*      SPRC0 (0x2001b150)                                                      */
/*      SPRMCC (0x2001b150)                                                     */
/*      SPRUCC (0x2001b150)                                                     */
/* Register default value on SPRA0: 0x00084188                                  */
/* Register default value on SPRB0: 0x00084188                                  */
/* Register default value on SPRHBM: 0x00084188                                 */
/* Register default value on SPRC0: 0x00084188                                  */
/* Register default value on SPRMCC: 0x00084188                                 */
/* Register default value on SPRUCC: 0x00084188                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank DFE Coefficient
*/


#define DDRD_N0_DFE_COEFF_RANK_4_MC_DDRIOMC_REG 0x0822B150

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfe_coeff1 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 1st post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -120mV to +35mV in 5mV
                               steps.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff2 : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000006*/

                            /*
                               DFE 2nd post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -40mV to +35mV in 5mV steps
                            */
    UINT32 rsvd_10 : 1;

                            /* Bits[10:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff3 : 4;

                            /* Bits[14:11], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 3rd post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -40mV to +35mV in 5 mV steps
                            */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff4 : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 4th post cursor tap coefficient. (In DDR4
                               mode this is the floating tap coefficient).[br]
                               -40mV to +35mV in 5mV steps
                            */
    UINT32 rsvd_20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFE_COEFF_RANK_4_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DFE_COEFF_RANK_5_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001b154)                                                      */
/*      SPRB0 (0x2001b154)                                                      */
/*      SPRHBM (0x2001b154)                                                     */
/*      SPRC0 (0x2001b154)                                                      */
/*      SPRMCC (0x2001b154)                                                     */
/*      SPRUCC (0x2001b154)                                                     */
/* Register default value on SPRA0: 0x00084188                                  */
/* Register default value on SPRB0: 0x00084188                                  */
/* Register default value on SPRHBM: 0x00084188                                 */
/* Register default value on SPRC0: 0x00084188                                  */
/* Register default value on SPRMCC: 0x00084188                                 */
/* Register default value on SPRUCC: 0x00084188                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank DFE Coefficient
*/


#define DDRD_N0_DFE_COEFF_RANK_5_MC_DDRIOMC_REG 0x0822B154

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfe_coeff1 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 1st post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -120mV to +35mV in 5mV
                               steps.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff2 : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000006*/

                            /*
                               DFE 2nd post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -40mV to +35mV in 5mV steps
                            */
    UINT32 rsvd_10 : 1;

                            /* Bits[10:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff3 : 4;

                            /* Bits[14:11], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 3rd post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -40mV to +35mV in 5 mV steps
                            */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff4 : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 4th post cursor tap coefficient. (In DDR4
                               mode this is the floating tap coefficient).[br]
                               -40mV to +35mV in 5mV steps
                            */
    UINT32 rsvd_20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFE_COEFF_RANK_5_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DFE_COEFF_RANK_6_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001b158)                                                      */
/*      SPRB0 (0x2001b158)                                                      */
/*      SPRHBM (0x2001b158)                                                     */
/*      SPRC0 (0x2001b158)                                                      */
/*      SPRMCC (0x2001b158)                                                     */
/*      SPRUCC (0x2001b158)                                                     */
/* Register default value on SPRA0: 0x00084188                                  */
/* Register default value on SPRB0: 0x00084188                                  */
/* Register default value on SPRHBM: 0x00084188                                 */
/* Register default value on SPRC0: 0x00084188                                  */
/* Register default value on SPRMCC: 0x00084188                                 */
/* Register default value on SPRUCC: 0x00084188                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank DFE Coefficient
*/


#define DDRD_N0_DFE_COEFF_RANK_6_MC_DDRIOMC_REG 0x0822B158

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfe_coeff1 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 1st post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -120mV to +35mV in 5mV
                               steps.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff2 : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000006*/

                            /*
                               DFE 2nd post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -40mV to +35mV in 5mV steps
                            */
    UINT32 rsvd_10 : 1;

                            /* Bits[10:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff3 : 4;

                            /* Bits[14:11], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 3rd post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -40mV to +35mV in 5 mV steps
                            */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff4 : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 4th post cursor tap coefficient. (In DDR4
                               mode this is the floating tap coefficient).[br]
                               -40mV to +35mV in 5mV steps
                            */
    UINT32 rsvd_20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFE_COEFF_RANK_6_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DFE_COEFF_RANK_7_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001b15c)                                                      */
/*      SPRB0 (0x2001b15c)                                                      */
/*      SPRHBM (0x2001b15c)                                                     */
/*      SPRC0 (0x2001b15c)                                                      */
/*      SPRMCC (0x2001b15c)                                                     */
/*      SPRUCC (0x2001b15c)                                                     */
/* Register default value on SPRA0: 0x00084188                                  */
/* Register default value on SPRB0: 0x00084188                                  */
/* Register default value on SPRHBM: 0x00084188                                 */
/* Register default value on SPRC0: 0x00084188                                  */
/* Register default value on SPRMCC: 0x00084188                                 */
/* Register default value on SPRUCC: 0x00084188                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Per Rank DFE Coefficient
*/


#define DDRD_N0_DFE_COEFF_RANK_7_MC_DDRIOMC_REG 0x0822B15C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfe_coeff1 : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 1st post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -120mV to +35mV in 5mV
                               steps.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff2 : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000006*/

                            /*
                               DFE 2nd post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -40mV to +35mV in 5mV steps
                            */
    UINT32 rsvd_10 : 1;

                            /* Bits[10:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff3 : 4;

                            /* Bits[14:11], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 3rd post cursor tap coefficient. Used in
                               DDR5 mode only.[br] -40mV to +35mV in 5 mV steps
                            */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dfe_coeff4 : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000008*/

                            /*
                               DFE 4th post cursor tap coefficient. (In DDR4
                               mode this is the floating tap coefficient).[br]
                               -40mV to +35mV in 5mV steps
                            */
    UINT32 rsvd_20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFE_COEFF_RANK_7_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DLL_CTL0_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001b170)                                                      */
/*      SPRB0 (0x2001b170)                                                      */
/*      SPRHBM (0x2001b170)                                                     */
/*      SPRC0 (0x2001b170)                                                      */
/*      SPRMCC (0x2001b170)                                                     */
/*      SPRUCC (0x2001b170)                                                     */
/* Register default value on SPRA0: 0x00001E24                                  */
/* Register default value on SPRB0: 0x00001E24                                  */
/* Register default value on SPRHBM: 0x00001E24                                 */
/* Register default value on SPRC0: 0x00001E24                                  */
/* Register default value on SPRMCC: 0x00001E24                                 */
/* Register default value on SPRUCC: 0x00001E24                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* DLL Control 0 Register
*/


#define DDRD_N0_DLL_CTL0_MC_DDRIOMC_REG 0x0822B170

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dll_discharge_tmr : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000024*/

                            /*
                               BIOS must program this DLL discharge timer based
                               on the analog tuning value and hclk freq before
                               enable the DLL. The default value is based on
                               hclk is 1200 MHz and discharge time is 30ns.
                            */
    UINT32 rsvd : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dll_lock_tmr : 7;

                            /* Bits[13:7], Access Type=RW, default=0x0000003C*/

                            /*
                               BIOS must program this DLL lock timer based on
                               the analog tuning value and hclk freq before
                               enable the DLL. The default value is based on
                               hclk is 1200 MHz and lock time is 50ns.
                            */
    UINT32 rsvd_14 : 18;

                            /* Bits[31:14], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_DLL_CTL0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_RETRAIN0_MC_DDRIOMC_REG supported on:                             */
/*      SPRA0 (0x2001b174)                                                      */
/*      SPRB0 (0x2001b174)                                                      */
/*      SPRHBM (0x2001b174)                                                     */
/*      SPRC0 (0x2001b174)                                                      */
/*      SPRMCC (0x2001b174)                                                     */
/*      SPRUCC (0x2001b174)                                                     */
/* Register default value on SPRA0: 0x0C000001                                  */
/* Register default value on SPRB0: 0x0C000001                                  */
/* Register default value on SPRHBM: 0x0C000001                                 */
/* Register default value on SPRC0: 0x0C000001                                  */
/* Register default value on SPRMCC: 0x0C000001                                 */
/* Register default value on SPRUCC: 0x0C000001                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* TX retrain 0 Register
*/


#define DDRD_N0_TX_RETRAIN0_MC_DDRIOMC_REG 0x0822B174

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 txrt_dur : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000001*/

                            /*
                               TX retraining duration. SW must programs the
                               same TCK duration value as progammed in the
                               memory device.[br] 001: 128 x 16 TCK[br] 010:
                               256 x 16 TCK[br] 100: 512 x 16 TCK[br] others:
                               Reserved
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txrt_init : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to indicate this is the 1st retraining
                               to initialize the txrt_init_picode. HW will not
                               calculate and apply the txrt_dq_dly_adj.
                            */
    UINT32 txrt_debug_rank : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /*
                               Select which rank of RO count value to capture
                               in txrt_ro_count for debug.
                            */
    UINT32 txrt_ro_count : 14;

                            /* Bits[21:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               This is the last TX retraining Ring Oscillator
                               count value captured by HW. HW only capture the
                               rank sepcify in txrt_debug_rank.
                            */
    UINT32 txrt_update : 1;

                            /* Bits[22:22], Access Type=RW/V, default=0x00000000*/

                            /*
                               Set to 1 to apply the calculation results to
                               txrt_init_picode or txrt_dq_dly_adj. HW will
                               clear this bit once it is applied. [br] HW does
                               not require the spid_update_req/ack handshake to
                               apply the results if this CSR is used. [br] SW
                               needs to guarantee that there are no CAP errors,
                               and there is no write traffic to the targeted
                               rank before setting this bit.
                            */
    UINT32 txrt_rank_err : 1;

                            /* Bits[23:23], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Set to 1 by HW to indicate MR46 rank did not
                               match MR47 rank when txrt_update or
                               spid_update_req/ack occurs. [br] SW must clear
                               this bit to 0 when enable HW calibration.
                            */
    UINT32 txrt_fsm_status : 2;

                            /* Bits[25:24], Access Type=RO/V, default=0x00000000*/

                            /*
                               Reads back the TXRT FSM state. [br] 0: IDLE [br]
                               1: WAIT_MR [br] 2: CALC [br] 3: UPDATE
                            */
    UINT32 txrt_mrr_status : 2;

                            /* Bits[27:26], Access Type=RO/V, default=0x00000003*/

                            /*
                               Reads back the MRR that the TXRT FSM is waiting
                               on. [br] bit 0: MR46. 1 indicates that the FSM
                               is waiting for this read. [br] bit 1: MR47. 1
                               indicates that the FSM is waiting for this read.
                            */
    UINT32 rsvd_28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_RETRAIN0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_SAMPLER_ODD_OFFSET_MC_DDRIOMC_REG supported on:                      */
/*      SPRA0 (0x2001b178)                                                      */
/*      SPRB0 (0x2001b178)                                                      */
/*      SPRHBM (0x2001b178)                                                     */
/*      SPRC0 (0x2001b178)                                                      */
/*      SPRMCC (0x2001b178)                                                     */
/*      SPRUCC (0x2001b178)                                                     */
/* Register default value on SPRA0: 0x03E7CF9F                                  */
/* Register default value on SPRB0: 0x03E7CF9F                                  */
/* Register default value on SPRHBM: 0x03E7CF9F                                 */
/* Register default value on SPRC0: 0x03E7CF9F                                  */
/* Register default value on SPRMCC: 0x03E7CF9F                                 */
/* Register default value on SPRUCC: 0x03E7CF9F                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* RX Sampler Odd offset for DQ0-3
*/


#define DDRD_N0_SAMPLER_ODD_OFFSET_MC_DDRIOMC_REG 0x0822B178

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sampler_odd_offset0 : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001F*/

                            /*
                               Rx Odd Sampler Offset Control.[br] Normal
                               operation (dfe_coeff_training_en=0): -155mV to
                               +155mV in 5mV steps in normal operation
                               (0=-155mV, 31=no offset, 62=+155mV, 63=not
                               used)[br] Extended range
                               (dfe_coeff_training_en=1): -620mV to +620mV in
                               20mV steps (0=-620mV, 31=no offset, 62=+620mV,
                               63=not used). [br] Real range may be smaller due
                               to limited signal swing & common-mode.[br] This
                               value is added with sampler_offset_adj to allow
                               BIOS for margining sweep (Signed number. The
                               Range is -32 to 31).[br] Note: BIOS must make
                               sure the sampler_offset_adj value doesn't cause
                               an overflow or underflow.[br] This field can be
                               programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sampler_odd_offset1 : 6;

                            /* Bits[12:7], Access Type=RW/V, default=0x0000001F*/

                            /*
                               Rx Odd Sampler Offset Control.[br] Normal
                               operation (dfe_coeff_training_en=0): -155mV to
                               +155mV in 5mV steps in normal operation
                               (0=-155mV, 31=no offset, 62=+155mV, 63=not
                               used)[br] Extended range
                               (dfe_coeff_training_en=1): -620mV to +620mV in
                               20mV steps (0=-620mV, 31=no offset, 62=+620mV,
                               63=not used). [br] Real range may be smaller due
                               to limited signal swing & common-mode.[br] This
                               value is added with sampler_offset_adj to allow
                               BIOS for margining sweep (Signed number. The
                               Range is -32 to 31).[br] Note: BIOS must make
                               sure the sampler_offset_adj value doesn't cause
                               an overflow or underflow.[br] This field can be
                               programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_13 : 1;

                            /* Bits[13:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sampler_odd_offset2 : 6;

                            /* Bits[19:14], Access Type=RW/V, default=0x0000001F*/

                            /*
                               Rx Odd Sampler Offset Control.[br] Normal
                               operation (dfe_coeff_training_en=0): -155mV to
                               +155mV in 5mV steps in normal operation
                               (0=-155mV, 31=no offset, 62=+155mV, 63=not
                               used)[br] Extended range
                               (dfe_coeff_training_en=1): -620mV to +620mV in
                               20mV steps (0=-620mV, 31=no offset, 62=+620mV,
                               63=not used). [br] Real range may be smaller due
                               to limited signal swing & common-mode.[br] This
                               value is added with sampler_offset_adj to allow
                               BIOS for margining sweep (Signed number. The
                               Range is -32 to 31).[br] Note: BIOS must make
                               sure the sampler_offset_adj value doesn't cause
                               an overflow or underflow.[br] This field can be
                               programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_20 : 1;

                            /* Bits[20:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sampler_odd_offset3 : 6;

                            /* Bits[26:21], Access Type=RW/V, default=0x0000001F*/

                            /*
                               Rx Odd Sampler Offset Control.[br] Normal
                               operation (dfe_coeff_training_en=0): -155mV to
                               +155mV in 5mV steps in normal operation
                               (0=-155mV, 31=no offset, 62=+155mV, 63=not
                               used)[br] Extended range
                               (dfe_coeff_training_en=1): -620mV to +620mV in
                               20mV steps (0=-620mV, 31=no offset, 62=+620mV,
                               63=not used). [br] Real range may be smaller due
                               to limited signal swing & common-mode.[br] This
                               value is added with sampler_offset_adj to allow
                               BIOS for margining sweep (Signed number. The
                               Range is -32 to 31).[br] Note: BIOS must make
                               sure the sampler_offset_adj value doesn't cause
                               an overflow or underflow.[br] This field can be
                               programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_SAMPLER_ODD_OFFSET_MC_DDRIOMC_STRUCT;

/* DDRD_N0_SAMPLER_EVEN_OFFSET_MC_DDRIOMC_REG supported on:                     */
/*      SPRA0 (0x2001b17c)                                                      */
/*      SPRB0 (0x2001b17c)                                                      */
/*      SPRHBM (0x2001b17c)                                                     */
/*      SPRC0 (0x2001b17c)                                                      */
/*      SPRMCC (0x2001b17c)                                                     */
/*      SPRUCC (0x2001b17c)                                                     */
/* Register default value on SPRA0: 0x03E7CF9F                                  */
/* Register default value on SPRB0: 0x03E7CF9F                                  */
/* Register default value on SPRHBM: 0x03E7CF9F                                 */
/* Register default value on SPRC0: 0x03E7CF9F                                  */
/* Register default value on SPRMCC: 0x03E7CF9F                                 */
/* Register default value on SPRUCC: 0x03E7CF9F                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* RX Sampler Even offset for DQ0-3
*/


#define DDRD_N0_SAMPLER_EVEN_OFFSET_MC_DDRIOMC_REG 0x0822B17C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sampler_even_offset0 : 6;

                            /* Bits[5:0], Access Type=RW/V, default=0x0000001F*/

                            /*
                               Rx Even Sampler Offset Control.[br] Normal
                               operation (dfe_coeff_training_en=0): -155mV to
                               +155mV in 5mV steps in normal operation
                               (0=-155mV, 31=no offset, 62=+155mV, 63=not
                               used)[br] Extended range
                               (dfe_coeff_training_en=1): -620mV to +620mV in
                               20mV steps (0=-620mV, 31=no offset, 62=+620mV,
                               63=not used). [br] Real range may be smaller due
                               to limited signal swing & common-mode.[br] This
                               value is added with sampler_offset_adj to allow
                               BIOS for margining sweep (Signed number. The
                               Range is -32 to 31).[br] Note: BIOS must make
                               sure the sampler_offset_adj value doesn't cause
                               an overflow or underflow.[br] This field can be
                               programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sampler_even_offset1 : 6;

                            /* Bits[12:7], Access Type=RW/V, default=0x0000001F*/

                            /*
                               Rx Even Sampler Offset Control.[br] Normal
                               operation (dfe_coeff_training_en=0): -155mV to
                               +155mV in 5mV steps in normal operation
                               (0=-155mV, 31=no offset, 62=+155mV, 63=not
                               used)[br] Extended range
                               (dfe_coeff_training_en=1): -620mV to +620mV in
                               20mV steps (0=-620mV, 31=no offset, 62=+620mV,
                               63=not used). [br] Real range may be smaller due
                               to limited signal swing & common-mode.[br] This
                               value is added with sampler_offset_adj to allow
                               BIOS for margining sweep (Signed number. The
                               Range is -32 to 31).[br] Note: BIOS must make
                               sure the sampler_offset_adj value doesn't cause
                               an overflow or underflow.[br] This field can be
                               programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_13 : 1;

                            /* Bits[13:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sampler_even_offset2 : 6;

                            /* Bits[19:14], Access Type=RW/V, default=0x0000001F*/

                            /*
                               Rx Even Sampler Offset Control.[br] Normal
                               operation (dfe_coeff_training_en=0): -155mV to
                               +155mV in 5mV steps in normal operation
                               (0=-155mV, 31=no offset, 62=+155mV, 63=not
                               used)[br] Extended range
                               (dfe_coeff_training_en=1): -620mV to +620mV in
                               20mV steps (0=-620mV, 31=no offset, 62=+620mV,
                               63=not used). [br] Real range may be smaller due
                               to limited signal swing & common-mode.[br] This
                               value is added with sampler_offset_adj to allow
                               BIOS for margining sweep (Signed number. The
                               Range is -32 to 31).[br] Note: BIOS must make
                               sure the sampler_offset_adj value doesn't cause
                               an overflow or underflow.[br] This field can be
                               programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_20 : 1;

                            /* Bits[20:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sampler_even_offset3 : 6;

                            /* Bits[26:21], Access Type=RW/V, default=0x0000001F*/

                            /*
                               Rx Even Sampler Offset Control.[br] Normal
                               operation (dfe_coeff_training_en=0): -155mV to
                               +155mV in 5mV steps in normal operation
                               (0=-155mV, 31=no offset, 62=+155mV, 63=not
                               used)[br] Extended range
                               (dfe_coeff_training_en=1): -620mV to +620mV in
                               20mV steps (0=-620mV, 31=no offset, 62=+620mV,
                               63=not used). [br] Real range may be smaller due
                               to limited signal swing & common-mode.[br] This
                               value is added with sampler_offset_adj to allow
                               BIOS for margining sweep (Signed number. The
                               Range is -32 to 31).[br] Note: BIOS must make
                               sure the sampler_offset_adj value doesn't cause
                               an overflow or underflow.[br] This field can be
                               programmed by BIOS or HW cal FSM.
                            */
    UINT32 rsvd_27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_SAMPLER_EVEN_OFFSET_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RXVREF_CTL_MC_DDRIOMC_REG supported on:                              */
/*      SPRA0 (0x2001b180)                                                      */
/*      SPRB0 (0x2001b180)                                                      */
/*      SPRHBM (0x2001b180)                                                     */
/*      SPRC0 (0x2001b180)                                                      */
/*      SPRMCC (0x2001b180)                                                     */
/*      SPRUCC (0x2001b180)                                                     */
/* Register default value on SPRA0: 0x07EFDFBF                                  */
/* Register default value on SPRB0: 0x07EFDFBF                                  */
/* Register default value on SPRHBM: 0x07EFDFBF                                 */
/* Register default value on SPRC0: 0x07EFDFBF                                  */
/* Register default value on SPRMCC: 0x07EFDFBF                                 */
/* Register default value on SPRUCC: 0x07EFDFBF                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* RX VREF Control Register
*/


#define DDRD_N0_RXVREF_CTL_MC_DDRIOMC_REG 0x0822B180

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vref_ctl0 : 7;

                            /* Bits[6:0], Access Type=RW, default=0x0000003F*/

                            /*
                               Per bit Rx Vref Control for DQ0. This value is
                               added with vref_adj to allow BIOS for margining
                               sweep (Signed number. The Range is -64 to 63).
                               The final result is sent to vref CBB. [br] Note:
                               The vref CBB control input is 8-bit. The MSB
                               (Bit 8 is tie to 1). It means the default value
                               is 75% of vccddr_hv[br] Note: BIOS must make
                               sure the vref_adj value doens't cause an
                               overflow or underflow.
                            */
    UINT32 vref_ctl1 : 7;

                            /* Bits[13:7], Access Type=RW, default=0x0000003F*/

                            /*
                               Per bit Rx Vref Control for DQ1. This value is
                               added with vref_adj to allow BIOS for margining
                               sweep (Signed number. The Range is -64 to 63).
                               The final result is sent to vref CBB. [br] Note:
                               The vref CBB control input is 8-bit. The MSB
                               (Bit 8 is tie to 1). It means the default value
                               is 75% of vccddr_hv[br] Note: BIOS must make
                               sure the vref_adj value doens't cause an
                               overflow or underflow.
                            */
    UINT32 vref_ctl2 : 7;

                            /* Bits[20:14], Access Type=RW, default=0x0000003F*/

                            /*
                               Per bit Rx Vref Control for DQ2. This value is
                               added with vref_adj to allow BIOS for margining
                               sweep (Signed number. The Range is -64 to 63).
                               The final result is sent to vref CBB. [br] Note:
                               The vref CBB control input is 8-bit. The MSB
                               (Bit 8 is tie to 1). It means the default value
                               is 75% of vccddr_hv[br] Note: BIOS must make
                               sure the vref_adj value doens't cause an
                               overflow or underflow.
                            */
    UINT32 vref_ctl3 : 7;

                            /* Bits[27:21], Access Type=RW, default=0x0000003F*/

                            /*
                               Per bit Rx Vref Control for DQ3. This value is
                               added with vref_adj to allow BIOS for margining
                               sweep (Signed number. The Range is -64 to 63).
                               The final result is sent to vref CBB. [br] Note:
                               The vref CBB control input is 8-bit. The MSB
                               (Bit 8 is tie to 1). It means the default value
                               is 75% of vccddr_hv[br] Note: BIOS must make
                               sure the vref_adj value doens't cause an
                               overflow or underflow.
                            */
    UINT32 rsvd_28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RXVREF_CTL_MC_DDRIOMC_STRUCT;

/* DDRD_N0_COMP_LA0_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001b184)                                                      */
/*      SPRB0 (0x2001b184)                                                      */
/*      SPRHBM (0x2001b184)                                                     */
/*      SPRC0 (0x2001b184)                                                      */
/*      SPRMCC (0x2001b184)                                                     */
/*      SPRUCC (0x2001b184)                                                     */
/* Register default value on SPRA0: 0x01020408                                  */
/* Register default value on SPRB0: 0x01020408                                  */
/* Register default value on SPRHBM: 0x01020408                                 */
/* Register default value on SPRC0: 0x01020408                                  */
/* Register default value on SPRMCC: 0x01020408                                 */
/* Register default value on SPRUCC: 0x01020408                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Late Action Register for RCOMP DRV/ODT UP/DN. It is updated either by COMP training FSM or SW. The promotion from late acton register to effective register is controlled by COMP FSM after quiescent request is granted from MC.
*/


#define DDRD_N0_COMP_LA0_MC_DDRIOMC_REG 0x0822B184

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rcomp_drv_up : 5;

                            /* Bits[4:0], Access Type=RW/V, default=0x00000008*/

                            /*
                               Data Rcomp Drive Up Comp Value. It is trained by
                               COMP FSM.[br] This value is added with
                               rcomp_drv_up_adj (signed number. Range is -8 to
                               7) before send it to the dqbuf and dqsbuf.[br]
                               Note: HW checks for overflow and underflow
                               condition.
                            */
    UINT32 rsvd : 2;

                            /* Bits[6:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rcomp_drv_dn : 5;

                            /* Bits[11:7], Access Type=RW/V, default=0x00000008*/

                            /*
                               Data Rcomp Drive Down Comp Value. It is trained
                               by COMP FSM.[br] This value is added with
                               rcomp_drv_dn_adj (signed number. Range is -8 to
                               7) before send it to the dqbuf and dqsbuf.[br]
                               Note: HW checks for overflow and underflow
                               condition.
                            */
    UINT32 rsvd_12 : 2;

                            /* Bits[13:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rcomp_odt_up : 5;

                            /* Bits[18:14], Access Type=RW/V, default=0x00000008*/

                            /*
                               Data Rcomp OdtUp Comp Value. It is trained by
                               COMP FSM.[br] This value is added with
                               rcomp_odt_up_adj (signed number. Range is -8 to
                               7) before send it to the dqbuf and dqsbuf.[br]
                               Note: HW checks for overflow and underflow
                               condition.
                            */
    UINT32 rsvd_19 : 2;

                            /* Bits[20:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rcomp_odt_dn : 5;

                            /* Bits[25:21], Access Type=RW/V, default=0x00000008*/

                            /*
                               Data Rcomp Odt-Down Comp Value. It is trained by
                               COMP FSM.[br] This value is added with
                               rcomp_odt_dn_adj (signed number. Range is -8 to
                               7) before send it to the dqbuf and dqsbuf.[br]
                               Note: HW checks for overflow and underflow
                               condition.
                            */
    UINT32 rsvd_26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_COMP_LA0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_COMP_LA1_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001b188)                                                      */
/*      SPRB0 (0x2001b188)                                                      */
/*      SPRHBM (0x2001b188)                                                     */
/*      SPRC0 (0x2001b188)                                                      */
/*      SPRMCC (0x2001b188)                                                     */
/*      SPRUCC (0x2001b188)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Late Action Register for SCOMP, and TCO COMP. It is updated by BIOS. The promotion from late acton register to effective register is controlled by COMP FSM after quiescent request is granted from MC.
*/


#define DDRD_N0_COMP_LA1_MC_DDRIOMC_REG 0x0822B188

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tco_comp : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               Data TCO Comp Value for dqbuf and dqsbuf. It is
                               trained by BIOS.[br] 0/64: fastest rise & fall
                               delay[br] 0->31: increasing fall delay[br]
                               64->95: increasing rise delay[br] Other values
                               are not used (32-63 & 96-127).[br] To get
                               monotonic increasing sweep of dutycycle, sweep
                               from (95 to 65, 0 to 31)
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 scomp : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000000*/

                            /*
                               Data Slew Rate Comp Value for dqbuf and dqsbuf.
                               It is trained by BIOS.[br] [br] 0 is fastest
                               slew rate, 31 is slowest slew rate.[br] The
                               SCOMP Up/Down Code are generated from the
                               following equation:[br] SCOMP Up code[lb]4:0[rb]
                               = scomp[lb]4:0[rb] +
                               scomp_up_adj[lb]3:0[rb];[br] SCOMP Down
                               code[lb]4:0[rb] = scomp[lb]4:0[rb] +
                               scomp_dn_adj[lb]3:0[rb];[br] Note : both SCOMP
                               up Adjust (scomp_up_adj) and SCOMP down adjust
                               (scomp_dn_adj) are signed valued. The adjust
                               range is -8 to 7[br] Note: HW checks for
                               overflow and underflow condition.
                            */
    UINT32 rsvd_13 : 1;

                            /* Bits[13:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxrt_dqs_dly_adj : 7;

                            /* Bits[20:14], Access Type=RO/V, default=0x00000000*/

                            /*
                               Rx Retraining DQS delay adjust value for DQS N
                               and P. This field is calcuated by DDRCOMP fub
                               and broadcast to all the data fub. The adjust
                               range is -64 to 63.
                            */
    UINT32 rsvd_21 : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_COMP_LA1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_COMP_OFFSET_MC_DDRIOMC_REG supported on:                             */
/*      SPRA0 (0x2001b18c)                                                      */
/*      SPRB0 (0x2001b18c)                                                      */
/*      SPRHBM (0x2001b18c)                                                     */
/*      SPRC0 (0x2001b18c)                                                      */
/*      SPRMCC (0x2001b18c)                                                     */
/*      SPRUCC (0x2001b18c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* COMP offset values add on to SCOMP, RCOMP DRV/ODT up/down
*/


#define DDRD_N0_COMP_OFFSET_MC_DDRIOMC_REG 0x0822B18C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rcomp_drv_up_adj : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               Signed number add to rcomp_drv_up to generate
                               the RCOMP Drive up code. The adjust range is -8
                               to 7.
                            */
    UINT32 rsvd : 1;

                            /* Bits[4:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rcomp_drv_dn_adj : 4;

                            /* Bits[8:5], Access Type=RW, default=0x00000000*/

                            /*
                               Signed number add to rcomp_drv_dn to generate
                               the RCOMP Drive down code. The adjust range is
                               -8 to 7.
                            */
    UINT32 rsvd_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rcomp_odt_up_adj : 4;

                            /* Bits[13:10], Access Type=RW, default=0x00000000*/

                            /*
                               Signed number add to rcomp_odt_up to generate
                               the RCOMP ODT up code. The adjust range is -8 to
                               7
                            */
    UINT32 rsvd_14 : 1;

                            /* Bits[14:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rcomp_odt_dn_adj : 4;

                            /* Bits[18:15], Access Type=RW, default=0x00000000*/

                            /*
                               Signed number add to rcomp_odt_dn to generate
                               the RCOMP ODT down code. The adjust range is -8
                               to 7
                            */
    UINT32 rsvd_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 scomp_up_adj : 4;

                            /* Bits[23:20], Access Type=RW, default=0x00000000*/

                            /*
                               Signed number add to scomp to generate the SCOMP
                               Up Code. The adjust range is -8 to 7.
                            */
    UINT32 rsvd_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 scomp_dn_adj : 4;

                            /* Bits[28:25], Access Type=RW, default=0x00000000*/

                            /*
                               Signed number add to scomp to generate the SCOMP
                               Down Code. The adjust range is -8 to 7.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_COMP_OFFSET_MC_DDRIOMC_STRUCT;

/* DDRD_N0_VSSHI_CTL_MC_DDRIOMC_REG supported on:                               */
/*      SPRA0 (0x2001b190)                                                      */
/*      SPRB0 (0x2001b190)                                                      */
/*      SPRHBM (0x2001b190)                                                     */
/*      SPRC0 (0x2001b190)                                                      */
/*      SPRMCC (0x2001b190)                                                     */
/*      SPRUCC (0x2001b190)                                                     */
/* Register default value on SPRA0: 0x00600118                                  */
/* Register default value on SPRB0: 0x00600118                                  */
/* Register default value on SPRHBM: 0x00600118                                 */
/* Register default value on SPRC0: 0x00600118                                  */
/* Register default value on SPRMCC: 0x00600118                                 */
/* Register default value on SPRUCC: 0x00600118                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* VSSHI/LDO Control Register
*/


#define DDRD_N0_VSSHI_CTL_MC_DDRIOMC_REG 0x0822B190

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vsshi_target_code : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000018*/

                            /*
                               VSSHI target code to vsshi vref control. Step
                               size for 10nm VssHi is vccddr_hv/256.[br] Code
                               should be programmed according to analog_tuning
                               field in dll status register:[br] DDR5/T2
                               DDR4/T[br] 3'd3: 0x45 0x55[br] 3'd1,3'd2: 0x3a
                               0x4a[br] 3'd0: 0x2e 0x40[br] Note: the vref_ctrl
                               MSB (Bit 7) is hardtie to 0 inside VSSHI. Only
                               the lower 7-bit is controlled by this field.
                            */
    UINT32 vsshi_bias_ctl : 2;

                            /* Bits[8:7], Access Type=RW, default=0x00000002*/

                            /*
                               Vsshi Bias Current trim.[br] The field should be
                               programmed according to analog_tuning field.[br]
                               00: min current (if analog_tuning=3d3, fast
                               skew)[br] 01: mid current (if
                               analog_tuning=3d1/3d2, typ skew)[br] 11: max
                               current (if analog_tuning=3d0, slow skew)
                            */
    UINT32 vsshi_pulldown_en : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* Pull VSSHI to VSS */
    UINT32 vsshi_close_loop : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Operates VssHi in Close loop mode */
    UINT32 ldo_bypass_ddra : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /* LDO output is bypassed to VCCDDRA */
    UINT32 ldo_vref_sel_ddra : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /* Use vccddra as LDO vref */
    UINT32 ldo_bw_ctl : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               LDO driver strength based on process variation.
                               Bit 1 is unused. Bit 0 used for LDO Driver
                               Strength[br] This field should be programmed
                               according to analog_tuning field in dll status
                               register:[br] (Fast) 3'd3: 0x0[br] (Typ)
                               3'd1,3'd2: 0x0[br] (Slow) 3'd0: 0x1[br]
                            */
    UINT32 ldo_rcfilter_trim : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /* LDO RC Filter Trim */
    UINT32 ldo_codetarget : 7;

                            /* Bits[24:18], Access Type=RW, default=0x00000018*/

                            /*
                               Sets the LDO reference voltage when
                               ldo_vref_sel_ddra=0.[br] Range is (vccddr_hv/2
                               to vccddr_hv), with step size of
                               vccddr_hv/256.[br] Note: the vref_ctrl MSB (Bit
                               7) is hardtie to 1 inside LDO. Only the lower
                               7-bit is controlled by this field.
                            */
    UINT32 ldo_captrim_loop : 4;

                            /* Bits[28:25], Access Type=RW, default=0x00000000*/

                            /* LDO Cap Trim Loop */
    UINT32 ldo_close_loop : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* Operate LDO in close loop mode */
    UINT32 vsshi_ldo_tmr_ext : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Double the timer for LDO/VSSHI settle time. Use
                               for failsafe in case settle time was
                               underestimated.[br] 0: 8K+1K=9K Dclk cycles[br]
                               1: 16K+2K=18K Dclk cycles[br] Doubles the
                               LDO/VSSHI settle time counter in case hard-coded
                               value is not adequate
                            */
    UINT32 vsshi_dclk_gate_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate DCLK for VSSHI
                               control logic. Default is disable clock gating.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_VSSHI_CTL_MC_DDRIOMC_STRUCT;


/* DDRD_N0_DLL_CSR_MC_DDRIOMC_REG supported on:                                 */
/*      SPRA0 (0x2001b198)                                                      */
/*      SPRB0 (0x2001b198)                                                      */
/*      SPRHBM (0x2001b198)                                                     */
/*      SPRC0 (0x2001b198)                                                      */
/*      SPRMCC (0x2001b198)                                                     */
/*      SPRUCC (0x2001b198)                                                     */
/* Register default value on SPRA0: 0x28000000                                  */
/* Register default value on SPRB0: 0x28000000                                  */
/* Register default value on SPRHBM: 0x28000000                                 */
/* Register default value on SPRC0: 0x28000000                                  */
/* Register default value on SPRMCC: 0x28000000                                 */
/* Register default value on SPRUCC: 0x28000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* DLL Control and Status Register
*/


#define DDRD_N0_DLL_CSR_MC_DDRIOMC_REG 0x0822B198

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 detrm_lock : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /* DLL Deterministic Lock Status */
    UINT32 raw_lock : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /* DLL Raw Lock Status Sticky bit. */
    UINT32 lock_timeout : 1;

                            /* Bits[2:2], Access Type=RO/V, default=0x00000000*/

                            /* DLL Lock timeout. */
    UINT32 dll_reset : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000000*/

                            /* DLL Reset. */
    UINT32 adcout : 10;

                            /* Bits[13:4], Access Type=RO/V, default=0x00000000*/

                            /* DLL ADC out. */
    UINT32 long_lock : 1;

                            /* Bits[14:14], Access Type=RO/V, default=0x00000000*/

                            /* DLL Long Lock Status. */
    UINT32 detlock_earlylockstky : 1;

                            /* Bits[15:15], Access Type=RO/V, default=0x00000000*/

                            /* Detect lock CBB early lock sticky output */
    UINT32 weak_lock : 1;

                            /* Bits[16:16], Access Type=RO/V, default=0x00000000*/

                            /* DLL Weak Lock Status. */
    UINT32 adc_done : 1;

                            /* Bits[17:17], Access Type=RO/V, default=0x00000000*/

                            /* DLL ADC done. */
    UINT32 pilags : 1;

                            /* Bits[18:18], Access Type=RO/V, default=0x00000000*/

                            /*
                               DLL output of PiDFx FSM to indciate Pi lags. In
                               order to read this debug register, clock gating
                               must be disabled.
                            */
    UINT32 openloop : 1;

                            /* Bits[19:19], Access Type=RO/V, default=0x00000000*/

                            /* MDLL open loop output */
    UINT32 lockrst_b : 1;

                            /* Bits[20:20], Access Type=RO/V, default=0x00000000*/

                            /* Detect lock CBB lock reset output */
    UINT32 analog_tuning : 3;

                            /* Bits[23:21], Access Type=RO/V, default=0x00000000*/

                            /*
                               BIOS should configure certain analog components
                               based on the value of this register.[br] Details
                               will be found in the description of any CSR that
                               relies on this value
                            */
    UINT32 rsvd : 3;

                            /* Bits[26:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 flybyclk_sel : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000001*/

                            /*
                               Bypasses flyby clock and selects H-tree clock
                               when disbled
                            */
    UINT32 iofreq_range : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000002*/

                            /*
                               BIOS program this IO Frequency range field based
                               on PLL freq. It is half of the DRAM transfer
                               rate.[br] For example DDR 4800. The PLL freq is
                               2400.[br] 2b00: 933MHz - 1333MHz (i.e. 1867MT/s
                               to 2667MT/s)[br] 2b01: 1467MHz 1600MHz (i.e.
                               2933MT/s to 3200MT/s)[br] 2b10: 1800MHz 2000MHz
                               (i.e. 3600MT/s to 4000MT/s)[br] 2b11: 2200MHz
                               2400MHz, or above (i.e. 4400MT/s to 4800MT/s)
                            */
    UINT32 rsvd_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dll_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS must enable DLL when program the IO freq
                               range.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_DLL_CSR_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RXFIFO_PTR_LOG_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b19c)                                                      */
/*      SPRB0 (0x2001b19c)                                                      */
/*      SPRHBM (0x2001b19c)                                                     */
/*      SPRC0 (0x2001b19c)                                                      */
/*      SPRMCC (0x2001b19c)                                                     */
/*      SPRUCC (0x2001b19c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Debug register to observe RX FIFO write and read pointer.
*/


#define DDRD_N0_RXFIFO_PTR_LOG_MC_DDRIOMC_REG 0x0822B19C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxfifo_ptr_err_cnt : 3;

                            /* Bits[2:0], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Sticky error count. Reset by power good
                               reset.[br] Increment when data fub detect rxfifo
                               read and write pointer is out of sync.
                            */
    UINT32 rsvd : 29;

                            /* Bits[31:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_RXFIFO_PTR_LOG_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TRAIN_OFFSET0_MC_DDRIOMC_REG supported on:                           */
/*      SPRA0 (0x2001b1a0)                                                      */
/*      SPRB0 (0x2001b1a0)                                                      */
/*      SPRHBM (0x2001b1a0)                                                     */
/*      SPRC0 (0x2001b1a0)                                                      */
/*      SPRMCC (0x2001b1a0)                                                     */
/*      SPRUCC (0x2001b1a0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Training offset control for VREF, TXDQ and RXDQS
*/


#define DDRD_N0_TRAIN_OFFSET0_MC_DDRIOMC_REG 0x0822B1A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rxdqs_dly_adj : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               Rx DQS delay adjust value. It is added to all
                               per bit RXDQS delay. It is used by BIOS for
                               margining sweep or ACIO HW training. The adjust
                               range is -128 to 127. The expected usage model
                               is BIOS broadcast the same adjust value to all
                               the bytes.
                            */
    UINT32 txdq_dly_adj : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Tx DQ delay adjust value. It is added to all per
                               bit TXDQ delay. It is used by BIOS for margining
                               sweep. The adjust range is -128 to 127. The
                               expected usage model is BIOS broadcast the same
                               adjust value to all the bytes.
                            */
    UINT32 vref_adj : 7;

                            /* Bits[22:16], Access Type=RW, default=0x00000000*/

                            /*
                               Signed number with range from -64 to 63. It is
                               used by BIOS for marging sweep. This value is
                               added to the vref_ctrl before sending to the DQ
                               VREF. [br] Note: HW doesn't check for overflow
                               and underflow. BIOS must ensure the adjust value
                               doesn't overflow or underflow the final vref
                               control value.
                            */
    UINT32 sampler_offset_adj : 6;

                            /* Bits[28:23], Access Type=RW, default=0x00000000*/

                            /*
                               Rx Sampler Offset adjust value. It is added to
                               all sampler_even/odd_offset. It is used by BIOS
                               for sampler offsets margining. The adjust range
                               is -32 to 31. The expected usage model is BIOS
                               broadcast the same value to all the bytes.
                            */
    UINT32 rsvd : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TRAIN_OFFSET0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_PIREF_OFFSET0_MC_DDRIOMC_REG supported on:                           */
/*      SPRA0 (0x2001b1a4)                                                      */
/*      SPRB0 (0x2001b1a4)                                                      */
/*      SPRHBM (0x2001b1a4)                                                     */
/*      SPRC0 (0x2001b1a4)                                                      */
/*      SPRMCC (0x2001b1a4)                                                     */
/*      SPRUCC (0x2001b1a4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* PIREF offset for TXDQS, TXDQ and Receive Enable XOVER
*/


#define DDRD_N0_PIREF_OFFSET0_MC_DDRIOMC_REG 0x0822B1A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 piref_train_pi_code : 7;

                            /* Bits[6:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               It is the train PI code to align the PIREF clock
                               to the failing edge of DCLK with data
                               propagation delay after xover training. [br]
                               This value is added with a signed
                               piref_setup_adj (default value is 63) to
                               generate the piref_code to DLL. The xover input
                               is driven from a failing edge of DCLK flop. [br]
                               By moving the piref odd clock to the right by 63
                               ticks, we will have 63 pi tick of setup
                               margin.[br] This field can be programed by BIOS
                               or HW cal FSM.
                            */
    UINT32 rcven_piref_offset : 7;

                            /* Bits[13:7], Access Type=RW/V, default=0x00000000*/

                            /*
                               This rcven piref offset is added with a signed
                               piref_setup_adj (default value is 63). The
                               result is added to the rcven_dly[6:0], so the
                               txdq PI odd code is relative to the piref clock.
                               This field can be programed by BIOS or HW cal
                               FSM.
                            */
    UINT32 txdq_piref_offset : 7;

                            /* Bits[20:14], Access Type=RW/V, default=0x00000000*/

                            /*
                               This txdq piref offset is added with a signed
                               piref_setup_adj (default value is 63). The
                               result is added to the per bit txdq_dly[6:0], so
                               the txdq PI odd code is relative to the piref
                               clock. This field can be programed by BIOS or HW
                               cal FSM.
                            */
    UINT32 txdqs_piref_offset : 7;

                            /* Bits[27:21], Access Type=RW/V, default=0x00000000*/

                            /*
                               This txdqs piref offset is added with a signed
                               piref_setup_adj (default value is 63). The
                               result is added to the txdqs_dly[6:0], so the
                               txdqs PI odd code is relative to the piref
                               clock. This field can be programed by BIOS or HW
                               cal FSM.
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_PIREF_OFFSET0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_PIREF_OFFSET1_MC_DDRIOMC_REG supported on:                           */
/*      SPRA0 (0x2001b1a8)                                                      */
/*      SPRB0 (0x2001b1a8)                                                      */
/*      SPRHBM (0x2001b1a8)                                                     */
/*      SPRC0 (0x2001b1a8)                                                      */
/*      SPRMCC (0x2001b1a8)                                                     */
/*      SPRUCC (0x2001b1a8)                                                     */
/* Register default value on SPRA0: 0x0000003F                                  */
/* Register default value on SPRB0: 0x0000003F                                  */
/* Register default value on SPRHBM: 0x0000003F                                 */
/* Register default value on SPRC0: 0x0000003F                                  */
/* Register default value on SPRMCC: 0x0000003F                                 */
/* Register default value on SPRUCC: 0x0000003F                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Training offset control for all PI codes
*/


#define DDRD_N0_PIREF_OFFSET1_MC_DDRIOMC_REG 0x0822B1A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 piref_setup_adj : 7;

                            /* Bits[6:0], Access Type=RW/V, default=0x0000003F*/

                            /*
                               A singed number for piref setup adjust. Range is
                               -64 to 63. [br] The xover input is driven from a
                               inverted DCLK flop. This conrol allows BIOS to
                               adjust the setup time to the input of the xover
                               piref odd clock flop. [br] Default value is 63.
                               [br] It means after xover training to align the
                               piref odd clock to the dclk. The piref odd clock
                               is moved to the right by 64 ticks, and we will
                               have 64 pi tick of setup margin. [br] HW will
                               add this value to all the pi codes before send
                               to DLL.
                            */
    UINT32 rsvd : 25;

                            /* Bits[31:7], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_PIREF_OFFSET1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL0_MC_DDRIOMC_REG supported on:                                 */
/*      SPRA0 (0x2001b1ac)                                                      */
/*      SPRB0 (0x2001b1ac)                                                      */
/*      SPRHBM (0x2001b1ac)                                                     */
/*      SPRC0 (0x2001b1ac)                                                      */
/*      SPRMCC (0x2001b1ac)                                                     */
/*      SPRUCC (0x2001b1ac)                                                     */
/* Register default value on SPRA0: 0x07C09003                                  */
/* Register default value on SPRB0: 0x07C09003                                  */
/* Register default value on SPRHBM: 0x07C09003                                 */
/* Register default value on SPRC0: 0x07C09003                                  */
/* Register default value on SPRMCC: 0x07C09003                                 */
/* Register default value on SPRUCC: 0x07C09003                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* RX control 0 Register
*/


#define DDRD_N0_RX_CTL0_MC_DDRIOMC_REG 0x0822B1AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 odt_seg_en : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000003*/

                            /*
                               Control number of ODT segment enable for DQ and
                               DQS. ODT rotation is applied before sending the
                               control to CBB. The rotation is used to ensure
                               the segment is evenly burn. Rotation is happened
                               when odten is deasserted. [br] Note: Setting
                               this field to 0x3 means enable all segments and
                               rotation has no meaning.
                            */
    UINT32 rsvd : 5;

                            /* Bits[6:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pbias_stg2amp_trim : 3;

                            /* Bits[9:7], Access Type=RW, default=0x00000000*/

                            /*
                               Amplifier control. The bits in this field
                               control: [br] 2:1 - is used to adjust the bias
                               current for the 2nd stage amplifier in the DQS
                               amplifier path. 0=min, 3=max. [br] 0 - is used
                               to force local receiver bias to on. Otherwise,
                               local receiver bias is enabled through senseamp
                               enable.
                            */
    UINT32 rsvd_10 : 1;

                            /* Bits[10:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxgainfuse_ovrd : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Repurposed for force local receiver bias on for
                               DQbuf.[br] When set to 1, it will keep the local
                               bias mirror always enabled.[br] When set to 0,
                               local bias gets enabled with senseamp_enable.
                            */
    UINT32 rxbias_vcm_ctl : 2;

                            /* Bits[13:12], Access Type=RW, default=0x00000001*/

                            /*
                               Rx summer output common mode control[br] 0:
                               0.25*vccddra[br] 1: 0.3*vccddra (default)[br] 2:
                               0.35*vccddra[br] 3: 0.4*vccddra
                            */
    UINT32 rsvd_14 : 1;

                            /* Bits[14:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rxbias_rxgain_ctl : 2;

                            /* Bits[16:15], Access Type=RW, default=0x00000001*/

                            /*
                               00 1.5x (default for CMD/CLK)[br] 01 2x[br] 10 -
                               2.5x (default for DQ)[br] 11 3x
                            */
    UINT32 rsvd_17 : 5;

                            /* Bits[21:17], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 odt_static_leg_cfg : 5;

                            /* Bits[26:22], Access Type=RW, default=0x0000001F*/

                            /*
                               Sets number of ODT static legs. First 3 MSB bits
                               has weight of 4, 4th MSB has weight of 2 and LSB
                               bit has weight of 1. [br] Default of 0x1F has 15
                               static legs enabled.[br] Static leg training
                               starts with 0x1F (all 15 legs enabled)
                            */
    UINT32 ctle_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* CTLE enable */
    UINT32 rx_postamble_len : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               RX Postamble Length.[br] 0: 0.5 TCK Postamble
                               (default case)[br] 1: 1.5 TCK Postamble (the
                               extra 1 TCK pattern is toggle)
                            */
    UINT32 rx_preamble_type : 3;

                            /* Bits[31:29], Access Type=RW, default=0x00000000*/

                            /*
                               This field is used by rxdeskew logic to
                               determine preamble pattern type.[br] 0: 1 tclk -
                               10 Pattern (MSB is the 1st UI)[br] 1: 2 tclk -
                               0010 Pattern[br] 2: 2 tclk - 1110 Pattern [br]
                               3: 3 tclk - 000010 Pattern[br] 4: 4 tclk -
                               00001010 Pattern[br] Others : Reserved
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_RX_CTL1_MC_DDRIOMC_REG supported on:                                 */
/*      SPRA0 (0x2001b1b0)                                                      */
/*      SPRB0 (0x2001b1b0)                                                      */
/*      SPRHBM (0x2001b1b0)                                                     */
/*      SPRC0 (0x2001b1b0)                                                      */
/*      SPRMCC (0x2001b1b0)                                                     */
/*      SPRUCC (0x2001b1b0)                                                     */
/* Register default value on SPRA0: 0x000001DE                                  */
/* Register default value on SPRB0: 0x000001DE                                  */
/* Register default value on SPRHBM: 0x000001DE                                 */
/* Register default value on SPRC0: 0x000001DE                                  */
/* Register default value on SPRMCC: 0x000001DE                                 */
/* Register default value on SPRUCC: 0x000001DE                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* RX control 1 Register
*/


#define DDRD_N0_RX_CTL1_MC_DDRIOMC_REG 0x0822B1B0

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rx_dqs_sa_offset : 6;

                            /* Bits[5:0], Access Type=RW, default=0x0000001E*/

                            /* strobe Rx Amp offset control in DQS RxAmp */
    UINT32 rx_offset_en : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /*
                               enable the offset control in DQ/DQS RxAmp and RX
                               BIAS.
                            */
    UINT32 sdll_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000001*/

                            /*
                               Controls if the slave DLL is enabled in the
                               Deskew logic.
                            */
    UINT32 rx_sampler_offset_en : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Rx Sampler offset enable. Also enables the RDAC
                               for the sampler offset correction. Needs to be 1
                               for DDR5/DDRT2.
                            */
    UINT32 ext_rx_pulse_width : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Extend DDR4 RxDFE serializer pulse width.[br]
                               Set to 1 to extend the pulse width of the pulsed
                               clocks to the DDR4 RxDFE serializers.[br] Value
                               of 1 seems to work across PVT. May need to set
                               to 0 for slow silicon if we see issues in post
                               silicon.
                            */
    UINT32 dfe_en : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Enable DFE in DQ. Also it is used in RXBIASANA. */
    UINT32 set_vcdl_fdbk_path : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               When set the feedback data is muxed into the
                               VCDL[br] When cleared the DQ data from Amp is
                               muxed into the VCDL
                            */
    UINT32 byp_vcdl_fwd_path : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               When set, the VCDL is removed from the DQ path
                               from Amp to samplers[br] When cleared, the DQ
                               passes from Amp to VCDL and then to samplers
                            */
    UINT32 rx_sampler_tailtune : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 0 by default to enable all the devices in
                               the current source legs across all skews.[br]
                               Set to 1 to reduce number of current sources for
                               any sensitivity issues during post silicon
                               testing.
                            */
    UINT32 rsvd : 10;

                            /* Bits[23:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sdl_max_picode : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /*
                               After training , this max value of picode is
                               used for enabling appropriate number of delay
                               cells in SDL for power saving . It should be
                               programmed with the max sdl picode from the
                               nibble
                            */
    UINT32 sdl_gating_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable gating of delay elements in
                               SDL. Default is disable gating. Note : gating
                               must be disabled during any training steps. BIOS
                               can enable gating for power saving after all the
                               training steps are done.
                            */
    UINT32 hw_rxfifo_ptr_rst_en : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW reset RXFIFO Pointer when
                               there is no outstanding read in DDRIO.
                            */
    UINT32 loadtrim : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* Rload trimming in rx decoder */
    UINT32 bwextend : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /* Negative cap BW extension */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL1_MC_DDRIOMC_SPRA0_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rx_dqs_sa_offset : 6;

                            /* Bits[5:0], Access Type=RW, default=0x0000001E*/

                            /* strobe Rx Amp offset control in DQS RxAmp */
    UINT32 rx_offset_en : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /*
                               enable the offset control in DQ/DQS RxAmp and RX
                               BIAS.
                            */
    UINT32 sdll_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000001*/

                            /*
                               Controls if the slave DLL is enabled in the
                               Deskew logic.
                            */
    UINT32 rx_sampler_offset_en : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Rx Sampler offset enable. Also enables the RDAC
                               for the sampler offset correction. Needs to be 1
                               for DDR5/DDRT2.
                            */
    UINT32 ext_rx_pulse_width : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Extend DDR4 RxDFE serializer pulse width.[br]
                               Set to 1 to extend the pulse width of the pulsed
                               clocks to the DDR4 RxDFE serializers.[br] Value
                               of 1 seems to work across PVT. May need to set
                               to 0 for slow silicon if we see issues in post
                               silicon.
                            */
    UINT32 dfe_en : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Enable DFE in DQ. Also it is used in RXBIASANA. */
    UINT32 set_vcdl_fdbk_path : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               When set the feedback data is muxed into the
                               VCDL[br] When cleared the DQ data from Amp is
                               muxed into the VCDL
                            */
    UINT32 byp_vcdl_fwd_path : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               When set, the VCDL is removed from the DQ path
                               from Amp to samplers[br] When cleared, the DQ
                               passes from Amp to VCDL and then to samplers
                            */
    UINT32 rx_sampler_tailtune : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 0 by default to enable all the devices in
                               the current source legs across all skews.[br]
                               Set to 1 to reduce number of current sources for
                               any sensitivity issues during post silicon
                               testing.
                            */
    UINT32 rsvd : 4;

                            /* Bits[17:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dqs_ctle_en : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /* DQS CTLE enable */
    UINT32 dqs_ctle_cap_en : 2;

                            /* Bits[20:19], Access Type=RW, default=0x00000000*/

                            /* DQS CTLE Cap enable. 0=1C, 1=2C, 2=3C, 3=4C. */
    UINT32 dqs_ctle_res_en : 3;

                            /* Bits[23:21], Access Type=RW, default=0x00000000*/

                            /*
                               DQS CTLE Resistor Enable (Controls DC gain). 0 =
                               lowest DC gain (max peaking)[br] Res: 0-3R,
                               1=2R, 2=3R/2, 3=R, 4=2R/3, 5=R/2, 6=R/3,
                               7=R/4[br] where R is ~500 Ohms and depends on
                               process.
                            */
    UINT32 sdl_max_picode : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /*
                               After training , this max value of picode is
                               used for enabling appropriate number of delay
                               cells in SDL for power saving . It should be
                               programmed with the max sdl picode from the
                               nibble
                            */
    UINT32 sdl_gating_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable gating of delay elements in
                               SDL. Default is disable gating. Note : gating
                               must be disabled during any training steps. BIOS
                               can enable gating for power saving after all the
                               training steps are done.
                            */
    UINT32 hw_rxfifo_ptr_rst_en : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW reset RXFIFO Pointer when
                               there is no outstanding read in DDRIO.
                            */
    UINT32 loadtrim : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* Rload trimming in rx decoder */
    UINT32 bwextend : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /* Negative cap BW extension */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL1_MC_DDRIOMC_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rx_dqs_sa_offset : 6;

                            /* Bits[5:0], Access Type=RW, default=0x0000001E*/

                            /* strobe Rx Amp offset control in DQS RxAmp */
    UINT32 rx_offset_en : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /*
                               enable the offset control in DQ/DQS RxAmp and RX
                               BIAS.
                            */
    UINT32 sdll_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000001*/

                            /*
                               Controls if the slave DLL is enabled in the
                               Deskew logic.
                            */
    UINT32 rx_sampler_offset_en : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Rx Sampler offset enable. Also enables the RDAC
                               for the sampler offset correction. Needs to be 1
                               for DDR5/DDRT2.
                            */
    UINT32 ext_rx_pulse_width : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Extend DDR4 RxDFE serializer pulse width.[br]
                               Set to 1 to extend the pulse width of the pulsed
                               clocks to the DDR4 RxDFE serializers.[br] Value
                               of 1 seems to work across PVT. May need to set
                               to 0 for slow silicon if we see issues in post
                               silicon.
                            */
    UINT32 dfe_en : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Enable DFE in DQ. Also it is used in RXBIASANA. */
    UINT32 set_vcdl_fdbk_path : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               When set the feedback data is muxed into the
                               VCDL[br] When cleared the DQ data from Amp is
                               muxed into the VCDL
                            */
    UINT32 byp_vcdl_fwd_path : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               When set, the VCDL is removed from the DQ path
                               from Amp to samplers[br] When cleared, the DQ
                               passes from Amp to VCDL and then to samplers
                            */
    UINT32 rx_sampler_tailtune : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 0 by default to enable all the devices in
                               the current source legs across all skews.[br]
                               Set to 1 to reduce number of current sources for
                               any sensitivity issues during post silicon
                               testing.
                            */
    UINT32 rsvd : 10;

                            /* Bits[23:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sdl_max_picode : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /*
                               After training , this max value of picode is
                               used for enabling appropriate number of delay
                               cells in SDL for power saving . It should be
                               programmed with the max sdl picode from the
                               nibble
                            */
    UINT32 sdl_gating_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable gating of delay elements in
                               SDL. Default is disable gating. Note : gating
                               must be disabled during any training steps. BIOS
                               can enable gating for power saving after all the
                               training steps are done.
                            */
    UINT32 hw_rxfifo_ptr_rst_en : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW reset RXFIFO Pointer when
                               there is no outstanding read in DDRIO.
                            */
    UINT32 loadtrim : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* Rload trimming in rx decoder */
    UINT32 bwextend : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /* Negative cap BW extension */

  } Bits;
  UINT32 Data;

} DDRD_N0_RX_CTL1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL0_MC_DDRIOMC_REG supported on:                                 */
/*      SPRA0 (0x2001b1b8)                                                      */
/*      SPRB0 (0x2001b1b8)                                                      */
/*      SPRHBM (0x2001b1b8)                                                     */
/*      SPRC0 (0x2001b1b8)                                                      */
/*      SPRMCC (0x2001b1b8)                                                     */
/*      SPRUCC (0x2001b1b8)                                                     */
/* Register default value on SPRA0: 0x802000DF                                  */
/* Register default value on SPRB0: 0x802000DF                                  */
/* Register default value on SPRHBM: 0x802000DF                                 */
/* Register default value on SPRC0: 0x802000DF                                  */
/* Register default value on SPRMCC: 0x802000DF                                 */
/* Register default value on SPRUCC: 0x802000DF                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* TX control 0 Register
*/


#define DDRD_N0_TX_CTL0_MC_DDRIOMC_REG 0x0822B1B8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 drv_static_leg_cfg : 5;

                            /* Bits[4:0], Access Type=RW, default=0x0000001F*/

                            /*
                               Sets number of DQ/DQS driver (Ron) static
                               legs.[br] First 3 MSB bits has weight of 4, 4th
                               MSB has weight of 2 and LSB bit has weight of
                               1.[br] RTL default of 0x1F has 15 static legs
                               enabled.[br] Static leg training starts with
                               0x1F (all 15 legs enabled)
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 data_seg_en : 2;

                            /* Bits[7:6], Access Type=RW, default=0x00000003*/

                            /*
                               Control number of data sement enable for DQ and
                               DQS.
                            */
    UINT32 rsvd_8 : 9;

                            /* Bits[16:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 imode_en : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Enable Imode EQ per byte lane. [br] 0: Imode
                               completely off [br] 1: Imode enabled (Xtalk
                               cancellation OR swing boost selected by ImodeCfg
                            */
    UINT32 rsvd_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 eq_post2_sign : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               2nd tap equalization sign bit[br] 0 +ve
                               equalization[br] 1: -ve equalization
                            */
    UINT32 rsvd_20 : 1;

                            /* Bits[20:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 eq_post2_sel : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000001*/

                            /*
                               2nd tap selection:[br] 0 txeq_2nd_tap used for
                               2nd post cursor tap[br] 1 txeq_2nd_tap used for
                               extending range of 1st tap.
                            */
    UINT32 rsvd_22 : 1;

                            /* Bits[22:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 imode_eq_code : 6;

                            /* Bits[28:23], Access Type=RW, default=0x00000000*/

                            /*
                               Imode coefficient, sets Imode current.[br] Sweep
                               values: (0-15, 40-42, 48-63) for a linear
                               increase of current from 0 to max.
                            */
    UINT32 rsvd_29 : 1;

                            /* Bits[29:29], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_serializer_pwradj : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to extend the pulse width of the pulsed
                               clocks to the Tx serializers.[br] No need skew
                               based settings, value of 1 seems to work across
                               PVT.[br] May need to set to 0 for slow silicon
                               if we see issues in post silicon.
                            */
    UINT32 scomp_tco_bypass_dis : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               0 -DQBUF and DQSBUF bypass SCOMP and TCO delay
                               in the transmitter.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TX_CTL1_MC_DDRIOMC_REG supported on:                                 */
/*      SPRA0 (0x2001b1bc)                                                      */
/*      SPRB0 (0x2001b1bc)                                                      */
/*      SPRHBM (0x2001b1bc)                                                     */
/*      SPRC0 (0x2001b1bc)                                                      */
/*      SPRMCC (0x2001b1bc)                                                     */
/*      SPRUCC (0x2001b1bc)                                                     */
/* Register default value on SPRA0: 0x00000011                                  */
/* Register default value on SPRB0: 0x00000011                                  */
/* Register default value on SPRHBM: 0x00000011                                 */
/* Register default value on SPRC0: 0x00000011                                  */
/* Register default value on SPRMCC: 0x00000011                                 */
/* Register default value on SPRUCC: 0x00000011                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* TX control 1 Register
*/


#define DDRD_N0_TX_CTL1_MC_DDRIOMC_REG 0x0822B1BC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tx_preamble_len : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000001*/

                            /*
                               TX Preenable Length. [br] Legal programming
                               value for [br] DDR4: 1-2 TCK [br] DDR5: 2-4 TCK
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_preamble_pat : 8;

                            /* Bits[11:4], Access Type=RW, default=0x00000001*/

                            /*
                               Programmable Preamble pattern. Each bit
                               represents a UI of the preamble pattern starting
                               at LSB for 1st UI.[br] Note: For DDR5 write
                               leveling training, which require to mask off the
                               preamble strobe, BIOS can program the pattern to
                               all 0's.[br] [br] Legal value is listed below.
                               [br] DDR4-[br] 1 TCK: 8'bXXXX_XX01[br] 2 TCK:
                               8'bXXXX_0111 (Long Preamble)[br] DDR5-[br] 2
                               TCK: 8'XXXX_0100[br] 3 TCK: 8'bXX01_0000 or
                               8'bXX01_0100[br] 4 TCK: 8'b0101_0000
                            */
    UINT32 rsvd_12 : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_postamble_len : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               TX Postamble Length.[br] 0: 0.5 TCK Postamble
                               (default case)[br] 1: 1.5 TCK Postamble (the
                               extra 1 TCK pattern is always differentially
                               low)
                            */
    UINT32 rsvd_17 : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TX_CTL1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_PXC_CTL0_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001b1c4)                                                      */
/*      SPRB0 (0x2001b1c4)                                                      */
/*      SPRHBM (0x2001b1c4)                                                     */
/*      SPRC0 (0x2001b1c4)                                                      */
/*      SPRMCC (0x2001b1c4)                                                     */
/*      SPRUCC (0x2001b1c4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* PXC Control 0 Register
*/


#define DDRD_N0_PXC_CTL0_MC_DDRIOMC_REG 0x0822B1C4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 attacker_sel0 : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               Select which bit within a byte is the attacker
                               for dq0 in this nibble. [br] Note: Attacker can
                               be from the other nibble inside a byte. BIOS
                               must not set the attacker to itself.
                            */
    UINT32 attacker_sel1 : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Select which bit within a byte is the attacker
                               for dq1 in this nibble. [br] Note: Attacker can
                               be from the other nibble inside a byte. BIOS
                               must not set the attacker to itself.
                            */
    UINT32 attacker_sel2 : 3;

                            /* Bits[8:6], Access Type=RW, default=0x00000000*/

                            /*
                               Select which bit within a byte is the attacker
                               for dq2 in this nibble. [br] Note: Attacker can
                               be from the other nibble inside a byte. BIOS
                               must not set the attacker to itself.
                            */
    UINT32 attacker_sel3 : 3;

                            /* Bits[11:9], Access Type=RW, default=0x00000000*/

                            /*
                               Select which bit within a byte is the attacker
                               for dq3 in this nibble. [br] Note: Attacker can
                               be from the other nibble inside a byte. BIOS
                               must not set the attacker to itself.
                            */
    UINT32 rsvd_12 : 5;

                            /* Bits[16:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 12;

                            /* Bits[28:17], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pxc_coupling_type : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Select PXC is inductive or capacitive coupling
                               cross talk dominant type[br] 0: capacitive
                               coupling. If victim and attacker data have the
                               same transition phase, the xtalk delta is added;
                               otherwise (oppsite transition phase) the xtalk
                               delta is subtracted.[br] 1: inductive coupling.
                               If victim and attacker data have the same
                               transition phase, the xtalk delta is subtracted
                               ; otherwise (oppsite transition phase) the xtalk
                               delta is added.
                            */
    UINT32 ddjc_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* DDJC enable */
    UINT32 pxc_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Phase base cross talk cancellaton enable */

  } Bits;
  UINT32 Data;

} DDRD_N0_PXC_CTL0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_DFX_CTL0_MC_DDRIOMC_REG supported on:                                */
/*      SPRA0 (0x2001b1c8)                                                      */
/*      SPRB0 (0x2001b1c8)                                                      */
/*      SPRHBM (0x2001b1c8)                                                     */
/*      SPRC0 (0x2001b1c8)                                                      */
/*      SPRMCC (0x2001b1c8)                                                     */
/*      SPRUCC (0x2001b1c8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* DFX Control 0 Register
*/


#define DDRD_N0_DFX_CTL0_MC_DDRIOMC_REG 0x0822B1C8

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd_0 : 1;

                            /* Bits[0:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 2;

                            /* Bits[2:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tmr_test_mode : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Simulation-only control to shorten VSSHI and LDO
                               timers
                            */
    UINT32 sr_vref_dis : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               0 - No Vref power saving in Self Refresh. All DQ
                               Vref generators is enabled by dq_vref_en.[br] 1
                               - DQ Vref generators are switched off while in
                               Self Refresh regardless the setting of
                               dq_vref_en.
                            */
    UINT32 ckepd_vref_dis : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               0 - No Vref power saving in CKE power down. All
                               DQ Vref generators is enabled by dq_vref_en.[br]
                               1 - DQ Vref generators are switched off while in
                               CKE power down regardless the setting of
                               dq_vref_en.
                            */
    UINT32 tx_rank_chg_hold_adj : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               A value of 1 add extra 1 cycle of hold time for
                               tx rank switching
                            */
    UINT32 rx_rank_chg_hold_adj : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               A value of 1 add extra 1 cycle of hold time for
                               rx rank switching
                            */
    UINT32 rsvd_8 : 5;

                            /* Bits[12:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_rcvenpost_early : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Disable using rcvenpost early to control the rx
                               rank switch latch.[br] If this bit is set to 1,
                               minimum Rd-Rd TR time will need to increase by
                               1.
                            */
    UINT32 rsvd_14 : 3;

                            /* Bits[16:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd_17 : 14;

                            /* Bits[30:17], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rx_voc_pass_gate_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               VOC RX pass gate enable for VOC training and NTL
                               testing.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFX_CTL0_MC_DDRIOMC_SPRA0_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd_0 : 1;

                            /* Bits[0:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 2;

                            /* Bits[2:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tmr_test_mode : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Simulation-only control to shorten VSSHI and LDO
                               timers
                            */
    UINT32 sr_vref_dis : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               0 - No Vref power saving in Self Refresh. All DQ
                               Vref generators is enabled by dq_vref_en.[br] 1
                               - DQ Vref generators are switched off while in
                               Self Refresh regardless the setting of
                               dq_vref_en.
                            */
    UINT32 ckepd_vref_dis : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               0 - No Vref power saving in CKE power down. All
                               DQ Vref generators is enabled by dq_vref_en.[br]
                               1 - DQ Vref generators are switched off while in
                               CKE power down regardless the setting of
                               dq_vref_en.
                            */
    UINT32 tx_rank_chg_hold_adj : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               A value of 1 add extra 1 cycle of hold time for
                               tx rank switching
                            */
    UINT32 rx_rank_chg_hold_adj : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               A value of 1 add extra 1 cycle of hold time for
                               rx rank switching
                            */
    UINT32 rsvd_8 : 5;

                            /* Bits[12:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_rcvenpost_early : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Disable using rcvenpost early to control the rx
                               rank switch latch.[br] If this bit is set to 1,
                               minimum Rd-Rd TR time will need to increase by
                               1.
                            */
    UINT32 rsvd_14 : 3;

                            /* Bits[16:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_pxc_1ui_zero : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Disable using zero for 1st UI of data when PXC
                               is enabled. It uses the calculated code instead.
                            */
    UINT32 rsvd_18 : 12;

                            /* Bits[29:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 txdqs_latch_en_ovr : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Forces tx dqs rank latches to be transparent and
                               pass per rank settings directly to analog
                               endpoints.
                            */
    UINT32 rx_voc_pass_gate_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               VOC RX pass gate enable for VOC training and NTL
                               testing.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFX_CTL0_MC_DDRIOMC_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd_0 : 1;

                            /* Bits[0:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 2;

                            /* Bits[2:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tmr_test_mode : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Simulation-only control to shorten VSSHI and LDO
                               timers
                            */
    UINT32 sr_vref_dis : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               0 - No Vref power saving in Self Refresh. All DQ
                               Vref generators is enabled by dq_vref_en.[br] 1
                               - DQ Vref generators are switched off while in
                               Self Refresh regardless the setting of
                               dq_vref_en.
                            */
    UINT32 ckepd_vref_dis : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               0 - No Vref power saving in CKE power down. All
                               DQ Vref generators is enabled by dq_vref_en.[br]
                               1 - DQ Vref generators are switched off while in
                               CKE power down regardless the setting of
                               dq_vref_en.
                            */
    UINT32 tx_rank_chg_hold_adj : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               A value of 1 add extra 1 cycle of hold time for
                               tx rank switching
                            */
    UINT32 rx_rank_chg_hold_adj : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               A value of 1 add extra 1 cycle of hold time for
                               rx rank switching
                            */
    UINT32 rsvd_8 : 5;

                            /* Bits[12:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_rcvenpost_early : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Disable using rcvenpost early to control the rx
                               rank switch latch.[br] If this bit is set to 1,
                               minimum Rd-Rd TR time will need to increase by
                               1.
                            */
    UINT32 rsvd_14 : 3;

                            /* Bits[16:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd_17 : 14;

                            /* Bits[30:17], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rx_voc_pass_gate_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               VOC RX pass gate enable for VOC training and NTL
                               testing.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_DFX_CTL0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_VREF_TRACK_CTL_MC_DDRIOMC_REG supported on:                          */
/*      SPRA0 (0x2001b1cc)                                                      */
/*      SPRB0 (0x2001b1cc)                                                      */
/*      SPRHBM (0x2001b1cc)                                                     */
/*      SPRC0 (0x2001b1cc)                                                      */
/*      SPRMCC (0x2001b1cc)                                                     */
/*      SPRUCC (0x2001b1cc)                                                     */
/* Register default value on SPRA0: 0x800001EF                                  */
/* Register default value on SPRB0: 0x800001EF                                  */
/* Register default value on SPRHBM: 0x800001EF                                 */
/* Register default value on SPRC0: 0x800001EF                                  */
/* Register default value on SPRMCC: 0x800001EF                                 */
/* Register default value on SPRUCC: 0x800001EF                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Vref Track Control Register
*/


#define DDRD_N0_VREF_TRACK_CTL_MC_DDRIOMC_REG 0x0822B1CC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vref_cntrl_cp : 4;

                            /* Bits[3:0], Access Type=RW, default=0x0000000F*/

                            /*
                               Code for Vref Cap to supply. 0=min, 15=max.
                               Sweep codes 0-15.
                            */
    UINT32 rsvd : 1;

                            /* Bits[4:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 vref_cntrl_cn : 4;

                            /* Bits[8:5], Access Type=RW, default=0x0000000F*/

                            /*
                               Code for Vref Cap to gnd. 0=min, 15=max. Sweep
                               codes 0-7,11-15
                            */
    UINT32 rsvd_9 : 22;

                            /* Bits[30:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 vreftrack_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /* Vref Track enable */

  } Bits;
  UINT32 Data;

} DDRD_N0_VREF_TRACK_CTL_MC_DDRIOMC_STRUCT;

/* DDRD_N0_HW_TRAIN_CTL0_MC_DDRIOMC_REG supported on:                           */
/*      SPRA0 (0x2001b1d0)                                                      */
/*      SPRB0 (0x2001b1d0)                                                      */
/*      SPRHBM (0x2001b1d0)                                                     */
/*      SPRC0 (0x2001b1d0)                                                      */
/*      SPRMCC (0x2001b1d0)                                                     */
/*      SPRUCC (0x2001b1d0)                                                     */
/* Register default value on SPRA0: 0x00042000                                  */
/* Register default value on SPRB0: 0x00042000                                  */
/* Register default value on SPRHBM: 0x00042000                                 */
/* Register default value on SPRC0: 0x00042000                                  */
/* Register default value on SPRMCC: 0x00042000                                 */
/* Register default value on SPRUCC: 0x00042000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* HW Training Control 0 Register
*/


#define DDRD_N0_HW_TRAIN_CTL0_MC_DDRIOMC_REG 0x0822B1D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 xover_stage_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Set to 1 to enable xover training stage */
    UINT32 sampler_offset_stage_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable even/odd sampler training
                               stage for all DQ bits.[br] Note: The result is
                               only logged to the sampler even/odd offset
                               register when both even and odd training are
                               done.
                            */
    UINT32 dfe_summer_offset_stage_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable DFE summer offset training
                               stage for all DQ bits.[br] Note: the training
                               result is applied to all ranks. BIOS will adjust
                               later for all ranks setting based on eye
                               centering.
                            */
    UINT32 rsvd_3 : 2;

                            /* Bits[4:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 2;

                            /* Bits[6:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 settling_time_x2 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to double the analog settling time.
                               [br] The default settling time for each stage
                               are [br] Xover : 32 Dclk for 1st, 24 Dclk for
                               subsequent [br] Sampler offset : 528 Dclk for
                               1st time; 144 Dlck for subsequent steps [br] DFE
                               summer offset : 24 Dclk [br] Rcven fine/coarse :
                               16 Dclk / 8 Dclk [br] Dqdqs fine / coarse : 16
                               Dclk / 8 Dclk
                            */
    UINT32 sample_cnt : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000000*/

                            /*
                               Number of Sample to evaluate for each iteration
                               step. It applied for all training stages. [br]
                               0: 16[br] 1: 32[br] 2: 64[br] 3: 2 (Should only
                               used to speed up digitial simulation)
                            */
    UINT32 sample_thresh : 6;

                            /* Bits[15:10], Access Type=RW, default=0x00000008*/

                            /* Sample threshold value for voting logic. */
    UINT32 rsvd_16 : 4;

                            /* Bits[19:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd_20 : 4;

                            /* Bits[23:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 xover_err : 1;

                            /* Bits[24:24], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Set to 1 by HW to indicate xover training is
                               failed. SW must clear this bit to 0 when enable
                               HW calibration.
                            */
    UINT32 even_sampler_offset_err : 1;

                            /* Bits[25:25], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Set to 1 by HW to indicate even sampler offset
                               training is failed. SW must clear this bit to 0
                               when enable HW calibration.
                            */
    UINT32 odd_sampler_offset_err : 1;

                            /* Bits[26:26], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Set to 1 by HW to indicate odd sampler offset
                               training is failed. SW must clear this bit to 0
                               when enable HW calibration.
                            */
    UINT32 dfe_summer_offset_err : 1;

                            /* Bits[27:27], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Set to 1 by HW to indicate dfe summer offset
                               training is failed. SW must clear this bit to 0
                               when enable HW calibration.
                            */
    UINT32 rsvd_28 : 2;

                            /* Bits[29:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 hw_cal_en : 1;

                            /* Bits[31:31], Access Type=RW/V, default=0x00000000*/

                            /*
                               Set to 1 to enable HW calibration. They are five
                               HW calibration stages that SW can request HW to
                               perform. It is defined in bit 0 to 4 in this
                               register. [br] HW will self clear this bit when
                               all the enabled calibration stages are
                               completed. [br] For BIOS training, XOVER,
                               sampler offset, and DFE summer offset training
                               can be enabled by SW.[br] For ACIO testing, all
                               5 stages can be enabled by SW.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_HW_TRAIN_CTL0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_HWCAL_SWEEP_RESULT0_MC_DDRIOMC_REG supported on:                     */
/*      SPRA0 (0x2001b1d8)                                                      */
/*      SPRB0 (0x2001b1d8)                                                      */
/*      SPRHBM (0x2001b1d8)                                                     */
/*      SPRC0 (0x2001b1d8)                                                      */
/*      SPRMCC (0x2001b1d8)                                                     */
/*      SPRUCC (0x2001b1d8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* HW Calibration Sweep Result 0 Register
*/


#define DDRD_N0_HWCAL_SWEEP_RESULT0_MC_DDRIOMC_REG 0x0822B1D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hwcal_sweep_result0 : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The sweep result 0-2 register is used for debug
                               to observe the full sweep result for rcven or
                               dqdqs fine training, so both stages can't be
                               enabled at the same time. For DQDQS training, it
                               only valid if one DQ bit is enabled.[br] Note :
                               we log every other step only. (0-143 step, only
                               even number of step is logged)
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_HWCAL_SWEEP_RESULT0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_HWCAL_SWEEP_RESULT1_MC_DDRIOMC_REG supported on:                     */
/*      SPRA0 (0x2001b1dc)                                                      */
/*      SPRB0 (0x2001b1dc)                                                      */
/*      SPRHBM (0x2001b1dc)                                                     */
/*      SPRC0 (0x2001b1dc)                                                      */
/*      SPRMCC (0x2001b1dc)                                                     */
/*      SPRUCC (0x2001b1dc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* HW Calibration Sweep Result 1 Register
*/


#define DDRD_N0_HWCAL_SWEEP_RESULT1_MC_DDRIOMC_REG 0x0822B1DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hwcal_sweep_result1 : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The sweep result 0-2 register is used for debug
                               to observe the full sweep result for rcven or
                               dqdqs fine training, so both stages can't be
                               enabled at the same time. For DQDQS training, it
                               only valid if one DQ bit is enabled.[br] Note :
                               we log every other step only. (0-143 step, only
                               even number of step is logged)
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_HWCAL_SWEEP_RESULT1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_HWCAL_SWEEP_RESULT2_MC_DDRIOMC_REG supported on:                     */
/*      SPRA0 (0x2001b1e0)                                                      */
/*      SPRB0 (0x2001b1e0)                                                      */
/*      SPRHBM (0x2001b1e0)                                                     */
/*      SPRC0 (0x2001b1e0)                                                      */
/*      SPRMCC (0x2001b1e0)                                                     */
/*      SPRUCC (0x2001b1e0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* HW Calibration Sweep Result 2 Register
*/


#define DDRD_N0_HWCAL_SWEEP_RESULT2_MC_DDRIOMC_REG 0x0822B1E0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hwcal_sweep_result2 : 8;

                            /* Bits[7:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The sweep result 0-2 register is used for debug
                               to observe the full sweep result for rcven or
                               dqdqs fine training, so both stages can't be
                               enabled at the same time. For DQDQS training, it
                               only valid if one DQ bit is enabled.[br] Note :
                               we log every other step only. (0-143 step, only
                               even number of step is logged)
                            */
    UINT32 rsvd : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_HWCAL_SWEEP_RESULT2_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TRAIN_CTL0_MC_DDRIOMC_REG supported on:                              */
/*      SPRA0 (0x2001b1e4)                                                      */
/*      SPRB0 (0x2001b1e4)                                                      */
/*      SPRHBM (0x2001b1e4)                                                     */
/*      SPRC0 (0x2001b1e4)                                                      */
/*      SPRMCC (0x2001b1e4)                                                     */
/*      SPRUCC (0x2001b1e4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Train Control 0 Register
*/


#define DDRD_N0_TRAIN_CTL0_MC_DDRIOMC_REG 0x0822B1E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dqs_odt_dly : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               Logic delay to turn on DQS ODT base on receive
                               enable signal. Unit is DLCK. Range is 0-12.
                            */
    UINT32 rsvd : 2;

                            /* Bits[5:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dqs_odt_dur : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Control how long the DQS ODT stay on after
                               receive enable signal deasserted in DCLK domain.
                               Unit is DCLK. Range is 0-31.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dqs_sa_dly : 4;

                            /* Bits[16:13], Access Type=RW, default=0x00000000*/

                            /*
                               Logic delay to turn on DQS Sense Amp base on
                               receive enable signal. Unit is DCLK. Range is
                               0-12.
                            */
    UINT32 rsvd_17 : 2;

                            /* Bits[18:17], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dqs_sa_dur : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Control how long the DQS Sense Amp stay on after
                               receive enable signal deasserted in DCLK domain.
                               Unit is DCLK. Range is 0-31.
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TRAIN_CTL0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TRAIN_CTL1_MC_DDRIOMC_REG supported on:                              */
/*      SPRA0 (0x2001b1e8)                                                      */
/*      SPRB0 (0x2001b1e8)                                                      */
/*      SPRHBM (0x2001b1e8)                                                     */
/*      SPRC0 (0x2001b1e8)                                                      */
/*      SPRMCC (0x2001b1e8)                                                     */
/*      SPRUCC (0x2001b1e8)                                                     */
/* Register default value on SPRA0: 0x98000000                                  */
/* Register default value on SPRB0: 0x98000000                                  */
/* Register default value on SPRHBM: 0x98000000                                 */
/* Register default value on SPRC0: 0x98000000                                  */
/* Register default value on SPRMCC: 0x98000000                                 */
/* Register default value on SPRUCC: 0x98000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Train Control 1 Register
*/


#define DDRD_N0_TRAIN_CTL1_MC_DDRIOMC_REG 0x0822B1E8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_train_ctr_en : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enables the Command Training Counter mode (DQ
                               receivers, ODT needs to be enabled separately
                               before setting this bit), resets the sample
                               counter and starts the counting of the samples.
                               One of these per nibble that is used for
                               feedback (i.e. all DQ nibble and the fub with
                               the ALERT_n feedback. DQ nibbles can be set with
                               broadcast). The value of this field remains at 1
                               until after the Counting Window expires, then
                               returns to 0. Can be polled to determine when
                               the counting has completed. When the Counting
                               Window field is set to 0, this field will not
                               return to 0. In that case, this field must be
                               set to 0 to disable.[br] When the CS Assertion
                               Trigger Enable is set, the counting window start
                               is delayed until the first CS Assertion event
                               but this delay only applies for the ALERT_n,
                               RSP_A, and RSP_B signals. This does not apply to
                               the DQ counters.
                            */
    UINT32 wr_level_train_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Enables Write Leveling Training Mode. Write
                               Leveling training is not the same for both DDR4
                               and DDR5. BIOS must set the ddr4 control bit to
                               indicate write leveling for DDR4 or DDR5.[br]
                               For DDR5, when set, the strobes have their
                               transmitter enable, while the DQ signals have
                               their receivers enabled. The Received value from
                               the DQ signals is sampled and stored in the
                               training result register. This is a continously
                               sampled valued.[br] Note: all clock gate enable
                               must 0 during Write Level training mode.
                            */
    UINT32 rd_level_train_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enables Read Leveling Training Mode. Read
                               Leveling training step is the same for DDR4 and
                               DDR5.[br] Note: all clock gate enable must 0
                               during Read Level training mode.
                            */
    UINT32 rd_level_train_type : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               0 : Front side[br] 1: Back side (DDR5 LRDIMM /
                               3D Xpoint DIMM)[br] [br] When
                               rd_level_train_type is set to 1 and
                               rd_level_train_en is set to 1, the training
                               counter increments based on the sampling of DQ
                               with the rising edge of rcven (DB sends feedback
                               to host through DQ pins, DB samples MDQS with
                               its internal rcven signal). [br] When
                               rd_level_train_type is set to 0 and
                               rd_level_train_en is set to 1, the training
                               counter increments based on the sampling of DQS
                               with the rising edge of rcven.
                            */
    UINT32 rsvd : 1;

                            /* Bits[4:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 xover_cal : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit to 1 will prepare data fub in a
                               state to allow BIOS only to perform Xover
                               calibraton training. [br] - enable all the DCLK
                               And PI clocks. (may remove clock gating
                               function)
                            */
    UINT32 vref_highz : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Tri-state the vref_hv output. Set to 1 for NTL
                               and Rx Summer Offset Cal.
                            */
    UINT32 even_sampler_offset_cal_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Used for even sampler offset calibration mode.
                               Shorts inputs of samplers to Vcm
                            */
    UINT32 odd_sampler_offset_cal_en : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Used for odd sampler offset calibration mode.
                               Shorts inputs of samplers to Vcm
                            */
    UINT32 dfe_coeff_train_en : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Should be set only during DFE coefficient
                               initial training (pulse response). Increases
                               sampler offset range by 2X.
                            */
    UINT32 elr_dimm : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Set this bit to 1 for DDR5 ELR DIMM type */
    UINT32 nibble_dis : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               BIOS can disable a nibble within a byte. This
                               can be used to disable 1 nibble of the ECC for
                               9x4 DIMM support.[br] The entire ECC byte can
                               also be disabled for DIMMs that doesn't support
                               ECC. In DDR4, the unused byte can be disabled as
                               well.
                            */
    UINT32 ddr4 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               For SPR, 2 Channel DDR-MC sub-system. It can
                               either operate in DDR4/DDR-T or DDR5/DDR-T2. It
                               doesn't support DDR4/DDR-T mix with
                               DDR5/DDR-T2.[br] Setting this bit to 1 indicate
                               it is operating in DDR4/DDR-T. 0 inidate it is
                               operating in DDR5/DDR-T2.[br] Fub use this bit
                               to determine the training level different
                               between DDR4 vs DDR5.
                            */
    UINT32 txrt_clk_gate_en : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate tx retraining
                               logic for power saving. Default is disable clock
                               gating.[br] Note: Clock gating must be disable
                               during any training steps. BIOS can enable clock
                               gating for power saving after all the training
                               steps are done.
                            */
    UINT32 compeff_clk_gate_en : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate effective register
                               update CLK for power saving. Default is disable
                               clock gating.[br] Note: Clock gating must be
                               disable during any training steps. BIOS can
                               enable clock gating for power saving after all
                               the training steps are done.
                            */
    UINT32 bclk_gate_en : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable BCLK gating for Burnin/ADC
                               counter and DLL lock timer for power saving.
                            */
    UINT32 tx_piclk_gate_en : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate TX PI CLK for
                               transmit path logic. Default is disable clock
                               gating. [br] Note: Clock gating must be disable
                               during any training steps. BIOS can enable clock
                               gating for power saving after all the training
                               steps are done.
                            */
    UINT32 rx_piclk_gate_en : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate RX PI CLK for
                               receive path logics. Default is disable clock
                               gating. [br] Note: Clock gating must be disable
                               during any training steps. BIOS can enable clock
                               gating for power saving after all the training
                               steps are done.
                            */
    UINT32 piref_clk_gate_en : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate PI REF clock for
                               power saving. Default is disable clock gating.
                               [br] Note: Clock gating must be disable during
                               any training steps. BIOS can enable clock gating
                               for power saving after all the training steps
                               are done.
                            */
    UINT32 tx_clk_gate_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate TX CLK for
                               transmit path logics. Default is disable clock
                               gating.[br] Note: Clock gating must be disable
                               during any training steps. BIOS can enable clock
                               gating for power saving after all the training
                               steps are done.
                            */
    UINT32 rx_clk_gate_en : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate RX CLK for receive
                               path logics. Default is disable clock gating.
                               [br] Note: Clock gating must be disable during
                               any training steps. BIOS can enable clock gating
                               for power saving after all the training steps
                               are done.
                            */
    UINT32 train_clk_gate_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate CLK for training
                               related logic (BIOS or HW training logics).
                               Default is disable clock gating. [br] Note:
                               Clock gating must be disable during any training
                               steps. BIOS can enable clock gating for power
                               saving after all the training steps are done.
                            */
    UINT32 csr_clk_gate_en : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable HW to gate CSR CLK. Default
                               is disable clock gating. [br] Note: Clock gating
                               must be disable during any training steps. BIOS
                               can enable clock gating for power saving after
                               all the training steps are done.
                            */
    UINT32 rank_ovr_en : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, HW uses the rank_value_ovr field
                               to select rank parameters instead of rank number
                               from MC. It is used for training step that
                               require to read out rank specific infomration
                               without MC command.[br] Note: The current use
                               case is for DDR4 Write leveling training.
                            */
    UINT32 rank_value_ovr : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /*
                               When rank_ovr_en is set, this rank override
                               value is used by HW to select rank parameters
                               instead of rank number from MC. It is used for
                               training step that require to read out rank
                               specific infomration without MC command.[br]
                               Note: The current use case is for DDR4 Write
                               leveling training.
                            */
    UINT32 force_odt_on : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000001*/

                            /*
                               Force Weak DQS/DQ ODT on. It is used before ODT
                               enable window is trained and program by BIOS.
                               [br] The weak ODT is ignored when drive enable
                               is asserted. [br] Note: For ACIO, ODT is
                               provided by different DDR channel.
                            */
    UINT32 force_rxbias_on : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000001*/

                            /*
                               Force Rx bias circuit on.[br] Note: In SPR
                               setting this bit to 1 doesnt force vref on. To
                               force vref on, user must set dq_vref_en to 1 and
                               sr_vref_dis to 0.
                            */
    UINT32 force_sa_on : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Force Senseamp on. Use for overclocking support
                               where we may not be able to hit the fast exit
                               latency.
                            */
    UINT32 force_strong_odt_on : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Force Strong DQS/DQ ODT on. when set, it always
                               enable one segement for ODT regardless of the
                               state of drive enable.[br] The intend use case
                               is for ACIO with burnin.
                            */
    UINT32 dq_vref_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               Vref generator Enable. Set to 1 to enable all DQ
                               bits vref.[br] Note: The self refresh VREF
                               disable control (sr_vref_dis) can disable vref
                               during DIMM in self refresh.[br] To force VREF
                               on all the time in SPR, user must program
                               sr_vref_dis to 0 and ckepd_vref_dis to 0. [br]
                               Note: Unlike wave 1 design, ForceBiasOn doesn't
                               force verf enable anymore.
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_TRAIN_CTL1_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TRAIN_CTL2_MC_DDRIOMC_REG supported on:                              */
/*      SPRA0 (0x2001b1ec)                                                      */
/*      SPRB0 (0x2001b1ec)                                                      */
/*      SPRHBM (0x2001b1ec)                                                     */
/*      SPRC0 (0x2001b1ec)                                                      */
/*      SPRMCC (0x2001b1ec)                                                     */
/*      SPRUCC (0x2001b1ec)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Train Control 2 Register
*/


#define DDRD_N0_TRAIN_CTL2_MC_DDRIOMC_REG 0x0822B1EC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tx_strobe_mask : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               Each bit in the TX strobe mask will mask out the
                               strobe pulse associated with each location in
                               the write burst (i.e. for a BL16 there are 8
                               strobe pulses (rising/falling combination)). A
                               value of 00000000b will enable all strobes. A
                               value of 1111_1110b will enable a single strobe
                               pulse at the first 2 UIs in the BL. [br] The
                               current use case is for DDR5 write leveling
                               training which only enable the 1st TCK DQS
                               strobe (0xFE)[br] Note: When drv_dqs_diff_high
                               is set, the masked Strobe is driven
                               differentially high. On the other hand, when
                               drv_dqs_diff_low is set, the masked stobe is
                               driven differentially low.
                            */
    UINT32 drv_dqs_diff_low : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When set, the strobe is driven differentially
                               low, other than when a WRITE strobe sequence is
                               sent to the DRAM
                            */
    UINT32 drv_dqs_diff_high : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               When set, the strobe is driven differentially
                               high, other than when a WRITE strobe sequence is
                               sent to the DRAM.
                            */
    UINT32 dq_value_ovr : 4;

                            /* Bits[13:10], Access Type=RW, default=0x00000000*/

                            /*
                               When the DQ Override Enable bit is set, this
                               setting determines the value that is driven by
                               the DQ transmitter at all time. The value is
                               constant over all UIs, but can be set per DQ in
                               the nibble.
                            */
    UINT32 dq_ovr_en : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               This setting enables the over-ride operation
                               associated with the DQ Value Override
                               setting.[br] Note: Once this bit is set, it
                               turns on the TX driver and drives the
                               dq_value_ovr on all DQs pins
                            */
    UINT32 sample_sel : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Determines if the command training counter will
                               count 1 or 0.[br] 0: count 1[br] 1: count 0
                            */
    UINT32 dq_sample_mask : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000000*/

                            /*
                               Mask off any DQ bits not considered in the OR
                               computation for the command training counting.
                            */
    UINT32 sampler_feedback_en : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enables feedback from DQ SAL for any DDR5
                               training modes, requiring feedback from DQ
                               lanes.
                            */
    UINT32 unsampled_path_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               The unsampled path is automatically enabled in
                               DDR4, but not for DDR5. In DDR5, set this bit to
                               0x1 during write level, and cmd training (DQ
                               feedback is used).
                            */
    UINT32 rsvd : 6;

                            /* Bits[27:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 xover_cal_mux_sel : 3;

                            /* Bits[30:28], Access Type=RW, default=0x00000000*/

                            /*
                               Select which xover phase detect output for
                               calibration. For each nibble, we have 8 xover
                               per DLL piref.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TRAIN_CTL2_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TRAIN_CTL3_MC_DDRIOMC_REG supported on:                              */
/*      SPRA0 (0x2001b1f0)                                                      */
/*      SPRB0 (0x2001b1f0)                                                      */
/*      SPRHBM (0x2001b1f0)                                                     */
/*      SPRC0 (0x2001b1f0)                                                      */
/*      SPRMCC (0x2001b1f0)                                                     */
/*      SPRUCC (0x2001b1f0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Train Control 3 Register
*/


#define DDRD_N0_TRAIN_CTL3_MC_DDRIOMC_REG 0x0822B1F0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dq_odt_dly : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               Logic delay to turn on DQ ODT base on receive
                               enable signal. Unit is DCLK. Range is 0-12.
                            */
    UINT32 rsvd : 2;

                            /* Bits[5:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dq_odt_dur : 5;

                            /* Bits[10:6], Access Type=RW, default=0x00000000*/

                            /*
                               Control how long the DQ ODT stay on after
                               receive enable signal deasserted in DCLK domain.
                               Unit is DCLK. Range is 0-31.
                            */
    UINT32 rsvd_11 : 2;

                            /* Bits[12:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dq_sa_dly : 4;

                            /* Bits[16:13], Access Type=RW, default=0x00000000*/

                            /*
                               Logic delay to turn on DQ Sense Amp base on
                               receive enable signal. Unit is DCLK. Range is
                               0-12.
                            */
    UINT32 rsvd_17 : 2;

                            /* Bits[18:17], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dq_sa_dur : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000000*/

                            /*
                               Control how long the DQ Sense Amp stay on after
                               receive enable signal deasserted in DCLK domain.
                               Unit is DCLK. Range is 0-31.
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TRAIN_CTL3_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TRAIN_CNT_WINDOW0_MC_DDRIOMC_REG supported on:                       */
/*      SPRA0 (0x2001b1f4)                                                      */
/*      SPRB0 (0x2001b1f4)                                                      */
/*      SPRHBM (0x2001b1f4)                                                     */
/*      SPRC0 (0x2001b1f4)                                                      */
/*      SPRMCC (0x2001b1f4)                                                     */
/*      SPRUCC (0x2001b1f4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Training Counting Window 0 Register
*/


#define DDRD_N0_TRAIN_CNT_WINDOW0_MC_DDRIOMC_REG 0x0822B1F4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cnt_window : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               cmd_train_ctr_en:[br] value that sets the number
                               of DCLK cycles that the DQ samples will be
                               counted. Linear setting. This is broadcast to
                               all bytes one register per byte. When this field
                               is set to 0 the counter will run until it
                               saturates, or until it the CMD Training Counter
                               Mode field is cleared.[br] wr_level_train_en:
                               [br] control when to increment the coutner after
                               the trigger event (DQS OE)[br]
                               rd_level_train_en:[br] control when to increment
                               the coutner after the sampling event (rising
                               edge of receive enable)
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_TRAIN_CNT_WINDOW0_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TRAIN_CNT_RESULT_MC_DDRIOMC_REG supported on:                        */
/*      SPRA0 (0x2001b1f8)                                                      */
/*      SPRB0 (0x2001b1f8)                                                      */
/*      SPRHBM (0x2001b1f8)                                                     */
/*      SPRC0 (0x2001b1f8)                                                      */
/*      SPRMCC (0x2001b1f8)                                                     */
/*      SPRUCC (0x2001b1f8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Sample counter result for CMD Training Counter Mode
*/


#define DDRD_N0_TRAIN_CNT_RESULT_MC_DDRIOMC_REG 0x0822B1F8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 train_cnt : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               cmd_train_ctr_en:[br] Value that indicates the
                               number of logic 1 or 0 values sampled during the
                               Counting Window (based on sample_sel). This is
                               cleared when the CMD Training Counter mode is
                               enabled. This count is the result of the OR of
                               all DQs in the nibble, for those DQs that are
                               not masked off. Whten the cnt_window is set to
                               0, the counter will run until it saturates.[br]
                               wr_level_train_en:[br] DQ sample count[br]
                               rd_level_train_en:[br] Receive enable sample
                               count
                            */

  } Bits;
  UINT32 Data;

} DDRD_N0_TRAIN_CNT_RESULT_MC_DDRIOMC_STRUCT;

/* DDRD_N0_TRAIN_RESULT0_MC_DDRIOMC_REG supported on:                           */
/*      SPRA0 (0x2001b1fc)                                                      */
/*      SPRB0 (0x2001b1fc)                                                      */
/*      SPRHBM (0x2001b1fc)                                                     */
/*      SPRC0 (0x2001b1fc)                                                      */
/*      SPRMCC (0x2001b1fc)                                                     */
/*      SPRUCC (0x2001b1fc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRB0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRHBM Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRC0 Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRMCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* SPRUCC Register File:    sprsp_top/ddrphy_top[0]/ddrd1_type/ddrd1_n0_ch0/ddrd1_n0_mem*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRB0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRHBM Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRC0 Security PolicyGroup: MEMIO_BOOT                                       */
/* SPRMCC Security PolicyGroup: MEMIO_BOOT                                      */
/* SPRUCC Security PolicyGroup: MEMIO_BOOT                                      */
/* Training Result 0 Register
*/


#define DDRD_N0_TRAIN_RESULT0_MC_DDRIOMC_REG 0x0822B1FC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 xover_cal_pd_result : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /* Xover Calibration Phase Detected Result */
    UINT32 sa_even_sampler : 4;

                            /* Bits[4:1], Access Type=RO/V, default=0x00000000*/

                            /*
                               Per bit even sampler value for senseamp
                               training. It is used for DDR5 sampler and DFE
                               summer VOC training stage
                            */
    UINT32 sa_odd_sampler : 4;

                            /* Bits[8:5], Access Type=RO/V, default=0x00000000*/

                            /*
                               Per bit odd sampler value for senseamp training.
                               It is used only for DDR5 sampler training stage.
                            */
    UINT32 sa_ddr4_train_result : 4;

                            /* Bits[12:9], Access Type=RO/V, default=0x00000000*/

                            /* Per bit senseamp train result for DDR4 only */
    UINT32 rsvd : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRD_N0_TRAIN_RESULT0_MC_DDRIOMC_STRUCT;
#endif /* _MC_DDRIOMC_h */
