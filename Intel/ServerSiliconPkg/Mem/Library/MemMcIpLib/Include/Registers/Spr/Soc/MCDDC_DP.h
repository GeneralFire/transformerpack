
/** @file
  MCDDC_DP.h

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2007 - 2020 Intel Corporation. <BR>
  
  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.
  
  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.
  
  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
  
  This file contains Silicon register definitions.
  
  This is a generated file; please do not modify it directly.
  
**/

/* The following security policy groups are used by registers in this file:     */

/* SPRA0 Security Policy Groups:                                                */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRB0 Security Policy Groups:                                                */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRHBM Security Policy Groups:                                               */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRC0 Security Policy Groups:                                                */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRMCC Security Policy Groups:                                               */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRUCC Security Policy Groups:                                               */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */


#ifndef _MCDDC_DP_h
#define _MCDDC_DP_h
#include <Base.h>

/* PXPCAP_MCDDC_DP_REG supported on:                                            */
/*      SPRA0 (0x20022c08)                                                      */
/*      SPRB0 (0x20022c08)                                                      */
/*      SPRHBM (0x20022c08)                                                     */
/*      SPRC0 (0x20022c08)                                                      */
/*      SPRMCC (0x20022c08)                                                     */
/*      SPRUCC (0x20022c08)                                                     */
/* Register default value on SPRA0: 0x00910010                                  */
/* Register default value on SPRB0: 0x00910010                                  */
/* Register default value on SPRHBM: 0x00910010                                 */
/* Register default value on SPRC0: 0x00910010                                  */
/* Register default value on SPRMCC: 0x00910010                                 */
/* Register default value on SPRUCC: 0x00910010                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* PXPCAP - PCI Express Capability
*/


#define PXPCAP_MCDDC_DP_REG 0x0B122C08

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 capability_id : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000010*/

                            /*
                               Provides the PCI Express capability ID assigned
                               by PCI-SIG.
                            */
    UINT32 next_ptr : 8;

                            /* Bits[15:8], Access Type=RO, default=0x00000000*/

                            /*
                               Pointer to the next capability. Set to 0 to
                               indicate there are no more capability
                               structures.
                            */
    UINT32 capability_version : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               PCI Express Capability is Compliant with Version
                               1.0 of the PCI Express Spec. Note: This
                               capability structure is not compliant with
                               Versions beyond 1.0, since they require
                               additional capability registers to be reserved.
                               The only purpose for this capability structure
                               is to make enhanced configuration space
                               available. Minimizing the size of this structure
                               is accomplished by reporting version 1.0
                               compliancy and reporting that this is an
                               integrated root port device. As such, only three
                               Dwords of configuration space are required for
                               this structure.
                            */
    UINT32 device_port_type : 4;

                            /* Bits[23:20], Access Type=RO, default=0x00000009*/

                            /* Device type is Root Complex Integrated Endpoint */
    UINT32 slot_implemented : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000000*/

                            /* N/A for integrated endpoints */
    UINT32 interrupt_message_number : 5;

                            /* Bits[29:25], Access Type=RO, default=0x00000000*/

                            /* N/A for this device */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PXPCAP_MCDDC_DP_STRUCT;

/* PXPENHCAP_MCDDC_DP_REG supported on:                                         */
/*      SPRA0 (0x20022c14)                                                      */
/*      SPRB0 (0x20022c14)                                                      */
/*      SPRHBM (0x20022c14)                                                     */
/*      SPRC0 (0x20022c14)                                                      */
/*      SPRMCC (0x20022c14)                                                     */
/*      SPRUCC (0x20022c14)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This field points to the next Capability in extended configuration space.
*/


#define PXPENHCAP_MCDDC_DP_REG 0x0B122C14

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 capability_id : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates there are no capability structures in
                               the enhanced configuration space.
                            */
    UINT32 capability_version : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates there are no capability structures in
                               the enhanced configuration space.
                            */
    UINT32 next_capability_offset : 12;

                            /* Bits[31:20], Access Type=RO, default=0x00000000*/

                            /* Next capability offset. */

  } Bits;
  UINT32 Data;

} PXPENHCAP_MCDDC_DP_STRUCT;

/* CORRERRCNT_0_MCDDC_DP_REG supported on:                                      */
/*      SPRA0 (0x20022c18)                                                      */
/*      SPRB0 (0x20022c18)                                                      */
/*      SPRHBM (0x20022c18)                                                     */
/*      SPRC0 (0x20022c18)                                                      */
/*      SPRMCC (0x20022c18)                                                     */
/*      SPRUCC (0x20022c18)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Per Rank corrected error counters.
*/


#define CORRERRCNT_0_MCDDC_DP_REG 0x0B122C18

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_err_cnt_0 : 15;

                            /* Bits[14:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               The corrected error count for this rank.
                               Hardware automatically clear this field when the
                               corresponding OVERFLOW_x bit is changing from 0
                               to 1. This counter increments in number of
                               cacheline accesses - not by codewords. On a read
                               access, if either of the codewords or both
                               codewords have a corrected error, this counter
                               increments by 1.
                            */
    UINT32 overflow_0 : 1;

                            /* Bits[15:15], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               The corrected error count for this rank has been
                               overflowed. Once set it can only be cleared via
                               a write from BIOS.
                            */
    UINT32 cor_err_cnt_1 : 15;

                            /* Bits[30:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               The corrected error count for this rank.
                               Hardware automatically clear this field when the
                               corresponding OVERFLOW_x bit is changing from 0
                               to 1. This counter increments in number of
                               cacheline accesses - not by codewords. On a read
                               access, if either of the codewords or both
                               codewords have a corrected error, this counter
                               increments by 1.
                            */
    UINT32 overflow_1 : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               The corrected error count for this rank has been
                               overflowed. Once set it can only be cleared via
                               a write from BIOS.
                            */

  } Bits;
  UINT32 Data;

} CORRERRCNT_0_MCDDC_DP_STRUCT;

/* CORRERRCNT_1_MCDDC_DP_REG supported on:                                      */
/*      SPRA0 (0x20022c1c)                                                      */
/*      SPRB0 (0x20022c1c)                                                      */
/*      SPRHBM (0x20022c1c)                                                     */
/*      SPRC0 (0x20022c1c)                                                      */
/*      SPRMCC (0x20022c1c)                                                     */
/*      SPRUCC (0x20022c1c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Per Rank corrected error counters.
*/


#define CORRERRCNT_1_MCDDC_DP_REG 0x0B122C1C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_err_cnt_2 : 15;

                            /* Bits[14:0], Access Type=RW/V, default=0x00000000*/

                            /* The corrected error count for this rank. */
    UINT32 overflow_2 : 1;

                            /* Bits[15:15], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               The corrected error count has crested over the
                               limit for this rank. Once set it can only be
                               cleared via a write from BIOS.
                            */
    UINT32 cor_err_cnt_3 : 15;

                            /* Bits[30:16], Access Type=RW/V, default=0x00000000*/

                            /* The corrected error count for this rank. */
    UINT32 overflow_3 : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               The corrected error count has crested over the
                               limit for this rank. Once set it can only be
                               cleared via a write from BIOS.
                            */

  } Bits;
  UINT32 Data;

} CORRERRCNT_1_MCDDC_DP_STRUCT;

/* CORRERRCNT_2_MCDDC_DP_REG supported on:                                      */
/*      SPRA0 (0x20022c20)                                                      */
/*      SPRB0 (0x20022c20)                                                      */
/*      SPRHBM (0x20022c20)                                                     */
/*      SPRC0 (0x20022c20)                                                      */
/*      SPRMCC (0x20022c20)                                                     */
/*      SPRUCC (0x20022c20)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Per Rank corrected error counters.
*/


#define CORRERRCNT_2_MCDDC_DP_REG 0x0B122C20

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_err_cnt_4 : 15;

                            /* Bits[14:0], Access Type=RW/V, default=0x00000000*/

                            /* The corrected error count for this rank. */
    UINT32 overflow_4 : 1;

                            /* Bits[15:15], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               The corrected error count has crested over the
                               limit for this rank. Once set it can only be
                               cleared via a write from BIOS.
                            */
    UINT32 cor_err_cnt_5 : 15;

                            /* Bits[30:16], Access Type=RW/V, default=0x00000000*/

                            /* The corrected error count for this rank. */
    UINT32 overflow_5 : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               The corrected error count has crested over the
                               limit for this rank. Once set it can only be
                               cleared via a write from BIOS.
                            */

  } Bits;
  UINT32 Data;

} CORRERRCNT_2_MCDDC_DP_STRUCT;

/* CORRERRCNT_3_MCDDC_DP_REG supported on:                                      */
/*      SPRA0 (0x20022c24)                                                      */
/*      SPRB0 (0x20022c24)                                                      */
/*      SPRHBM (0x20022c24)                                                     */
/*      SPRC0 (0x20022c24)                                                      */
/*      SPRMCC (0x20022c24)                                                     */
/*      SPRUCC (0x20022c24)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Per Rank corrected error counters.
*/


#define CORRERRCNT_3_MCDDC_DP_REG 0x0B122C24

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_err_cnt_6 : 15;

                            /* Bits[14:0], Access Type=RW/V, default=0x00000000*/

                            /* The corrected error count for this rank. */
    UINT32 overflow_6 : 1;

                            /* Bits[15:15], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               The corrected error count has crested over the
                               limit for this rank. Once set it can only be
                               cleared via a write from BIOS.
                            */
    UINT32 cor_err_cnt_7 : 15;

                            /* Bits[30:16], Access Type=RW/V, default=0x00000000*/

                            /* The corrected error count for this rank. */
    UINT32 overflow_7 : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               The corrected error count has crested over the
                               limit for this rank. Once set it can only be
                               cleared via a write from BIOS.
                            */

  } Bits;
  UINT32 Data;

} CORRERRCNT_3_MCDDC_DP_STRUCT;

/* RETRY_RD_ERR_LOG_ADDRESS2_MCDDC_DP_REG supported on:                         */
/*      SPRA0 (0x20022c28)                                                      */
/*      SPRB0 (0x20022c28)                                                      */
/*      SPRHBM (0x20022c28)                                                     */
/*      SPRC0 (0x20022c28)                                                      */
/*      SPRMCC (0x20022c28)                                                     */
/*      SPRUCC (0x20022c28)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG.
            Logged value is {3'b0,Row_addr[17:0]}
            Bits 20,19,18 are spares to accomodate for future growth in DDR5

            This also stored the following when BIST is enabled.
            Bist result err type
            bist correctable error device number
            correction fsm errtype --> this is needed when BIST results is also taken to make the decision on the err type. 
      
*/


#define RETRY_RD_ERR_LOG_ADDRESS2_MCDDC_DP_REG 0x0B122C28

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 row : 18;

                            /* Bits[17:0], Access Type=RW/V/P, default=0x00000000*/

                            /* Row address for the last retry. */
    UINT32 failed_dev_upper : 5;

                            /* Bits[22:18], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Holds the failed device number for HBM second 32
                               bytes, with a value between 0-17. Value of 31
                               means there is no error in these 32 bytes.
                            */
    UINT32 ecc_bist_errtype : 2;

                            /* Bits[24:23], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the err type for the BIST result.
                               Valid only if ecc_bist_valid field is true in
                               the retry_rd_err_log. BIST Result No Error =
                               2'b00 BIST Result Uncorrectable = 2'b01 BIST
                               Result Correctable = 2'b10 For HBM mode, this is
                               the type for lower 32 bytes.
                            */
    UINT32 ecc_bist_corr_err_devnum : 5;

                            /* Bits[29:25], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the device number for the correctable
                               error signaled by BIST. Valid only when
                               ecc_bist_valid is true and ecc_bist_errtype is
                               correctable. For HBM mode, this is the device
                               number for lower 32 bytes.
                            */
    UINT32 corr_fsm_errtype : 2;

                            /* Bits[31:30], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the err type for the Corection fsm
                               result. BIST Result No Error = 2'b00 BIST Result
                               Uncorrectable = 2'b01 BIST Result Correctable =
                               2'b10 This isnt logged when in BIST bypass mode
                               or error reporting mode as the retry_rd_err_log
                               contents represents only the correction fsm
                               results. valid only for BIST SDC control mode.
                            */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_LOG_ADDRESS2_MCDDC_DP_STRUCT;

/* CORRERRTHRSHLD_0_MCDDC_DP_REG supported on:                                  */
/*      SPRA0 (0x20022c30)                                                      */
/*      SPRB0 (0x20022c30)                                                      */
/*      SPRHBM (0x20022c30)                                                     */
/*      SPRC0 (0x20022c30)                                                      */
/*      SPRMCC (0x20022c30)                                                     */
/*      SPRUCC (0x20022c30)                                                     */
/* Register default value on SPRA0: 0x7FFF7FFF                                  */
/* Register default value on SPRB0: 0x7FFF7FFF                                  */
/* Register default value on SPRHBM: 0x7FFF7FFF                                 */
/* Register default value on SPRC0: 0x7FFF7FFF                                  */
/* Register default value on SPRMCC: 0x7FFF7FFF                                 */
/* Register default value on SPRUCC: 0x7FFF7FFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* This register holds the per rank corrected error thresholding value.
*/


#define CORRERRTHRSHLD_0_MCDDC_DP_REG 0x0B122C30

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_err_th_0 : 15;

                            /* Bits[14:0], Access Type=RW, default=0x00007FFF*/

                            /*
                               The corrected error threshold for this rank that
                               will be compared to the per rank corrected error
                               counter.
                            */
    UINT32 rsvd : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cor_err_th_1 : 15;

                            /* Bits[30:16], Access Type=RW, default=0x00007FFF*/

                            /*
                               The corrected error threshold for this rank that
                               will be compared to the per rank corrected error
                               counter.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CORRERRTHRSHLD_0_MCDDC_DP_STRUCT;

/* CORRERRTHRSHLD_1_MCDDC_DP_REG supported on:                                  */
/*      SPRA0 (0x20022c34)                                                      */
/*      SPRB0 (0x20022c34)                                                      */
/*      SPRHBM (0x20022c34)                                                     */
/*      SPRC0 (0x20022c34)                                                      */
/*      SPRMCC (0x20022c34)                                                     */
/*      SPRUCC (0x20022c34)                                                     */
/* Register default value on SPRA0: 0x7FFF7FFF                                  */
/* Register default value on SPRB0: 0x7FFF7FFF                                  */
/* Register default value on SPRHBM: 0x7FFF7FFF                                 */
/* Register default value on SPRC0: 0x7FFF7FFF                                  */
/* Register default value on SPRMCC: 0x7FFF7FFF                                 */
/* Register default value on SPRUCC: 0x7FFF7FFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* This register holds the per rank corrected error thresholding value.
*/


#define CORRERRTHRSHLD_1_MCDDC_DP_REG 0x0B122C34

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_err_th_2 : 15;

                            /* Bits[14:0], Access Type=RW, default=0x00007FFF*/

                            /*
                               The corrected error threshold for this rank that
                               will be compared to the per rank corrected error
                               counter.
                            */
    UINT32 rsvd : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cor_err_th_3 : 15;

                            /* Bits[30:16], Access Type=RW, default=0x00007FFF*/

                            /*
                               The corrected error threshold for this rank that
                               will be compared to the per rank corrected error
                               counter.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CORRERRTHRSHLD_1_MCDDC_DP_STRUCT;

/* CORRERRTHRSHLD_2_MCDDC_DP_REG supported on:                                  */
/*      SPRA0 (0x20022c38)                                                      */
/*      SPRB0 (0x20022c38)                                                      */
/*      SPRHBM (0x20022c38)                                                     */
/*      SPRC0 (0x20022c38)                                                      */
/*      SPRMCC (0x20022c38)                                                     */
/*      SPRUCC (0x20022c38)                                                     */
/* Register default value on SPRA0: 0x7FFF7FFF                                  */
/* Register default value on SPRB0: 0x7FFF7FFF                                  */
/* Register default value on SPRHBM: 0x7FFF7FFF                                 */
/* Register default value on SPRC0: 0x7FFF7FFF                                  */
/* Register default value on SPRMCC: 0x7FFF7FFF                                 */
/* Register default value on SPRUCC: 0x7FFF7FFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* This register holds the per rank corrected error thresholding value.
*/


#define CORRERRTHRSHLD_2_MCDDC_DP_REG 0x0B122C38

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_err_th_4 : 15;

                            /* Bits[14:0], Access Type=RW, default=0x00007FFF*/

                            /*
                               The corrected error threshold for this rank that
                               will be compared to the per rank corrected error
                               counter.
                            */
    UINT32 rsvd : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cor_err_th_5 : 15;

                            /* Bits[30:16], Access Type=RW, default=0x00007FFF*/

                            /*
                               The corrected error threshold for this rank that
                               will be compared to the per rank corrected error
                               counter.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CORRERRTHRSHLD_2_MCDDC_DP_STRUCT;

/* CORRERRTHRSHLD_3_MCDDC_DP_REG supported on:                                  */
/*      SPRA0 (0x20022c3c)                                                      */
/*      SPRB0 (0x20022c3c)                                                      */
/*      SPRHBM (0x20022c3c)                                                     */
/*      SPRC0 (0x20022c3c)                                                      */
/*      SPRMCC (0x20022c3c)                                                     */
/*      SPRUCC (0x20022c3c)                                                     */
/* Register default value on SPRA0: 0x7FFF7FFF                                  */
/* Register default value on SPRB0: 0x7FFF7FFF                                  */
/* Register default value on SPRHBM: 0x7FFF7FFF                                 */
/* Register default value on SPRC0: 0x7FFF7FFF                                  */
/* Register default value on SPRMCC: 0x7FFF7FFF                                 */
/* Register default value on SPRUCC: 0x7FFF7FFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* This register holds the per rank corrected error thresholding value.
*/


#define CORRERRTHRSHLD_3_MCDDC_DP_REG 0x0B122C3C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_err_th_6 : 15;

                            /* Bits[14:0], Access Type=RW, default=0x00007FFF*/

                            /*
                               The corrected error threshold for this rank that
                               will be compared to the per rank corrected error
                               counter.
                            */
    UINT32 rsvd : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cor_err_th_7 : 15;

                            /* Bits[30:16], Access Type=RW, default=0x00007FFF*/

                            /*
                               The corrected error threshold for this rank that
                               will be compared to the per rank corrected error
                               counter.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CORRERRTHRSHLD_3_MCDDC_DP_STRUCT;

/* CORRECTION_DEBUG_LOG_MCDDC_DP_REG supported on:                              */
/*      SPRA0 (0x20022c44)                                                      */
/*      SPRB0 (0x20022c44)                                                      */
/*      SPRHBM (0x20022c44)                                                     */
/*      SPRC0 (0x20022c44)                                                      */
/*      SPRMCC (0x20022c44)                                                     */
/*      SPRUCC (0x20022c44)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* this register hold extra correction debug signals for adddc and sddc.  The contents of this register are valid with RETRY_RD_ERR_LOG
*/


#define CORRECTION_DEBUG_LOG_MCDDC_DP_REG 0x0B122C44

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 adddc_failed_col_num : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               1LM adddc: failed column number is over data
                               bits 0-63(64 columns)
                            */
    UINT32 adddc_meta_failed_col_num : 4;

                            /* Bits[9:6], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               1LM adddc: metadata failed column number is over
                               metadata bits 0-3(4 columns)
                            */
    UINT32 adddc_par_col_syn_low : 4;

                            /* Bits[13:10], Access Type=RW/V/P, default=0x00000000*/

                            /* 1LM adddc: parity column syndrome low */
    UINT32 adddc_par_col_syn_high : 4;

                            /* Bits[17:14], Access Type=RW/V/P, default=0x00000000*/

                            /* 1LM adddc: parity column syndrome high */
    UINT32 adddc_one_col_failed_1st : 1;

                            /* Bits[18:18], Access Type=RW/V/P, default=0x00000000*/

                            /* 1LM adddc: one column failed only in 1st half */
    UINT32 adddc_one_col_failed_2nd : 1;

                            /* Bits[19:19], Access Type=RW/V/P, default=0x00000000*/

                            /* 1LM adddc: one column failed only in 2nd half */
    UINT32 adddc_one_col_failed : 1;

                            /* Bits[20:20], Access Type=RW/V/P, default=0x00000000*/

                            /* 1LM adddc: one column failed over both half */
    UINT32 adddc_pc_col_failed : 1;

                            /* Bits[21:21], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               1LM adddc: 2 columns that include ParityColumn
                               and Locator bits are failed
                            */
    UINT32 adddc_meta_bit_failed : 1;

                            /* Bits[22:22], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               1LM adddc: any of the metadata bits failed (m0 ,
                               m1)
                            */
    UINT32 adddc_failed_col_in_spare_dev : 1;

                            /* Bits[23:23], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               1LM adddc: half of the failed column is in the
                               spare device
                            */
    UINT32 adddc_one_data_dev_failed : 1;

                            /* Bits[24:24], Access Type=RW/V/P, default=0x00000000*/

                            /* adddc: one data device failed */
    UINT32 adddc_meta_dev_failed : 1;

                            /* Bits[25:25], Access Type=RW/V/P, default=0x00000000*/

                            /* adddc: metadata device failed */
    UINT32 adddc_loc_dev_failed : 1;

                            /* Bits[26:26], Access Type=RW/V/P, default=0x00000000*/

                            /* adddc: locator device failed */
    UINT32 adddc_par_dev_failed : 1;

                            /* Bits[27:27], Access Type=RW/V/P, default=0x00000000*/

                            /* adddc: parity device failed */
    UINT32 sddc_multi_dev_failed : 1;

                            /* Bits[28:28], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               sddc DUE case: there are more than one failed
                               device
                            */
    UINT32 sddc_par_err_no_ls_match : 1;

                            /* Bits[29:29], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               sddc DUE case: there are (parity) errors but we
                               are unable to located the failed device
                            */
    UINT32 sddc_meta_err : 1;

                            /* Bits[30:30], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               sddc DUE case: metadata bits have errors cannot
                               be trusted. this signal was sent to m2m to
                               indicate metadata error
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CORRECTION_DEBUG_LOG_MCDDC_DP_STRUCT;

/* CORRECTION_DEBUG_PLUS1_LOG_MCDDC_DP_REG supported on:                        */
/*      SPRA0 (0x20022c48)                                                      */
/*      SPRB0 (0x20022c48)                                                      */
/*      SPRHBM (0x20022c48)                                                     */
/*      SPRC0 (0x20022c48)                                                      */
/*      SPRMCC (0x20022c48)                                                     */
/*      SPRUCC (0x20022c48)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* this register hold extra correction debug signals for plus1.  The contents of this register are valid with RETRY_RD_ERR_LOG
*/


#define CORRECTION_DEBUG_PLUS1_LOG_MCDDC_DP_REG 0x0B122C48

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tnx_num : 4;

                            /* Bits[3:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               plus1: cache line is transfered over 8
                               transacations tnx0 or tnx1 => 0 tnx2 or tnx3 =>
                               1 tnx4 or tnx5 => 2 tnx6 or tnx7 => 3 no match
                               => 7
                            */
    UINT32 meta_bit_num : 16;

                            /* Bits[19:4], Access Type=RW/V/P, default=0x00000000*/

                            /* plus1: one of the metadata bit has an error */
    UINT32 loc_bit_num : 12;

                            /* Bits[31:20], Access Type=RW/V/P, default=0x00000000*/

                            /* plus1: one of the locator bit has an error */

  } Bits;
  UINT32 Data;

} CORRECTION_DEBUG_PLUS1_LOG_MCDDC_DP_STRUCT;

/* CORRERRORSTATUS_MCDDC_DP_REG supported on:                                   */
/*      SPRA0 (0x20022c50)                                                      */
/*      SPRB0 (0x20022c50)                                                      */
/*      SPRHBM (0x20022c50)                                                     */
/*      SPRC0 (0x20022c50)                                                      */
/*      SPRMCC (0x20022c50)                                                     */
/*      SPRUCC (0x20022c50)                                                     */
/* Register default value on SPRA0: 0x00006000                                  */
/* Register default value on SPRB0: 0x00006000                                  */
/* Register default value on SPRHBM: 0x00006000                                 */
/* Register default value on SPRC0: 0x00006000                                  */
/* Register default value on SPRMCC: 0x00006000                                 */
/* Register default value on SPRUCC: 0x00006000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Per rank corrected error status. These bits are reset by bios.
*/


#define CORRERRORSTATUS_MCDDC_DP_REG 0x0B122C50

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 err_overflow_stat : 8;

                            /* Bits[7:0], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This 8 bit field is the per rank error over-
                               threshold status bits. The organization is as
                               follows: Bit 0 : Rank 0 Bit 1 : Rank 1 Bit 2 :
                               Rank 2 Bit 3 : Rank 3 Bit 4 : Rank 4 Bit 5 :
                               Rank 5 Bit 6 : Rank 6 Bit 7 : Rank 7 Note: The
                               register tracks which rank has reached or
                               exceeded the corresponding CORRERRTHRSHLD
                               threshold settings.
                            */
    UINT32 dimm_alert : 4;

                            /* Bits[11:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit field gets updated on a MRS read.
                               Hardware keep on updating this field with the
                               MRS result for rank selected by
                               dimm_alert_select field. BIOS attempts to clear
                               this will give an impression that it cannot be
                               cleared. Bit 0 is for DIMM 0 for DDR4 or sub-
                               channel 0 DIMM 0 for DDR5; Bit 1 is for DIMM 1
                               for DDR4 or sub-channel 0 DIMM 1 for DDR5; Bit 2
                               is for sub-channel 1 DIMM 0 for DDR5 (unused for
                               DDR4); Bit 3 is for sub-channel 1 DIMM 1 for
                               DDR5 (unused for DDR4).
                            */
    UINT32 dimm_alert_select : 3;

                            /* Bits[14:12], Access Type=RW, default=0x00000006*/

                            /*
                               Select the rank to get the dimm_alert
                               information.
                            */
    UINT32 rsvd : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddr4crc_rank_log : 8;

                            /* Bits[23:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field get set with 1b1 , if the
                               corresponding rank detected ddr4 or ddr5 crc
                               error in one of its write data. This will be
                               cleared by BIOS
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CORRERRORSTATUS_MCDDC_DP_STRUCT;

/* RETRY_RD_ERR_LOG_MISC_MCDDC_DP_REG supported on:                             */
/*      SPRA0 (0x20022c54)                                                      */
/*      SPRB0 (0x20022c54)                                                      */
/*      SPRHBM (0x20022c54)                                                     */
/*      SPRC0 (0x20022c54)                                                      */
/*      SPRMCC (0x20022c54)                                                     */
/*      SPRUCC (0x20022c54)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG
*/


#define RETRY_RD_ERR_LOG_MISC_MCDDC_DP_REG 0x0B122C54

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 plus1_loc_syn : 12;

                            /* Bits[11:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this register hold the value of plus1 locator
                               syndrome from correction path. the number of
                               plus1 LS bits are the same for all the plus1
                               modes
                            */
    UINT32 inter_loc_syn : 12;

                            /* Bits[23:12], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this register hold the value Intermediate
                               Locator Syndrome from correction path which are
                               only valid when the mode is sddc 1lm. Only valid
                               iff hard failure effect the IL bits. The
                               syndrome will indicate which bit is the failing
                               one
                            */
    UINT32 data_failed_col_num : 6;

                            /* Bits[29:24], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this register indicate the failed column number
                               over the data device. columns over data are
                               numbered from 0 to 63. this field is only valid
                               for 1LM ADDDC and when the column correction
                               indication is set in the retry_rd_err_log
                               register
                            */
    UINT32 meta_failed_col_num : 2;

                            /* Bits[31:30], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this register indicate the failed column number
                               over the metadata+locator device. bit 0 of this
                               field is set when column 0 has failed (value
                               01), while bit 1 of this field is set when
                               column 1 has failed (value 10). this field is
                               only valid for 1LM ADDDC and when the column
                               correction indication is set in the
                               retry_rd_err_log register
                            */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_LOG_MISC_MCDDC_DP_STRUCT;

/* RETRY_RD_ERR_LOG_ADDRESS1_MCDDC_DP_REG supported on:                         */
/*      SPRA0 (0x20022c58)                                                      */
/*      SPRB0 (0x20022c58)                                                      */
/*      SPRHBM (0x20022c58)                                                     */
/*      SPRC0 (0x20022c58)                                                      */
/*      SPRMCC (0x20022c58)                                                     */
/*      SPRUCC (0x20022c58)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG.
        The values in this register indicate the address of failed device. failed device id, chip select, cbit, bank  
        DDR     : Decoded Address: Rank[2:0], BG, BA, Row Col
        DDR 3DS : Decoded Address: Rank[2], Rank[0], SubRank[2:0], BG, BA Row Col
        HBM     : Decoded Address: Rank[1:0](for SID and PCH resp), BA, BG, Row, column --> No SubRank field 
      
*/


#define RETRY_RD_ERR_LOG_ADDRESS1_MCDDC_DP_REG 0x0B122C58

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 failed_dev : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Holds the failed device number: for
                               sddc/ddrt/HBM the device number is between 0-17.
                               for adddc device number between 0-16 and 18-35
                               dev 17 is the spare device. for HBM mode, value
                               of 31 means there is no error; also this is
                               failed device number for first 32 bytes.
                            */
    UINT32 chip_select : 3;

                            /* Bits[8:6], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Rank CS0-CS7 (encoded chip select) of retried
                               read
                            */
    UINT32 cbit : 5;

                            /* Bits[13:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               C0-C2 (encoded subrank) for last retry. Bit 12
                               is spare to accomodate for future growth in DDR5
                               Logged value is {2'b0,cbit[2:0]} For HBM mode,
                               indicates the device number for the correctable
                               error signaled by BIST for upper 32 bytes. Valid
                               only when ecc_bist_valid is true and
                               ecc_bist_errtype_upper is correctable.
                            */
    UINT32 bank : 6;

                            /* Bits[19:14], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Bank ID for last retry. Bottom three bits are
                               Bank Group, top two bits are Bank Address Logged
                               value is {1'b0,bank_group[2],bank_address[1:0],b
                               ank_group[1:0]} Bit 18 is spare to accomodate
                               for future growth in DDR5
                            */
    UINT32 col : 10;

                            /* Bits[29:20], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Column address for the last retry Logged value
                               is DDR - {2'b0,Column_addr[9:3],1'b0}.
                               Column_addr[2] indicates Critical chunk, so
                               making that as 0 HBM - {2'b0,Column_addr[9:2]}
                               Bits 9 and 8 as spare to accomodate possible
                               future growth in size for DDR5 In DDR - Actual
                               Column address = {Column_addr[9:3],3'b0}
                               Column_addr[2] indicates Critical chunk In HBM -
                               Actual Column address = {Column_addr[9:2],2'b0}
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_LOG_ADDRESS1_MCDDC_DP_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 failed_dev : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Holds the failed device number: for
                               sddc/ddrt/HBM the device number is between 0-17.
                               for adddc device number between 0-16 and 18-35
                               dev 17 is the spare device. for HBM mode, value
                               of 31 means there is no error; also this is
                               failed device number for first 32 bytes.
                            */
    UINT32 chip_select : 3;

                            /* Bits[8:6], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Rank CS0-CS7 (encoded chip select) of retried
                               read
                            */
    UINT32 cbit : 5;

                            /* Bits[13:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               C0-C2 (encoded subrank) for last retry. Bit 12
                               is spare to accomodate for future growth in DDR5
                               Logged value is {2'b0,cbit[2:0]} For HBM mode,
                               indicates the device number for the correctable
                               error signaled by BIST for upper 32 bytes. Valid
                               only when ecc_bist_valid is true and
                               ecc_bist_errtype_upper is correctable.
                            */
    UINT32 bank : 6;

                            /* Bits[19:14], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Bank ID for last retry. Bottom three bits are
                               Bank Group, top two bits are Bank Address Logged
                               value is {1'b0,bank_group[2],bank_address[1:0],b
                               ank_group[1:0]} Bit 18 is spare to accomodate
                               for future growth in DDR5
                            */
    UINT32 col : 10;

                            /* Bits[29:20], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Column address for the last retry Logged value
                               is DDR - {2'b0,Column_addr[9:3],1'b0}.
                               Column_addr[2] indicates Critical chunk, so
                               making that as 0 HBM - {2'b0,Column_addr[9:2]}
                               Bits 9 and 8 as spare to accomodate possible
                               future growth in size for DDR5 In DDR - Actual
                               Column address = {Column_addr[9:3],3'b0}
                               Column_addr[2] indicates Critical chunk In HBM -
                               Actual Column address = {Column_addr[9:2],2'b0}
                            */
    UINT32 rsvd_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_LOG_ADDRESS1_MCDDC_DP_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 failed_dev : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Holds the failed device number: for sddc/ddrt
                               the device number is between 0-9. for adddc
                               device number between 0-8 and 10-19 with dev 9
                               being the spare device. for HBM mode, device
                               number is between 0-17, with value of 31 means
                               there is no error; also this is failed device
                               number for first 32 bytes with 32B ECC mode.
                               This field is only valid with correctable error
                               of the type device correction.
                            */
    UINT32 chip_select : 3;

                            /* Bits[8:6], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Rank CS0-CS7 (encoded chip select) of retried
                               read
                            */
    UINT32 cbit : 5;

                            /* Bits[13:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               C0-C2 (encoded subrank) for last retry. Bit 12
                               is spare to accomodate for future growth Logged
                               value is {2'b0,cbit[2:0]} For HBM controller
                               with 32B ECC mode, indicates the device number
                               for the correctable error as detected by BIST
                               for upper 32 bytes. Valid only when
                               ecc_bist_valid is true and
                               ecc_bist_errtype_upper is correctable. For all
                               other modes, this field doesn't contain valid
                               information.
                            */
    UINT32 bank : 6;

                            /* Bits[19:14], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Bank ID for last retry. Logged value is {1'b0,ba
                               nk_group[2],bank_address[1:0],bank_group[1:0]}
                               Bit 18 is spare to accomodate for future growth
                            */
    UINT32 col : 10;

                            /* Bits[29:20], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Column address for the last retry Logged value
                               is {2'b0,Column_addr[9:2]} Bits 9 and 8 as spare
                               to accomodate possible future growth in size In
                               DDR - Actual Column address =
                               {Column_addr[9:3],3'b0} Column_addr[2] indicates
                               Critical chunk In HBM - Actual Column address =
                               {Column_addr[9:2],2'b0}
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_LOG_ADDRESS1_MCDDC_DP_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 failed_dev : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Holds the failed device number: for
                               sddc/ddrt/HBM the device number is between 0-17.
                               for adddc device number between 0-16 and 18-35
                               dev 17 is the spare device. for HBM mode, value
                               of 31 means there is no error; also this is
                               failed device number for first 32 bytes.
                            */
    UINT32 chip_select : 3;

                            /* Bits[8:6], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Rank CS0-CS7 (encoded chip select) of retried
                               read
                            */
    UINT32 cbit : 5;

                            /* Bits[13:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               C0-C2 (encoded subrank) for last retry. Bit 12
                               is spare to accomodate for future growth in DDR5
                               Logged value is {2'b0,cbit[2:0]} For HBM mode,
                               indicates the device number for the correctable
                               error signaled by BIST for upper 32 bytes. Valid
                               only when ecc_bist_valid is true and
                               ecc_bist_errtype_upper is correctable.
                            */
    UINT32 bank : 6;

                            /* Bits[19:14], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Bank ID for last retry. Bottom three bits are
                               Bank Group, top two bits are Bank Address Logged
                               value is {1'b0,bank_group[2],bank_address[1:0],b
                               ank_group[1:0]} Bit 18 is spare to accomodate
                               for future growth in DDR5
                            */
    UINT32 col : 10;

                            /* Bits[29:20], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Column address for the last retry Logged value
                               is DDR - {2'b0,Column_addr[9:3],1'b0}.
                               Column_addr[2] indicates Critical chunk, so
                               making that as 0 HBM - {2'b0,Column_addr[9:2]}
                               Bits 9 and 8 as spare to accomodate possible
                               future growth in size for DDR5 In DDR - Actual
                               Column address = {Column_addr[9:3],3'b0}
                               Column_addr[2] indicates Critical chunk In HBM -
                               Actual Column address = {Column_addr[9:2],2'b0}
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_LOG_ADDRESS1_MCDDC_DP_STRUCT;

#ifdef SPRA0_HOST
/* RETRY_RD_ERR_LOG_PARITY_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x20022c5c)                                                      */
/* Register default value on SPRA0: 0x00000000                                  */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG
*/


#define RETRY_RD_ERR_LOG_PARITY_MCDDC_DP_REG 0x0B122C5C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 par_syn : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this register hold the parity syndrome(mask)
                               from correction path. for sddc/x8/ddrt parity
                               syndrome is 32 bits. but for 2LM adddc it is 16
                               bits so the 16 upper bits are always 0 for 2LM
                               adddc: 16 bits 0 + Parity Syndrome (16 bits). in
                               1LM adddc reused the 8 upper bits to log the
                               Parity Column Syndrome. so the order for 1LM
                               adddc will be: PC syn for upper half of CL
                               (4bits)+ PC syn for lower half of CL (4bits)+ 8
                               bits 0 + Parity Syndrome (16 bits)
                            */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_LOG_PARITY_MCDDC_DP_STRUCT;
#endif /* (SPRA0_HOST) */

/* RETRY_RD_ERR_LOG_MCDDC_DP_REG supported on:                                  */
/*      SPRA0 (0x20022c60)                                                      */
/*      SPRB0 (0x20022c60)                                                      */
/*      SPRHBM (0x20022c60)                                                     */
/*      SPRC0 (0x20022c60)                                                      */
/*      SPRMCC (0x20022c60)                                                     */
/*      SPRUCC (0x20022c60)                                                     */
/* Register default value on SPRA0: 0x0000C000                                  */
/* Register default value on SPRB0: 0x0000C000                                  */
/* Register default value on SPRHBM: 0x0000C000                                 */
/* Register default value on SPRC0: 0x0000C000                                  */
/* Register default value on SPRMCC: 0x0000C000                                 */
/* Register default value on SPRUCC: 0x0000C000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads
*/


#define RETRY_RD_ERR_LOG_MCDDC_DP_REG 0x0B122C60

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 v : 1;

                            /* Bits[0:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               The contents of this register have valid data as
                               well as RETRY_RD_ERR_LOG_PARITY,
                               RETRY_RD_ERR_LOG_MISC,
                               RETRY_RD_ERR_LOG_ADDRESS1, and
                               RETRY_RD_ERR_LOG_ADDRESS2.
                            */
    UINT32 uc : 1;

                            /* Bits[1:1], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Uncorrectable error. Logs cannot be overwritten
                               while UC is set. This bit is not controlled by
                               MC, but by a lock indication from HA.
                            */
    UINT32 over : 1;

                            /* Bits[2:2], Access Type=RW/V/P, default=0x00000000*/

                            /* The log has been overwritten. */
    UINT32 mode : 4;

                            /* Bits[6:3], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               indicate the ecc mode the register is logging
                               for DDR mode: 4b0000 => sddc 2LM 4b0001 => sddc
                               1LM 4b0010 => sddc +1 2LM 4b0011 => sddc +1 1LM
                               4b0100 => adddc 2LM 4b0101 => adddc 1LM 4b0110
                               => adddc +1 2LM 4b0111 => adddc +1 1LM 4b1000 =>
                               read is from ddrt dimm 4b1011 => not a valid ecc
                               mode For HBM mode: 4b0001 => 64B read 4b1001 =>
                               32B read
                            */
    UINT32 corr_err : 1;

                            /* Bits[7:7], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but was
                               not able to correct hte error => DUE
                            */
    UINT32 corr_noerr : 1;

                            /* Bits[8:8], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but no
                               ecc error was detected
                            */
    UINT32 corr_correctable : 1;

                            /* Bits[9:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction and
                               detect a correctable ecc error and corrected
                            */
    UINT32 corr_correctable_par_dev : 1;

                            /* Bits[10:10], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction, error
                               was in parity device which consider a
                               correctable error
                            */
    UINT32 ecc_err : 1;

                            /* Bits[11:11], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, the ecc error indication
                               sent to m2m
                            */
    UINT32 patspr : 1;

                            /* Bits[12:12], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if we have logged a patrol/spare
                               error. If patspr=1 we have logged patrol/spare
                               error.
                            */
    UINT32 en_patspr : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /*
                               If en_patspr=1: Log patrol/sparing errors and
                               NOT demand/ufill reads; if en_patspr=0: Log
                               demand/ufill reads and NOT patrol/sparing.
                               Default is to log demand/ufill reads.
                            */
    UINT32 noover : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /*
                               Lock register after the first error, do not
                               overflow.
                            */
    UINT32 en : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000001*/

                            /* Enable error logging. Will log on every retry. */
    UINT32 col_correction : 1;

                            /* Bits[16:16], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This field indicate a column correction done
                               instead of the device correction and is only
                               valid for 1LM adddc mode (retry_rd_err_log.mode
                               = 4'b0101). In all other modes, this field
                               should be ignored.
                            */
    UINT32 single_bit_error : 1;

                            /* Bits[17:17], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if there was a single bit correction -
                               SDDC and SDDC +1 modes, used in PCLS
                            */
    UINT32 transfer_number : 3;

                            /* Bits[20:18], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates Transfer number of the single bit
                               correction,used in PCLS
                            */
    UINT32 persistent_error : 1;

                            /* Bits[21:21], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates persistent error indicated by BIST,
                               for HBM
                            */
    UINT32 system_addr_valid : 1;

                            /* Bits[22:22], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates there is valid system address in the
                               retry_rd_err_address3_log register
                            */
    UINT32 mirror : 1;

                            /* Bits[23:23], Access Type=RW/V/P, default=0x00000000*/

                            /* Indicates if the transaction is mirrored */
    UINT32 mirror_pri : 1;

                            /* Bits[24:24], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               primary channel
                            */
    UINT32 mirror_failover : 1;

                            /* Bits[25:25], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               failed over channel
                            */
    UINT32 ecc_bist_valid : 1;

                            /* Bits[26:26], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that ECCBIST is enabled. The fields
                               ecc_bist_errtype and ecc_bist_corr_err_devnum
                               are only valid if this is true
                            */
    UINT32 ddrt_modeb_uc : 1;

                            /* Bits[27:27], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that in DDRT ECC mode B - The
                               correction fsm indicates correctable but the
                               failed device doesnt match the one identified by
                               BIOS. So we mark the result as UC
                            */
    UINT32 ecc_bist_errtype_upper : 2;

                            /* Bits[29:28], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the err type for the BIST result for
                               upper 32 byte for HBM mode. Valid only if
                               ecc_bist_valid field is true in the
                               retry_rd_err_log. BIST Result No Error = 2'b00
                               BIST Result Uncorrectable = 2'b01 BIST Result
                               Correctable = 2'b10 BIST Result Not Available
                               (req_length = 1) = 2'b11
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_LOG_MCDDC_DP_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 v : 1;

                            /* Bits[0:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               The contents of this register have valid data as
                               well as RETRY_RD_ERR_LOG_PARITY,
                               RETRY_RD_ERR_LOG_MISC,
                               RETRY_RD_ERR_LOG_ADDRESS1, and
                               RETRY_RD_ERR_LOG_ADDRESS2.
                            */
    UINT32 uc : 1;

                            /* Bits[1:1], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Uncorrectable error. Logs cannot be overwritten
                               while UC is set. This bit is not controlled by
                               MC, but by a lock indication from HA.
                            */
    UINT32 over : 1;

                            /* Bits[2:2], Access Type=RW/V/P, default=0x00000000*/

                            /* The log has been overwritten. */
    UINT32 mode : 4;

                            /* Bits[6:3], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               indicate the ecc mode the register is logging
                               for DDR mode: 4b0000 => sddc 2LM 4b0001 => sddc
                               1LM 4b0010 => sddc +1 2LM 4b0011 => sddc +1 1LM
                               4b0100 => adddc 2LM 4b0101 => adddc 1LM 4b0110
                               => adddc +1 2LM 4b0111 => adddc +1 1LM 4b1000 =>
                               read is from ddrt dimm 4b1011 => not a valid ecc
                               mode For HBM mode: 4b0001 => 64B read 4b1001 =>
                               32B read
                            */
    UINT32 corr_err : 1;

                            /* Bits[7:7], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but was
                               not able to correct hte error => DUE
                            */
    UINT32 corr_noerr : 1;

                            /* Bits[8:8], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but no
                               ecc error was detected
                            */
    UINT32 corr_correctable : 1;

                            /* Bits[9:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction and
                               detect a correctable ecc error and corrected
                            */
    UINT32 corr_correctable_par_dev : 1;

                            /* Bits[10:10], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction, error
                               was in parity device which consider a
                               correctable error
                            */
    UINT32 ecc_err : 1;

                            /* Bits[11:11], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, the ecc error indication
                               sent to m2m
                            */
    UINT32 patspr : 1;

                            /* Bits[12:12], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if we have logged a patrol/spare
                               error. If patspr=1 we have logged patrol/spare
                               error.
                            */
    UINT32 en_patspr : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /*
                               If en_patspr=1: Log patrol/sparing errors and
                               NOT demand/ufill reads; if en_patspr=0: Log
                               demand/ufill reads and NOT patrol/sparing.
                               Default is to log demand/ufill reads.
                            */
    UINT32 noover : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /*
                               Lock register after the first error, do not
                               overflow.
                            */
    UINT32 en : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000001*/

                            /* Enable error logging. Will log on every retry. */
    UINT32 col_correction : 1;

                            /* Bits[16:16], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This field indicate a column correction done
                               instead of the device correction and is only
                               valid for 1LM adddc mode (retry_rd_err_log.mode
                               = 4'b0101). In all other modes, this field
                               should be ignored.
                            */
    UINT32 single_bit_error : 1;

                            /* Bits[17:17], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if there was a single bit correction -
                               SDDC and SDDC +1 modes, used in PCLS
                            */
    UINT32 transfer_number : 4;

                            /* Bits[21:18], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates Transfer number of the single bit
                               correction,used in PCLS
                            */
    UINT32 persistent_error : 1;

                            /* Bits[22:22], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates persistent error indicated by BIST,
                               for HBM
                            */
    UINT32 system_addr_valid : 1;

                            /* Bits[23:23], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates there is valid system address in the
                               retry_rd_err_address3_log register
                            */
    UINT32 mirror : 1;

                            /* Bits[24:24], Access Type=RW/V/P, default=0x00000000*/

                            /* Indicates if the transaction is mirrored */
    UINT32 mirror_pri : 1;

                            /* Bits[25:25], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               primary channel
                            */
    UINT32 mirror_failover : 1;

                            /* Bits[26:26], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               failed over channel
                            */
    UINT32 ecc_bist_valid : 1;

                            /* Bits[27:27], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that ECCBIST is enabled. The fields
                               ecc_bist_errtype and ecc_bist_corr_err_devnum
                               are only valid if this is true
                            */
    UINT32 ddrt_modeb_uc : 1;

                            /* Bits[28:28], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that in DDRT ECC mode B - The
                               correction fsm indicates correctable but the
                               failed device doesnt match the one identified by
                               BIOS. So we mark the result as UC
                            */
    UINT32 ecc_bist_errtype_upper : 2;

                            /* Bits[30:29], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the err type for the BIST result for
                               upper 32 byte for HBM mode. Valid only if
                               ecc_bist_valid field is true in the
                               retry_rd_err_log. BIST Result No Error = 2'b00
                               BIST Result Uncorrectable = 2'b01 BIST Result
                               Correctable = 2'b10 BIST Result Not Available
                               (req_length = 1) = 2'b11
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_LOG_MCDDC_DP_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 v : 1;

                            /* Bits[0:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               The contents of this register have valid data as
                               well as RETRY_RD_ERR_LOG_PARITY,
                               RETRY_RD_ERR_LOG_MISC,
                               RETRY_RD_ERR_LOG_ADDRESS1, and
                               RETRY_RD_ERR_LOG_ADDRESS2.
                            */
    UINT32 uc : 1;

                            /* Bits[1:1], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Uncorrectable error. Logs cannot be overwritten
                               while UC is set. This bit is not controlled by
                               MC, but by a lock indication from HA.
                            */
    UINT32 over : 1;

                            /* Bits[2:2], Access Type=RW/V/P, default=0x00000000*/

                            /* The log has been overwritten. */
    UINT32 mode : 4;

                            /* Bits[6:3], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               indicate the ecc mode the register is logging
                               for DDR mode: 4b0000 => sddc 2LM 4b0001 => sddc
                               1LM 4b0010 => sddc +1 2LM 4b0011 => sddc +1 1LM
                               4b0100 => adddc 2LM 4b0101 => adddc 1LM 4b0110
                               => adddc +1 2LM 4b0111 => adddc +1 1LM 4b1000 =>
                               read is from ddrt dimm 4b1011 => not a valid ecc
                               mode For HBM mode: 4b0001 => 64B read 4b1001 =>
                               32B read
                            */
    UINT32 corr_err : 1;

                            /* Bits[7:7], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but was
                               not able to correct hte error => DUE
                            */
    UINT32 corr_noerr : 1;

                            /* Bits[8:8], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but no
                               ecc error was detected
                            */
    UINT32 corr_correctable : 1;

                            /* Bits[9:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction and
                               detect a correctable ecc error and corrected
                            */
    UINT32 corr_correctable_par_dev : 1;

                            /* Bits[10:10], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction, error
                               was in parity device which consider a
                               correctable error
                            */
    UINT32 ecc_err : 1;

                            /* Bits[11:11], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, the ecc error indication
                               sent to m2m
                            */
    UINT32 patspr : 1;

                            /* Bits[12:12], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if we have logged a patrol/spare
                               error. If patspr=1 we have logged patrol/spare
                               error.
                            */
    UINT32 en_patspr : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /*
                               If en_patspr=1: Log patrol/sparing errors and
                               NOT demand/ufill reads; if en_patspr=0: Log
                               demand/ufill reads and NOT patrol/sparing.
                               Default is to log demand/ufill reads.
                            */
    UINT32 noover : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /*
                               Lock register after the first error, do not
                               overflow.
                            */
    UINT32 en : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000001*/

                            /* Enable error logging. Will log on every retry. */
    UINT32 col_correction : 1;

                            /* Bits[16:16], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This field indicate a column correction done
                               instead of the device correction and is only
                               valid for 1LM adddc mode (retry_rd_err_log.mode
                               = 4'b0101). In all other modes, this field
                               should be ignored.
                            */
    UINT32 single_bit_error : 1;

                            /* Bits[17:17], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if there was a single bit correction -
                               SDDC and SDDC +1 modes, used in PCLS
                            */
    UINT32 transfer_number : 4;

                            /* Bits[21:18], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates Transfer number of the single bit
                               correction,used in PCLS
                            */
    UINT32 persistent_error : 1;

                            /* Bits[22:22], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates persistent error indicated by BIST,
                               for HBM
                            */
    UINT32 system_addr_valid : 1;

                            /* Bits[23:23], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates there is valid system address in the
                               retry_rd_err_address3_log register
                            */
    UINT32 mirror : 1;

                            /* Bits[24:24], Access Type=RW/V/P, default=0x00000000*/

                            /* Indicates if the transaction is mirrored */
    UINT32 mirror_pri : 1;

                            /* Bits[25:25], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               primary channel. Value of this bit is irrelevant
                               if mirror bit is not set.
                            */
    UINT32 mirror_failover : 1;

                            /* Bits[26:26], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               failed over channel
                            */
    UINT32 ecc_bist_valid : 1;

                            /* Bits[27:27], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that ECCBIST is enabled. The fields
                               ecc_bist_errtype and ecc_bist_corr_err_devnum
                               are only valid if this is true
                            */
    UINT32 ddrt_modeb_uc : 1;

                            /* Bits[28:28], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that in DDRT ECC mode B - The
                               correction fsm indicates correctable but the
                               failed device doesnt match the one identified by
                               BIOS. So we mark the result as UC
                            */
    UINT32 ecc_bist_errtype_upper : 2;

                            /* Bits[30:29], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the err type for the BIST result for
                               upper 32 byte for HBM mode. Valid only if
                               ecc_bist_valid field is true in the
                               retry_rd_err_log. BIST Result No Error = 2'b00
                               BIST Result Uncorrectable = 2'b01 BIST Result
                               Correctable = 2'b10 BIST Result Not Available
                               (req_length = 1) = 2'b11
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_LOG_MCDDC_DP_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 v : 1;

                            /* Bits[0:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               The contents of this register have valid data as
                               well as RETRY_RD_ERR_LOG_PARITY,
                               RETRY_RD_ERR_LOG_MISC,
                               RETRY_RD_ERR_LOG_ADDRESS1, and
                               RETRY_RD_ERR_LOG_ADDRESS2.
                            */
    UINT32 uc : 1;

                            /* Bits[1:1], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Uncorrectable error. Logs cannot be overwritten
                               while UC is set. This bit is not controlled by
                               MC, but by a lock indication from HA.
                            */
    UINT32 over : 1;

                            /* Bits[2:2], Access Type=RW/V/P, default=0x00000000*/

                            /* The log has been overwritten. */
    UINT32 mode : 4;

                            /* Bits[6:3], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               indicate the ecc mode the register is logging
                               for DDR mode: 4b0000 => sddc 2LM 4b0001 => sddc
                               1LM 4b0010 => sddc +1 2LM 4b0011 => sddc +1 1LM
                               4b0100 => adddc 2LM 4b0101 => adddc 1LM 4b0110
                               => adddc +1 2LM 4b0111 => adddc +1 1LM 4b1000 =>
                               read is from ddrt dimm 4b1011 => not a valid ecc
                               mode For HBM mode: 4b0001 => 64B read 4b1001 =>
                               32B read
                            */
    UINT32 corr_err : 1;

                            /* Bits[7:7], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but was
                               not able to correct hte error => DUE
                            */
    UINT32 corr_noerr : 1;

                            /* Bits[8:8], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but no
                               ecc error was detected
                            */
    UINT32 corr_correctable : 1;

                            /* Bits[9:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction and
                               detect a correctable ecc error and corrected
                            */
    UINT32 corr_correctable_par_dev : 1;

                            /* Bits[10:10], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction, error
                               was in parity device which consider a
                               correctable error
                            */
    UINT32 ecc_err : 1;

                            /* Bits[11:11], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, the ecc error indication
                               sent to m2m
                            */
    UINT32 patspr : 1;

                            /* Bits[12:12], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if we have logged a patrol/spare
                               error. If patspr=1 we have logged patrol/spare
                               error.
                            */
    UINT32 en_patspr : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /*
                               If en_patspr=1: Log patrol/sparing errors and
                               NOT demand/ufill reads; if en_patspr=0: Log
                               demand/ufill reads and NOT patrol/sparing.
                               Default is to log demand/ufill reads.
                            */
    UINT32 noover : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /*
                               Lock register after the first error, do not
                               overflow.
                            */
    UINT32 en : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000001*/

                            /* Enable error logging. Will log on every retry. */
    UINT32 col_correction : 1;

                            /* Bits[16:16], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This field indicate a column correction done
                               instead of the device correction and is only
                               valid for 1LM adddc mode (retry_rd_err_log.mode
                               = 4'b0101). In all other modes, this field
                               should be ignored.
                            */
    UINT32 single_bit_error : 1;

                            /* Bits[17:17], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if there was a single bit correction -
                               SDDC and SDDC +1 modes, used in PCLS
                            */
    UINT32 rsvd : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_LOG_MCDDC_DP_STRUCT;

/* RETRY_RD_ERR_SET3_LOG_ADDRESS2_MCDDC_DP_REG supported on:                    */
/*      SPRA0 (0x20022c64)                                                      */
/*      SPRB0 (0x20022c64)                                                      */
/*      SPRHBM (0x20022c64)                                                     */
/*      SPRC0 (0x20022c64)                                                      */
/*      SPRMCC (0x20022c64)                                                     */
/*      SPRUCC (0x20022c64)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG.
            Logged value is {3'b0,Row_addr[17:0]}
            Bits 20,19,18 are spares to accomodate for future growth in DDR5

            This also stored the following when BIST is enabled.
            Bist result err type
            bist correctable error device number
            correction fsm errtype --> this is needed when BIST results is also taken to make the decision on the err type. 
      
*/


#define RETRY_RD_ERR_SET3_LOG_ADDRESS2_MCDDC_DP_REG 0x0B122C64

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 row : 18;

                            /* Bits[17:0], Access Type=RW/V/P, default=0x00000000*/

                            /* Row address for the last retry. */
    UINT32 failed_dev_upper : 5;

                            /* Bits[22:18], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Holds the failed device number for HBM second 32
                               bytes, with a value between 0-17. Value of 31
                               means there is no error in these 32 bytes.
                            */
    UINT32 ecc_bist_errtype : 2;

                            /* Bits[24:23], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the err type for the BIST result.
                               Valid only if ecc_bist_valid field is true in
                               the retry_rd_err_log. BIST Result No Error =
                               2'b00 BIST Result Uncorrectable = 2'b01 BIST
                               Result Correctable = 2'b10 For HBM mode, this is
                               the type for lower 32 bytes.
                            */
    UINT32 ecc_bist_corr_err_devnum : 5;

                            /* Bits[29:25], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the device number for the correctable
                               error signaled by BIST. Valid only when
                               ecc_bist_valid is true and ecc_bist_errtype is
                               correctable. For HBM mode, this is the device
                               number for lower 32 bytes.
                            */
    UINT32 corr_fsm_errtype : 2;

                            /* Bits[31:30], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the err type for the Corection fsm
                               result. BIST Result No Error = 2'b00 BIST Result
                               Uncorrectable = 2'b01 BIST Result Correctable =
                               2'b10 This isnt logged when in BIST bypass mode
                               or error reporting mode as the retry_rd_err_log
                               contents represents only the correction fsm
                               results. valid only for BIST SDC control mode.
                            */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET3_LOG_ADDRESS2_MCDDC_DP_STRUCT;

/* ALERTSIGNAL_MCDDC_DP_REG supported on:                                       */
/*      SPRA0 (0x22c6c)                                                         */
/*      SPRB0 (0x22c6c)                                                         */
/*      SPRHBM (0x22c6c)                                                        */
/*      SPRC0 (0x22c6c)                                                         */
/*      SPRMCC (0x22c6c)                                                        */
/*      SPRUCC (0x22c6c)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* alert status
*/


#define ALERTSIGNAL_MCDDC_DP_REG 0x0B102C6C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 seen : 1;

                            /* Bits[0:0], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               If 1, alert signal (DDR4 parity error) has been
                               observed. This bit is intended to be used as
                               feedback during CMD/address training. A write 1
                               will clear this field.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} ALERTSIGNAL_MCDDC_DP_STRUCT;

/* RETRY_RD_ERR_SET3_LOG_MCDDC_DP_REG supported on:                             */
/*      SPRA0 (0x20022c70)                                                      */
/*      SPRB0 (0x20022c70)                                                      */
/*      SPRHBM (0x20022c70)                                                     */
/*      SPRC0 (0x20022c70)                                                      */
/*      SPRMCC (0x20022c70)                                                     */
/*      SPRUCC (0x20022c70)                                                     */
/* Register default value on SPRA0: 0x0000C000                                  */
/* Register default value on SPRB0: 0x0000C000                                  */
/* Register default value on SPRHBM: 0x0000C000                                 */
/* Register default value on SPRC0: 0x0000C000                                  */
/* Register default value on SPRMCC: 0x0000C000                                 */
/* Register default value on SPRUCC: 0x0000C000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads
*/


#define RETRY_RD_ERR_SET3_LOG_MCDDC_DP_REG 0x0B122C70

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 v : 1;

                            /* Bits[0:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               The contents of this register have valid data as
                               well as RETRY_RD_ERR_LOG_PARITY,
                               RETRY_RD_ERR_LOG_MISC,
                               RETRY_RD_ERR_LOG_ADDRESS1, and
                               RETRY_RD_ERR_LOG_ADDRESS2.
                            */
    UINT32 uc : 1;

                            /* Bits[1:1], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Uncorrectable error. Logs cannot be overwritten
                               while UC is set. This bit is not controlled by
                               MC, but by a lock indication from HA.
                            */
    UINT32 over : 1;

                            /* Bits[2:2], Access Type=RW/V/P, default=0x00000000*/

                            /* The log has been overwritten. */
    UINT32 mode : 4;

                            /* Bits[6:3], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               indicate the ecc mode the register is logging
                               for DDR mode: 4b0000 => sddc 2LM 4b0001 => sddc
                               1LM 4b0010 => sddc +1 2LM 4b0011 => sddc +1 1LM
                               4b0100 => adddc 2LM 4b0101 => adddc 1LM 4b0110
                               => adddc +1 2LM 4b0111 => adddc +1 1LM 4b1000 =>
                               read is from ddrt dimm 4b1011 => not a valid ecc
                               mode For HBM mode: 4b0001 => 64B read 4b1001 =>
                               32B read
                            */
    UINT32 corr_err : 1;

                            /* Bits[7:7], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but was
                               not able to correct hte error => DUE
                            */
    UINT32 corr_noerr : 1;

                            /* Bits[8:8], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but no
                               ecc error was detected
                            */
    UINT32 corr_correctable : 1;

                            /* Bits[9:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction and
                               detect a correctable ecc error and corrected
                            */
    UINT32 corr_correctable_par_dev : 1;

                            /* Bits[10:10], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction, error
                               was in parity device which consider a
                               correctable error
                            */
    UINT32 ecc_err : 1;

                            /* Bits[11:11], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, the ecc error indication
                               sent to m2m
                            */
    UINT32 patspr : 1;

                            /* Bits[12:12], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if we have logged a patrol/spare
                               error. If patspr=1 we have logged patrol/spare
                               error.
                            */
    UINT32 en_patspr : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /*
                               If en_patspr=1: Log patrol/sparing errors and
                               NOT demand/ufill reads; if en_patspr=0: Log
                               demand/ufill reads and NOT patrol/sparing.
                               Default is to log demand/ufill reads.
                            */
    UINT32 noover : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /*
                               Lock register after the first error, do not
                               overflow.
                            */
    UINT32 en : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000001*/

                            /* Enable error logging. Will log on every retry. */
    UINT32 col_correction : 1;

                            /* Bits[16:16], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This field indicate a column correction done
                               instead of the device correction and is only
                               valid for 1LM adddc mode (retry_rd_err_log.mode
                               = 4'b0101). In all other modes, this field
                               should be ignored.
                            */
    UINT32 single_bit_error : 1;

                            /* Bits[17:17], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if there was a single bit correction -
                               SDDC and SDDC +1 modes, used in PCLS
                            */
    UINT32 transfer_number : 3;

                            /* Bits[20:18], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates Transfer number of the single bit
                               correction,used in PCLS
                            */
    UINT32 persistent_error : 1;

                            /* Bits[21:21], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates persistent error indicated by BIST,
                               for HBM
                            */
    UINT32 system_addr_valid : 1;

                            /* Bits[22:22], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates there is valid system address in the
                               retry_rd_err_address3_log register
                            */
    UINT32 mirror : 1;

                            /* Bits[23:23], Access Type=RW/V/P, default=0x00000000*/

                            /* Indicates if the transaction is mirrored */
    UINT32 mirror_pri : 1;

                            /* Bits[24:24], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               primary channel
                            */
    UINT32 mirror_failover : 1;

                            /* Bits[25:25], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               failed over channel
                            */
    UINT32 ecc_bist_valid : 1;

                            /* Bits[26:26], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that ECCBIST is enabled. The fields
                               ecc_bist_errtype and ecc_bist_corr_err_devnum
                               are only valid if this is true
                            */
    UINT32 ddrt_modeb_uc : 1;

                            /* Bits[27:27], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that in DDRT ECC mode B - The
                               correction fsm indicates correctable but the
                               failed device doesnt match the one identified by
                               BIOS. So we mark the result as UC
                            */
    UINT32 ecc_bist_errtype_upper : 2;

                            /* Bits[29:28], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the err type for the BIST result for
                               upper 32 byte for HBM mode. Valid only if
                               ecc_bist_valid field is true in the
                               retry_rd_err_log. BIST Result No Error = 2'b00
                               BIST Result Uncorrectable = 2'b01 BIST Result
                               Correctable = 2'b10 BIST Result Not Available
                               (req_length = 1) = 2'b11
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET3_LOG_MCDDC_DP_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 v : 1;

                            /* Bits[0:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               The contents of this register have valid data as
                               well as RETRY_RD_ERR_LOG_PARITY,
                               RETRY_RD_ERR_LOG_MISC,
                               RETRY_RD_ERR_LOG_ADDRESS1, and
                               RETRY_RD_ERR_LOG_ADDRESS2.
                            */
    UINT32 uc : 1;

                            /* Bits[1:1], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Uncorrectable error. Logs cannot be overwritten
                               while UC is set. This bit is not controlled by
                               MC, but by a lock indication from HA.
                            */
    UINT32 over : 1;

                            /* Bits[2:2], Access Type=RW/V/P, default=0x00000000*/

                            /* The log has been overwritten. */
    UINT32 mode : 4;

                            /* Bits[6:3], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               indicate the ecc mode the register is logging
                               for DDR mode: 4b0000 => sddc 2LM 4b0001 => sddc
                               1LM 4b0010 => sddc +1 2LM 4b0011 => sddc +1 1LM
                               4b0100 => adddc 2LM 4b0101 => adddc 1LM 4b0110
                               => adddc +1 2LM 4b0111 => adddc +1 1LM 4b1000 =>
                               read is from ddrt dimm 4b1011 => not a valid ecc
                               mode For HBM mode: 4b0001 => 64B read 4b1001 =>
                               32B read
                            */
    UINT32 corr_err : 1;

                            /* Bits[7:7], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but was
                               not able to correct hte error => DUE
                            */
    UINT32 corr_noerr : 1;

                            /* Bits[8:8], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but no
                               ecc error was detected
                            */
    UINT32 corr_correctable : 1;

                            /* Bits[9:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction and
                               detect a correctable ecc error and corrected
                            */
    UINT32 corr_correctable_par_dev : 1;

                            /* Bits[10:10], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction, error
                               was in parity device which consider a
                               correctable error
                            */
    UINT32 ecc_err : 1;

                            /* Bits[11:11], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, the ecc error indication
                               sent to m2m
                            */
    UINT32 patspr : 1;

                            /* Bits[12:12], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if we have logged a patrol/spare
                               error. If patspr=1 we have logged patrol/spare
                               error.
                            */
    UINT32 en_patspr : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /*
                               If en_patspr=1: Log patrol/sparing errors and
                               NOT demand/ufill reads; if en_patspr=0: Log
                               demand/ufill reads and NOT patrol/sparing.
                               Default is to log demand/ufill reads.
                            */
    UINT32 noover : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /*
                               Lock register after the first error, do not
                               overflow.
                            */
    UINT32 en : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000001*/

                            /* Enable error logging. Will log on every retry. */
    UINT32 col_correction : 1;

                            /* Bits[16:16], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This field indicate a column correction done
                               instead of the device correction and is only
                               valid for 1LM adddc mode (retry_rd_err_log.mode
                               = 4'b0101). In all other modes, this field
                               should be ignored.
                            */
    UINT32 single_bit_error : 1;

                            /* Bits[17:17], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if there was a single bit correction -
                               SDDC and SDDC +1 modes, used in PCLS
                            */
    UINT32 transfer_number : 4;

                            /* Bits[21:18], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates Transfer number of the single bit
                               correction,used in PCLS
                            */
    UINT32 persistent_error : 1;

                            /* Bits[22:22], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates persistent error indicated by BIST,
                               for HBM
                            */
    UINT32 system_addr_valid : 1;

                            /* Bits[23:23], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates there is valid system address in the
                               retry_rd_err_address3_log register
                            */
    UINT32 mirror : 1;

                            /* Bits[24:24], Access Type=RW/V/P, default=0x00000000*/

                            /* Indicates if the transaction is mirrored */
    UINT32 mirror_pri : 1;

                            /* Bits[25:25], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               primary channel
                            */
    UINT32 mirror_failover : 1;

                            /* Bits[26:26], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               failed over channel
                            */
    UINT32 ecc_bist_valid : 1;

                            /* Bits[27:27], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that ECCBIST is enabled. The fields
                               ecc_bist_errtype and ecc_bist_corr_err_devnum
                               are only valid if this is true
                            */
    UINT32 ddrt_modeb_uc : 1;

                            /* Bits[28:28], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that in DDRT ECC mode B - The
                               correction fsm indicates correctable but the
                               failed device doesnt match the one identified by
                               BIOS. So we mark the result as UC
                            */
    UINT32 ecc_bist_errtype_upper : 2;

                            /* Bits[30:29], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the err type for the BIST result for
                               upper 32 byte for HBM mode. Valid only if
                               ecc_bist_valid field is true in the
                               retry_rd_err_log. BIST Result No Error = 2'b00
                               BIST Result Uncorrectable = 2'b01 BIST Result
                               Correctable = 2'b10 BIST Result Not Available
                               (req_length = 1) = 2'b11
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET3_LOG_MCDDC_DP_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 v : 1;

                            /* Bits[0:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               The contents of this register have valid data as
                               well as RETRY_RD_ERR_LOG_PARITY,
                               RETRY_RD_ERR_LOG_MISC,
                               RETRY_RD_ERR_LOG_ADDRESS1, and
                               RETRY_RD_ERR_LOG_ADDRESS2.
                            */
    UINT32 uc : 1;

                            /* Bits[1:1], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Uncorrectable error. Logs cannot be overwritten
                               while UC is set. This bit is not controlled by
                               MC, but by a lock indication from HA.
                            */
    UINT32 over : 1;

                            /* Bits[2:2], Access Type=RW/V/P, default=0x00000000*/

                            /* The log has been overwritten. */
    UINT32 mode : 4;

                            /* Bits[6:3], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               indicate the ecc mode the register is logging
                               for DDR mode: 4b0000 => sddc 2LM 4b0001 => sddc
                               1LM 4b0010 => sddc +1 2LM 4b0011 => sddc +1 1LM
                               4b0100 => adddc 2LM 4b0101 => adddc 1LM 4b0110
                               => adddc +1 2LM 4b0111 => adddc +1 1LM 4b1000 =>
                               read is from ddrt dimm 4b1011 => not a valid ecc
                               mode For HBM mode: 4b0001 => 64B read 4b1001 =>
                               32B read
                            */
    UINT32 corr_err : 1;

                            /* Bits[7:7], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but was
                               not able to correct hte error => DUE
                            */
    UINT32 corr_noerr : 1;

                            /* Bits[8:8], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but no
                               ecc error was detected
                            */
    UINT32 corr_correctable : 1;

                            /* Bits[9:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction and
                               detect a correctable ecc error and corrected
                            */
    UINT32 corr_correctable_par_dev : 1;

                            /* Bits[10:10], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction, error
                               was in parity device which consider a
                               correctable error
                            */
    UINT32 ecc_err : 1;

                            /* Bits[11:11], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, the ecc error indication
                               sent to m2m
                            */
    UINT32 patspr : 1;

                            /* Bits[12:12], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if we have logged a patrol/spare
                               error. If patspr=1 we have logged patrol/spare
                               error.
                            */
    UINT32 en_patspr : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /*
                               If en_patspr=1: Log patrol/sparing errors and
                               NOT demand/ufill reads; if en_patspr=0: Log
                               demand/ufill reads and NOT patrol/sparing.
                               Default is to log demand/ufill reads.
                            */
    UINT32 noover : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /*
                               Lock register after the first error, do not
                               overflow.
                            */
    UINT32 en : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000001*/

                            /* Enable error logging. Will log on every retry. */
    UINT32 col_correction : 1;

                            /* Bits[16:16], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This field indicate a column correction done
                               instead of the device correction and is only
                               valid for 1LM adddc mode (retry_rd_err_log.mode
                               = 4'b0101). In all other modes, this field
                               should be ignored.
                            */
    UINT32 single_bit_error : 1;

                            /* Bits[17:17], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if there was a single bit correction -
                               SDDC and SDDC +1 modes, used in PCLS
                            */
    UINT32 transfer_number : 4;

                            /* Bits[21:18], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates Transfer number of the single bit
                               correction,used in PCLS
                            */
    UINT32 persistent_error : 1;

                            /* Bits[22:22], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates persistent error indicated by BIST,
                               for HBM
                            */
    UINT32 system_addr_valid : 1;

                            /* Bits[23:23], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates there is valid system address in the
                               retry_rd_err_address3_log register
                            */
    UINT32 mirror : 1;

                            /* Bits[24:24], Access Type=RW/V/P, default=0x00000000*/

                            /* Indicates if the transaction is mirrored */
    UINT32 mirror_pri : 1;

                            /* Bits[25:25], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               primary channel. Value of this bit is irrelevant
                               if mirror bit is not set.
                            */
    UINT32 mirror_failover : 1;

                            /* Bits[26:26], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               failed over channel
                            */
    UINT32 ecc_bist_valid : 1;

                            /* Bits[27:27], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that ECCBIST is enabled. The fields
                               ecc_bist_errtype and ecc_bist_corr_err_devnum
                               are only valid if this is true
                            */
    UINT32 ddrt_modeb_uc : 1;

                            /* Bits[28:28], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that in DDRT ECC mode B - The
                               correction fsm indicates correctable but the
                               failed device doesnt match the one identified by
                               BIOS. So we mark the result as UC
                            */
    UINT32 ecc_bist_errtype_upper : 2;

                            /* Bits[30:29], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the err type for the BIST result for
                               upper 32 byte for HBM mode. Valid only if
                               ecc_bist_valid field is true in the
                               retry_rd_err_log. BIST Result No Error = 2'b00
                               BIST Result Uncorrectable = 2'b01 BIST Result
                               Correctable = 2'b10 BIST Result Not Available
                               (req_length = 1) = 2'b11
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET3_LOG_MCDDC_DP_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 v : 1;

                            /* Bits[0:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               The contents of this register have valid data as
                               well as RETRY_RD_ERR_LOG_PARITY,
                               RETRY_RD_ERR_LOG_MISC,
                               RETRY_RD_ERR_LOG_ADDRESS1, and
                               RETRY_RD_ERR_LOG_ADDRESS2.
                            */
    UINT32 uc : 1;

                            /* Bits[1:1], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Uncorrectable error. Logs cannot be overwritten
                               while UC is set. This bit is not controlled by
                               MC, but by a lock indication from HA.
                            */
    UINT32 over : 1;

                            /* Bits[2:2], Access Type=RW/V/P, default=0x00000000*/

                            /* The log has been overwritten. */
    UINT32 mode : 4;

                            /* Bits[6:3], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               indicate the ecc mode the register is logging
                               for DDR mode: 4b0000 => sddc 2LM 4b0001 => sddc
                               1LM 4b0010 => sddc +1 2LM 4b0011 => sddc +1 1LM
                               4b0100 => adddc 2LM 4b0101 => adddc 1LM 4b0110
                               => adddc +1 2LM 4b0111 => adddc +1 1LM 4b1000 =>
                               read is from ddrt dimm 4b1011 => not a valid ecc
                               mode For HBM mode: 4b0001 => 64B read 4b1001 =>
                               32B read
                            */
    UINT32 corr_err : 1;

                            /* Bits[7:7], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but was
                               not able to correct hte error => DUE
                            */
    UINT32 corr_noerr : 1;

                            /* Bits[8:8], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but no
                               ecc error was detected
                            */
    UINT32 corr_correctable : 1;

                            /* Bits[9:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction and
                               detect a correctable ecc error and corrected
                            */
    UINT32 corr_correctable_par_dev : 1;

                            /* Bits[10:10], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction, error
                               was in parity device which consider a
                               correctable error
                            */
    UINT32 ecc_err : 1;

                            /* Bits[11:11], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, the ecc error indication
                               sent to m2m
                            */
    UINT32 patspr : 1;

                            /* Bits[12:12], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if we have logged a patrol/spare
                               error. If patspr=1 we have logged patrol/spare
                               error.
                            */
    UINT32 en_patspr : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /*
                               If en_patspr=1: Log patrol/sparing errors and
                               NOT demand/ufill reads; if en_patspr=0: Log
                               demand/ufill reads and NOT patrol/sparing.
                               Default is to log demand/ufill reads.
                            */
    UINT32 noover : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /*
                               Lock register after the first error, do not
                               overflow.
                            */
    UINT32 en : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000001*/

                            /* Enable error logging. Will log on every retry. */
    UINT32 col_correction : 1;

                            /* Bits[16:16], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This field indicate a column correction done
                               instead of the device correction and is only
                               valid for 1LM adddc mode (retry_rd_err_log.mode
                               = 4'b0101). In all other modes, this field
                               should be ignored.
                            */
    UINT32 single_bit_error : 1;

                            /* Bits[17:17], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if there was a single bit correction -
                               SDDC and SDDC +1 modes, used in PCLS
                            */
    UINT32 rsvd : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET3_LOG_MCDDC_DP_STRUCT;

/* DENGATEHEALTHCNTR_N0_MCDDC_DP_REG supported on:                              */
/*      SPRA0 (0x20022c78)                                                      */
/*      SPRB0 (0x20022c78)                                                      */
/*      SPRHBM (0x20022c78)                                                     */
/*      SPRC0 (0x20022c78)                                                      */
/*      SPRMCC (0x20022c78)                                                     */
/*      SPRUCC (0x20022c78)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register is a dengate counter.  Software can both read it and write it.
*/


#define DENGATEHEALTHCNTR_N0_MCDDC_DP_REG 0x0B122C78

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 res_enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               If 1, this counter will count. If 0, it will
                               not.
                            */
    UINT32 value : 31;

                            /* Bits[31:1], Access Type=RW/V, default=0x00000000*/

                            /*
                               note: even if this filed is marked as rw-lv, it
                               is is rw_lb_v but there is no such thing
                               supported by critter. This is the current value
                               of the counter. In native ddr4 mode, this value
                               is important in each channel that is not fused
                               off. In Intel LINK 2 mode, channels 1 and 3
                               values in each MC should be ignored. This is a
                               saturating counter.
                            */

  } Bits;
  UINT32 Data;

} DENGATEHEALTHCNTR_N0_MCDDC_DP_STRUCT;

/* DENGATEHEALTHCNTR_N1_MCDDC_DP_REG supported on:                              */
/*      SPRA0 (0x20022c7c)                                                      */
/*      SPRB0 (0x20022c7c)                                                      */
/*      SPRHBM (0x20022c7c)                                                     */
/*      SPRC0 (0x20022c7c)                                                      */
/*      SPRMCC (0x20022c7c)                                                     */
/*      SPRUCC (0x20022c7c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register is a dengate counter.  Software can both read it and write it.
*/


#define DENGATEHEALTHCNTR_N1_MCDDC_DP_REG 0x0B122C7C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 value : 5;

                            /* Bits[4:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               note: even if this filed is marked as rw-lv, it
                               is is rw_lb_v but there is no such thing
                               supported by critter. This is the current value
                               of the counter. In native ddr4 mode, this value
                               is important in each channel that is not fused
                               off. In Intel LINK 2 mode, channels 1 and 3
                               values in each MC should be ignored. This is a
                               saturating counter.
                            */
    UINT32 event_select : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               If 1, this counter will count clocks (for
                               testability only); if 0, this counter will count
                               number of clocks we spend time handling Intel
                               LINK 2 errors or ddr4 Command/Address parity
                               error.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DENGATEHEALTHCNTR_N1_MCDDC_DP_STRUCT;

/* MR_READ_RESULT_DQ12TO0_MCDDC_DP_REG supported on:                            */
/*      SPRA0 (0x20022c80)                                                      */
/*      SPRB0 (0x20022c80)                                                      */
/*      SPRHBM (0x20022c80)                                                     */
/*      SPRC0 (0x20022c80)                                                      */
/*      SPRMCC (0x20022c80)                                                     */
/*      SPRUCC (0x20022c80)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* saves information from last Mode Register read
*/


#define MR_READ_RESULT_DQ12TO0_MCDDC_DP_REG 0x0B122C80

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dq : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               For by 8 parts: device 0 result:
                               MR_READ_RESULT_DQ12TO0[7:0] device 1 result:
                               MR_READ_RESULT_DQ12TO0[23:16] For by 4 parts:
                               device 0 result: MR_READ_RESULT_DQ12TO0[7:0]
                               device 1 result: MR_READ_RESULT_DQ12TO0[15:8]
                               device 2 result: MR_READ_RESULT_DQ12TO0[23:16]
                               device 3 result: MR_READ_RESULT_DQ12TO0[31:24]
                            */

  } Bits;
  UINT32 Data;

} MR_READ_RESULT_DQ12TO0_MCDDC_DP_STRUCT;

/* MR_READ_RESULT_DQ28TO16_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x20022c84)                                                      */
/*      SPRB0 (0x20022c84)                                                      */
/*      SPRHBM (0x20022c84)                                                     */
/*      SPRC0 (0x20022c84)                                                      */
/*      SPRMCC (0x20022c84)                                                     */
/*      SPRUCC (0x20022c84)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* saves information from last Mode Register read
*/


#define MR_READ_RESULT_DQ28TO16_MCDDC_DP_REG 0x0B122C84

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dq : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               For by 8 parts: device 2 result:
                               MR_READ_RESULT_DQ28TO16[7:0] device 3 result:
                               MR_READ_RESULT_DQ28TO16[23:16] For by 4 parts:
                               device 4 result: MR_READ_RESULT_DQ28TO16[7:0]
                               device 5 result: MR_READ_RESULT_DQ28TO16[15:8]
                               device 6 result: MR_READ_RESULT_DQ28TO16[23:16]
                               device 7 result: MR_READ_RESULT_DQ28TO16[31:24]
                            */

  } Bits;
  UINT32 Data;

} MR_READ_RESULT_DQ28TO16_MCDDC_DP_STRUCT;

/* MR_READ_RESULT_DQ44TO32_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x20022c88)                                                      */
/*      SPRB0 (0x20022c88)                                                      */
/*      SPRHBM (0x20022c88)                                                     */
/*      SPRC0 (0x20022c88)                                                      */
/*      SPRMCC (0x20022c88)                                                     */
/*      SPRUCC (0x20022c88)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* saves information from last Mode Register read
*/


#define MR_READ_RESULT_DQ44TO32_MCDDC_DP_REG 0x0B122C88

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dq : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               For by 8 parts: device 4 result:
                               MR_READ_RESULT_DQ44TO32[7:0] device 5 result:
                               MR_READ_RESULT_DQ44TO32[23:16] For by 4 parts:
                               device 8 result: MR_READ_RESULT_DQ44TO32[7:0]
                               device 9 result: MR_READ_RESULT_DQ44TO32[15:8]
                               device 10 result: MR_READ_RESULT_DQ44TO32[23:16]
                               device 11 result: MR_READ_RESULT_DQ44TO32[31:24]
                            */

  } Bits;
  UINT32 Data;

} MR_READ_RESULT_DQ44TO32_MCDDC_DP_STRUCT;

/* MR_READ_RESULT_DQ60TO48_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x20022c8c)                                                      */
/*      SPRB0 (0x20022c8c)                                                      */
/*      SPRHBM (0x20022c8c)                                                     */
/*      SPRC0 (0x20022c8c)                                                      */
/*      SPRMCC (0x20022c8c)                                                     */
/*      SPRUCC (0x20022c8c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* saves information from last Mode Register read
*/


#define MR_READ_RESULT_DQ60TO48_MCDDC_DP_REG 0x0B122C8C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dq : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               For by 8 parts: device 6 result:
                               MR_READ_RESULT_DQ60To48[7:0] device 7 result:
                               MR_READ_RESULT_DQ60To48[23:16] For by 4 parts:
                               device 12 result: MR_READ_RESULT_DQ60To48[7:0]
                               device 13 result: MR_READ_RESULT_DQ60To48[15:8]
                               device 14 result: MR_READ_RESULT_DQ60To48[23:16]
                               device 15 result: MR_READ_RESULT_DQ60To48[31:24]
                            */

  } Bits;
  UINT32 Data;

} MR_READ_RESULT_DQ60TO48_MCDDC_DP_STRUCT;

/* MR_READ_RESULT_DQ68TO64_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x20022c90)                                                      */
/*      SPRB0 (0x20022c90)                                                      */
/*      SPRHBM (0x20022c90)                                                     */
/*      SPRC0 (0x20022c90)                                                      */
/*      SPRMCC (0x20022c90)                                                     */
/*      SPRUCC (0x20022c90)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* saves information from last Mode Register read
*/


#define MR_READ_RESULT_DQ68TO64_MCDDC_DP_REG 0x0B122C90

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dq : 16;

                            /* Bits[15:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               For by 8 parts: device 8 result:
                               MR_READ_RESULT_DQ68TO64[7:0] For by 4 parts:
                               device 16 result: MR_READ_RESULT_DQ68TO64[7:0]
                               device 17 result: MR_READ_RESULT_DQ68TO64[15:8]
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MR_READ_RESULT_DQ68TO64_MCDDC_DP_STRUCT;

/* MCSCRAMBLECONFIG_MCDDC_DP_REG supported on:                                  */
/*      SPRA0 (0x20022c9c)                                                      */
/*      SPRB0 (0x20022c9c)                                                      */
/*      SPRHBM (0x20022c9c)                                                     */
/*      SPRC0 (0x20022c9c)                                                      */
/*      SPRMCC (0x20022c9c)                                                     */
/*      SPRUCC (0x20022c9c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register is used to scramble and unscramble the IMC to DDR Pad data using the DDR command address and the scramble seed. All the fields CH_ENABLE, TX_ENABLE and RX_ENABLE must be set to 1 to enable scrambling, and must be cleared to disable scrambling. This is also used for HBM scrambling
*/


#define MCSCRAMBLECONFIG_MCDDC_DP_REG 0x0B122C9C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tx_enable : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /* TX_ENABLE: DDR4 Tx data bus scrambling. */
    UINT32 rx_enable : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /* RX_ENABLE: DDR4 Rx data bus scrambling. */
    UINT32 ch_enable : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /* Channel enable */
    UINT32 seed_lock : 1;

                            /* Bits[3:3], Access Type=RW/O/P, default=0x00000000*/

                            /*
                               lock bit for the seed update. 1b = lock 0b =
                               unlock
                            */
    UINT32 rsvd : 3;

                            /* Bits[6:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tx_enable_ddrt : 1;

                            /* Bits[7:7], Access Type=RW/P, default=0x00000000*/

                            /* TX_ENABLE: DDR-T Tx data bus scrambling. */
    UINT32 rx_enable_ddrt : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /* RX_ENABLE: DDR-T Rx data bus scrambling. */
    UINT32 ch_enable_ddrt : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /* DDRT Channel enable */
    UINT32 scr_dis_rank : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000000*/

                            /* Disable rank from scramble seed. */
    UINT32 rsvd_11 : 21;

                            /* Bits[31:11], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCSCRAMBLECONFIG_MCDDC_DP_STRUCT;

/* MCSCRAMBLE_SEED_SEL_MCDDC_DP_REG supported on:                               */
/*      SPRA0 (0x20022ca0)                                                      */
/*      SPRB0 (0x20022ca0)                                                      */
/*      SPRHBM (0x20022ca0)                                                     */
/*      SPRC0 (0x20022ca0)                                                      */
/*      SPRMCC (0x20022ca0)                                                     */
/*      SPRUCC (0x20022ca0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register is locked by SEED_LOCK bit in MCSCRAMBLECONFIG register.
*/


#define MCSCRAMBLE_SEED_SEL_MCDDC_DP_REG 0x0B122CA0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 scrb_lower_seed_sel : 16;

                            /* Bits[15:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Reordering the lower srambling seed select
                               control.
                            */
    UINT32 scrb_upper_seed_sel : 16;

                            /* Bits[31:16], Access Type=RW/P, default=0x00000000*/

                            /*
                               Reordering the upper srambling seed select
                               control.
                            */

  } Bits;
  UINT32 Data;

} MCSCRAMBLE_SEED_SEL_MCDDC_DP_STRUCT;

/* MCSCRAMBLE_SEED_SEL_DDRT_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x20022ca4)                                                      */
/*      SPRB0 (0x20022ca4)                                                      */
/*      SPRHBM (0x20022ca4)                                                     */
/*      SPRC0 (0x20022ca4)                                                      */
/*      SPRMCC (0x20022ca4)                                                     */
/*      SPRUCC (0x20022ca4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register is locked by SEED_LOCK bit in MCSCRAMBLECONFIG register.
*/


#define MCSCRAMBLE_SEED_SEL_DDRT_MCDDC_DP_REG 0x0B122CA4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 scrb_lower_seed_sel_ddrt : 16;

                            /* Bits[15:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Reordering the lower srambling seed select
                               control.
                            */
    UINT32 scrb_upper_seed_sel_ddrt : 16;

                            /* Bits[31:16], Access Type=RW/P, default=0x00000000*/

                            /*
                               Reordering the upper srambling seed select
                               control.
                            */

  } Bits;
  UINT32 Data;

} MCSCRAMBLE_SEED_SEL_DDRT_MCDDC_DP_STRUCT;

/* MCSCRAMBLE_RX_SEED_DDRT_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x20022ca8)                                                      */
/*      SPRB0 (0x20022ca8)                                                      */
/*      SPRHBM (0x20022ca8)                                                     */
/*      SPRC0 (0x20022ca8)                                                      */
/*      SPRMCC (0x20022ca8)                                                     */
/*      SPRUCC (0x20022ca8)                                                     */
/* Register default value on SPRA0: 0x0000FFFF                                  */
/* Register default value on SPRB0: 0x0000FFFF                                  */
/* Register default value on SPRHBM: 0x0000FFFF                                 */
/* Register default value on SPRC0: 0x0000FFFF                                  */
/* Register default value on SPRMCC: 0x0000FFFF                                 */
/* Register default value on SPRUCC: 0x0000FFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT Rx Data Scrambler Initial Seed. This register is locked by SEED_LOCK bit in MCSCRAMBLECONFIG register.
*/


#define MCSCRAMBLE_RX_SEED_DDRT_MCDDC_DP_REG 0x0B122CA8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 seed : 16;

                            /* Bits[15:0], Access Type=RW/P, default=0x0000FFFF*/

                            /*
                               DDRT Rx descramble seed. This seed is loaded at
                               reset de-assertion and is the default seed that
                               MC uses to unscramble DDRT read data. If a
                               different seed needs to be loaded, then it needs
                               to be done under quiesce. CSRs in FNV and SKX
                               should be loaded with the new seed and DDRT
                               Error FSM should be triggered using CSR bit
                               DDRT_RETRY_CTL.trigger_retry
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCSCRAMBLE_RX_SEED_DDRT_MCDDC_DP_STRUCT;

/* CMPL_TO_DATA_DELAY_MCDDC_DP_REG supported on:                                */
/*      SPRA0 (0x20022cb0)                                                      */
/*      SPRB0 (0x20022cb0)                                                      */
/*      SPRHBM (0x20022cb0)                                                     */
/*      SPRC0 (0x20022cb0)                                                      */
/*      SPRMCC (0x20022cb0)                                                     */
/*      SPRUCC (0x20022cb0)                                                     */
/* Register default value on SPRA0: 0x006A0100                                  */
/* Register default value on SPRB0: 0x006A0100                                  */
/* Register default value on SPRHBM: 0x006A0100                                 */
/* Register default value on SPRC0: 0x006A0100                                  */
/* Register default value on SPRMCC: 0x006A0100                                 */
/* Register default value on SPRUCC: 0x006A0100                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Control the delay between command completion and data completion.
*/


#define CMPL_TO_DATA_DELAY_MCDDC_DP_REG 0x0B122CB0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmpl_program_delay : 4;

                            /* Bits[7:4], Access Type=RW, default=0x00000000*/

                            /*
                               Program the delay between command and data
                               completion in number of dclk. For DDR4, DDR5,
                               DDRT, DDRT2, the value can be 4, 6, or 8. For
                               HBM, only value for 4 can be used. All other
                               values are reserved. For DDRT on SPR, the
                               formula to generate this value depends on
                               gnt2erid CSR value - if(gnt2erid is even)
                               (((roundtrip_delay-gnt2erid)-1)/2 )*2-2 else
                               (gnt2erid is odd) (((roundtrip_delay-
                               gnt2erid)+1)/2 )*2-2
                            */
    UINT32 data_return_blk_norm : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000001*/

                            /*
                               Time to block subsequent data return after start
                               of non-retry data transfer; default value is 1
                               to data return 2 cycles apart. For 32B
                               interleave mode for DDR5, set to 0 to support
                               data return every cycle. The value from this
                               register field is only used when
                               data_return_blk_norm_override_en is set 1;
                               otherwise, hardware default is taken (0 for 32B
                               interleave mode and 1 for all other cases).
                            */
    UINT32 data_return_blk_retry : 5;

                            /* Bits[17:13], Access Type=RW, default=0x00000010*/

                            /*
                               Time to block subsequent data return after start
                               of retry data transfer; block time should allow
                               correction to start
                            */
    UINT32 spare_rank_diff : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /* Reserved; keep this bit at 0. */
    UINT32 rd_data_vld_dly : 6;

                            /* Bits[24:19], Access Type=RW, default=0x0000000D*/

                            /*
                               Delay (in number of hclk) to read CAS to align
                               with read data on IO interface; used for
                               reseting DBI in HBM mode
                            */
    UINT32 rsvd_25 : 6;

                            /* Bits[30:25], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 data_return_blk_norm_override_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, data_return_blk_norm is used;
                               otherwise, hardware default is taken for data
                               return spacing (0 for 32B interleave mode and 1
                               for all other cases).
                            */

  } Bits;
  UINT32 Data;

} CMPL_TO_DATA_DELAY_MCDDC_DP_STRUCT;

/* DDRT_FNV_INTR_CTL_MCDDC_DP_REG supported on:                                 */
/*      SPRA0 (0x20022cb8)                                                      */
/*      SPRB0 (0x20022cb8)                                                      */
/*      SPRHBM (0x20022cb8)                                                     */
/*      SPRC0 (0x20022cb8)                                                      */
/*      SPRMCC (0x20022cb8)                                                     */
/*      SPRUCC (0x20022cb8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Delay for DDRT
      
*/


#define DDRT_FNV_INTR_CTL_MCDDC_DP_REG 0x0B122CB8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 slot0_lo_smi_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Enable SMI signalling for DDRT Lo priority
                               interrupt from Slot 0
                            */
    UINT32 slot1_lo_smi_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Enable SMI signalling for DDRT Lo priority
                               interrupt from Slot 0
                            */
    UINT32 slot0_hi_smi_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enable SMI signalling for DDRT Lo priority
                               interrupt from Slot 0
                            */
    UINT32 slot1_hi_smi_en : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Enable SMI signalling for DDRT Lo priority
                               interrupt from Slot 0
                            */
    UINT32 slot0_lo_err0_en : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Enable ERR0 signalling for DDRT Lo priority
                               interrupt from Slot 0
                            */
    UINT32 slot1_lo_err0_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable ERR0 signalling for DDRT Lo priority
                               interrupt from Slot 0
                            */
    UINT32 slot0_hi_err0_en : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Enable ERR0 signalling for DDRT Lo priority
                               interrupt from Slot 0
                            */
    UINT32 slot1_hi_err0_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Enable ERR0 signalling for DDRT Lo priority
                               interrupt from Slot 0
                            */
    UINT32 dis_fast_zero : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* Disable fast zero assertion for ddrt2 */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_FNV_INTR_CTL_MCDDC_DP_STRUCT;

/* X4MODESEL_MCDDC_DP_REG supported on:                                         */
/*      SPRA0 (0x20022cbc)                                                      */
/*      SPRB0 (0x20022cbc)                                                      */
/*      SPRHBM (0x20022cbc)                                                     */
/*      SPRC0 (0x20022cbc)                                                      */
/*      SPRMCC (0x20022cbc)                                                     */
/*      SPRUCC (0x20022cbc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* x4ModelSel - MCDP x4 Mode Select
*/


#define X4MODESEL_MCDDC_DP_REG 0x0B122CBC

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dimm0_mode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Controls the DDRIO x4 (if set) / x8 (if cleared)
                               DIMM0 DQS select.
                            */
    UINT32 dimm1_mode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Controls the DDRIO x4 (if set) / x8 (if cleared)
                               DIMM1 DQS select.
                            */
    UINT32 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 enable_esddc : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to enable enhanced SDDC mode
                               for DDR5. 1: enable; 0: disable
                            */
    UINT32 rsvd_4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} X4MODESEL_MCDDC_DP_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dimm0_mode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Controls the DDRIO x4 (if set) / x8 (if cleared)
                               DIMM0 DQS select.
                            */
    UINT32 dimm1_mode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Controls the DDRIO x4 (if set) / x8 (if cleared)
                               DIMM1 DQS select.
                            */
    UINT32 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 enable_esddc : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to enable enhanced SDDC mode
                               for DDR5. 1: enable; 0: disable
                            */
    UINT32 enable_nsddc : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to enable 96b SDDC mode for
                               DDR5 or new SDDC mode for 9x4 DIMM. 1: enable;
                               0: disable
                            */
    UINT32 rsvd_5 : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} X4MODESEL_MCDDC_DP_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dimm0_mode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Controls the DDRIO x4 (if set) / x8 (if cleared)
                               DIMM0 DQS select.
                            */
    UINT32 dimm1_mode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Controls the DDRIO x4 (if set) / x8 (if cleared)
                               DIMM1 DQS select.
                            */
    UINT32 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 enable_esddc : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to enable enhanced SDDC mode
                               for DDR5. 1: enable; 0: disable
                            */
    UINT32 enable_nsddc : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to enable 96b SDDC mode for
                               DDR5 or new SDDC mode for 9x4 DIMM. 1: enable;
                               0: disable
                            */
    UINT32 enable_nadddc : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to enable 96b SDDC mode for
                               DDR5 or new SDDC mode for 9x4 DIMM. 1: enable;
                               0: disable
                            */
    UINT32 rsvd_6 : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} X4MODESEL_MCDDC_DP_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dimm0_mode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Controls the DDRIO x4 (if set) / x8 (if cleared)
                               DIMM0 DQS select.
                            */
    UINT32 dimm1_mode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Controls the DDRIO x4 (if set) / x8 (if cleared)
                               DIMM1 DQS select.
                            */
    UINT32 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 enable_esddc : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to enable enhanced SDDC mode
                               for DDR5. 1: enable; 0: disable
                            */
    UINT32 rsvd_4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} X4MODESEL_MCDDC_DP_STRUCT;

/* CORRECTION_DEBUG_DEV_VEC_1_MCDDC_DP_REG supported on:                        */
/*      SPRA0 (0x20022cc0)                                                      */
/*      SPRB0 (0x20022cc0)                                                      */
/*      SPRHBM (0x20022cc0)                                                     */
/*      SPRC0 (0x20022cc0)                                                      */
/*      SPRMCC (0x20022cc0)                                                     */
/*      SPRUCC (0x20022cc0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* this register hold extra correction debug. it hold the vecotr for failed device number.
		    it should be a one-hot vector for the device number.
		    it is a DUE case if more than one device is set. 
                    the contents of this register are valid with RETRY_RD_ERR_LOG
*/


#define CORRECTION_DEBUG_DEV_VEC_1_MCDDC_DP_REG 0x0B122CC0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sddc : 18;

                            /* Bits[17:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               sddc device: 0-15 data device, dev16
                               metadata/locator device, dev17 parity device
                            */
    UINT32 adddc_1st : 14;

                            /* Bits[31:18], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               adddc device 1st half: 0-15 data device, and
                               dev16 metadata device. (dev 17 is not included
                               since it is the spare dev) only 14 bits (data
                               device 0-13) in this register the rest in
                               correction_debug_dev_vec_2 register
                            */

  } Bits;
  UINT32 Data;

} CORRECTION_DEBUG_DEV_VEC_1_MCDDC_DP_STRUCT;

/* CORRECTION_DEBUG_DEV_VEC_2_MCDDC_DP_REG supported on:                        */
/*      SPRA0 (0x20022cc4)                                                      */
/*      SPRB0 (0x20022cc4)                                                      */
/*      SPRHBM (0x20022cc4)                                                     */
/*      SPRC0 (0x20022cc4)                                                      */
/*      SPRMCC (0x20022cc4)                                                     */
/*      SPRUCC (0x20022cc4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* this register hold extra correction debug. it hold the vecotr for failed device number.
		    it should be a one-hot vector for the device number.
		    it is a DUE case if more than one device is set. 
                    the contents of this register are valid with RETRY_RD_ERR_LOG
*/


#define CORRECTION_DEBUG_DEV_VEC_2_MCDDC_DP_REG 0x0B122CC4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 adddc_1st : 3;

                            /* Bits[2:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               adddc device 1st half: 0-15 data device, dev16
                               metadata device. (dev 17 is not included since
                               it is the spare dev) data device 0-13 in
                               correction_debug_dev_vec_1 register this
                               register holds data device 14-15, and metadata
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 adddc_2nd : 18;

                            /* Bits[21:4], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               adddc device 2nd half: 0-15 data device (device
                               18-33), dev16 locator device(dev34), dev17
                               parity device(dev35)
                            */
    UINT32 rsvd_22 : 10;

                            /* Bits[31:22], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CORRECTION_DEBUG_DEV_VEC_2_MCDDC_DP_STRUCT;

/* CORRECTION_DEBUG_CORR_DATA_MCDDC_DP_REG supported on:                        */
/*      SPRA0 (0x20022ccc)                                                      */
/*      SPRB0 (0x20022ccc)                                                      */
/*      SPRHBM (0x20022ccc)                                                     */
/*      SPRC0 (0x20022ccc)                                                      */
/*      SPRMCC (0x20022ccc)                                                     */
/*      SPRUCC (0x20022ccc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* this register hold extra correction debug. it hold the accumulated data before it goes to correction logic
                   512 bits of data + 32 bit ecc data. the data is copied first to this register first over 16 writes
                   and then the ecc bits over 1 writes. for the total of 17 writes. 
		   correction_debug_corr_data_cntl register control the read and write to this register
                   the contents of this register are valid with RETRY_RD_ERR_LOG
*/


#define CORRECTION_DEBUG_CORR_DATA_MCDDC_DP_REG 0x0B122CCC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 accum_data : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               accumulated data before it gets corrected. 512
                               bit data + 32 ecc data write to this field over
                               17 writes
                            */

  } Bits;
  UINT32 Data;

} CORRECTION_DEBUG_CORR_DATA_MCDDC_DP_STRUCT;

/* DDR4_WRCRC2_DQ15_DQ0_MCDDC_DP_REG supported on:                              */
/*      SPRA0 (0x20022cd0)                                                      */
/*      SPRB0 (0x20022cd0)                                                      */
/*      SPRHBM (0x20022cd0)                                                     */
/*      SPRC0 (0x20022cd0)                                                      */
/*      SPRMCC (0x20022cd0)                                                     */
/*      SPRUCC (0x20022cd0)                                                     */
/* Register default value on SPRA0: 0xE4E4E4E4                                  */
/* Register default value on SPRB0: 0xE4E4E4E4                                  */
/* Register default value on SPRHBM: 0xE4E4E4E4                                 */
/* Register default value on SPRC0: 0xE4E4E4E4                                  */
/* Register default value on SPRMCC: 0xE4E4E4E4                                 */
/* Register default value on SPRUCC: 0xE4E4E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 2; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC2_DQ15_DQ0_MCDDC_DP_REG 0x0B122CD0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 swizzle_ctl : 32;

                            /* Bits[31:0], Access Type=RW, default=0xE4E4E4E4*/

                            /*
                               Swizzling for DQ Bits 15 to 0. 2 CSR bits per DQ
                               lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC2_DQ15_DQ0_MCDDC_DP_STRUCT;

/* DDR4_WRCRC2_DQ31_DQ16_MCDDC_DP_REG supported on:                             */
/*      SPRA0 (0x20022cd4)                                                      */
/*      SPRB0 (0x20022cd4)                                                      */
/*      SPRHBM (0x20022cd4)                                                     */
/*      SPRC0 (0x20022cd4)                                                      */
/*      SPRMCC (0x20022cd4)                                                     */
/*      SPRUCC (0x20022cd4)                                                     */
/* Register default value on SPRA0: 0xE4E4E4E4                                  */
/* Register default value on SPRB0: 0xE4E4E4E4                                  */
/* Register default value on SPRHBM: 0xE4E4E4E4                                 */
/* Register default value on SPRC0: 0xE4E4E4E4                                  */
/* Register default value on SPRMCC: 0xE4E4E4E4                                 */
/* Register default value on SPRUCC: 0xE4E4E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 2; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC2_DQ31_DQ16_MCDDC_DP_REG 0x0B122CD4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 swizzle_ctl : 32;

                            /* Bits[31:0], Access Type=RW, default=0xE4E4E4E4*/

                            /*
                               Swizzling for DQ Bits 31 to 16. 2 CSR bits per
                               DQ lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC2_DQ31_DQ16_MCDDC_DP_STRUCT;

/* DDR4_WRCRC2_DQ47_DQ32_MCDDC_DP_REG supported on:                             */
/*      SPRA0 (0x20022cd8)                                                      */
/*      SPRB0 (0x20022cd8)                                                      */
/*      SPRHBM (0x20022cd8)                                                     */
/*      SPRC0 (0x20022cd8)                                                      */
/*      SPRMCC (0x20022cd8)                                                     */
/*      SPRUCC (0x20022cd8)                                                     */
/* Register default value on SPRA0: 0xE4E4E4E4                                  */
/* Register default value on SPRB0: 0xE4E4E4E4                                  */
/* Register default value on SPRHBM: 0xE4E4E4E4                                 */
/* Register default value on SPRC0: 0xE4E4E4E4                                  */
/* Register default value on SPRMCC: 0xE4E4E4E4                                 */
/* Register default value on SPRUCC: 0xE4E4E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 2; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC2_DQ47_DQ32_MCDDC_DP_REG 0x0B122CD8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 swizzle_ctl : 32;

                            /* Bits[31:0], Access Type=RW, default=0xE4E4E4E4*/

                            /*
                               Swizzling for DQ Bits 47 to 32. 2 CSR bits per
                               DQ lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC2_DQ47_DQ32_MCDDC_DP_STRUCT;

/* DDR4_WRCRC2_DQ63_DQ48_MCDDC_DP_REG supported on:                             */
/*      SPRA0 (0x20022cdc)                                                      */
/*      SPRB0 (0x20022cdc)                                                      */
/*      SPRHBM (0x20022cdc)                                                     */
/*      SPRC0 (0x20022cdc)                                                      */
/*      SPRMCC (0x20022cdc)                                                     */
/*      SPRUCC (0x20022cdc)                                                     */
/* Register default value on SPRA0: 0xE4E4E4E4                                  */
/* Register default value on SPRB0: 0xE4E4E4E4                                  */
/* Register default value on SPRHBM: 0xE4E4E4E4                                 */
/* Register default value on SPRC0: 0xE4E4E4E4                                  */
/* Register default value on SPRMCC: 0xE4E4E4E4                                 */
/* Register default value on SPRUCC: 0xE4E4E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 2; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC2_DQ63_DQ48_MCDDC_DP_REG 0x0B122CDC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 swizzle_ctl : 32;

                            /* Bits[31:0], Access Type=RW, default=0xE4E4E4E4*/

                            /*
                               Swizzling for DQ Bits 63 to 48. 2 CSR bits per
                               DQ lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC2_DQ63_DQ48_MCDDC_DP_STRUCT;

/* DDR4_WRCRC3_DQ15_DQ0_MCDDC_DP_REG supported on:                              */
/*      SPRA0 (0x20022ce4)                                                      */
/*      SPRB0 (0x20022ce4)                                                      */
/*      SPRHBM (0x20022ce4)                                                     */
/*      SPRC0 (0x20022ce4)                                                      */
/*      SPRMCC (0x20022ce4)                                                     */
/*      SPRUCC (0x20022ce4)                                                     */
/* Register default value on SPRA0: 0xE4E4E4E4                                  */
/* Register default value on SPRB0: 0xE4E4E4E4                                  */
/* Register default value on SPRHBM: 0xE4E4E4E4                                 */
/* Register default value on SPRC0: 0xE4E4E4E4                                  */
/* Register default value on SPRMCC: 0xE4E4E4E4                                 */
/* Register default value on SPRUCC: 0xE4E4E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 3; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC3_DQ15_DQ0_MCDDC_DP_REG 0x0B122CE4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 swizzle_ctl : 32;

                            /* Bits[31:0], Access Type=RW, default=0xE4E4E4E4*/

                            /*
                               Swizzling for DQ Bits 15 to 0. 2 CSR bits per DQ
                               lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC3_DQ15_DQ0_MCDDC_DP_STRUCT;

/* DDR4_WRCRC3_DQ31_DQ16_MCDDC_DP_REG supported on:                             */
/*      SPRA0 (0x20022ce8)                                                      */
/*      SPRB0 (0x20022ce8)                                                      */
/*      SPRHBM (0x20022ce8)                                                     */
/*      SPRC0 (0x20022ce8)                                                      */
/*      SPRMCC (0x20022ce8)                                                     */
/*      SPRUCC (0x20022ce8)                                                     */
/* Register default value on SPRA0: 0xE4E4E4E4                                  */
/* Register default value on SPRB0: 0xE4E4E4E4                                  */
/* Register default value on SPRHBM: 0xE4E4E4E4                                 */
/* Register default value on SPRC0: 0xE4E4E4E4                                  */
/* Register default value on SPRMCC: 0xE4E4E4E4                                 */
/* Register default value on SPRUCC: 0xE4E4E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 3; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC3_DQ31_DQ16_MCDDC_DP_REG 0x0B122CE8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 swizzle_ctl : 32;

                            /* Bits[31:0], Access Type=RW, default=0xE4E4E4E4*/

                            /*
                               Swizzling for DQ Bits 31 to 16. 2 CSR bits per
                               DQ lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC3_DQ31_DQ16_MCDDC_DP_STRUCT;

/* DDR4_WRCRC3_DQ47_DQ32_MCDDC_DP_REG supported on:                             */
/*      SPRA0 (0x20022cec)                                                      */
/*      SPRB0 (0x20022cec)                                                      */
/*      SPRHBM (0x20022cec)                                                     */
/*      SPRC0 (0x20022cec)                                                      */
/*      SPRMCC (0x20022cec)                                                     */
/*      SPRUCC (0x20022cec)                                                     */
/* Register default value on SPRA0: 0xE4E4E4E4                                  */
/* Register default value on SPRB0: 0xE4E4E4E4                                  */
/* Register default value on SPRHBM: 0xE4E4E4E4                                 */
/* Register default value on SPRC0: 0xE4E4E4E4                                  */
/* Register default value on SPRMCC: 0xE4E4E4E4                                 */
/* Register default value on SPRUCC: 0xE4E4E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 3; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC3_DQ47_DQ32_MCDDC_DP_REG 0x0B122CEC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 swizzle_ctl : 32;

                            /* Bits[31:0], Access Type=RW, default=0xE4E4E4E4*/

                            /*
                               Swizzling for DQ Bits 47 to 32. 2 CSR bits per
                               DQ lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC3_DQ47_DQ32_MCDDC_DP_STRUCT;

/* DDR4_WRCRC3_DQ63_DQ48_MCDDC_DP_REG supported on:                             */
/*      SPRA0 (0x20022cf0)                                                      */
/*      SPRB0 (0x20022cf0)                                                      */
/*      SPRHBM (0x20022cf0)                                                     */
/*      SPRC0 (0x20022cf0)                                                      */
/*      SPRMCC (0x20022cf0)                                                     */
/*      SPRUCC (0x20022cf0)                                                     */
/* Register default value on SPRA0: 0xE4E4E4E4                                  */
/* Register default value on SPRB0: 0xE4E4E4E4                                  */
/* Register default value on SPRHBM: 0xE4E4E4E4                                 */
/* Register default value on SPRC0: 0xE4E4E4E4                                  */
/* Register default value on SPRMCC: 0xE4E4E4E4                                 */
/* Register default value on SPRUCC: 0xE4E4E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 3; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC3_DQ63_DQ48_MCDDC_DP_REG 0x0B122CF0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 swizzle_ctl : 32;

                            /* Bits[31:0], Access Type=RW, default=0xE4E4E4E4*/

                            /*
                               Swizzling for DQ Bits 63 to 48. 2 CSR bits per
                               DQ lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC3_DQ63_DQ48_MCDDC_DP_STRUCT;

/* DDR4_WRCRC0_DQ15_DQ0_MCDDC_DP_REG supported on:                              */
/*      SPRA0 (0x20022cf8)                                                      */
/*      SPRB0 (0x20022cf8)                                                      */
/*      SPRHBM (0x20022cf8)                                                     */
/*      SPRC0 (0x20022cf8)                                                      */
/*      SPRMCC (0x20022cf8)                                                     */
/*      SPRUCC (0x20022cf8)                                                     */
/* Register default value on SPRA0: 0xE4E4E4E4                                  */
/* Register default value on SPRB0: 0xE4E4E4E4                                  */
/* Register default value on SPRHBM: 0xE4E4E4E4                                 */
/* Register default value on SPRC0: 0xE4E4E4E4                                  */
/* Register default value on SPRMCC: 0xE4E4E4E4                                 */
/* Register default value on SPRUCC: 0xE4E4E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 0; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC0_DQ15_DQ0_MCDDC_DP_REG 0x0B122CF8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 swizzle_ctl : 32;

                            /* Bits[31:0], Access Type=RW, default=0xE4E4E4E4*/

                            /*
                               Swizzling for DQ Bits 15 to 0. 2 CSR bits per DQ
                               lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC0_DQ15_DQ0_MCDDC_DP_STRUCT;

/* DDR4_WRCRC0_DQ31_DQ16_MCDDC_DP_REG supported on:                             */
/*      SPRA0 (0x20022cfc)                                                      */
/*      SPRB0 (0x20022cfc)                                                      */
/*      SPRHBM (0x20022cfc)                                                     */
/*      SPRC0 (0x20022cfc)                                                      */
/*      SPRMCC (0x20022cfc)                                                     */
/*      SPRUCC (0x20022cfc)                                                     */
/* Register default value on SPRA0: 0xE4E4E4E4                                  */
/* Register default value on SPRB0: 0xE4E4E4E4                                  */
/* Register default value on SPRHBM: 0xE4E4E4E4                                 */
/* Register default value on SPRC0: 0xE4E4E4E4                                  */
/* Register default value on SPRMCC: 0xE4E4E4E4                                 */
/* Register default value on SPRUCC: 0xE4E4E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 0; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC0_DQ31_DQ16_MCDDC_DP_REG 0x0B122CFC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 swizzle_ctl : 32;

                            /* Bits[31:0], Access Type=RW, default=0xE4E4E4E4*/

                            /*
                               Swizzling for DQ Bits 31 to 16. 2 CSR bits per
                               DQ lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC0_DQ31_DQ16_MCDDC_DP_STRUCT;

/* DDR4_WRCRC0_DQ47_DQ32_MCDDC_DP_REG supported on:                             */
/*      SPRA0 (0x20022d00)                                                      */
/*      SPRB0 (0x20022d00)                                                      */
/*      SPRHBM (0x20022d00)                                                     */
/*      SPRC0 (0x20022d00)                                                      */
/*      SPRMCC (0x20022d00)                                                     */
/*      SPRUCC (0x20022d00)                                                     */
/* Register default value on SPRA0: 0xE4E4E4E4                                  */
/* Register default value on SPRB0: 0xE4E4E4E4                                  */
/* Register default value on SPRHBM: 0xE4E4E4E4                                 */
/* Register default value on SPRC0: 0xE4E4E4E4                                  */
/* Register default value on SPRMCC: 0xE4E4E4E4                                 */
/* Register default value on SPRUCC: 0xE4E4E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 0; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC0_DQ47_DQ32_MCDDC_DP_REG 0x0B122D00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 swizzle_ctl : 32;

                            /* Bits[31:0], Access Type=RW, default=0xE4E4E4E4*/

                            /*
                               Swizzling for DQ Bits 47 to 32. 2 CSR bits per
                               DQ lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC0_DQ47_DQ32_MCDDC_DP_STRUCT;

/* DDR4_WRCRC0_DQ63_DQ48_MCDDC_DP_REG supported on:                             */
/*      SPRA0 (0x20022d04)                                                      */
/*      SPRB0 (0x20022d04)                                                      */
/*      SPRHBM (0x20022d04)                                                     */
/*      SPRC0 (0x20022d04)                                                      */
/*      SPRMCC (0x20022d04)                                                     */
/*      SPRUCC (0x20022d04)                                                     */
/* Register default value on SPRA0: 0xE4E4E4E4                                  */
/* Register default value on SPRB0: 0xE4E4E4E4                                  */
/* Register default value on SPRHBM: 0xE4E4E4E4                                 */
/* Register default value on SPRC0: 0xE4E4E4E4                                  */
/* Register default value on SPRMCC: 0xE4E4E4E4                                 */
/* Register default value on SPRUCC: 0xE4E4E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 0; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC0_DQ63_DQ48_MCDDC_DP_REG 0x0B122D04

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 swizzle_ctl : 32;

                            /* Bits[31:0], Access Type=RW, default=0xE4E4E4E4*/

                            /*
                               Swizzling for DQ Bits 63 to 48. 2 CSR bits per
                               DQ lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC0_DQ63_DQ48_MCDDC_DP_STRUCT;

/* DDR4_WRCRC1_DQ15_DQ0_MCDDC_DP_REG supported on:                              */
/*      SPRA0 (0x20022d0c)                                                      */
/*      SPRB0 (0x20022d0c)                                                      */
/*      SPRHBM (0x20022d0c)                                                     */
/*      SPRC0 (0x20022d0c)                                                      */
/*      SPRMCC (0x20022d0c)                                                     */
/*      SPRUCC (0x20022d0c)                                                     */
/* Register default value on SPRA0: 0xE4E4E4E4                                  */
/* Register default value on SPRB0: 0xE4E4E4E4                                  */
/* Register default value on SPRHBM: 0xE4E4E4E4                                 */
/* Register default value on SPRC0: 0xE4E4E4E4                                  */
/* Register default value on SPRMCC: 0xE4E4E4E4                                 */
/* Register default value on SPRUCC: 0xE4E4E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 1; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC1_DQ15_DQ0_MCDDC_DP_REG 0x0B122D0C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 swizzle_ctl : 32;

                            /* Bits[31:0], Access Type=RW, default=0xE4E4E4E4*/

                            /*
                               Swizzling for DQ Bits 15 to 0. 2 CSR bits per DQ
                               lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC1_DQ15_DQ0_MCDDC_DP_STRUCT;

/* DDR4_WRCRC1_DQ31_DQ16_MCDDC_DP_REG supported on:                             */
/*      SPRA0 (0x20022d10)                                                      */
/*      SPRB0 (0x20022d10)                                                      */
/*      SPRHBM (0x20022d10)                                                     */
/*      SPRC0 (0x20022d10)                                                      */
/*      SPRMCC (0x20022d10)                                                     */
/*      SPRUCC (0x20022d10)                                                     */
/* Register default value on SPRA0: 0xE4E4E4E4                                  */
/* Register default value on SPRB0: 0xE4E4E4E4                                  */
/* Register default value on SPRHBM: 0xE4E4E4E4                                 */
/* Register default value on SPRC0: 0xE4E4E4E4                                  */
/* Register default value on SPRMCC: 0xE4E4E4E4                                 */
/* Register default value on SPRUCC: 0xE4E4E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 1; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC1_DQ31_DQ16_MCDDC_DP_REG 0x0B122D10

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 swizzle_ctl : 32;

                            /* Bits[31:0], Access Type=RW, default=0xE4E4E4E4*/

                            /*
                               Swizzling for DQ Bits 31 to 16. 2 CSR bits per
                               DQ lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC1_DQ31_DQ16_MCDDC_DP_STRUCT;

/* DDR4_WRCRC1_DQ47_DQ32_MCDDC_DP_REG supported on:                             */
/*      SPRA0 (0x20022d14)                                                      */
/*      SPRB0 (0x20022d14)                                                      */
/*      SPRHBM (0x20022d14)                                                     */
/*      SPRC0 (0x20022d14)                                                      */
/*      SPRMCC (0x20022d14)                                                     */
/*      SPRUCC (0x20022d14)                                                     */
/* Register default value on SPRA0: 0xE4E4E4E4                                  */
/* Register default value on SPRB0: 0xE4E4E4E4                                  */
/* Register default value on SPRHBM: 0xE4E4E4E4                                 */
/* Register default value on SPRC0: 0xE4E4E4E4                                  */
/* Register default value on SPRMCC: 0xE4E4E4E4                                 */
/* Register default value on SPRUCC: 0xE4E4E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 1; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC1_DQ47_DQ32_MCDDC_DP_REG 0x0B122D14

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 swizzle_ctl : 32;

                            /* Bits[31:0], Access Type=RW, default=0xE4E4E4E4*/

                            /*
                               Swizzling for DQ Bits 47 to 32. 2 CSR bits per
                               DQ lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC1_DQ47_DQ32_MCDDC_DP_STRUCT;

/* DDR4_WRCRC1_DQ63_DQ48_MCDDC_DP_REG supported on:                             */
/*      SPRA0 (0x20022d18)                                                      */
/*      SPRB0 (0x20022d18)                                                      */
/*      SPRHBM (0x20022d18)                                                     */
/*      SPRC0 (0x20022d18)                                                      */
/*      SPRMCC (0x20022d18)                                                     */
/*      SPRUCC (0x20022d18)                                                     */
/* Register default value on SPRA0: 0xE4E4E4E4                                  */
/* Register default value on SPRB0: 0xE4E4E4E4                                  */
/* Register default value on SPRHBM: 0xE4E4E4E4                                 */
/* Register default value on SPRC0: 0xE4E4E4E4                                  */
/* Register default value on SPRMCC: 0xE4E4E4E4                                 */
/* Register default value on SPRUCC: 0xE4E4E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 1; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC1_DQ63_DQ48_MCDDC_DP_REG 0x0B122D18

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 swizzle_ctl : 32;

                            /* Bits[31:0], Access Type=RW, default=0xE4E4E4E4*/

                            /*
                               Swizzling for DQ Bits 63 to 48. 2 CSR bits per
                               DQ lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC1_DQ63_DQ48_MCDDC_DP_STRUCT;

/* DDR4_WRCRC_RANK_CTL_MCDDC_DP_REG supported on:                               */
/*      SPRA0 (0x20022d20)                                                      */
/*      SPRB0 (0x20022d88)                                                      */
/*      SPRHBM (0x20022d88)                                                     */
/*      SPRC0 (0x20022d88)                                                      */
/*      SPRMCC (0x20022d88)                                                     */
/*      SPRUCC (0x20022d88)                                                     */
/* Register default value on SPRA0: 0x03000000                                  */
/* Register default value on SPRB0: 0x03000000                                  */
/* Register default value on SPRHBM: 0x03000000                                 */
/* Register default value on SPRC0: 0x03000000                                  */
/* Register default value on SPRMCC: 0x03000000                                 */
/* Register default value on SPRUCC: 0x03000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control
*/


#define DDR4_WRCRC_RANK_CTL_MCDDC_DP_REG 0x0B1A0000

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rank0 : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /* DDR4 WR CRC mask to use for Rank0 */
    UINT32 rank1 : 2;

                            /* Bits[3:2], Access Type=RW, default=0x00000000*/

                            /* DDR4 WR CRC mask to use for Rank1 */
    UINT32 rank2 : 2;

                            /* Bits[5:4], Access Type=RW, default=0x00000000*/

                            /* DDR4 WR CRC mask to use for Rank2 */
    UINT32 rank3 : 2;

                            /* Bits[7:6], Access Type=RW, default=0x00000000*/

                            /* DDR4 WR CRC mask to use for Rank3 */
    UINT32 rank4 : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000000*/

                            /* DDR4 WR CRC mask to use for Rank4 */
    UINT32 rank5 : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /* DDR4 WR CRC mask to use for Rank5 */
    UINT32 rank6 : 2;

                            /* Bits[13:12], Access Type=RW, default=0x00000000*/

                            /* DDR4 WR CRC mask to use for Rank6 */
    UINT32 rank7 : 2;

                            /* Bits[15:14], Access Type=RW, default=0x00000000*/

                            /* DDR4 WR CRC mask to use for Rank7 */
    UINT32 cr_wrcrc_enable : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               1 = DDR4 write CRC is enabled 0 = DDR4 write CRC
                               is disabled
                            */
    UINT32 rsvd : 7;

                            /* Bits[23:17], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 err_log_sel : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000003*/

                            /*
                               Select the bit for WrCRC error log. Only used if
                               err_log_sel_override is 1.
                            */
    UINT32 err_log_sel_override : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, use err_log_sel to select the bit
                               for WrCRC error log.
                            */
    UINT32 rsvd_28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC_RANK_CTL_MCDDC_DP_STRUCT;

/* DIS_CORR_ERR_LOG_MCDDC_DP_REG supported on:                                  */
/*      SPRA0 (0x20022d24)                                                      */
/*      SPRB0 (0x20022d24)                                                      */
/*      SPRHBM (0x20022d24)                                                     */
/*      SPRC0 (0x20022d24)                                                      */
/*      SPRMCC (0x20022d24)                                                     */
/*      SPRUCC (0x20022d24)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* this register has one bit per rank to disable correctable error logging/signaling 
*/


#define DIS_CORR_ERR_LOG_MCDDC_DP_REG 0x0B122D24

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rank0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               disable correctable error logging/signaling for
                               Rank0
                            */
    UINT32 rank1 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               disable correctable error logging/signaling for
                               Rank1
                            */
    UINT32 rank2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               disable correctable error logging/signaling for
                               Rank2
                            */
    UINT32 rank3 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               disable correctable error logging/signaling for
                               Rank3
                            */
    UINT32 rank4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               disable correctable error logging/signaling for
                               Rank4
                            */
    UINT32 rank5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               disable correctable error logging/signaling for
                               Rank5
                            */
    UINT32 rank6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               disable correctable error logging/signaling for
                               Rank6
                            */
    UINT32 rank7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               disable correctable error logging/signaling for
                               Rank7
                            */
    UINT32 rsvd : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIS_CORR_ERR_LOG_MCDDC_DP_STRUCT;

/* PLUS1_RANK0_MCDDC_DP_REG supported on:                                       */
/*      SPRA0 (0x22d28)                                                         */
/*      SPRB0 (0x22d28)                                                         */
/*      SPRHBM (0x22d28)                                                        */
/*      SPRC0 (0x22d28)                                                         */
/*      SPRMCC (0x22d28)                                                        */
/*      SPRUCC (0x22d28)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This register specifies the current ECC configuration for each rank, including portions of the rank that participates in an ADDDC region and its buddy.
*/


#define PLUS1_RANK0_MCDDC_DP_REG 0x0B102D28

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 faildevice : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the failed device to be
                               mapped out for this rank in +1 mode, including
                               portion of the rank (and its buddy) that is
                               participating in an ADDDC region. Set by BIOS at
                               the beginning of a SDDC sparing flow. Valid
                               Range is decimal 0-17 to indicate which device
                               has failed.
                            */
    UINT8 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} PLUS1_RANK0_MCDDC_DP_STRUCT;

/* PLUS1_RANK1_MCDDC_DP_REG supported on:                                       */
/*      SPRA0 (0x22d2c)                                                         */
/*      SPRB0 (0x22d2c)                                                         */
/*      SPRHBM (0x22d2c)                                                        */
/*      SPRC0 (0x22d2c)                                                         */
/*      SPRMCC (0x22d2c)                                                        */
/*      SPRUCC (0x22d2c)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This register specifies the current ECC configuration for each rank, including portions of the rank that participates in an ADDDC region and its buddy.
*/


#define PLUS1_RANK1_MCDDC_DP_REG 0x0B102D2C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 faildevice : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the failed device to be
                               mapped out for this rank in +1 mode, including
                               portion of the rank (and its buddy) that is
                               participating in an ADDDC region. Set by BIOS at
                               the beginning of a SDDC sparing flow. Valid
                               Range is decimal 0-17 to indicate which device
                               has failed.
                            */
    UINT8 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} PLUS1_RANK1_MCDDC_DP_STRUCT;

/* PLUS1_RANK2_MCDDC_DP_REG supported on:                                       */
/*      SPRA0 (0x22d30)                                                         */
/*      SPRB0 (0x22d30)                                                         */
/*      SPRHBM (0x22d30)                                                        */
/*      SPRC0 (0x22d30)                                                         */
/*      SPRMCC (0x22d30)                                                        */
/*      SPRUCC (0x22d30)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This register specifies the current ECC configuration for each rank, including portions of the rank that participates in an ADDDC region and its buddy.
*/


#define PLUS1_RANK2_MCDDC_DP_REG 0x0B102D30

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 faildevice : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the failed device to be
                               mapped out for this rank in +1 mode, including
                               portion of the rank (and its buddy) that is
                               participating in an ADDDC region. Set by BIOS at
                               the beginning of a SDDC sparing flow. Valid
                               Range is decimal 0-17 to indicate which device
                               has failed.
                            */
    UINT8 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} PLUS1_RANK2_MCDDC_DP_STRUCT;

/* PLUS1_RANK3_MCDDC_DP_REG supported on:                                       */
/*      SPRA0 (0x22d34)                                                         */
/*      SPRB0 (0x22d34)                                                         */
/*      SPRHBM (0x22d34)                                                        */
/*      SPRC0 (0x22d34)                                                         */
/*      SPRMCC (0x22d34)                                                        */
/*      SPRUCC (0x22d34)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This register specifies the current ECC configuration for each rank, including portions of the rank that participates in an ADDDC region and its buddy.
*/


#define PLUS1_RANK3_MCDDC_DP_REG 0x0B102D34

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 faildevice : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the failed device to be
                               mapped out for this rank in +1 mode, including
                               portion of the rank (and its buddy) that is
                               participating in an ADDDC region. Set by BIOS at
                               the beginning of a SDDC sparing flow. Valid
                               Range is decimal 0-17 to indicate which device
                               has failed.
                            */
    UINT8 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} PLUS1_RANK3_MCDDC_DP_STRUCT;

/* PLUS1_RANK4_MCDDC_DP_REG supported on:                                       */
/*      SPRA0 (0x22d38)                                                         */
/*      SPRB0 (0x22d38)                                                         */
/*      SPRHBM (0x22d38)                                                        */
/*      SPRC0 (0x22d38)                                                         */
/*      SPRMCC (0x22d38)                                                        */
/*      SPRUCC (0x22d38)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This register specifies the current ECC configuration for each rank, including portions of the rank that participates in an ADDDC region and its buddy.
*/


#define PLUS1_RANK4_MCDDC_DP_REG 0x0B102D38

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 faildevice : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the failed device to be
                               mapped out for this rank in +1 mode, including
                               portion of the rank (and its buddy) that is
                               participating in an ADDDC region. Set by BIOS at
                               the beginning of a SDDC sparing flow. Valid
                               Range is decimal 0-17 to indicate which device
                               has failed.
                            */
    UINT8 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} PLUS1_RANK4_MCDDC_DP_STRUCT;

/* PLUS1_RANK5_MCDDC_DP_REG supported on:                                       */
/*      SPRA0 (0x22d3c)                                                         */
/*      SPRB0 (0x22d3c)                                                         */
/*      SPRHBM (0x22d3c)                                                        */
/*      SPRC0 (0x22d3c)                                                         */
/*      SPRMCC (0x22d3c)                                                        */
/*      SPRUCC (0x22d3c)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This register specifies the current ECC configuration for each rank, including portions of the rank that participates in an ADDDC region and its buddy.
*/


#define PLUS1_RANK5_MCDDC_DP_REG 0x0B102D3C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 faildevice : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the failed device to be
                               mapped out for this rank in +1 mode, including
                               portion of the rank (and its buddy) that is
                               participating in an ADDDC region. Set by BIOS at
                               the beginning of a SDDC sparing flow. Valid
                               Range is decimal 0-17 to indicate which device
                               has failed.
                            */
    UINT8 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} PLUS1_RANK5_MCDDC_DP_STRUCT;

/* PLUS1_RANK6_MCDDC_DP_REG supported on:                                       */
/*      SPRA0 (0x22d40)                                                         */
/*      SPRB0 (0x22d40)                                                         */
/*      SPRHBM (0x22d40)                                                        */
/*      SPRC0 (0x22d40)                                                         */
/*      SPRMCC (0x22d40)                                                        */
/*      SPRUCC (0x22d40)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This register specifies the current ECC configuration for each rank, including portions of the rank that participates in an ADDDC region and its buddy.
*/


#define PLUS1_RANK6_MCDDC_DP_REG 0x0B102D40

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 faildevice : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the failed device to be
                               mapped out for this rank in +1 mode, including
                               portion of the rank (and its buddy) that is
                               participating in an ADDDC region. Set by BIOS at
                               the beginning of a SDDC sparing flow. Valid
                               Range is decimal 0-17 to indicate which device
                               has failed.
                            */
    UINT8 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} PLUS1_RANK6_MCDDC_DP_STRUCT;

/* PLUS1_RANK7_MCDDC_DP_REG supported on:                                       */
/*      SPRA0 (0x22d44)                                                         */
/*      SPRB0 (0x22d44)                                                         */
/*      SPRHBM (0x22d44)                                                        */
/*      SPRC0 (0x22d44)                                                         */
/*      SPRMCC (0x22d44)                                                        */
/*      SPRUCC (0x22d44)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This register specifies the current ECC configuration for each rank, including portions of the rank that participates in an ADDDC region and its buddy.
*/


#define PLUS1_RANK7_MCDDC_DP_REG 0x0B102D44

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 faildevice : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the failed device to be
                               mapped out for this rank in +1 mode, including
                               portion of the rank (and its buddy) that is
                               participating in an ADDDC region. Set by BIOS at
                               the beginning of a SDDC sparing flow. Valid
                               Range is decimal 0-17 to indicate which device
                               has failed.
                            */
    UINT8 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} PLUS1_RANK7_MCDDC_DP_STRUCT;

/* ADDDC_REGION0_MCDDC_DP_REG supported on:                                     */
/*      SPRA0 (0x22d48)                                                         */
/*      SPRB0 (0x22d48)                                                         */
/*      SPRHBM (0x22d48)                                                        */
/*      SPRC0 (0x22d48)                                                         */
/*      SPRMCC (0x22d48)                                                        */
/*      SPRUCC (0x22d48)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
            This register specifies the current ECC configuration for each region using ADDDC.
            
*/


#define ADDDC_REGION0_MCDDC_DP_REG 0x0B102D48

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 faildevice : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the failed device to be
                               mapped out for this adddc region. Valid range is
                               0-35, with values >=18 indicating the buddy
                               rank.
                            */
    UINT8 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} ADDDC_REGION0_MCDDC_DP_STRUCT;

/* ADDDC_REGION1_MCDDC_DP_REG supported on:                                     */
/*      SPRA0 (0x22d4c)                                                         */
/*      SPRB0 (0x22d4c)                                                         */
/*      SPRHBM (0x22d4c)                                                        */
/*      SPRC0 (0x22d4c)                                                         */
/*      SPRMCC (0x22d4c)                                                        */
/*      SPRUCC (0x22d4c)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
            This register specifies the current ECC configuration for each region using ADDDC.
            
*/


#define ADDDC_REGION1_MCDDC_DP_REG 0x0B102D4C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 faildevice : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the failed device to be
                               mapped out for this adddc region. Valid range is
                               0-35, with values >=18 indicating the buddy
                               rank.
                            */
    UINT8 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} ADDDC_REGION1_MCDDC_DP_STRUCT;

/* ADDDC_REGION2_MCDDC_DP_REG supported on:                                     */
/*      SPRA0 (0x22d50)                                                         */
/*      SPRB0 (0x22d50)                                                         */
/*      SPRHBM (0x22d50)                                                        */
/*      SPRC0 (0x22d50)                                                         */
/*      SPRMCC (0x22d50)                                                        */
/*      SPRUCC (0x22d50)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
            This register specifies the current ECC configuration for each region using ADDDC.
            
*/


#define ADDDC_REGION2_MCDDC_DP_REG 0x0B102D50

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 faildevice : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the failed device to be
                               mapped out for this adddc region. Valid range is
                               0-35, with values >=18 indicating the buddy
                               rank.
                            */
    UINT8 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} ADDDC_REGION2_MCDDC_DP_STRUCT;

/* ADDDC_REGION3_MCDDC_DP_REG supported on:                                     */
/*      SPRA0 (0x22d54)                                                         */
/*      SPRB0 (0x22d54)                                                         */
/*      SPRHBM (0x22d54)                                                        */
/*      SPRC0 (0x22d54)                                                         */
/*      SPRMCC (0x22d54)                                                        */
/*      SPRUCC (0x22d54)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
            This register specifies the current ECC configuration for each region using ADDDC.
            
*/


#define ADDDC_REGION3_MCDDC_DP_REG 0x0B102D54

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 faildevice : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the failed device to be
                               mapped out for this adddc region. Valid range is
                               0-35, with values >=18 indicating the buddy
                               rank.
                            */
    UINT8 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} ADDDC_REGION3_MCDDC_DP_STRUCT;

/* RETRY_RD_ERR_SET3_LOG_ADDRESS1_MCDDC_DP_REG supported on:                    */
/*      SPRA0 (0x20022d58)                                                      */
/*      SPRB0 (0x20022d58)                                                      */
/*      SPRHBM (0x20022d58)                                                     */
/*      SPRC0 (0x20022d58)                                                      */
/*      SPRMCC (0x20022d58)                                                     */
/*      SPRUCC (0x20022d58)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG.
        The values in this register indicate the address of failed device. failed device id, chip select, cbit, bank  
        DDR     : Decoded Address: Rank[2:0], BG, BA, Row Col
        DDR 3DS : Decoded Address: Rank[2], Rank[0], SubRank[2:0], BG, BA Row Col
        HBM     : Decoded Address: Rank[1:0](for SID and PCH resp), BA, BG, Row, column --> No SubRank field 
      
*/


#define RETRY_RD_ERR_SET3_LOG_ADDRESS1_MCDDC_DP_REG 0x0B122D58

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 failed_dev : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Holds the failed device number: for
                               sddc/ddrt/HBM the device number is between 0-17.
                               for adddc device number between 0-16 and 18-35
                               dev 17 is the spare device. for HBM mode, value
                               of 31 means there is no error; also this is
                               failed device number for first 32 bytes.
                            */
    UINT32 chip_select : 3;

                            /* Bits[8:6], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Rank CS0-CS7 (encoded chip select) of retried
                               read
                            */
    UINT32 cbit : 5;

                            /* Bits[13:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               C0-C2 (encoded subrank) for last retry. Bit 12
                               is spare to accomodate for future growth in DDR5
                               Logged value is {2'b0,cbit[2:0]} For HBM mode,
                               indicates the device number for the correctable
                               error signaled by BIST for upper 32 bytes. Valid
                               only when ecc_bist_valid is true and
                               ecc_bist_errtype_upper is correctable.
                            */
    UINT32 bank : 6;

                            /* Bits[19:14], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Bank ID for last retry. Bottom three bits are
                               Bank Group, top two bits are Bank Address Logged
                               value is {1'b0,bank_group[2],bank_address[1:0],b
                               ank_group[1:0]} Bit 18 is spare to accomodate
                               for future growth in DDR5
                            */
    UINT32 col : 10;

                            /* Bits[29:20], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Column address for the last retry Logged value
                               is DDR - {2'b0,Column_addr[9:3],1'b0}.
                               Column_addr[2] indicates Critical chunk, so
                               making that as 0 HBM - {2'b0,Column_addr[9:2]}
                               Bits 9 and 8 as spare to accomodate possible
                               future growth in size for DDR5 In DDR - Actual
                               Column address = {Column_addr[9:3],3'b0}
                               Column_addr[2] indicates Critical chunk In HBM -
                               Actual Column address = {Column_addr[9:2],2'b0}
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET3_LOG_ADDRESS1_MCDDC_DP_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 failed_dev : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Holds the failed device number: for
                               sddc/ddrt/HBM the device number is between 0-17.
                               for adddc device number between 0-16 and 18-35
                               dev 17 is the spare device. for HBM mode, value
                               of 31 means there is no error; also this is
                               failed device number for first 32 bytes.
                            */
    UINT32 chip_select : 3;

                            /* Bits[8:6], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Rank CS0-CS7 (encoded chip select) of retried
                               read
                            */
    UINT32 cbit : 5;

                            /* Bits[13:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               C0-C2 (encoded subrank) for last retry. Bit 12
                               is spare to accomodate for future growth in DDR5
                               Logged value is {2'b0,cbit[2:0]} For HBM mode,
                               indicates the device number for the correctable
                               error signaled by BIST for upper 32 bytes. Valid
                               only when ecc_bist_valid is true and
                               ecc_bist_errtype_upper is correctable.
                            */
    UINT32 bank : 6;

                            /* Bits[19:14], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Bank ID for last retry. Bottom three bits are
                               Bank Group, top two bits are Bank Address Logged
                               value is {1'b0,bank_group[2],bank_address[1:0],b
                               ank_group[1:0]} Bit 18 is spare to accomodate
                               for future growth in DDR5
                            */
    UINT32 col : 10;

                            /* Bits[29:20], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Column address for the last retry Logged value
                               is DDR - {2'b0,Column_addr[9:3],1'b0}.
                               Column_addr[2] indicates Critical chunk, so
                               making that as 0 HBM - {2'b0,Column_addr[9:2]}
                               Bits 9 and 8 as spare to accomodate possible
                               future growth in size for DDR5 In DDR - Actual
                               Column address = {Column_addr[9:3],3'b0}
                               Column_addr[2] indicates Critical chunk In HBM -
                               Actual Column address = {Column_addr[9:2],2'b0}
                            */
    UINT32 rsvd_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET3_LOG_ADDRESS1_MCDDC_DP_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 failed_dev : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Holds the failed device number: for sddc/ddrt
                               the device number is between 0-9. for adddc
                               device number between 0-8 and 10-19 with dev 9
                               being the spare device. for HBM mode, device
                               number is between 0-17, with value of 31 means
                               there is no error; also this is failed device
                               number for first 32 bytes with 32B ECC mode.
                               This field is only valid with correctable error
                               of the type device correction.
                            */
    UINT32 chip_select : 3;

                            /* Bits[8:6], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Rank CS0-CS7 (encoded chip select) of retried
                               read
                            */
    UINT32 cbit : 5;

                            /* Bits[13:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               C0-C2 (encoded subrank) for last retry. Bit 12
                               is spare to accomodate for future growth Logged
                               value is {2'b0,cbit[2:0]} For HBM controller
                               with 32B ECC mode, indicates the device number
                               for the correctable error as detected by BIST
                               for upper 32 bytes. Valid only when
                               ecc_bist_valid is true and
                               ecc_bist_errtype_upper is correctable. For all
                               other modes, this field doesn't contain valid
                               information.
                            */
    UINT32 bank : 6;

                            /* Bits[19:14], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Bank ID for last retry. Logged value is {1'b0,ba
                               nk_group[2],bank_address[1:0],bank_group[1:0]}
                               Bit 18 is spare to accomodate for future growth
                            */
    UINT32 col : 10;

                            /* Bits[29:20], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Column address for the last retry Logged value
                               is {2'b0,Column_addr[9:2]} Bits 9 and 8 as spare
                               to accomodate possible future growth in size In
                               DDR - Actual Column address =
                               {Column_addr[9:3],3'b0} Column_addr[2] indicates
                               Critical chunk In HBM - Actual Column address =
                               {Column_addr[9:2],2'b0}
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET3_LOG_ADDRESS1_MCDDC_DP_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 failed_dev : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Holds the failed device number: for
                               sddc/ddrt/HBM the device number is between 0-17.
                               for adddc device number between 0-16 and 18-35
                               dev 17 is the spare device. for HBM mode, value
                               of 31 means there is no error; also this is
                               failed device number for first 32 bytes.
                            */
    UINT32 chip_select : 3;

                            /* Bits[8:6], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Rank CS0-CS7 (encoded chip select) of retried
                               read
                            */
    UINT32 cbit : 5;

                            /* Bits[13:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               C0-C2 (encoded subrank) for last retry. Bit 12
                               is spare to accomodate for future growth in DDR5
                               Logged value is {2'b0,cbit[2:0]} For HBM mode,
                               indicates the device number for the correctable
                               error signaled by BIST for upper 32 bytes. Valid
                               only when ecc_bist_valid is true and
                               ecc_bist_errtype_upper is correctable.
                            */
    UINT32 bank : 6;

                            /* Bits[19:14], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Bank ID for last retry. Bottom three bits are
                               Bank Group, top two bits are Bank Address Logged
                               value is {1'b0,bank_group[2],bank_address[1:0],b
                               ank_group[1:0]} Bit 18 is spare to accomodate
                               for future growth in DDR5
                            */
    UINT32 col : 10;

                            /* Bits[29:20], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Column address for the last retry Logged value
                               is DDR - {2'b0,Column_addr[9:3],1'b0}.
                               Column_addr[2] indicates Critical chunk, so
                               making that as 0 HBM - {2'b0,Column_addr[9:2]}
                               Bits 9 and 8 as spare to accomodate possible
                               future growth in size for DDR5 In DDR - Actual
                               Column address = {Column_addr[9:3],3'b0}
                               Column_addr[2] indicates Critical chunk In HBM -
                               Actual Column address = {Column_addr[9:2],2'b0}
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET3_LOG_ADDRESS1_MCDDC_DP_STRUCT;

/* DDR4_WRCRC0_CTL_N0_MCDDC_DP_REG supported on:                                */
/*      SPRA0 (0x20022d60)                                                      */
/*      SPRB0 (0x20022d60)                                                      */
/*      SPRHBM (0x20022d60)                                                     */
/*      SPRC0 (0x20022d60)                                                      */
/*      SPRMCC (0x20022d60)                                                     */
/*      SPRUCC (0x20022d60)                                                     */
/* Register default value on SPRA0: 0xE4E40000                                  */
/* Register default value on SPRB0: 0xE4E40000                                  */
/* Register default value on SPRHBM: 0xE4E40000                                 */
/* Register default value on SPRC0: 0xE4E40000                                  */
/* Register default value on SPRMCC: 0xE4E40000                                 */
/* Register default value on SPRUCC: 0xE4E40000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 0; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC0_CTL_N0_MCDDC_DP_REG 0x0B122D60

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 enable_nibble_swizzle : 10;

                            /* Bits[13:4], Access Type=RW, default=0x00000000*/

                            /* Enable swizzling per nibble */
    UINT32 rsvd_14 : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dq71_dq64_swizzle_ctl : 16;

                            /* Bits[31:16], Access Type=RW, default=0x0000E4E4*/

                            /*
                               Swizzling for DQ Bits 71 to 64. 2 CSR bits per
                               DQ lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC0_CTL_N0_MCDDC_DP_STRUCT;

/* DDR4_WRCRC0_CTL_N1_MCDDC_DP_REG supported on:                                */
/*      SPRA0 (0x20022d64)                                                      */
/*      SPRB0 (0x20022d64)                                                      */
/*      SPRHBM (0x20022d64)                                                     */
/*      SPRC0 (0x20022d64)                                                      */
/*      SPRMCC (0x20022d64)                                                     */
/*      SPRUCC (0x20022d64)                                                     */
/* Register default value on SPRA0: 0x0000E4E4                                  */
/* Register default value on SPRB0: 0x0000E4E4                                  */
/* Register default value on SPRHBM: 0x0000E4E4                                 */
/* Register default value on SPRC0: 0x0000E4E4                                  */
/* Register default value on SPRMCC: 0x0000E4E4                                 */
/* Register default value on SPRUCC: 0x0000E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 0; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC0_CTL_N1_MCDDC_DP_REG 0x0B122D64

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dq79_dq72_swizzle_ctl : 16;

                            /* Bits[15:0], Access Type=RW, default=0x0000E4E4*/

                            /*
                               Swizzling for DQ Bits 79 to 72. 2 CSR bits per
                               DQ lane
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC0_CTL_N1_MCDDC_DP_STRUCT;

/* DDR4_WRCRC1_CTL_N0_MCDDC_DP_REG supported on:                                */
/*      SPRA0 (0x20022d68)                                                      */
/*      SPRB0 (0x20022d68)                                                      */
/*      SPRHBM (0x20022d68)                                                     */
/*      SPRC0 (0x20022d68)                                                      */
/*      SPRMCC (0x20022d68)                                                     */
/*      SPRUCC (0x20022d68)                                                     */
/* Register default value on SPRA0: 0xE4E40000                                  */
/* Register default value on SPRB0: 0xE4E40000                                  */
/* Register default value on SPRHBM: 0xE4E40000                                 */
/* Register default value on SPRC0: 0xE4E40000                                  */
/* Register default value on SPRMCC: 0xE4E40000                                 */
/* Register default value on SPRUCC: 0xE4E40000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 1; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC1_CTL_N0_MCDDC_DP_REG 0x0B122D68

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 enable_nibble_swizzle : 10;

                            /* Bits[13:4], Access Type=RW, default=0x00000000*/

                            /* Enable swizzling per nibble */
    UINT32 rsvd_14 : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dq71_dq64_swizzle_ctl : 16;

                            /* Bits[31:16], Access Type=RW, default=0x0000E4E4*/

                            /*
                               Swizzling for DQ Bits 71 to 64. 2 CSR bits per
                               DQ lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC1_CTL_N0_MCDDC_DP_STRUCT;

/* DDR4_WRCRC1_CTL_N1_MCDDC_DP_REG supported on:                                */
/*      SPRA0 (0x20022d6c)                                                      */
/*      SPRB0 (0x20022d6c)                                                      */
/*      SPRHBM (0x20022d6c)                                                     */
/*      SPRC0 (0x20022d6c)                                                      */
/*      SPRMCC (0x20022d6c)                                                     */
/*      SPRUCC (0x20022d6c)                                                     */
/* Register default value on SPRA0: 0x0000E4E4                                  */
/* Register default value on SPRB0: 0x0000E4E4                                  */
/* Register default value on SPRHBM: 0x0000E4E4                                 */
/* Register default value on SPRC0: 0x0000E4E4                                  */
/* Register default value on SPRMCC: 0x0000E4E4                                 */
/* Register default value on SPRUCC: 0x0000E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 1; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC1_CTL_N1_MCDDC_DP_REG 0x0B122D6C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dq79_dq72_swizzle_ctl : 16;

                            /* Bits[15:0], Access Type=RW, default=0x0000E4E4*/

                            /*
                               Swizzling for DQ Bits 79 to 72. 2 CSR bits per
                               DQ lane
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC1_CTL_N1_MCDDC_DP_STRUCT;

/* DDR4_WRCRC2_CTL_N0_MCDDC_DP_REG supported on:                                */
/*      SPRA0 (0x20022d70)                                                      */
/*      SPRB0 (0x20022d70)                                                      */
/*      SPRHBM (0x20022d70)                                                     */
/*      SPRC0 (0x20022d70)                                                      */
/*      SPRMCC (0x20022d70)                                                     */
/*      SPRUCC (0x20022d70)                                                     */
/* Register default value on SPRA0: 0xE4E40000                                  */
/* Register default value on SPRB0: 0xE4E40000                                  */
/* Register default value on SPRHBM: 0xE4E40000                                 */
/* Register default value on SPRC0: 0xE4E40000                                  */
/* Register default value on SPRMCC: 0xE4E40000                                 */
/* Register default value on SPRUCC: 0xE4E40000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 2; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC2_CTL_N0_MCDDC_DP_REG 0x0B122D70

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 enable_nibble_swizzle : 10;

                            /* Bits[13:4], Access Type=RW, default=0x00000000*/

                            /* Enable swizzling per nibble */
    UINT32 rsvd_14 : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dq71_dq64_swizzle_ctl : 16;

                            /* Bits[31:16], Access Type=RW, default=0x0000E4E4*/

                            /*
                               Swizzling for DQ Bits 71 to 64. 2 CSR bits per
                               DQ lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC2_CTL_N0_MCDDC_DP_STRUCT;

/* DDR4_WRCRC2_CTL_N1_MCDDC_DP_REG supported on:                                */
/*      SPRA0 (0x20022d74)                                                      */
/*      SPRB0 (0x20022d74)                                                      */
/*      SPRHBM (0x20022d74)                                                     */
/*      SPRC0 (0x20022d74)                                                      */
/*      SPRMCC (0x20022d74)                                                     */
/*      SPRUCC (0x20022d74)                                                     */
/* Register default value on SPRA0: 0x0000E4E4                                  */
/* Register default value on SPRB0: 0x0000E4E4                                  */
/* Register default value on SPRHBM: 0x0000E4E4                                 */
/* Register default value on SPRC0: 0x0000E4E4                                  */
/* Register default value on SPRMCC: 0x0000E4E4                                 */
/* Register default value on SPRUCC: 0x0000E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 2; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC2_CTL_N1_MCDDC_DP_REG 0x0B122D74

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dq79_dq72_swizzle_ctl : 16;

                            /* Bits[15:0], Access Type=RW, default=0x0000E4E4*/

                            /*
                               Swizzling for DQ Bits 79 to 72. 2 CSR bits per
                               DQ lane
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC2_CTL_N1_MCDDC_DP_STRUCT;

/* DDR4_WRCRC3_CTL_N0_MCDDC_DP_REG supported on:                                */
/*      SPRA0 (0x20022d78)                                                      */
/*      SPRB0 (0x20022d78)                                                      */
/*      SPRHBM (0x20022d78)                                                     */
/*      SPRC0 (0x20022d78)                                                      */
/*      SPRMCC (0x20022d78)                                                     */
/*      SPRUCC (0x20022d78)                                                     */
/* Register default value on SPRA0: 0xE4E40000                                  */
/* Register default value on SPRB0: 0xE4E40000                                  */
/* Register default value on SPRHBM: 0xE4E40000                                 */
/* Register default value on SPRC0: 0xE4E40000                                  */
/* Register default value on SPRMCC: 0xE4E40000                                 */
/* Register default value on SPRUCC: 0xE4E40000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 3; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC3_CTL_N0_MCDDC_DP_REG 0x0B122D78

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 4;

                            /* Bits[3:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 enable_nibble_swizzle : 10;

                            /* Bits[13:4], Access Type=RW, default=0x00000000*/

                            /* Enable swizzling per nibble */
    UINT32 rsvd_14 : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dq71_dq64_swizzle_ctl : 16;

                            /* Bits[31:16], Access Type=RW, default=0x0000E4E4*/

                            /*
                               Swizzling for DQ Bits 71 to 64. 2 CSR bits per
                               DQ lane
                            */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC3_CTL_N0_MCDDC_DP_STRUCT;

/* DDR4_WRCRC3_CTL_N1_MCDDC_DP_REG supported on:                                */
/*      SPRA0 (0x20022d7c)                                                      */
/*      SPRB0 (0x20022d7c)                                                      */
/*      SPRHBM (0x20022d7c)                                                     */
/*      SPRC0 (0x20022d7c)                                                      */
/*      SPRMCC (0x20022d7c)                                                     */
/*      SPRUCC (0x20022d7c)                                                     */
/* Register default value on SPRA0: 0x0000E4E4                                  */
/* Register default value on SPRB0: 0x0000E4E4                                  */
/* Register default value on SPRHBM: 0x0000E4E4                                 */
/* Register default value on SPRC0: 0x0000E4E4                                  */
/* Register default value on SPRMCC: 0x0000E4E4                                 */
/* Register default value on SPRUCC: 0x0000E4E4                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR4 Write CRC swizzling control for set 3; the rank this set is used for is selected by ddr4_wrcrc_rank_ctl
*/


#define DDR4_WRCRC3_CTL_N1_MCDDC_DP_REG 0x0B122D7C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dq79_dq72_swizzle_ctl : 16;

                            /* Bits[15:0], Access Type=RW, default=0x0000E4E4*/

                            /*
                               Swizzling for DQ Bits 79 to 72. 2 CSR bits per
                               DQ lane
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDR4_WRCRC3_CTL_N1_MCDDC_DP_STRUCT;

/* RETRY_RD_ERR_SET3_LOG_MISC_MCDDC_DP_REG supported on:                        */
/*      SPRA0 (0x20022d80)                                                      */
/*      SPRB0 (0x20022d80)                                                      */
/*      SPRHBM (0x20022d80)                                                     */
/*      SPRC0 (0x20022d80)                                                      */
/*      SPRMCC (0x20022d80)                                                     */
/*      SPRUCC (0x20022d80)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG
*/


#define RETRY_RD_ERR_SET3_LOG_MISC_MCDDC_DP_REG 0x0B122D80

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 plus1_loc_syn : 12;

                            /* Bits[11:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this register hold the value of plus1 locator
                               syndrome from correction path. the number of
                               plus1 LS bits are the same for all the plus1
                               modes
                            */
    UINT32 inter_loc_syn : 12;

                            /* Bits[23:12], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this register hold the value Intermediate
                               Locator Syndrome from correction path which are
                               only valid when the mode is sddc 1lm. Only valid
                               iff hard failure effect the IL bits. The
                               syndrome will indicate which bit is the failing
                               one
                            */
    UINT32 data_failed_col_num : 6;

                            /* Bits[29:24], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this register indicate the failed column number
                               over the data device. columns over data are
                               numbered from 0 to 63. this field is only valid
                               for 1LM ADDDC and when the column correction
                               indication is set in the retry_rd_err_log
                               register
                            */
    UINT32 meta_failed_col_num : 2;

                            /* Bits[31:30], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this register indicate the failed column number
                               over the metadata+locator device. bit 0 of this
                               field is set when column 0 has failed (value
                               01), while bit 1 of this field is set when
                               column 1 has failed (value 10). this field is
                               only valid for 1LM ADDDC and when the column
                               correction indication is set in the
                               retry_rd_err_log register
                            */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET3_LOG_MISC_MCDDC_DP_STRUCT;

#ifdef SPRA0_HOST
/* RETRY_RD_ERR_SET3_LOG_PARITY_MCDDC_DP_REG supported on:                      */
/*      SPRA0 (0x20022d84)                                                      */
/* Register default value on SPRA0: 0x00000000                                  */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG
*/


#define RETRY_RD_ERR_SET3_LOG_PARITY_MCDDC_DP_REG 0x0B122D84

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 par_syn : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this register hold the parity syndrome(mask)
                               from correction path. for sddc/x8/ddrt parity
                               syndrome is 32 bits. but for 2LM adddc it is 16
                               bits so the 16 upper bits are always 0 for 2LM
                               adddc: 16 bits 0 + Parity Syndrome (16 bits). in
                               1LM adddc reused the 8 upper bits to log the
                               Parity Column Syndrome. so the order for 1LM
                               adddc will be: PC syn for upper half of CL
                               (4bits)+ PC syn for lower half of CL (4bits)+ 8
                               bits 0 + Parity Syndrome (16 bits)
                            */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET3_LOG_PARITY_MCDDC_DP_STRUCT;
#endif /* (SPRA0_HOST) */

/* INTERNAL_ERROR_DP_N0_MCDDC_DP_REG supported on:                              */
/*      SPRA0 (0x20022e00)                                                      */
/*      SPRB0 (0x20022e00)                                                      */
/*      SPRHBM (0x20022e00)                                                     */
/*      SPRC0 (0x20022e00)                                                      */
/*      SPRMCC (0x20022e00)                                                     */
/*      SPRUCC (0x20022e00)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains internal errors from mcdp
*/


#define INTERNAL_ERROR_DP_N0_MCDDC_DP_REG 0x0B122E00

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rrd_bad_rd_return : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /* Wrong number of data cycles */
    UINT32 rrd_bad_ddrt_viral : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /* Wrong DDRT viral */
    UINT32 wdb_data_fifo_full : 1;

                            /* Bits[2:2], Access Type=RO/V, default=0x00000000*/

                            /* WDB data FIFO full */
    UINT32 wdb_ufill_of : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000000*/

                            /* WDB ufill storage overflow */
    UINT32 wdb_alloc_put_collide : 1;

                            /* Bits[4:4], Access Type=RO/V, default=0x00000000*/

                            /* WDB cmd collision */
    UINT32 wdb_unexp_prmrr : 1;

                            /* Bits[5:5], Access Type=RO/V, default=0x00000000*/

                            /* Unexpected PRMRR programming */
    UINT32 wdb_illegal_rf_write : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000000*/

                            /* WDB illegal RF write */
    UINT32 wdb_unexp_deprd_error : 1;

                            /* Bits[7:7], Access Type=RO/V, default=0x00000000*/

                            /* Unexpected error from deprd */
    UINT32 wdb_unexp_deprd_error2 : 1;

                            /* Bits[8:8], Access Type=RO/V, default=0x00000000*/

                            /* Unexpected error from deprd */
    UINT32 rt_ddrt_ufill_entry_wrong : 1;

                            /* Bits[9:9], Access Type=RO/V, default=0x00000000*/

                            /* Wrong DDRT entry */
    UINT32 cpl_fab_credit_error : 1;

                            /* Bits[10:10], Access Type=RO/V, default=0x00000000*/

                            /* Fabric credit error */
    UINT32 wdb_spr_ufill_err : 1;

                            /* Bits[11:11], Access Type=RO/V, default=0x00000000*/

                            /* WDB internal error */
    UINT32 rt_unexp_sched_active : 1;

                            /* Bits[12:12], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_unexp_alert_active : 1;

                            /* Bits[13:13], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rrd_corr_fast_path_rd_vld : 1;

                            /* Bits[14:14], Access Type=RO/V, default=0x00000000*/

                            /* RRD internal error */
    UINT32 rrd_malformed_rdvalid : 1;

                            /* Bits[15:15], Access Type=RO/V, default=0x00000000*/

                            /* RRD internal error */
    UINT32 rrd_eridblock_nordvalid : 1;

                            /* Bits[16:16], Access Type=RO/V, default=0x00000000*/

                            /* RRD internal error */
    UINT32 rt_rdbfifo_of : 1;

                            /* Bits[17:17], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_unexp_ddrt_wrni : 1;

                            /* Bits[18:18], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_adddcplusone_no_dev_sub : 1;

                            /* Bits[19:19], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 wdb_skip_mac_check_from_nonspec_rd_err : 1;

                            /* Bits[20:20], Access Type=RO/V, default=0x00000000*/

                            /*
                               skip_mac_check is only asserted for a depdendent
                               spec rd. If this bit is set, the a demand
                               dependent Rd was returned with skip_mac_check =
                               1
                            */
    UINT32 rsvd : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} INTERNAL_ERROR_DP_N0_MCDDC_DP_SPRA0_SPRB0_SPRHBM_SPRC0_SPRMCC_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) */

#if defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rrd_bad_rd_return : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /* Wrong number of data cycles */
    UINT32 rrd_bad_ddrt_viral : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /* Wrong DDRT viral */
    UINT32 wdb_data_fifo_full : 1;

                            /* Bits[2:2], Access Type=RO/V, default=0x00000000*/

                            /* WDB data FIFO full */
    UINT32 wdb_ufill_of : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000000*/

                            /* WDB ufill storage overflow */
    UINT32 wdb_alloc_put_collide : 1;

                            /* Bits[4:4], Access Type=RO/V, default=0x00000000*/

                            /* WDB cmd collision */
    UINT32 wdb_unexp_prmrr : 1;

                            /* Bits[5:5], Access Type=RO/V, default=0x00000000*/

                            /* Unexpected PRMRR programming */
    UINT32 wdb_illegal_rf_write : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000000*/

                            /* WDB illegal RF write */
    UINT32 wdb_unexp_deprd_error : 1;

                            /* Bits[7:7], Access Type=RO/V, default=0x00000000*/

                            /* Unexpected error from deprd */
    UINT32 wdb_unexp_deprd_error2 : 1;

                            /* Bits[8:8], Access Type=RO/V, default=0x00000000*/

                            /* Unexpected error from deprd */
    UINT32 rt_ddrt_ufill_entry_wrong : 1;

                            /* Bits[9:9], Access Type=RO/V, default=0x00000000*/

                            /* Wrong DDRT entry */
    UINT32 cpl_fab_credit_error : 1;

                            /* Bits[10:10], Access Type=RO/V, default=0x00000000*/

                            /* Fabric credit error */
    UINT32 wdb_spr_ufill_err : 1;

                            /* Bits[11:11], Access Type=RO/V, default=0x00000000*/

                            /* WDB internal error */
    UINT32 rt_unexp_sched_active : 1;

                            /* Bits[12:12], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_unexp_alert_active : 1;

                            /* Bits[13:13], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rrd_corr_fast_path_rd_vld : 1;

                            /* Bits[14:14], Access Type=RO/V, default=0x00000000*/

                            /* RRD internal error */
    UINT32 rrd_malformed_rdvalid : 1;

                            /* Bits[15:15], Access Type=RO/V, default=0x00000000*/

                            /* RRD internal error */
    UINT32 rrd_eridblock_nordvalid : 1;

                            /* Bits[16:16], Access Type=RO/V, default=0x00000000*/

                            /* RRD internal error */
    UINT32 rt_rdbfifo_of : 1;

                            /* Bits[17:17], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_unexp_ddrt_wrni : 1;

                            /* Bits[18:18], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_adddcplusone_no_dev_sub : 1;

                            /* Bits[19:19], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 wdb_skip_mac_check_from_nonspec_rd_err : 1;

                            /* Bits[20:20], Access Type=RO/V, default=0x00000000*/

                            /*
                               skip_mac_check is only asserted for a depdendent
                               spec rd. If this bit is set, the a demand
                               dependent Rd was returned with skip_mac_check =
                               1
                            */
    UINT32 rt_txscr_south_of : 1;

                            /* Bits[21:21], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_txscr_south_uf : 1;

                            /* Bits[22:22], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_txscr_south_mcp_viol : 1;

                            /* Bits[23:23], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_txscr_north_of : 1;

                            /* Bits[24:24], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_txscr_north_uf : 1;

                            /* Bits[25:25], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_txscr_north_mcp_viol : 1;

                            /* Bits[26:26], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_rxscr_south_of : 1;

                            /* Bits[27:27], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_rxscr_south_uf : 1;

                            /* Bits[28:28], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_rxscr_south_mcp_viol : 1;

                            /* Bits[29:29], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_rxscr_north_of : 1;

                            /* Bits[30:30], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_rxscr_north_uf : 1;

                            /* Bits[31:31], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */

  } Bits;
  UINT32 Data;

} INTERNAL_ERROR_DP_N0_MCDDC_DP_SPRUCC_STRUCT;
#endif /* (SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rrd_bad_rd_return : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /* Wrong number of data cycles */
    UINT32 rrd_bad_ddrt_viral : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /* Wrong DDRT viral */
    UINT32 wdb_data_fifo_full : 1;

                            /* Bits[2:2], Access Type=RO/V, default=0x00000000*/

                            /* WDB data FIFO full */
    UINT32 wdb_ufill_of : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000000*/

                            /* WDB ufill storage overflow */
    UINT32 wdb_alloc_put_collide : 1;

                            /* Bits[4:4], Access Type=RO/V, default=0x00000000*/

                            /* WDB cmd collision */
    UINT32 wdb_unexp_prmrr : 1;

                            /* Bits[5:5], Access Type=RO/V, default=0x00000000*/

                            /* Unexpected PRMRR programming */
    UINT32 wdb_illegal_rf_write : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000000*/

                            /* WDB illegal RF write */
    UINT32 wdb_unexp_deprd_error : 1;

                            /* Bits[7:7], Access Type=RO/V, default=0x00000000*/

                            /* Unexpected error from deprd */
    UINT32 wdb_unexp_deprd_error2 : 1;

                            /* Bits[8:8], Access Type=RO/V, default=0x00000000*/

                            /* Unexpected error from deprd */
    UINT32 rt_ddrt_ufill_entry_wrong : 1;

                            /* Bits[9:9], Access Type=RO/V, default=0x00000000*/

                            /* Wrong DDRT entry */
    UINT32 cpl_fab_credit_error : 1;

                            /* Bits[10:10], Access Type=RO/V, default=0x00000000*/

                            /* Fabric credit error */
    UINT32 wdb_spr_ufill_err : 1;

                            /* Bits[11:11], Access Type=RO/V, default=0x00000000*/

                            /* WDB internal error */
    UINT32 rt_unexp_sched_active : 1;

                            /* Bits[12:12], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_unexp_alert_active : 1;

                            /* Bits[13:13], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rrd_corr_fast_path_rd_vld : 1;

                            /* Bits[14:14], Access Type=RO/V, default=0x00000000*/

                            /* RRD internal error */
    UINT32 rrd_malformed_rdvalid : 1;

                            /* Bits[15:15], Access Type=RO/V, default=0x00000000*/

                            /* RRD internal error */
    UINT32 rrd_eridblock_nordvalid : 1;

                            /* Bits[16:16], Access Type=RO/V, default=0x00000000*/

                            /* RRD internal error */
    UINT32 rt_rdbfifo_of : 1;

                            /* Bits[17:17], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_unexp_ddrt_wrni : 1;

                            /* Bits[18:18], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_adddcplusone_no_dev_sub : 1;

                            /* Bits[19:19], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 wdb_skip_mac_check_from_nonspec_rd_err : 1;

                            /* Bits[20:20], Access Type=RO/V, default=0x00000000*/

                            /*
                               skip_mac_check is only asserted for a depdendent
                               spec rd. If this bit is set, the a demand
                               dependent Rd was returned with skip_mac_check =
                               1
                            */
    UINT32 rsvd : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} INTERNAL_ERROR_DP_N0_MCDDC_DP_STRUCT;

/* INTERNAL_ERROR_DP_N1_MCDDC_DP_REG supported on:                              */
/*      SPRA0 (0x20022e04)                                                      */
/*      SPRB0 (0x20022e04)                                                      */
/*      SPRHBM (0x20022e04)                                                     */
/*      SPRC0 (0x20022e04)                                                      */
/*      SPRMCC (0x20022e04)                                                     */
/*      SPRUCC (0x20022e04)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains internal errors from mcdp
*/


#define INTERNAL_ERROR_DP_N1_MCDDC_DP_REG 0x0B122E04

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 32;

                            /* Bits[31:0], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} INTERNAL_ERROR_DP_N1_MCDDC_DP_SPRA0_SPRB0_SPRHBM_SPRC0_SPRMCC_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) */

#if defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rt_rxscr_north_mcp_viol : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_txscr_sch0_of_ddrt : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_txscr_sch0_uf_ddrt : 1;

                            /* Bits[2:2], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_txscr_sch0_mcp_viol_ddrt : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_txscr_sch1_of_ddrt : 1;

                            /* Bits[4:4], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_txscr_sch1_uf_ddrt : 1;

                            /* Bits[5:5], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rt_txscr_sch1_mcp_viol_ddrt : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000000*/

                            /* RT internal error */
    UINT32 rsvd : 25;

                            /* Bits[31:7], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} INTERNAL_ERROR_DP_N1_MCDDC_DP_SPRUCC_STRUCT;
#endif /* (SPRUCC_HOST) */

/* DIS_INTERNAL_ERROR_DP_N0_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x20022e08)                                                      */
/*      SPRB0 (0x20022e08)                                                      */
/*      SPRHBM (0x20022e08)                                                     */
/*      SPRC0 (0x20022e08)                                                      */
/*      SPRMCC (0x20022e08)                                                     */
/*      SPRUCC (0x20022e08)                                                     */
/* Register default value on SPRA0: 0x00100000                                  */
/* Register default value on SPRB0: 0x00100000                                  */
/* Register default value on SPRHBM: 0x00100000                                 */
/* Register default value on SPRC0: 0x00100000                                  */
/* Register default value on SPRMCC: 0x00100000                                 */
/* Register default value on SPRUCC: 0x00100000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains disable bits for internal errors from mcdp
*/


#define DIS_INTERNAL_ERROR_DP_N0_MCDDC_DP_REG 0x0B122E08

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_rrd_bad_rd_return : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by wrong number of data
                               cycles
                            */
    UINT32 dis_rrd_bad_ddrt_viral : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Disable error caused by wrong DDRT viral */
    UINT32 dis_wdb_data_fifo_full : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Disable error caused by WDB data FIFO full */
    UINT32 dis_wdb_ufill_of : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by WDB ufill storage
                               overflow
                            */
    UINT32 dis_wdb_alloc_put_collide : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Disable error caused by WDB cmd collision */
    UINT32 dis_wdb_unexp_prmrr : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by unexpected PRMRR
                               programming
                            */
    UINT32 dis_wdb_illegal_rf_write : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* Disable error caused by WDB illegal RF write */
    UINT32 dis_wdb_unexp_deprd_error : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by unexpected error for
                               deprd
                            */
    UINT32 dis_wdb_unexp_deprd_error2 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by unexpected error for
                               deprd
                            */
    UINT32 dis_rt_ddrt_ufill_entry_wrong : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* Disable error caused by wrong DDRT entry */
    UINT32 dis_cpl_fab_credit_error : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_wdb_spr_ufill_err : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_unexp_sched_active : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_unexp_alert_active : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rrd_corr_fast_path_rd_vld : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rrd_malformed_rdvalid : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rrd_eridblock_nordvalid : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_rdbfifo_of : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_unexp_ddrt_wrni : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_adddcplusone_no_dev_sub : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_wdb_skip_mac_check_from_nonspec_rd_err : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000001*/

                            /*
                               Disable correspoding to error logging for a
                               skip_mac_check returned for a non-spec rd. Only
                               speculative Dependent RDs are expected to return
                               a skip_mac_check
                            */
    UINT32 rsvd : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIS_INTERNAL_ERROR_DP_N0_MCDDC_DP_SPRA0_SPRB0_SPRHBM_SPRC0_SPRMCC_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) */

#if defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_rrd_bad_rd_return : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by wrong number of data
                               cycles
                            */
    UINT32 dis_rrd_bad_ddrt_viral : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Disable error caused by wrong DDRT viral */
    UINT32 dis_wdb_data_fifo_full : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Disable error caused by WDB data FIFO full */
    UINT32 dis_wdb_ufill_of : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by WDB ufill storage
                               overflow
                            */
    UINT32 dis_wdb_alloc_put_collide : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Disable error caused by WDB cmd collision */
    UINT32 dis_wdb_unexp_prmrr : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by unexpected PRMRR
                               programming
                            */
    UINT32 dis_wdb_illegal_rf_write : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* Disable error caused by WDB illegal RF write */
    UINT32 dis_wdb_unexp_deprd_error : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by unexpected error for
                               deprd
                            */
    UINT32 dis_wdb_unexp_deprd_error2 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by unexpected error for
                               deprd
                            */
    UINT32 dis_rt_ddrt_ufill_entry_wrong : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* Disable error caused by wrong DDRT entry */
    UINT32 dis_cpl_fab_credit_error : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_wdb_spr_ufill_err : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_unexp_sched_active : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_unexp_alert_active : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rrd_corr_fast_path_rd_vld : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rrd_malformed_rdvalid : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rrd_eridblock_nordvalid : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_rdbfifo_of : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_unexp_ddrt_wrni : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_adddcplusone_no_dev_sub : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_wdb_skip_mac_check_from_nonspec_rd_err : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000001*/

                            /*
                               Disable correspoding to error logging for a
                               skip_mac_check returned for a non-spec rd. Only
                               speculative Dependent RDs are expected to return
                               a skip_mac_check
                            */
    UINT32 dis_rt_txscr_south_of : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_txscr_south_uf : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_txscr_south_mcp_viol : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_txscr_north_of : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_txscr_north_uf : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_txscr_north_mcp_viol : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_rxscr_south_of : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_rxscr_south_uf : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_rxscr_south_mcp_viol : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_rxscr_north_of : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_rxscr_north_uf : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */

  } Bits;
  UINT32 Data;

} DIS_INTERNAL_ERROR_DP_N0_MCDDC_DP_SPRUCC_STRUCT;
#endif /* (SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_rrd_bad_rd_return : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by wrong number of data
                               cycles
                            */
    UINT32 dis_rrd_bad_ddrt_viral : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Disable error caused by wrong DDRT viral */
    UINT32 dis_wdb_data_fifo_full : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Disable error caused by WDB data FIFO full */
    UINT32 dis_wdb_ufill_of : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by WDB ufill storage
                               overflow
                            */
    UINT32 dis_wdb_alloc_put_collide : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Disable error caused by WDB cmd collision */
    UINT32 dis_wdb_unexp_prmrr : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by unexpected PRMRR
                               programming
                            */
    UINT32 dis_wdb_illegal_rf_write : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* Disable error caused by WDB illegal RF write */
    UINT32 dis_wdb_unexp_deprd_error : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by unexpected error for
                               deprd
                            */
    UINT32 dis_wdb_unexp_deprd_error2 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by unexpected error for
                               deprd
                            */
    UINT32 dis_rt_ddrt_ufill_entry_wrong : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* Disable error caused by wrong DDRT entry */
    UINT32 dis_cpl_fab_credit_error : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_wdb_spr_ufill_err : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_unexp_sched_active : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_unexp_alert_active : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rrd_corr_fast_path_rd_vld : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rrd_malformed_rdvalid : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rrd_eridblock_nordvalid : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_rdbfifo_of : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_unexp_ddrt_wrni : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_adddcplusone_no_dev_sub : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_wdb_skip_mac_check_from_nonspec_rd_err : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000001*/

                            /*
                               Disable correspoding to error logging for a
                               skip_mac_check returned for a non-spec rd. Only
                               speculative Dependent RDs are expected to return
                               a skip_mac_check
                            */
    UINT32 rsvd : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIS_INTERNAL_ERROR_DP_N0_MCDDC_DP_STRUCT;

/* DIS_INTERNAL_ERROR_DP_N1_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x20022e0c)                                                      */
/*      SPRB0 (0x20022e0c)                                                      */
/*      SPRHBM (0x20022e0c)                                                     */
/*      SPRC0 (0x20022e0c)                                                      */
/*      SPRMCC (0x20022e0c)                                                     */
/*      SPRUCC (0x20022e0c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains disable bits for internal errors from mcdp
*/


#define DIS_INTERNAL_ERROR_DP_N1_MCDDC_DP_REG 0x0B122E0C

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 32;

                            /* Bits[31:0], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIS_INTERNAL_ERROR_DP_N1_MCDDC_DP_SPRA0_SPRB0_SPRHBM_SPRC0_SPRMCC_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) */

#if defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_rt_rxscr_north_mcp_viol : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_txscr_sch0_of_ddrt : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_txscr_sch0_uf_ddrt : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_txscr_sch0_mcp_viol_ddrt : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_txscr_sch1_of_ddrt : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_txscr_sch1_uf_ddrt : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 dis_rt_txscr_sch1_mcp_viol_ddrt : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Disable correspoding error in internal_error_dp
                               register
                            */
    UINT32 rsvd : 25;

                            /* Bits[31:7], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIS_INTERNAL_ERROR_DP_N1_MCDDC_DP_SPRUCC_STRUCT;
#endif /* (SPRUCC_HOST) */

/* DFT_RDRET_CONTROL_MCDDC_DP_REG supported on:                                 */
/*      SPRA0 (0x20022e4c)                                                      */
/*      SPRB0 (0x20022e4c)                                                      */
/*      SPRHBM (0x20022e4c)                                                     */
/*      SPRC0 (0x20022e4c)                                                      */
/*      SPRMCC (0x20022e4c)                                                     */
/*      SPRUCC (0x20022e4c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* controls dft features for read data return path
*/


#define DFT_RDRET_CONTROL_MCDDC_DP_REG 0x0B122E4C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               enable bit for this DFT feature. force data
                               return using the pattern from
                               dft_rdret_control.pattern, and also force the
                               read cmd to be dummy type on spid.
                            */
    UINT32 pattern : 8;

                            /* Bits[8:1], Access Type=RW, default=0x00000000*/

                            /*
                               this register hold the data pattern to be
                               returned when this feature is enabled; this
                               8-bit field is copied onto all data bytes.
                            */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DFT_RDRET_CONTROL_MCDDC_DP_STRUCT;

/* RETRY_RD_ERR_SET2_LOG_MCDDC_DP_REG supported on:                             */
/*      SPRA0 (0x20022e54)                                                      */
/*      SPRB0 (0x20022e54)                                                      */
/*      SPRHBM (0x20022e54)                                                     */
/*      SPRC0 (0x20022e54)                                                      */
/*      SPRMCC (0x20022e54)                                                     */
/*      SPRUCC (0x20022e54)                                                     */
/* Register default value on SPRA0: 0x0000E000                                  */
/* Register default value on SPRB0: 0x0000E000                                  */
/* Register default value on SPRHBM: 0x0000E000                                 */
/* Register default value on SPRC0: 0x0000E000                                  */
/* Register default value on SPRMCC: 0x0000E000                                 */
/* Register default value on SPRUCC: 0x0000E000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads
*/


#define RETRY_RD_ERR_SET2_LOG_MCDDC_DP_REG 0x0B122E54

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 v : 1;

                            /* Bits[0:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               The contents of this register have valid data as
                               well as RETRY_RD_ERR_LOG_PARITY,
                               RETRY_RD_ERR_LOG_MISC,
                               RETRY_RD_ERR_LOG_ADDRESS1, and
                               RETRY_RD_ERR_LOG_ADDRESS2.
                            */
    UINT32 uc : 1;

                            /* Bits[1:1], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Uncorrectable error. Logs cannot be overwritten
                               while UC is set. This bit is not controlled by
                               MC, but by a lock indication from HA.
                            */
    UINT32 over : 1;

                            /* Bits[2:2], Access Type=RW/V/P, default=0x00000000*/

                            /* The log has been overwritten. */
    UINT32 mode : 4;

                            /* Bits[6:3], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               indicate the ecc mode the register is logging
                               for : 4b0000 => sddc 2LM 4b0001 => sddc 1LM
                               4b0010 => sddc +1 2LM 4b0011 => sddc +1 1LM
                               4b0100 => adddc 2LM 4b0101 => adddc 1LM 4b0110
                               => adddc +1 2LM 4b0111 => adddc +1 1LM 4b1000 =>
                               read is from ddrt dimm 4b1001 => x8 sddc 4b1010
                               => x8 sddc +1 4b1011 => not a valid ecc mode
                            */
    UINT32 corr_err : 1;

                            /* Bits[7:7], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but was
                               not able to correct hte error => DUE
                            */
    UINT32 corr_noerr : 1;

                            /* Bits[8:8], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but no
                               ecc error was detected
                            */
    UINT32 corr_correctable : 1;

                            /* Bits[9:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction and
                               detect a correctable ecc error and corrected
                            */
    UINT32 corr_correctable_par_dev : 1;

                            /* Bits[10:10], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction, error
                               was in parity device which consider a
                               correctable error
                            */
    UINT32 ecc_err : 1;

                            /* Bits[11:11], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, the ecc error indication
                               sent to m2m
                            */
    UINT32 patspr : 1;

                            /* Bits[12:12], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if we have logged a patrol/spare
                               error. If patspr=1 we have logged patrol/spare
                               error.
                            */
    UINT32 en_patspr : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000001*/

                            /*
                               If en_patspr=1: Log patrol/sparing errors and
                               NOT demand/ufill reads; if en_patspr=0: Log
                               demand/ufill reads and NOT patrol/sparing.
                               Default is to log patrol/sparing errors.
                            */
    UINT32 noover : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /*
                               Lock register after the first error, do not
                               overflow.
                            */
    UINT32 en : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000001*/

                            /* Enable error logging. Will log on every retry. */
    UINT32 col_correction : 1;

                            /* Bits[16:16], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this field indicate a column correction vs the
                               device correction and can only be set for 1lm
                               adddc mode
                            */
    UINT32 single_bit_error : 1;

                            /* Bits[17:17], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if there was a single bit correction -
                               SDDC and SDDC +1 modes, used in PCLS
                            */
    UINT32 transfer_number : 3;

                            /* Bits[20:18], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates Transfer number of the single bit
                               correction,used in PCLS
                            */
    UINT32 persistent_error : 1;

                            /* Bits[21:21], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates persistent error indicated by BIST,
                               used in PCLS for HBM
                            */
    UINT32 system_addr_valid : 1;

                            /* Bits[22:22], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates there is valid system address in the
                               retry_rd_err_address3_log register
                            */
    UINT32 mirror : 1;

                            /* Bits[23:23], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the transaction is mirrored or non-
                               mirrored
                            */
    UINT32 mirror_pri : 1;

                            /* Bits[24:24], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               primary channel
                            */
    UINT32 mirror_failover : 1;

                            /* Bits[25:25], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               failed over channel
                            */
    UINT32 ecc_bist_valid : 1;

                            /* Bits[26:26], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that ECCBIST is enabled. The fields
                               ecc_bist_errtype and ecc_bist_corr_err_devnum
                               are only valid if this is true
                            */
    UINT32 ddrt_modeb_uc : 1;

                            /* Bits[27:27], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that in DDRT ECC mode B - The
                               correction fsm indicates correctable but the
                               failed device doesnt match the one identified by
                               BIOS. So we mark the result as UC
                            */
    UINT32 ecc_bist_errtype_upper : 2;

                            /* Bits[29:28], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the err type for the BIST result for
                               upper 32 byte for HBM mode. Valid only if
                               ecc_bist_valid field is true in the
                               retry_rd_err_log. BIST Result No Error = 2'b00
                               BIST Result Uncorrectable = 2'b01 BIST Result
                               Correctable = 2'b10 BIST Result Not Available
                               (req_length = 1) = 2'b11
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET2_LOG_MCDDC_DP_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 v : 1;

                            /* Bits[0:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               The contents of this register have valid data as
                               well as RETRY_RD_ERR_LOG_PARITY,
                               RETRY_RD_ERR_LOG_MISC,
                               RETRY_RD_ERR_LOG_ADDRESS1, and
                               RETRY_RD_ERR_LOG_ADDRESS2.
                            */
    UINT32 uc : 1;

                            /* Bits[1:1], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Uncorrectable error. Logs cannot be overwritten
                               while UC is set. This bit is not controlled by
                               MC, but by a lock indication from HA.
                            */
    UINT32 over : 1;

                            /* Bits[2:2], Access Type=RW/V/P, default=0x00000000*/

                            /* The log has been overwritten. */
    UINT32 mode : 4;

                            /* Bits[6:3], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               indicate the ecc mode the register is logging
                               for : 4b0000 => sddc 2LM 4b0001 => sddc 1LM
                               4b0010 => sddc +1 2LM 4b0011 => sddc +1 1LM
                               4b0100 => adddc 2LM 4b0101 => adddc 1LM 4b0110
                               => adddc +1 2LM 4b0111 => adddc +1 1LM 4b1000 =>
                               read is from ddrt dimm 4b1001 => x8 sddc 4b1010
                               => x8 sddc +1 4b1011 => not a valid ecc mode
                            */
    UINT32 corr_err : 1;

                            /* Bits[7:7], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but was
                               not able to correct hte error => DUE
                            */
    UINT32 corr_noerr : 1;

                            /* Bits[8:8], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but no
                               ecc error was detected
                            */
    UINT32 corr_correctable : 1;

                            /* Bits[9:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction and
                               detect a correctable ecc error and corrected
                            */
    UINT32 corr_correctable_par_dev : 1;

                            /* Bits[10:10], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction, error
                               was in parity device which consider a
                               correctable error
                            */
    UINT32 ecc_err : 1;

                            /* Bits[11:11], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, the ecc error indication
                               sent to m2m
                            */
    UINT32 patspr : 1;

                            /* Bits[12:12], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if we have logged a patrol/spare
                               error. If patspr=1 we have logged patrol/spare
                               error.
                            */
    UINT32 en_patspr : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000001*/

                            /*
                               If en_patspr=1: Log patrol/sparing errors and
                               NOT demand/ufill reads; if en_patspr=0: Log
                               demand/ufill reads and NOT patrol/sparing.
                               Default is to log patrol/sparing errors.
                            */
    UINT32 noover : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /*
                               Lock register after the first error, do not
                               overflow.
                            */
    UINT32 en : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000001*/

                            /* Enable error logging. Will log on every retry. */
    UINT32 col_correction : 1;

                            /* Bits[16:16], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this field indicate a column correction vs the
                               device correction and can only be set for 1lm
                               adddc mode
                            */
    UINT32 single_bit_error : 1;

                            /* Bits[17:17], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if there was a single bit correction -
                               SDDC and SDDC +1 modes, used in PCLS
                            */
    UINT32 transfer_number : 4;

                            /* Bits[21:18], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates Transfer number of the single bit
                               correction,used in PCLS
                            */
    UINT32 persistent_error : 1;

                            /* Bits[22:22], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates persistent error indicated by BIST,
                               used in PCLS for HBM
                            */
    UINT32 system_addr_valid : 1;

                            /* Bits[23:23], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates there is valid system address in the
                               retry_rd_err_address3_log register
                            */
    UINT32 mirror : 1;

                            /* Bits[24:24], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the transaction is mirrored or non-
                               mirrored
                            */
    UINT32 mirror_pri : 1;

                            /* Bits[25:25], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               primary channel
                            */
    UINT32 mirror_failover : 1;

                            /* Bits[26:26], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               failed over channel
                            */
    UINT32 ecc_bist_valid : 1;

                            /* Bits[27:27], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that ECCBIST is enabled. The fields
                               ecc_bist_errtype and ecc_bist_corr_err_devnum
                               are only valid if this is true
                            */
    UINT32 ddrt_modeb_uc : 1;

                            /* Bits[28:28], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that in DDRT ECC mode B - The
                               correction fsm indicates correctable but the
                               failed device doesnt match the one identified by
                               BIOS. So we mark the result as UC
                            */
    UINT32 ecc_bist_errtype_upper : 2;

                            /* Bits[30:29], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the err type for the BIST result for
                               upper 32 byte for HBM mode. Valid only if
                               ecc_bist_valid field is true in the
                               retry_rd_err_log. BIST Result No Error = 2'b00
                               BIST Result Uncorrectable = 2'b01 BIST Result
                               Correctable = 2'b10 BIST Result Not Available
                               (req_length = 1) = 2'b11
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET2_LOG_MCDDC_DP_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 v : 1;

                            /* Bits[0:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               The contents of this register have valid data as
                               well as RETRY_RD_ERR_LOG_PARITY,
                               RETRY_RD_ERR_LOG_MISC,
                               RETRY_RD_ERR_LOG_ADDRESS1, and
                               RETRY_RD_ERR_LOG_ADDRESS2.
                            */
    UINT32 uc : 1;

                            /* Bits[1:1], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Uncorrectable error. Logs cannot be overwritten
                               while UC is set. This bit is not controlled by
                               MC, but by a lock indication from HA.
                            */
    UINT32 over : 1;

                            /* Bits[2:2], Access Type=RW/V/P, default=0x00000000*/

                            /* The log has been overwritten. */
    UINT32 mode : 4;

                            /* Bits[6:3], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               indicate the ecc mode the register is logging
                               for : 4b0000 => sddc 2LM 4b0001 => sddc 1LM
                               4b0010 => sddc +1 2LM 4b0011 => sddc +1 1LM
                               4b0100 => adddc 2LM 4b0101 => adddc 1LM 4b0110
                               => adddc +1 2LM 4b0111 => adddc +1 1LM 4b1000 =>
                               read is from ddrt dimm 4b1001 => x8 sddc 4b1010
                               => x8 sddc +1 4b1011 => not a valid ecc mode
                            */
    UINT32 corr_err : 1;

                            /* Bits[7:7], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but was
                               not able to correct hte error => DUE
                            */
    UINT32 corr_noerr : 1;

                            /* Bits[8:8], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but no
                               ecc error was detected
                            */
    UINT32 corr_correctable : 1;

                            /* Bits[9:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction and
                               detect a correctable ecc error and corrected
                            */
    UINT32 corr_correctable_par_dev : 1;

                            /* Bits[10:10], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction, error
                               was in parity device which consider a
                               correctable error
                            */
    UINT32 ecc_err : 1;

                            /* Bits[11:11], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, the ecc error indication
                               sent to m2m
                            */
    UINT32 patspr : 1;

                            /* Bits[12:12], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if we have logged a patrol/spare
                               error. If patspr=1 we have logged patrol/spare
                               error.
                            */
    UINT32 en_patspr : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000001*/

                            /*
                               If en_patspr=1: Log patrol/sparing errors and
                               NOT demand/ufill reads; if en_patspr=0: Log
                               demand/ufill reads and NOT patrol/sparing.
                               Default is to log patrol/sparing errors.
                            */
    UINT32 noover : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /*
                               Lock register after the first error, do not
                               overflow.
                            */
    UINT32 en : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000001*/

                            /* Enable error logging. Will log on every retry. */
    UINT32 col_correction : 1;

                            /* Bits[16:16], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this field indicate a column correction vs the
                               device correction and can only be set for 1lm
                               adddc mode
                            */
    UINT32 single_bit_error : 1;

                            /* Bits[17:17], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if there was a single bit correction -
                               SDDC and SDDC +1 modes, used in PCLS
                            */
    UINT32 transfer_number : 4;

                            /* Bits[21:18], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates Transfer number of the single bit
                               correction,used in PCLS
                            */
    UINT32 persistent_error : 1;

                            /* Bits[22:22], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates persistent error indicated by BIST,
                               used in PCLS for HBM
                            */
    UINT32 system_addr_valid : 1;

                            /* Bits[23:23], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates there is valid system address in the
                               retry_rd_err_address3_log register
                            */
    UINT32 mirror : 1;

                            /* Bits[24:24], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the transaction is mirrored or non-
                               mirrored
                            */
    UINT32 mirror_pri : 1;

                            /* Bits[25:25], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               primary channel. Value of this bit is irrelevant
                               if mirror bit is not set.
                            */
    UINT32 mirror_failover : 1;

                            /* Bits[26:26], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if the mirrored transaction is to
                               failed over channel
                            */
    UINT32 ecc_bist_valid : 1;

                            /* Bits[27:27], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that ECCBIST is enabled. The fields
                               ecc_bist_errtype and ecc_bist_corr_err_devnum
                               are only valid if this is true
                            */
    UINT32 ddrt_modeb_uc : 1;

                            /* Bits[28:28], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that in DDRT ECC mode B - The
                               correction fsm indicates correctable but the
                               failed device doesnt match the one identified by
                               BIOS. So we mark the result as UC
                            */
    UINT32 ecc_bist_errtype_upper : 2;

                            /* Bits[30:29], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the err type for the BIST result for
                               upper 32 byte for HBM mode. Valid only if
                               ecc_bist_valid field is true in the
                               retry_rd_err_log. BIST Result No Error = 2'b00
                               BIST Result Uncorrectable = 2'b01 BIST Result
                               Correctable = 2'b10 BIST Result Not Available
                               (req_length = 1) = 2'b11
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET2_LOG_MCDDC_DP_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 v : 1;

                            /* Bits[0:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               The contents of this register have valid data as
                               well as RETRY_RD_ERR_LOG_PARITY,
                               RETRY_RD_ERR_LOG_MISC,
                               RETRY_RD_ERR_LOG_ADDRESS1, and
                               RETRY_RD_ERR_LOG_ADDRESS2.
                            */
    UINT32 uc : 1;

                            /* Bits[1:1], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Uncorrectable error. Logs cannot be overwritten
                               while UC is set. This bit is not controlled by
                               MC, but by a lock indication from HA.
                            */
    UINT32 over : 1;

                            /* Bits[2:2], Access Type=RW/V/P, default=0x00000000*/

                            /* The log has been overwritten. */
    UINT32 mode : 4;

                            /* Bits[6:3], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               indicate the ecc mode the register is logging
                               for : 4b0000 => sddc 2LM 4b0001 => sddc 1LM
                               4b0010 => sddc +1 2LM 4b0011 => sddc +1 1LM
                               4b0100 => adddc 2LM 4b0101 => adddc 1LM 4b0110
                               => adddc +1 2LM 4b0111 => adddc +1 1LM 4b1000 =>
                               read is from ddrt dimm 4b1001 => x8 sddc 4b1010
                               => x8 sddc +1 4b1011 => not a valid ecc mode
                            */
    UINT32 corr_err : 1;

                            /* Bits[7:7], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but was
                               not able to correct hte error => DUE
                            */
    UINT32 corr_noerr : 1;

                            /* Bits[8:8], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction but no
                               ecc error was detected
                            */
    UINT32 corr_correctable : 1;

                            /* Bits[9:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction and
                               detect a correctable ecc error and corrected
                            */
    UINT32 corr_correctable_par_dev : 1;

                            /* Bits[10:10], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, entered correction, error
                               was in parity device which consider a
                               correctable error
                            */
    UINT32 ecc_err : 1;

                            /* Bits[11:11], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               During the last log, the ecc error indication
                               sent to m2m
                            */
    UINT32 patspr : 1;

                            /* Bits[12:12], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if we have logged a patrol/spare
                               error. If patspr=1 we have logged patrol/spare
                               error.
                            */
    UINT32 en_patspr : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000001*/

                            /*
                               If en_patspr=1: Log patrol/sparing errors and
                               NOT demand/ufill reads; if en_patspr=0: Log
                               demand/ufill reads and NOT patrol/sparing.
                               Default is to log patrol/sparing errors.
                            */
    UINT32 noover : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000001*/

                            /*
                               Lock register after the first error, do not
                               overflow.
                            */
    UINT32 en : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000001*/

                            /* Enable error logging. Will log on every retry. */
    UINT32 col_correction : 1;

                            /* Bits[16:16], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this field indicate a column correction vs the
                               device correction and can only be set for 1lm
                               adddc mode
                            */
    UINT32 single_bit_error : 1;

                            /* Bits[17:17], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates if there was a single bit correction -
                               SDDC and SDDC +1 modes, used in PCLS
                            */
    UINT32 rsvd : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET2_LOG_MCDDC_DP_STRUCT;

/* RETRY_RD_ERR_SET2_LOG_ADDRESS1_MCDDC_DP_REG supported on:                    */
/*      SPRA0 (0x20022e58)                                                      */
/*      SPRB0 (0x20022e58)                                                      */
/*      SPRHBM (0x20022e58)                                                     */
/*      SPRC0 (0x20022e58)                                                      */
/*      SPRMCC (0x20022e58)                                                     */
/*      SPRUCC (0x20022e58)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG.
        The values in this register indicate the address of failed device. failed device id, chip select, cbit, bank   
        DDR     : Decoded Address: Rank[2:0], BG, BA, Row Col
        DDR 3DS : Decoded Address: Rank[2], Rank[0], SubRank[2:0], BG, BA Row Col
        HBM     : Decoded Address: Rank[1:0](for SID and PCH resp), BA, BG, Row, column --> No SubRank field 
      
*/


#define RETRY_RD_ERR_SET2_LOG_ADDRESS1_MCDDC_DP_REG 0x0B122E58

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 failed_dev : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Holds the failed device number: for
                               sddc/ddrt/HBM the device number is between 0-17.
                               for adddc device number between 0-16 and 18-35
                               dev 17 is the spare device. for HBM mode, value
                               of 31 means there is no error; also this is
                               failed device number for first 32 bytes.
                            */
    UINT32 chip_select : 3;

                            /* Bits[8:6], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Rank CS0-CS7 (encoded chip select) of retried
                               read
                            */
    UINT32 cbit : 5;

                            /* Bits[13:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               C0-C2 (encoded subrank) for last retry. Bit 12
                               is spare to accomodate for future growth in DDR5
                               Logged value is {2'b0,cbit[2:0]} For HBM mode,
                               indicates the device number for the correctable
                               error signaled by BIST for upper 32 bytes. Valid
                               only when ecc_bist_valid is true and
                               ecc_bist_errtype_upper is correctable.
                            */
    UINT32 bank : 6;

                            /* Bits[19:14], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Bank ID for last retry. Bottom three bits are
                               Bank Group, top two bits are Bank Address Logged
                               value is {1'b0,bank_group[2],bank_address[1:0],b
                               ank_group[1:0]} Bit 18 is spare to accomodate
                               for future growth in DDR5
                            */
    UINT32 col : 10;

                            /* Bits[29:20], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Column address for the last retry Logged value
                               is DDR - {2'b0,Column_addr[9:3],1'b0}.
                               Column_addr[2] indicates Critical chunk, so
                               making that as 0 HBM - {2'b0,Column_addr[9:2]}
                               Bits 9 and 8 as spare to accomodate possible
                               future growth in size for DDR5 In DDR - Actual
                               Column address = {Column_addr[9:3],3'b0}
                               Column_addr[2] indicates Critical chunk In HBM -
                               Actual Column address = {Column_addr[9:2],2'b0}
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET2_LOG_ADDRESS1_MCDDC_DP_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 failed_dev : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Holds the failed device number: for
                               sddc/ddrt/HBM the device number is between 0-17.
                               for adddc device number between 0-16 and 18-35
                               dev 17 is the spare device. for HBM mode, value
                               of 31 means there is no error; also this is
                               failed device number for first 32 bytes.
                            */
    UINT32 chip_select : 3;

                            /* Bits[8:6], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Rank CS0-CS7 (encoded chip select) of retried
                               read
                            */
    UINT32 cbit : 5;

                            /* Bits[13:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               C0-C2 (encoded subrank) for last retry. Bit 12
                               is spare to accomodate for future growth in DDR5
                               Logged value is {2'b0,cbit[2:0]} For HBM mode,
                               indicates the device number for the correctable
                               error signaled by BIST for upper 32 bytes. Valid
                               only when ecc_bist_valid is true and
                               ecc_bist_errtype_upper is correctable.
                            */
    UINT32 bank : 6;

                            /* Bits[19:14], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Bank ID for last retry. Bottom three bits are
                               Bank Group, top two bits are Bank Address Logged
                               value is {1'b0,bank_group[2],bank_address[1:0],b
                               ank_group[1:0]} Bit 18 is spare to accomodate
                               for future growth in DDR5
                            */
    UINT32 col : 10;

                            /* Bits[29:20], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Column address for the last retry Logged value
                               is DDR - {2'b0,Column_addr[9:3],1'b0}.
                               Column_addr[2] indicates Critical chunk, so
                               making that as 0 HBM - {2'b0,Column_addr[9:2]}
                               Bits 9 and 8 as spare to accomodate possible
                               future growth in size for DDR5 In DDR - Actual
                               Column address = {Column_addr[9:3],3'b0}
                               Column_addr[2] indicates Critical chunk In HBM -
                               Actual Column address = {Column_addr[9:2],2'b0}
                            */
    UINT32 rsvd_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET2_LOG_ADDRESS1_MCDDC_DP_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 failed_dev : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Holds the failed device number: for sddc/ddrt
                               the device number is between 0-9. for adddc
                               device number between 0-8 and 10-19 with dev 9
                               being the spare device. for HBM mode, device
                               number is between 0-17, with value of 31 means
                               there is no error; also this is failed device
                               number for first 32 bytes with 32B ECC mode.
                               This field is only valid with correctable error
                               of the type device correction.
                            */
    UINT32 chip_select : 3;

                            /* Bits[8:6], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Rank CS0-CS7 (encoded chip select) of retried
                               read
                            */
    UINT32 cbit : 5;

                            /* Bits[13:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               C0-C2 (encoded subrank) for last retry. Bit 12
                               is spare to accomodate for future growth Logged
                               value is {2'b0,cbit[2:0]} For HBM mode,
                               indicates the device number for the correctable
                               error signaled by BIST for upper 32 bytes. Valid
                               only when ecc_bist_valid is true and
                               ecc_bist_errtype_upper is correctable.
                            */
    UINT32 bank : 6;

                            /* Bits[19:14], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Bank ID for last retry. Logged value is {1'b0,ba
                               nk_group[2],bank_address[1:0],bank_group[1:0]}
                               Bit 18 is spare to accomodate for future growth
                            */
    UINT32 col : 10;

                            /* Bits[29:20], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Column address for the last retry Logged value
                               is DDR - {2'b0,Column_addr[9:3],1'b0}.
                               Column_addr[2] indicates Critical chunk, so
                               making that as 0 HBM - {2'b0,Column_addr[9:2]}
                               Bits 9 and 8 as spare to accomodate possible
                               future growth in size In DDR - Actual Column
                               address = {Column_addr[9:3],3'b0} Column_addr[2]
                               indicates Critical chunk In HBM - Actual Column
                               address = {Column_addr[9:2],2'b0}
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET2_LOG_ADDRESS1_MCDDC_DP_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 failed_dev : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Holds the failed device number: for
                               sddc/ddrt/HBM the device number is between 0-17.
                               for adddc device number between 0-16 and 18-35
                               dev 17 is the spare device. for HBM mode, value
                               of 31 means there is no error; also this is
                               failed device number for first 32 bytes.
                            */
    UINT32 chip_select : 3;

                            /* Bits[8:6], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Rank CS0-CS7 (encoded chip select) of retried
                               read
                            */
    UINT32 cbit : 5;

                            /* Bits[13:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               C0-C2 (encoded subrank) for last retry. Bit 12
                               is spare to accomodate for future growth in DDR5
                               Logged value is {2'b0,cbit[2:0]} For HBM mode,
                               indicates the device number for the correctable
                               error signaled by BIST for upper 32 bytes. Valid
                               only when ecc_bist_valid is true and
                               ecc_bist_errtype_upper is correctable.
                            */
    UINT32 bank : 6;

                            /* Bits[19:14], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Bank ID for last retry. Bottom three bits are
                               Bank Group, top two bits are Bank Address Logged
                               value is {1'b0,bank_group[2],bank_address[1:0],b
                               ank_group[1:0]} Bit 18 is spare to accomodate
                               for future growth in DDR5
                            */
    UINT32 col : 10;

                            /* Bits[29:20], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Column address for the last retry Logged value
                               is DDR - {2'b0,Column_addr[9:3],1'b0}.
                               Column_addr[2] indicates Critical chunk, so
                               making that as 0 HBM - {2'b0,Column_addr[9:2]}
                               Bits 9 and 8 as spare to accomodate possible
                               future growth in size for DDR5 In DDR - Actual
                               Column address = {Column_addr[9:3],3'b0}
                               Column_addr[2] indicates Critical chunk In HBM -
                               Actual Column address = {Column_addr[9:2],2'b0}
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET2_LOG_ADDRESS1_MCDDC_DP_STRUCT;

/* RETRY_RD_ERR_SET2_LOG_ADDRESS2_MCDDC_DP_REG supported on:                    */
/*      SPRA0 (0x20022e5c)                                                      */
/*      SPRB0 (0x20022e5c)                                                      */
/*      SPRHBM (0x20022e5c)                                                     */
/*      SPRC0 (0x20022e5c)                                                      */
/*      SPRMCC (0x20022e5c)                                                     */
/*      SPRUCC (0x20022e5c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG.
            Logged value is {3'b0,Row_addr[17:0]}
            Bits 20,19,18 are spares to accomodate for future growth in DDR5
      
*/


#define RETRY_RD_ERR_SET2_LOG_ADDRESS2_MCDDC_DP_REG 0x0B122E5C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 row : 18;

                            /* Bits[17:0], Access Type=RW/V/P, default=0x00000000*/

                            /* Row address for the last retry */
    UINT32 failed_dev_upper : 5;

                            /* Bits[22:18], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Holds the failed device number for HBM second 32
                               bytes, with a value between 0-17. Value of 31
                               means there is no error in these 32 bytes.
                            */
    UINT32 ecc_bist_errtype : 2;

                            /* Bits[24:23], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the err type for the BIST result.
                               Valid only if ecc_bist_valid field is true in
                               the retry_rd_err_log_set2. BIST Result No Error
                               = 2'b00 BIST Result Uncorrectable = 2'b01 BIST
                               Result Correctable = 2'b10 For HBM mode, this is
                               the type for lower 32 bytes.
                            */
    UINT32 ecc_bist_corr_err_devnum : 5;

                            /* Bits[29:25], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the device number for the correctable
                               error signaled by BIST. Valid only when
                               ecc_bist_valid is true and ecc_bist_errtype is
                               correctable. For HBM mode, this is the device
                               number for lower 32 bytes.
                            */
    UINT32 corr_fsm_errtype : 2;

                            /* Bits[31:30], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates the err type for the Corection fsm
                               result. Valid only if ecc_bist_valid field is
                               true. BIST Result No Error = 2'b00 BIST Result
                               Uncorrectable = 2'b01 BIST Result Correctable =
                               2'b10
                            */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET2_LOG_ADDRESS2_MCDDC_DP_STRUCT;

/* RETRY_RD_ERR_SET2_LOG_MISC_MCDDC_DP_REG supported on:                        */
/*      SPRA0 (0x20022e60)                                                      */
/*      SPRB0 (0x20022e60)                                                      */
/*      SPRHBM (0x20022e60)                                                     */
/*      SPRC0 (0x20022e60)                                                      */
/*      SPRMCC (0x20022e60)                                                     */
/*      SPRUCC (0x20022e60)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG
*/


#define RETRY_RD_ERR_SET2_LOG_MISC_MCDDC_DP_REG 0x0B122E60

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 plus1_loc_syn : 12;

                            /* Bits[11:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this register hold the value of plus1 locator
                               syndrome from correction path. the number of
                               plus1 LS bits are the same for all the plus1
                               modes
                            */
    UINT32 inter_loc_syn : 12;

                            /* Bits[23:12], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this register hold the value Intermediate
                               Locator Syndrome from correction path which are
                               only valid when the mode is sddc 1lm. Only valid
                               iff hard failure effect the IL bits. The
                               syndrome will indicate which bit is the failing
                               one
                            */
    UINT32 data_failed_col_num : 6;

                            /* Bits[29:24], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this register indicate the failed column number
                               over the data device. columns over data are
                               numbered from 0 to 63. this field is only valid
                               for 1LM ADDDC and when the column correction
                               indication is set in the retry_rd_err_log
                               register
                            */
    UINT32 meta_failed_col_num : 2;

                            /* Bits[31:30], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this register indicate the failed column number
                               over the metadata+locator device. bit 0 of this
                               field is set when column 0 has failed (value
                               01), while bit 1 of this field is set when
                               column 1 has failed (value 10). this field is
                               only valid for 1LM ADDDC and when the column
                               correction indication is set in the
                               retry_rd_err_log register
                            */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET2_LOG_MISC_MCDDC_DP_STRUCT;

#ifdef SPRA0_HOST
/* RETRY_RD_ERR_SET2_LOG_PARITY_MCDDC_DP_REG supported on:                      */
/*      SPRA0 (0x20022e64)                                                      */
/* Register default value on SPRA0: 0x00000000                                  */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG
*/


#define RETRY_RD_ERR_SET2_LOG_PARITY_MCDDC_DP_REG 0x0B122E64

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 par_syn : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               this register hold the parity syndrome(mask)
                               from correction path. for sddc/x8/ddrt parity
                               syndrome is 32 bits. but for 2LM adddc it is 16
                               bits so the 16 upper bits are always 0 for 2LM
                               adddc: 16 bits 0 + Parity Syndrome (16 bits). in
                               1LM adddc reused the 8 upper bits to log the
                               Parity Column Syndrome. so the order for 1LM
                               adddc will be: PC syn for upper half of CL
                               (4bits)+ PC syn for lower half of CL (4bits)+ 8
                               bits 0 + Parity Syndrome (16 bits)
                            */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET2_LOG_PARITY_MCDDC_DP_STRUCT;
#endif /* (SPRA0_HOST) */

/* PCLS_DEBUG_INFO_MCDDC_DP_REG supported on:                                   */
/*      SPRA0 (0x22e68)                                                         */
/*      SPRB0 (0x22e68)                                                         */
/*      SPRHBM (0x22e68)                                                        */
/*      SPRC0 (0x22e68)                                                         */
/*      SPRMCC (0x22e68)                                                        */
/*      SPRUCC (0x22e68)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This is updated when we log a PCLS Data parity error in the MCBank. 
            It contains the index for which the failure happened. Logging it here so as to not clutter the MCBank
*/


#define PCLS_DEBUG_INFO_MCDDC_DP_REG 0x0B102E68

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 v : 1;

                            /* Bits[0:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Valid bit indicates there is a valid pcls index
                               stored in this csr
                            */
    UINT8 pcls_index : 4;

                            /* Bits[4:1], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               PCLS Index for which a csr address parity error
                               or data parity error occurs.
                            */
    UINT8 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} PCLS_DEBUG_INFO_MCDDC_DP_STRUCT;

/* DDR4_VIRAL_CTL_MCDDC_DP_REG supported on:                                    */
/*      SPRA0 (0x20022e70)                                                      */
/*      SPRB0 (0x20022e70)                                                      */
/*      SPRHBM (0x20022e70)                                                     */
/*      SPRC0 (0x20022e70)                                                      */
/*      SPRMCC (0x20022e70)                                                     */
/*      SPRUCC (0x20022e70)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Bits to control viral signalling for DDR4 Errors
*/


#define DDR4_VIRAL_CTL_MCDDC_DP_REG 0x0B122E70

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_ha_wr_data_par_err : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for M2Mem write data
                               parity error for DDR4.
                            */
    UINT32 dis_wdb_fifo_err : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for WDB FIFO overflow
                               and underflow errors.
                            */
    UINT32 dis_ha_wr_be_par_err : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for M2Mem write data
                               byte enable parity error for DDR4.
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_wdb_par_err : 1;

                            /* Bits[4:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for DDR4 WDB parity
                               error.
                            */
    UINT32 rsvd_5 : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_rpq0_rpa_par_err : 1;

                            /* Bits[6:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for RPQ0 rpa parity
                               error.
                            */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_wpq_wpa_par_err : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for WPQ wpa parity
                               error.
                            */
    UINT32 dis_uncorr_pat_err : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for uncorrectable
                               patrol scurb error.
                            */
    UINT32 dis_uncorr_spr_err : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for uncorrectable
                               sparing error.
                            */
    UINT32 dis_appp_err : 1;

                            /* Bits[11:11], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering for APPP error. */
    UINT32 dis_fv_viral_bit : 1;

                            /* Bits[12:12], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for viral bit send from
                               FV.
                            */
    UINT32 dis_uncorr_demand_rd_err : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for Read ECC errors on
                               demand reads from m2mem. - NOT Patrol or Sparing
                            */
    UINT32 dis_uncorr_ufill_rd_err : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for Read ECC errors on
                               ufill reads - NOT Patrol or Sparing
                            */
    UINT32 dis_link_fail : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering for ddr4/ddrt link fail */
    UINT32 dis_hbmrddqparerr : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for HBM Read DQ Parity
                               Error
                            */
    UINT32 dis_hbmwrdqparerr : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for HBM Write DQ Parity
                               Error
                            */
    UINT32 dis_hbmcaperr : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering for HBM CAP Error */
    UINT32 dis_cmiucdataerr : 1;

                            /* Bits[19:19], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering for CMI UC Data Error */
    UINT32 dis_poison_err : 1;

                            /* Bits[20:20], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for sending poison to
                               m2m when poison was disabled
                            */
    UINT32 dis_cmi_illegal_opcode : 1;

                            /* Bits[21:21], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering for illegal cmi opcode */
    UINT32 dis_rpb_parity_err : 1;

                            /* Bits[22:22], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering for RPB parity error */
    UINT32 dis_pcls_csr_addr_parity_err : 1;

                            /* Bits[23:23], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for PCLS CSR Addr
                               Parity error
                            */
    UINT32 dis_ddrt_uc_ecc_err : 1;

                            /* Bits[24:24], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for DDRT uncorrectable
                               ECC error
                            */
    UINT32 dis_pcls_illegal_cfg_adddc_err : 1;

                            /* Bits[25:25], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for PCLS illegal
                               configuation with ADDDC error
                            */
    UINT32 dis_pcls_illegal_cfg_sddc_err : 1;

                            /* Bits[26:26], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for PCLS illegal
                               configuation with SDDC error
                            */
    UINT32 dis_cmi_rd_cpl_underflow_err : 1;

                            /* Bits[27:27], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for CMI rd_cpl
                               underflow
                            */
    UINT32 dis_cmi_rd_cpl_overflow_err : 1;

                            /* Bits[28:28], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering for CMI rd_cpl overflow */
    UINT32 dis_internal_error : 1;

                            /* Bits[29:29], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for various MC internal
                               errors
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDR4_VIRAL_CTL_MCDDC_DP_STRUCT;

/* LEAKY_BKT_2ND_CNTR_REG_MCDDC_DP_REG supported on:                            */
/*      SPRA0 (0x20022e78)                                                      */
/*      SPRB0 (0x20022e78)                                                      */
/*      SPRHBM (0x20022e78)                                                     */
/*      SPRC0 (0x20022e78)                                                      */
/*      SPRMCC (0x20022e78)                                                     */
/*      SPRUCC (0x20022e78)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Secondary Leaky Bucket Counter Limit
*/


#define LEAKY_BKT_2ND_CNTR_REG_MCDDC_DP_REG 0x0B122E78

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 leaky_bkt_2nd_cntr : 16;

                            /* Bits[15:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Per rank secondary leaky bucket counter (2b per
                               rank) bit 15:14: rank 7 secondary leaky bucket
                               counter bit 13:12: rank 6 secondary leaky bucket
                               counter bit 11:10: rank 5 secondary leaky bucket
                               counter bit 9:8: rank 4 secondary leaky bucket
                               counter bit 7:6: rank 3 secondary leaky bucket
                               counter bit 5:4: rank 2 secondary leaky bucket
                               counter bit 3:2: rank 1 secondary leaky bucket
                               counter bit 1:0: rank 0 secondary leaky bucket
                               counter
                            */
    UINT32 leaky_bkt_2nd_cntr_limit : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /*
                               Secondary Leaky Bucket Counter Limit (2b per
                               DIMM). This register defines secondary leaky
                               bucket counter limit for all 8 logical ranks
                               within channel. The counter logic will generate
                               the secondary LEAK pulse to decrement the ranks
                               correctable error counter by 1 when the
                               corresponding rank leaky bucket rank counter
                               roll over at the predefined counter limit. The
                               counter increment at the primary leak pulse from
                               the LEAKY_BUCKET_CNTR_LO and
                               LEAKY_BUCKET_CNTR_HI logic. Bit[31:30]: Rank 7
                               Secondary Leaky Bucket Counter Limit Bit[29:28]:
                               Rank 6 Secondary Leaky Bucket Counter Limit
                               Bit[27:26]: Rank 5 Secondary Leaky Bucket
                               Counter Limit Bit[25:24]: Rank 4 Secondary Leaky
                               Bucket Counter Limit Bit[23:22]: Rank 3
                               Secondary Leaky Bucket Counter Limit Bit[21:20]:
                               Rank 2 Secondary Leaky Bucket Counter Limit
                               Bit[19:18]: Rank 1 Secondary Leaky Bucket
                               Counter Limit Bit[17:16]: Rank 0 Secondary Leaky
                               Bucket Counter Limit The value of the limit is
                               defined as the following: 0: the LEAK pulse is
                               generated one DCLK after the primary LEAK pulse
                               is asserted. 1: the LEAK pulse is generated one
                               DCLK after the counter roll over at 1. 2: the
                               LEAK pulse is generated one DCLK after the
                               counter roll over at 2. 3: the LEAK pulse is
                               generated one DCLK after the counter roll over
                               at 3.
                            */

  } Bits;
  UINT32 Data;

} LEAKY_BKT_2ND_CNTR_REG_MCDDC_DP_STRUCT;

/* ECC_CORR_BIST_MCDDC_DP_REG supported on:                                     */
/*      SPRA0 (0x22e80)                                                         */
/*      SPRB0 (0x22e80)                                                         */
/*      SPRHBM (0x22e80)                                                        */
/*      SPRC0 (0x22e80)                                                         */
/*      SPRMCC (0x22e80)                                                        */
/*      SPRUCC (0x22e80)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000020                                  */
/* Register default value on SPRHBM: 0x00000020                                 */
/* Register default value on SPRC0: 0x00000020                                  */
/* Register default value on SPRMCC: 0x00000020                                 */
/* Register default value on SPRUCC: 0x00000020                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* BIST error status
*/


#define ECC_CORR_BIST_MCDDC_DP_REG 0x0B102E80

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 bist_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to indicate if the bist in the
                               ecc corr path is enabled.
                            */
    UINT8 bist_err_report_mode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to indicate if the bist would
                               work in Error reporting mode. In this mode, we
                               only log the BIST results, but they are not
                               considered to make the final decision in the ecc
                               correction path
                            */
    UINT8 bist_ce_corrfsm_noerr : 2;

                            /* Bits[3:2], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to program the final result for
                               the case when BISt gives CE and correction fsm
                               gives NoErorr. Values it can take are: 00 -> UC
                               01 -> CE 10 -> NoError
                            */
    UINT8 force_metaerror : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               When final result is UC and correction fsm is UC
                               - meta error follows the meta error indicated by
                               the correction fsm. This bit can be used to
                               force the meta error to 1 always when we have a
                               final result as UC when BISt is enabled.
                            */
    UINT8 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} ECC_CORR_BIST_MCDDC_DP_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 bist_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to indicate if the bist in the
                               ecc corr path is enabled.
                            */
    UINT8 bist_err_report_mode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to indicate if the bist would
                               work in Error reporting mode. In this mode, we
                               only log the BIST results, but they are not
                               considered to make the final decision in the ecc
                               correction path
                            */
    UINT8 bist_ce_corrfsm_noerr : 2;

                            /* Bits[3:2], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to program the final result for
                               the case when BISt gives CE and correction fsm
                               gives NoErorr. Values it can take are: 00 -> UC
                               01 -> CE 10 -> NoError
                            */
    UINT8 force_metaerror : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               When final result is UC and correction fsm is UC
                               - meta error follows the meta error indicated by
                               the correction fsm. This bit can be used to
                               force the meta error to 1 always when we have a
                               final result as UC when BISt is enabled.
                            */
    UINT8 bist_corr_mode : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*
                               When set to 1, BIST is used to correct single
                               device DUE case.
                            */
    UINT8 rsvd_6 : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 veeblockhabgf_stage_sel : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to select the signal stage for
                               VEEBlockHABgf; if set to 0, VEEFrcRdErrH007H
                               will be used. If set to 1, VEEBlockHABgfH002H
                               will be used.
                            */

  } Bits;
  UINT8 Data;

} ECC_CORR_BIST_MCDDC_DP_SPRB0_SPRHBM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 bist_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to indicate if the bist in the
                               ecc corr path is enabled.
                            */
    UINT8 bist_err_report_mode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to indicate if the bist would
                               work in Error reporting mode. In this mode, we
                               only log the BIST results, but they are not
                               considered to make the final decision in the ecc
                               correction path
                            */
    UINT8 bist_ce_corrfsm_noerr : 2;

                            /* Bits[3:2], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to program the final result for
                               the case when BISt gives CE and correction fsm
                               gives NoErorr. Values it can take are: 00 -> UC
                               01 -> CE 10 -> NoError
                            */
    UINT8 force_metaerror : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               When final result is UC and correction fsm is UC
                               - meta error follows the meta error indicated by
                               the correction fsm. This bit can be used to
                               force the meta error to 1 always when we have a
                               final result as UC when BISt is enabled.
                            */
    UINT8 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} ECC_CORR_BIST_MCDDC_DP_STRUCT;

/* DDRT_RETRY_UC_ERROR_COUNTER_MCDDC_DP_REG supported on:                       */
/*      SPRA0 (0x20022e8c)                                                      */
/*      SPRB0 (0x20022e8c)                                                      */
/*      SPRHBM (0x20022e8c)                                                     */
/*      SPRC0 (0x20022e8c)                                                      */
/*      SPRMCC (0x20022e8c)                                                     */
/*      SPRUCC (0x20022e8c)                                                     */
/* Register default value on SPRA0: 0x00000002                                  */
/* Register default value on SPRB0: 0x00000002                                  */
/* Register default value on SPRHBM: 0x00000002                                 */
/* Register default value on SPRC0: 0x00000002                                  */
/* Register default value on SPRMCC: 0x00000002                                 */
/* Register default value on SPRUCC: 0x00000002                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This csr is used in DDRT ECC mode A after threshold is reached or in mode B. It holds the threshold for the number of retries for UC error in correction FSM. 
             Also has a bit to reset the counter
*/


#define DDRT_RETRY_UC_ERROR_COUNTER_MCDDC_DP_REG 0x0B122E8C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cnt_threshold : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000002*/

                            /*
                               Threshold for the number of times UC error is
                               retried
                            */
    UINT32 reset_count : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* Reset the counter */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_RETRY_UC_ERROR_COUNTER_MCDDC_DP_STRUCT;

/* CORRECTION_DEBUG_CORR_DATA_CNTL_MCDDC_DP_REG supported on:                   */
/*      SPRA0 (0x20022e90)                                                      */
/*      SPRB0 (0x20022e90)                                                      */
/*      SPRHBM (0x20022e90)                                                     */
/*      SPRC0 (0x20022e90)                                                      */
/*      SPRMCC (0x20022e90)                                                     */
/*      SPRUCC (0x20022e90)                                                     */
/* Register default value on SPRA0: 0x00000040                                  */
/* Register default value on SPRB0: 0x00000040                                  */
/* Register default value on SPRHBM: 0x00000040                                 */
/* Register default value on SPRC0: 0x00000040                                  */
/* Register default value on SPRMCC: 0x00000040                                 */
/* Register default value on SPRUCC: 0x00000040                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* this register hold extra correction debug. it hold the vecotr for failed device number.
		    it should be a one-hot vector for the device number.
		    it is a DUE case if more than one device is set. 
                    the contents of this register are valid with RETRY_RD_ERR_LOG
                    this register is locked with dfx lock
*/


#define CORRECTION_DEBUG_CORR_DATA_CNTL_MCDDC_DP_REG 0x0B122E90

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mux_sel : 5;

                            /* Bits[4:0], Access Type=RW/L, default=0x00000000*/

                            /*
                               select which chunk of data to write to the data
                               register 0-15 to select over 512 bits of data
                               (e.x. sel=0 returns bits [31:0] 0f 512 bit data)
                               16 select over 32 bits of ecc data
                            */
    UINT32 clk_en : 1;

                            /* Bits[5:5], Access Type=RW/L, default=0x00000000*/

                            /*
                               will enable the clock of the data
                               register(correction_debug_corr_data). if this is
                               not set the data is not valid
                            */
    UINT32 write_en : 1;

                            /* Bits[6:6], Access Type=RW/V/P, default=0x00000001*/

                            /*
                               write enable for the data
                               register(correction_debug_corr_data) for the
                               default value (1) HW will write to this register
                               then HW will set it to 0 when done writing to it
                               Software needs to set this bit when it is done
                               reading from it
                            */
    UINT32 rsvd : 25;

                            /* Bits[31:7], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CORRECTION_DEBUG_CORR_DATA_CNTL_MCDDC_DP_STRUCT;

/* IOLATENCY1_MCDDC_DP_REG supported on:                                        */
/*      SPRA0 (0x20022e98)                                                      */
/*      SPRB0 (0x20022e98)                                                      */
/*      SPRHBM (0x20022e98)                                                     */
/*      SPRC0 (0x20022e98)                                                      */
/*      SPRMCC (0x20022e98)                                                     */
/*      SPRUCC (0x20022e98)                                                     */
/* Register default value on SPRA0: 0x007C0000                                  */
/* Register default value on SPRB0: 0x007C0000                                  */
/* Register default value on SPRHBM: 0x007C0000                                 */
/* Register default value on SPRC0: 0x007C0000                                  */
/* Register default value on SPRMCC: 0x007C0000                                 */
/* Register default value on SPRUCC: 0x007C0000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* WrCRC error injection control
*/


#define IOLATENCY1_MCDDC_DP_REG 0x0B122E98

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 9;

                            /* Bits[8:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cr_crc_err_inj : 8;

                            /* Bits[16:9], Access Type=RW/L, default=0x00000000*/

                            /*
                               All the bits those are high, lead to inversion
                               of correct CRC in the 8 bit CRC generated per
                               device (be it x4 or x8) Note that there is no
                               provision for injecting error in the all-ones of
                               the 9th beat of X8 device CRC
                            */
    UINT32 cr_oneshot_err_inj : 1;

                            /* Bits[17:17], Access Type=RW/L, default=0x00000000*/

                            /*
                               When this bit is set high, then the first write
                               operation is injected with a CRC error as
                               defined by cr_crc_err_inj field. The subsequent
                               writes are not injected with errors.
                            */
    UINT32 cr_crc_err_inj_nibble_sel : 5;

                            /* Bits[22:18], Access Type=RW/L, default=0x0000001F*/

                            /*
                               Select which nibble to inject the error on. In
                               DDR4 mode, value should be between 0 to 17 for
                               x4 and between 0 to 8 for x4. In DDR5 mode, bit
                               4 indicates sub-channel number, while bits 3:0
                               should be between 0 and 9. All 1's value in this
                               field means injection on all nibbles.
                            */
    UINT32 rsvd_23 : 5;

                            /* Bits[27:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cr_cont_wrcrc_err_inj : 1;

                            /* Bits[28:28], Access Type=RW/L, default=0x00000000*/

                            /* Continuous write crc error injection. */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} IOLATENCY1_MCDDC_DP_STRUCT;

/* DDRT_DATAPATH_DELAY_MCDDC_DP_REG supported on:                               */
/*      SPRA0 (0x20022f00)                                                      */
/*      SPRB0 (0x20022f00)                                                      */
/*      SPRHBM (0x20022f00)                                                     */
/*      SPRC0 (0x20022f00)                                                      */
/*      SPRMCC (0x20022f00)                                                     */
/*      SPRUCC (0x20022f00)                                                     */
/* Register default value on SPRA0: 0x02433700                                  */
/* Register default value on SPRB0: 0x02433700                                  */
/* Register default value on SPRHBM: 0x02433700                                 */
/* Register default value on SPRC0: 0x02433700                                  */
/* Register default value on SPRMCC: 0x02433700                                 */
/* Register default value on SPRUCC: 0x02433700                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Delay for read and write datapath to switch from 
      DDRT mode to DDR4 mode after DDRT command is scheduled 
      
*/


#define DDRT_DATAPATH_DELAY_MCDDC_DP_REG 0x0B122F00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 8;

                            /* Bits[7:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rid_underfill_entry : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000017*/

                            /*
                               Reserved underfill read number in RDB; only used
                               if the corresponding enable bit is set in
                               enable_rid_underfill; default value is 23; also
                               used for DDRT starve cases
                            */
    UINT32 enable_rid_underfill : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000001*/

                            /*
                               Enable bit for reserved underfill read entry in
                               RDB; the corresponding entry number is set in
                               rid_underfill_entry
                            */
    UINT32 rsvd_14 : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 erid_to_rdvalid_delay : 5;

                            /* Bits[20:16], Access Type=RW, default=0x00000003*/

                            /*
                               Delay between ERID and RdValid in DDRT mode;
                               also used for ECC error retry flow to drop data
                               with ECC error before last retry. The programmed
                               value should be
                               cmpl_to_data_delay.cmpl_program_delay - 4.
                            */
    UINT32 failed_nibble_number : 5;

                            /* Bits[25:21], Access Type=RW, default=0x00000012*/

                            /*
                               for ddrt hard failure BIOS program the failed
                               nibble number(device number)
                            */
    UINT32 ddrt_force_correction : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               for ddrt hard failure force to take the
                               correction path all the time
                            */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 spare : 4;

                            /* Bits[31:28], Access Type=RW, default=0x00000000*/

                            /* Spare */

  } Bits;
  UINT32 Data;

} DDRT_DATAPATH_DELAY_MCDDC_DP_STRUCT;

/* LINK_MCA_CTL_MCDDC_DP_REG supported on:                                      */
/*      SPRA0 (0x20022f04)                                                      */
/*      SPRB0 (0x20022f04)                                                      */
/*      SPRHBM (0x20022f04)                                                     */
/*      SPRC0 (0x20022f04)                                                      */
/*      SPRMCC (0x20022f04)                                                     */
/*      SPRUCC (0x20022f04)                                                     */
/* Register default value on SPRA0: 0x00100000                                  */
/* Register default value on SPRB0: 0x00100000                                  */
/* Register default value on SPRHBM: 0x00100000                                 */
/* Register default value on SPRC0: 0x00100000                                  */
/* Register default value on SPRMCC: 0x00100000                                 */
/* Register default value on SPRUCC: 0x00100000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* MC bank and signalling control. 
err4: Sb Persistent Counter Reached
*/


#define LINK_MCA_CTL_MCDDC_DP_REG 0x0B122F04

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 err0_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Enable CSR logging for link fail condition. If
                               set, the error will be logged in the
                               corresponding log field in this register.
                            */
    UINT32 err0_log : 1;

                            /* Bits[1:1], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Link Fail Error was logged by HW. BIOS clears by
                               writing 0.
                            */
    UINT32 err0_cmci : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enable/Disable CMCI signaling for link fail
                               condition. When disabled, these errors will not
                               be included in the Corrected Error Count. Note:
                               for corrected errors in general, CMCI is only
                               signaled when corr_err_cnt==corr_err_threshold.
                            */
    UINT32 err0_smi : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Enable/Disable SMI signaling each time link fail
                               error occurs.
                            */
    UINT32 err1_en : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Enable CSR logging. If set, the error will be
                               logged in the corresponding log field in this
                               register.
                            */
    UINT32 err1_log : 1;

                            /* Bits[5:5], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Error was logged by HW. BIOS clears by writing
                               0.
                            */
    UINT32 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 err2_en : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* Reserved - unused. */
    UINT32 err2_log : 1;

                            /* Bits[9:9], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Reserved - unused. */
    UINT32 rsvd_10 : 2;

                            /* Bits[11:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 err3_en : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Enable CSR logging. If set, the error will be
                               logged in the corresponding log field in this
                               register.
                            */
    UINT32 err3_log : 1;

                            /* Bits[13:13], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Error was logged by HW. BIOS clears by writing
                               0.
                            */
    UINT32 rsvd_14 : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 err4_en : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* Reserved - unused. */
    UINT32 err4_log : 1;

                            /* Bits[17:17], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* Reserved - unused. */
    UINT32 mask_ecc_error : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Mask ECC error from being seen. No ECC retry
                               will be perfromed. ECC correction can still be
                               forced when this bit is set.
                            */
    UINT32 dis_ptrl_err_log : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /* Disable patrol error logging */
    UINT32 ptl_sa_mode : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000001*/

                            /*
                               Patrol runs in system address generation mode if
                               patrol is enabled. If this mode bit is not set,
                               patrol runs in legacy mode if patrol is enabled.
                            */
    UINT32 mca_bank_id_index_override : 1;

                            /* Bits[21:21], Access Type=RW/P, default=0x00000000*/

                            /*
                               When mca_bank_id_index_override is set, use bank
                               ID/Index from CSR instead of from fuse/straps.
                               The override field should be set to 1 before
                               changing the value of the CSR field to allow it
                               to be effective.
                            */
    UINT32 mca_bank_id : 5;

                            /* Bits[26:22], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               When mca_bank_id_index_override is set, use bank
                               ID from this field instead of from fuse/straps.
                            */
    UINT32 mca_bank_index : 5;

                            /* Bits[31:27], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               When mca_bank_id_index_override is set, use bank
                               index from this field instead of from
                               fuse/straps.
                            */

  } Bits;
  UINT32 Data;

} LINK_MCA_CTL_MCDDC_DP_STRUCT;

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* RETRY_RD_ERR_LOG_PARITY_N0_MCDDC_DP_REG supported on:                        */
/*      SPRB0 (0x20022f08)                                                      */
/*      SPRHBM (0x20022f08)                                                     */
/*      SPRC0 (0x20022f08)                                                      */
/*      SPRMCC (0x20022f08)                                                     */
/*      SPRUCC (0x20022f08)                                                     */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG
*/


#define RETRY_RD_ERR_LOG_PARITY_N0_MCDDC_DP_REG 0x0B122F08

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 par_syn : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This register holds the parity syndrome(mask)
                               from correction path for the current ECC mode.
                               For DDR5 SDDC parity syndrome uses all 64 bits.
                               For DDR5 ADDDC without column correction parity
                               syndrome uses lower 32 bits. For DDR5 ADDDC with
                               column correction upper 16 bits contain PC syn
                               for upper half of CL (8bits)+ PC syn for lower
                               half of CL (8bits) while lower 32bits contain
                               parity syndrome. For DDR5 9x4 parity syndrome
                               uses lower 32 bits.
                            */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_LOG_PARITY_N0_MCDDC_DP_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* RETRY_RD_ERR_LOG_PARITY_N1_MCDDC_DP_REG supported on:                        */
/*      SPRB0 (0x20022f0c)                                                      */
/*      SPRHBM (0x20022f0c)                                                     */
/*      SPRC0 (0x20022f0c)                                                      */
/*      SPRMCC (0x20022f0c)                                                     */
/*      SPRUCC (0x20022f0c)                                                     */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG
*/


#define RETRY_RD_ERR_LOG_PARITY_N1_MCDDC_DP_REG 0x0B122F0C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 par_syn : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This register holds the parity syndrome(mask)
                               from correction path for the current ECC mode.
                               For DDR5 SDDC parity syndrome uses all 64 bits.
                               For DDR5 ADDDC without column correction parity
                               syndrome uses lower 32 bits. For DDR5 ADDDC with
                               column correction upper 16 bits contain PC syn
                               for upper half of CL (8bits)+ PC syn for lower
                               half of CL (8bits) while lower 32bits contain
                               parity syndrome. For DDR5 9x4 parity syndrome
                               uses lower 32 bits.
                            */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_LOG_PARITY_N1_MCDDC_DP_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* RETRY_RD_ERR_SET2_LOG_PARITY_N0_MCDDC_DP_REG supported on:                   */
/*      SPRB0 (0x20022f10)                                                      */
/*      SPRHBM (0x20022f10)                                                     */
/*      SPRC0 (0x20022f10)                                                      */
/*      SPRMCC (0x20022f10)                                                     */
/*      SPRUCC (0x20022f10)                                                     */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG
*/


#define RETRY_RD_ERR_SET2_LOG_PARITY_N0_MCDDC_DP_REG 0x0B122F10

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 par_syn : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This register holds the parity syndrome(mask)
                               from correction path for the current ECC mode.
                               For DDR5 SDDC parity syndrome uses all 64 bits.
                               For DDR5 ADDDC without column correction parity
                               syndrome uses lower 32 bits. For DDR5 ADDDC with
                               column correction upper 16 bits contain PC syn
                               for upper half of CL (8bits)+ PC syn for lower
                               half of CL (8bits) while lower 32bits contain
                               parity syndrome. For DDR5 9x4 parity syndrome
                               uses lower 32 bits.
                            */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET2_LOG_PARITY_N0_MCDDC_DP_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* RETRY_RD_ERR_SET2_LOG_PARITY_N1_MCDDC_DP_REG supported on:                   */
/*      SPRB0 (0x20022f14)                                                      */
/*      SPRHBM (0x20022f14)                                                     */
/*      SPRC0 (0x20022f14)                                                      */
/*      SPRMCC (0x20022f14)                                                     */
/*      SPRUCC (0x20022f14)                                                     */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG
*/


#define RETRY_RD_ERR_SET2_LOG_PARITY_N1_MCDDC_DP_REG 0x0B122F14

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 par_syn : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This register holds the parity syndrome(mask)
                               from correction path for the current ECC mode.
                               For DDR5 SDDC parity syndrome uses all 64 bits.
                               For DDR5 ADDDC without column correction parity
                               syndrome uses lower 32 bits. For DDR5 ADDDC with
                               column correction upper 16 bits contain PC syn
                               for upper half of CL (8bits)+ PC syn for lower
                               half of CL (8bits) while lower 32bits contain
                               parity syndrome. For DDR5 9x4 parity syndrome
                               uses lower 32 bits.
                            */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET2_LOG_PARITY_N1_MCDDC_DP_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* RETRY_RD_ERR_SET3_LOG_PARITY_N0_MCDDC_DP_REG supported on:                   */
/*      SPRB0 (0x20022f18)                                                      */
/*      SPRHBM (0x20022f18)                                                     */
/*      SPRC0 (0x20022f18)                                                      */
/*      SPRMCC (0x20022f18)                                                     */
/*      SPRUCC (0x20022f18)                                                     */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG
*/


#define RETRY_RD_ERR_SET3_LOG_PARITY_N0_MCDDC_DP_REG 0x0B122F18

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 par_syn : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This register holds the parity syndrome(mask)
                               from correction path for the current ECC mode.
                               For DDR5 SDDC parity syndrome uses all 64 bits.
                               For DDR5 ADDDC without column correction parity
                               syndrome uses lower 32 bits. For DDR5 ADDDC with
                               column correction upper 16 bits contain PC syn
                               for upper half of CL (8bits)+ PC syn for lower
                               half of CL (8bits) while lower 32bits contain
                               parity syndrome. For DDR5 9x4 parity syndrome
                               uses lower 32 bits.
                            */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET3_LOG_PARITY_N0_MCDDC_DP_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* RETRY_RD_ERR_SET3_LOG_PARITY_N1_MCDDC_DP_REG supported on:                   */
/*      SPRB0 (0x20022f1c)                                                      */
/*      SPRHBM (0x20022f1c)                                                     */
/*      SPRC0 (0x20022f1c)                                                      */
/*      SPRMCC (0x20022f1c)                                                     */
/*      SPRUCC (0x20022f1c)                                                     */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_rrd_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG
*/


#define RETRY_RD_ERR_SET3_LOG_PARITY_N1_MCDDC_DP_REG 0x0B122F1C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 par_syn : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This register holds the parity syndrome(mask)
                               from correction path for the current ECC mode.
                               For DDR5 SDDC parity syndrome uses all 64 bits.
                               For DDR5 ADDDC without column correction parity
                               syndrome uses lower 32 bits. For DDR5 ADDDC with
                               column correction upper 16 bits contain PC syn
                               for upper half of CL (8bits)+ PC syn for lower
                               half of CL (8bits) while lower 32bits contain
                               parity syndrome. For DDR5 9x4 parity syndrome
                               uses lower 32 bits.
                            */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET3_LOG_PARITY_N1_MCDDC_DP_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */


/* RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK_MCDDC_DP_REG supported on:                 */
/*      SPRA0 (0x20023008)                                                      */
/*      SPRB0 (0x20023008)                                                      */
/*      SPRHBM (0x20023008)                                                     */
/*      SPRC0 (0x20023008)                                                      */
/*      SPRMCC (0x20023008)                                                     */
/*      SPRUCC (0x20023008)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Error Injection Response Function on Address Match Write Data Error Injection. Associating registers: RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_CRC_ERR_INJ_EXTRA.CRC_ERR_INJ_DEV0_5_BITS and CRC_ERR_INJ_DEV1_5_BITS
In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
*/


#define RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK_MCDDC_DP_REG 0x0B123008

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dev0_xor_msk : 32;

                            /* Bits[31:0], Access Type=RW/L, default=0x00000000*/

                            /*
                               device 0 data inversion mask for error
                               injection. Eight 4-bit values specify which bits
                               of the nibble are inverted on each data cycle of
                               a BL8 write or 1st half of a DDR5 BL16 write.
                               Bits 3:0 correspond to the first data cycle. In
                               addition to LT lock, this register is locked by
                               EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND
                               MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */

  } Bits;
  UINT32 Data;

} RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK_MCDDC_DP_STRUCT;

/* RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK_MCDDC_DP_REG supported on:                 */
/*      SPRA0 (0x2002300c)                                                      */
/*      SPRB0 (0x2002300c)                                                      */
/*      SPRHBM (0x2002300c)                                                     */
/*      SPRC0 (0x2002300c)                                                      */
/*      SPRMCC (0x2002300c)                                                     */
/*      SPRUCC (0x2002300c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Error Injection Response Function on Address Match Write Data Error Injection. Associating registers: RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_CRC_ERR_INJ_EXTRA.CRC_ERR_INJ_DEV0_5_BITS and CRC_ERR_INJ_DEV1_5_BITS
In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
*/


#define RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK_MCDDC_DP_REG 0x0B12300C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dev1_xor_msk : 32;

                            /* Bits[31:0], Access Type=RW/L, default=0x00000000*/

                            /*
                               device 1 data inversion mask for error
                               injection. Eight 4-bit values specify which bits
                               of the nibble are inverted on each data cycle of
                               a BL8 write or 1st half of a DDR5 BL16 write.
                               Bits 3:0 correspond to the first data cycle. In
                               addition to LT lock, this register is locked by
                               EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND
                               MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */

  } Bits;
  UINT32 Data;

} RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK_MCDDC_DP_STRUCT;

/* RSP_FUNC_CRC_ERR_INJ_EXTRA_MCDDC_DP_REG supported on:                        */
/*      SPRA0 (0x20023010)                                                      */
/*      SPRB0 (0x20023010)                                                      */
/*      SPRHBM (0x20023010)                                                     */
/*      SPRC0 (0x20023010)                                                      */
/*      SPRMCC (0x20023010)                                                     */
/*      SPRUCC (0x20023010)                                                     */
/* Register default value on SPRA0: 0xF0004040                                  */
/* Register default value on SPRB0: 0xF0004040                                  */
/* Register default value on SPRHBM: 0xF0004040                                 */
/* Register default value on SPRC0: 0xF0004040                                  */
/* Register default value on SPRMCC: 0xF0004040                                 */
/* Register default value on SPRUCC: 0xF0004040                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Error Injection Response Function
In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
*/


#define RSP_FUNC_CRC_ERR_INJ_EXTRA_MCDDC_DP_REG 0x0B123010

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 crc_err_inj_dev0_5_bits : 5;

                            /* Bits[4:0], Access Type=RW/L, default=0x00000000*/

                            /*
                               Error Injection Response Function on Address
                               Match Write Data Error Injection. Associating
                               registers: RSP_FUNC_ADDR/2_MATCH_LO&HI,
                               RSP_FUNC_ADDR/2_MATCH_LO&HI,
                               RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK and
                               RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK Selects nibble
                               of data bus for device 0 error injection. 0x0
                               selects DQ[3:0], 0x1 selects DQ[7:4], 0x17
                               selects ECC[7:4] etc... 0x18 - 0x31 are
                               reserved. In addition to LT lock, this register
                               is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR)
                               AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 crc_err_inj_match0 : 2;

                            /* Bits[7:6], Access Type=RW/L, default=0x00000001*/

                            /*
                               Error Injection Response Function on Address
                               Match Write Data Error Injection. Associating
                               registers: RSP_FUNC_ADDR/2_MATCH_LO&HI,
                               RSP_FUNC_ADDR/2_MATCH_LO&HI,
                               RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK and
                               RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK Bit 0 of this
                               field (bit 6) selects injection with
                               rsp_func_addr_match/mask and bit 1 of this field
                               (bit 7) selects injection with
                               rsp_func_addr2_match/mask for device 0 error
                               injection. In addition to LT lock, this register
                               is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR)
                               AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */
    UINT32 crc_err_inj_dev1_5_bits : 5;

                            /* Bits[12:8], Access Type=RW/L, default=0x00000000*/

                            /*
                               Error Injection Response Function on Address
                               Match Write Data Error Injection. Associating
                               registers: RSP_FUNC_ADDR/2_MATCH_LO&HI,
                               RSP_FUNC_ADDR/2_MATCH_LO&HI,
                               RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK and
                               RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK Selects nibble
                               of data bus for device 1 error injection. 0x0
                               selects DQ[3:0], 0x1 selects DQ[7:4], 0x17
                               selects ECC[7:4] etc... 0x18 - 0x31 are
                               reserved. In addition to LT lock, this register
                               is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR)
                               AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */
    UINT32 rsvd_13 : 1;

                            /* Bits[13:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 crc_err_inj_match1 : 2;

                            /* Bits[15:14], Access Type=RW/L, default=0x00000001*/

                            /*
                               Error Injection Response Function on Address
                               Match Write Data Error Injection. Associating
                               registers: RSP_FUNC_ADDR/2_MATCH_LO&HI,
                               RSP_FUNC_ADDR/2_MATCH_LO&HI,
                               RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK and
                               RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK Bit 0 of this
                               field (bit 6) selects injection with
                               rsp_func_addr_match/mask and bit 1 of this field
                               (bit 7) selects injection with
                               rsp_func_addr2_match/mask for device 1 error
                               injection. In addition to LT lock, this register
                               is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR)
                               AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */
    UINT32 inj_ha_data_par_err_sel : 2;

                            /* Bits[17:16], Access Type=RW/L, default=0x00000000*/

                            /*
                               Internal Use only since this function require
                               MBP/ASC DFx hooks. The following triggers the
                               error injection. 00 - Dont inject 01 - Use
                               Trigger-0 from MCGLBRSPCNTL.GlbRsp0 10 - Use
                               Trigger-1 from MCGLBRSPCNTL.GlbRsp1 11 - Use
                               Trigger-2 from MCGLBRSPCNTL.GlbRsp2 Please refer
                               to Jaketown DFx related MAS document for further
                               detail.
                            */
    UINT32 rsvd_18 : 6;

                            /* Bits[23:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 inj_ha_poison_err_sel : 2;

                            /* Bits[25:24], Access Type=RW/L, default=0x00000000*/

                            /*
                               Internal Use only since this function require
                               MBP/ASC DFx hooks. The following triggers the
                               error injection. 00 - Dont inject 01 - Use
                               Trigger-0 from MCGLBRSPCNTL.GlbRsp0 10 - Use
                               Trigger-1 from MCGLBRSPCNTL.GlbRsp1 11 - Use
                               Trigger-2 from MCGLBRSPCNTL.GlbRsp2 Please refer
                               to Jaketown DFx related MAS document for further
                               detail.
                            */
    UINT32 rsvd_26 : 2;

                            /* Bits[27:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 crc_err_inj_adddc_primary0 : 1;

                            /* Bits[28:28], Access Type=RW/L, default=0x00000001*/

                            /*
                               Error Injection Response Function on Address
                               Match Write Data Error Injection. Associating
                               registers: RSP_FUNC_ADDR/2_MATCH_LO&HI,
                               RSP_FUNC_ADDR/2_MATCH_LO&HI,
                               RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK and
                               RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK This field
                               enables the device 0 error injection to devices
                               in primary half of CL in ADDDC mode. When
                               cleared to 0, no injection on primary half of CL
                               even if the mask bits are set. This bit has no
                               effect if address match happens on a non-ADDDC
                               write. In addition to LT lock, this register is
                               locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND
                               MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */
    UINT32 crc_err_inj_adddc_buddy0 : 1;

                            /* Bits[29:29], Access Type=RW/L, default=0x00000001*/

                            /*
                               Error Injection Response Function on Address
                               Match Write Data Error Injection. Associating
                               registers: RSP_FUNC_ADDR/2_MATCH_LO&HI,
                               RSP_FUNC_ADDR/2_MATCH_LO&HI,
                               RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK and
                               RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK This field
                               enables the device 0 error injection to devices
                               in buddy half of CL in ADDDC mode. When cleared
                               to 0, no injection on buddy half of CL even if
                               the mask bits are set. This bit has no effect if
                               address match happens on a non-ADDDC write. In
                               addition to LT lock, this register is locked by
                               EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND
                               MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */
    UINT32 crc_err_inj_adddc_primary1 : 1;

                            /* Bits[30:30], Access Type=RW/L, default=0x00000001*/

                            /*
                               Error Injection Response Function on Address
                               Match Write Data Error Injection. Associating
                               registers: RSP_FUNC_ADDR/2_MATCH_LO&HI,
                               RSP_FUNC_ADDR/2_MATCH_LO&HI,
                               RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK and
                               RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK This field
                               enables the device 1 error injection to devices
                               in primary half of CL in ADDDC mode. When
                               cleared to 0, no injection on primary half of CL
                               even if the mask bits are set. This bit has no
                               effect if address match happens on a non-ADDDC
                               write. In addition to LT lock, this register is
                               locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND
                               MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */
    UINT32 crc_err_inj_adddc_buddy1 : 1;

                            /* Bits[31:31], Access Type=RW/L, default=0x00000001*/

                            /*
                               Error Injection Response Function on Address
                               Match Write Data Error Injection. Associating
                               registers: RSP_FUNC_ADDR/2_MATCH_LO&HI,
                               RSP_FUNC_ADDR/2_MATCH_LO&HI,
                               RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK and
                               RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK This field
                               enables the device 1 error injection to devices
                               in buddy half of CL in ADDDC mode. When cleared
                               to 0, no injection on buddy half of CL even if
                               the mask bits are set. This bit has no effect if
                               address match happens on a non-ADDDC write. In
                               addition to LT lock, this register is locked by
                               EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND
                               MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */

  } Bits;
  UINT32 Data;

} RSP_FUNC_CRC_ERR_INJ_EXTRA_MCDDC_DP_STRUCT;

/* RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK_DDRT_MCDDC_DP_REG supported on:            */
/*      SPRA0 (0x20023014)                                                      */
/*      SPRB0 (0x20023014)                                                      */
/*      SPRHBM (0x20023014)                                                     */
/*      SPRC0 (0x20023014)                                                      */
/*      SPRMCC (0x20023014)                                                     */
/*      SPRUCC (0x20023014)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Error Injection Response Function on Address Match Write Data Error Injection. Associating registers: RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_CRC_ERR_INJ_EXTRA.CRC_ERR_INJ_DEV0_5_BITS and CRC_ERR_INJ_DEV1_5_BITS
In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
*/


#define RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK_DDRT_MCDDC_DP_REG 0x0B123014

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dev0_xor_msk : 32;

                            /* Bits[31:0], Access Type=RW/L, default=0x00000000*/

                            /*
                               device 0 data inversion mask for error
                               injection. Eight 4-bit values specify which bits
                               of the nibble are inverted on each data cycle of
                               a BL8 write or 1st half of a DDRT2 B16 write.
                               Bits 3:0 correspond to the first data cycle. In
                               addition to LT lock, this register is locked by
                               EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND
                               MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */

  } Bits;
  UINT32 Data;

} RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK_DDRT_MCDDC_DP_STRUCT;

/* RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK_DDRT_MCDDC_DP_REG supported on:            */
/*      SPRA0 (0x20023018)                                                      */
/*      SPRB0 (0x20023018)                                                      */
/*      SPRHBM (0x20023018)                                                     */
/*      SPRC0 (0x20023018)                                                      */
/*      SPRMCC (0x20023018)                                                     */
/*      SPRUCC (0x20023018)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Error Injection Response Function on Address Match Write Data Error Injection. Associating registers: RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_CRC_ERR_INJ_EXTRA.CRC_ERR_INJ_DEV0_5_BITS and CRC_ERR_INJ_DEV1_5_BITS
In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
*/


#define RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK_DDRT_MCDDC_DP_REG 0x0B123018

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dev1_xor_msk : 32;

                            /* Bits[31:0], Access Type=RW/L, default=0x00000000*/

                            /*
                               device 1 data inversion mask for error
                               injection. Eight 4-bit values specify which bits
                               of the nibble are inverted on each data cycle of
                               a BL8 write or 1st half of a DDRT2 B16 write.
                               Bits 3:0 correspond to the first data cycle. In
                               addition to LT lock, this register is locked by
                               EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND
                               MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */

  } Bits;
  UINT32 Data;

} RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK_DDRT_MCDDC_DP_STRUCT;

/* RSP_FUNC_CRC_ERR_INJ_EXTRA_DDRT_MCDDC_DP_REG supported on:                   */
/*      SPRA0 (0x2002301c)                                                      */
/*      SPRB0 (0x2002301c)                                                      */
/*      SPRHBM (0x2002301c)                                                     */
/*      SPRC0 (0x2002301c)                                                      */
/*      SPRMCC (0x2002301c)                                                     */
/*      SPRUCC (0x2002301c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Error Injection Response Function
In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
*/


#define RSP_FUNC_CRC_ERR_INJ_EXTRA_DDRT_MCDDC_DP_REG 0x0B12301C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 crc_err_inj_dev0_5_bits : 5;

                            /* Bits[4:0], Access Type=RW/L, default=0x00000000*/

                            /*
                               Error Injection Response Function on Address
                               Match Write Data Error Injection. Associating
                               registers: RSP_FUNC_ADDR_MATCH_LO&HI,
                               RSP_FUNC_ADDR_MATCH_LO&HI,
                               RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK and
                               RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK Selects nibble
                               of data bus for error injection. 0x0 selects
                               DQ[3:0], 0x1 selects DQ[7:4], 0x17 selects
                               ECC[7:4] etc... 0x18 - 0x31 are reserved. In
                               addition to LT lock, this register is locked by
                               EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND
                               MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 crc_err_inj_dev1_5_bits : 5;

                            /* Bits[12:8], Access Type=RW/L, default=0x00000000*/

                            /*
                               Error Injection Response Function on Address
                               Match Write Data Error Injection. Associating
                               registers: RSP_FUNC_ADDR_MATCH_LO&HI,
                               RSP_FUNC_ADDR_MATCH_LO&HI,
                               RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK and
                               RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK Selects nibble
                               of data bus for device 1 error injection. 0x0
                               selects DQ[3:0], 0x1 selects DQ[7:4], 0x17
                               selects ECC[7:4] etc... 0x18 - 0x31 are
                               reserved. In addition to LT lock, this register
                               is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR)
                               AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RSP_FUNC_CRC_ERR_INJ_EXTRA_DDRT_MCDDC_DP_STRUCT;

/* WDB_INIT_PSN_CTL_MCDDC_DP_REG supported on:                                  */
/*      SPRA0 (0x23020)                                                         */
/*      SPRB0 (0x23020)                                                         */
/*      SPRHBM (0x23020)                                                        */
/*      SPRC0 (0x23020)                                                         */
/*      SPRMCC (0x23020)                                                        */
/*      SPRUCC (0x23020)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* WDB init poison control bit
*/


#define WDB_INIT_PSN_CTL_MCDDC_DP_REG 0x0B103020

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 poisonall : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will poison all writes coming
                               from WDB for this channel. This bit is meant to
                               be used during memory initialization for memory
                               space that is set aside for memory migration.
                            */
    UINT8 poisonall_ddrt : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will poison all DDRT writes
                               coming from WDB for this channel. This bit is
                               meant to be used during memory initialization
                               for memory space that is set aside for memory
                               migration.
                            */
    UINT8 rsvd : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} WDB_INIT_PSN_CTL_MCDDC_DP_STRUCT;

/* WDB_PAR_ERR_CTL_MCDDC_DP_REG supported on:                                   */
/*      SPRA0 (0x2002302c)                                                      */
/*      SPRB0 (0x2002302c)                                                      */
/*      SPRHBM (0x2002302c)                                                     */
/*      SPRC0 (0x2002302c)                                                      */
/*      SPRMCC (0x2002302c)                                                     */
/*      SPRUCC (0x2002302c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: ERR_INJ                                          */
/* SPRB0 Security PolicyGroup: ERR_INJ                                          */
/* SPRHBM Security PolicyGroup: ERR_INJ                                         */
/* SPRC0 Security PolicyGroup: ERR_INJ                                          */
/* SPRMCC Security PolicyGroup: ERR_INJ                                         */
/* SPRUCC Security PolicyGroup: ERR_INJ                                         */
/* Write Data Buffer error injection control
*/


#define WDB_PAR_ERR_CTL_MCDDC_DP_REG 0x0B12302C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 inj_mask : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /*
                               16 bit mask for injection on WDB read parity
                               value
                            */
    UINT32 res_enable : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               Parity error will be injected according to
                               inj_mask on the next WDB read after this bit is
                               set. Enable bit will be unset after injection.
                            */
    UINT32 rsvd : 7;

                            /* Bits[23:17], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 be_inj_mask : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               2 bit mask for injection on WDB BE read parity
                               value
                            */
    UINT32 be_enable : 1;

                            /* Bits[26:26], Access Type=RW/V, default=0x00000000*/

                            /*
                               Parity error will be injected according to
                               be_inj_mask on the next WDB BE read after this
                               bit is set. Enable bit will be unset after
                               injection.
                            */
    UINT32 rsvd_27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} WDB_PAR_ERR_CTL_MCDDC_DP_STRUCT;

/* RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK2_MCDDC_DP_REG supported on:                */
/*      SPRA0 (0x20023030)                                                      */
/*      SPRB0 (0x20023030)                                                      */
/*      SPRHBM (0x20023030)                                                     */
/*      SPRC0 (0x20023030)                                                      */
/*      SPRMCC (0x20023030)                                                     */
/*      SPRUCC (0x20023030)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Error Injection Response Function on Address Match Write Data Error Injection part 2. Associating registers: RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_CRC_ERR_INJ_EXTRA.CRC_ERR_INJ_DEV0_5_BITS and CRC_ERR_INJ_DEV1_5_BITS
In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
*/


#define RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK2_MCDDC_DP_REG 0x0B123030

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dev0_xor_msk2 : 32;

                            /* Bits[31:0], Access Type=RW/L, default=0x00000000*/

                            /*
                               device 0 data inversion mask for error injection
                               part 2. Used only for DDR5 error injection.
                               Eight 4-bit values specify which bits of the
                               nibble are inverted on each data cycle of 2nd
                               half of a BL16 write. Bits 3:0 correspond to the
                               data cycle 8. In addition to LT lock, this
                               register is locked by
                               EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND
                               MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */

  } Bits;
  UINT32 Data;

} RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK2_MCDDC_DP_STRUCT;

/* RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK2_MCDDC_DP_REG supported on:                */
/*      SPRA0 (0x20023034)                                                      */
/*      SPRB0 (0x20023034)                                                      */
/*      SPRHBM (0x20023034)                                                     */
/*      SPRC0 (0x20023034)                                                      */
/*      SPRMCC (0x20023034)                                                     */
/*      SPRUCC (0x20023034)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Error Injection Response Function on Address Match Write Data Error Injection part 2. Associating registers: RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_CRC_ERR_INJ_EXTRA.CRC_ERR_INJ_DEV0_5_BITS and CRC_ERR_INJ_DEV1_5_BITS
In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
*/


#define RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK2_MCDDC_DP_REG 0x0B123034

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dev1_xor_msk2 : 32;

                            /* Bits[31:0], Access Type=RW/L, default=0x00000000*/

                            /*
                               device 1 data inversion mask for error injection
                               part 2. Used only for DDR5 error injection.
                               Eight 4-bit values specify which bits of the
                               nibble are inverted on each data cycle of 2nd
                               half of a BL16 write. Bits 3:0 correspond to the
                               data cycle 8. In addition to LT lock, this
                               register is locked by
                               EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND
                               MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */

  } Bits;
  UINT32 Data;

} RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK2_MCDDC_DP_STRUCT;

/* RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK2_DDRT_MCDDC_DP_REG supported on:           */
/*      SPRA0 (0x20023038)                                                      */
/*      SPRB0 (0x20023038)                                                      */
/*      SPRHBM (0x20023038)                                                     */
/*      SPRC0 (0x20023038)                                                      */
/*      SPRMCC (0x20023038)                                                     */
/*      SPRUCC (0x20023038)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Error Injection Response Function on Address Match Write Data Error Injection. Associating registers: RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_CRC_ERR_INJ_EXTRA.CRC_ERR_INJ_DEV0_5_BITS and CRC_ERR_INJ_DEV1_5_BITS
In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
*/


#define RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK2_DDRT_MCDDC_DP_REG 0x0B123038

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dev0_xor_msk2 : 32;

                            /* Bits[31:0], Access Type=RW/L, default=0x00000000*/

                            /*
                               device 0 data inversion mask for error injection
                               for DDRT2 only. Eight 4-bit values specify which
                               bits of the nibble are inverted on each data
                               cycle of 2nd half a BL16 write. Bits 3:0
                               correspond to the data cycle 8. In addition to
                               LT lock, this register is locked by
                               EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND
                               MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */

  } Bits;
  UINT32 Data;

} RSP_FUNC_CRC_ERR_INJ_DEV0_XOR_MSK2_DDRT_MCDDC_DP_STRUCT;

/* RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK2_DDRT_MCDDC_DP_REG supported on:           */
/*      SPRA0 (0x2002303c)                                                      */
/*      SPRB0 (0x2002303c)                                                      */
/*      SPRHBM (0x2002303c)                                                     */
/*      SPRC0 (0x2002303c)                                                      */
/*      SPRMCC (0x2002303c)                                                     */
/*      SPRUCC (0x2002303c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Error Injection Response Function on Address Match Write Data Error Injection. Associating registers: RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_ADDR_MATCH_LO&HI, RSP_FUNC_CRC_ERR_INJ_EXTRA.CRC_ERR_INJ_DEV0_5_BITS and CRC_ERR_INJ_DEV1_5_BITS
In addition to LT lock, this register is locked by EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
*/


#define RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK2_DDRT_MCDDC_DP_REG 0x0B12303C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dev1_xor_msk2 : 32;

                            /* Bits[31:0], Access Type=RW/L, default=0x00000000*/

                            /*
                               device 1 data inversion mask for error injection
                               for DDRT2 only. Eight 4-bit values specify which
                               bits of the nibble are inverted on each data
                               cycle of 2nd half of a BL16 write. Bits 3:0
                               correspond to the data cycle 8. In addition to
                               LT lock, this register is locked by
                               EPMCMAIN_DFX_LCK_CNTL.RSPLCK (uCR) AND
                               MC_ERR_INJ_LCK.MC_ERR_INJ_LCK (MSR).
                            */

  } Bits;
  UINT32 Data;

} RSP_FUNC_CRC_ERR_INJ_DEV1_XOR_MSK2_DDRT_MCDDC_DP_STRUCT;

/* MCWDB_CHKN_BIT_MCDDC_DP_REG supported on:                                    */
/*      SPRA0 (0x20023084)                                                      */
/*      SPRB0 (0x20023084)                                                      */
/*      SPRHBM (0x20023084)                                                     */
/*      SPRC0 (0x20023084)                                                      */
/*      SPRMCC (0x20023084)                                                     */
/*      SPRUCC (0x20023084)                                                     */
/* Register default value on SPRA0: 0x00000005                                  */
/* Register default value on SPRB0: 0x00000005                                  */
/* Register default value on SPRHBM: 0x00000005                                 */
/* Register default value on SPRC0: 0x00000005                                  */
/* Register default value on SPRMCC: 0x00000005                                 */
/* Register default value on SPRUCC: 0x00000005                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Chicken bit register
*/


#define MCWDB_CHKN_BIT_MCDDC_DP_REG 0x0B123084

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_ddrio_earlywdata : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Disable sending write data early to ddrio for
                               anti cross talk logic; If 0, data will be sent
                               early one Dclock so ddrio has time to do cross
                               talk cancelation logic. If set to 1, write data
                               will be sent with normal timing and ddrio will
                               have no time to do cross talk cancelation logic.
                            */
    UINT32 rsvd_1 : 2;

                            /* Bits[2:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 29;

                            /* Bits[31:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCWDB_CHKN_BIT_MCDDC_DP_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_ddrio_earlywdata : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Disable sending write data early to ddrio for
                               anti cross talk logic; If 0, data will be sent
                               early one Dclock so ddrio has time to do cross
                               talk cancelation logic. If set to 1, write data
                               will be sent with normal timing and ddrio will
                               have no time to do cross talk cancelation logic.
                            */
    UINT32 rsvd_1 : 13;

                            /* Bits[13:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 18;

                            /* Bits[31:14], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCWDB_CHKN_BIT_MCDDC_DP_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_ddrio_earlywdata : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Disable sending write data early to ddrio for
                               anti cross talk logic; If 0, data will be sent
                               early one Dclock so ddrio has time to do cross
                               talk cancelation logic. If set to 1, write data
                               will be sent with normal timing and ddrio will
                               have no time to do cross talk cancelation logic.
                            */
    UINT32 rsvd_1 : 20;

                            /* Bits[20:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd_21 : 10;

                            /* Bits[30:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_ddrt_wdb : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to disable DDRT from using WDB, i.e.,
                               all WDB entries will be used for DDR5, when DDRT
                               is not populated
                            */

  } Bits;
  UINT32 Data;

} MCWDB_CHKN_BIT_MCDDC_DP_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_ddrio_earlywdata : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Disable sending write data early to ddrio for
                               anti cross talk logic; If 0, data will be sent
                               early one Dclock so ddrio has time to do cross
                               talk cancelation logic. If set to 1, write data
                               will be sent with normal timing and ddrio will
                               have no time to do cross talk cancelation logic.
                            */
    UINT32 rsvd_1 : 2;

                            /* Bits[2:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 29;

                            /* Bits[31:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCWDB_CHKN_BIT_MCDDC_DP_STRUCT;

/* PCLS_0_CFG_DATA_INFO_N0_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230a0)                                                      */
/*      SPRB0 (0x200230a0)                                                      */
/*      SPRHBM (0x200230a0)                                                     */
/*      SPRC0 (0x200230a0)                                                      */
/*      SPRMCC (0x200230a0)                                                     */
/*      SPRUCC (0x200230a0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_0_CFG_DATA_INFO_N0_MCDDC_DP_REG 0x0B1230A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pcls_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enable which is RW by BIOS. Also when the enable
                               of the pcls csr is true but there is change in
                               the address/nibble offset content hardware will
                               write 0 to the enable to prevent future pcls
                               match to this.
                            */
    UINT32 chip_select : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /*
                               Rank CS0-CS7 (encoded chip select) of address,
                               for HBM, Rank[0] is PCH and Rank[1] is SID
                            */
    UINT32 cbit : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* C0-C2 (encoded subrank) of address */
    UINT32 bg : 3;

                            /* Bits[9:7], Access Type=RW, default=0x00000000*/

                            /* Bank Group */
    UINT32 ba : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /* Bank Address */
    UINT32 row : 18;

                            /* Bits[29:12], Access Type=RW, default=0x00000000*/

                            /* Row address */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_0_CFG_DATA_INFO_N0_MCDDC_DP_STRUCT;

/* PCLS_0_CFG_DATA_INFO_N1_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230a4)                                                      */
/*      SPRB0 (0x200230a4)                                                      */
/*      SPRHBM (0x200230a4)                                                     */
/*      SPRC0 (0x200230a4)                                                      */
/*      SPRMCC (0x200230a4)                                                     */
/*      SPRUCC (0x200230a4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_0_CFG_DATA_INFO_N1_MCDDC_DP_REG 0x0B1230A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 col : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Column address bits 9:2 */
    UINT32 data_offset : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Offset for the nibble of data to be spared; for
                               DDR4 or HBM, bits 7:5 selects transfer number 0
                               to 7 and bits 4:0 selects device number 0 to 17;
                               for DDR5, bits 7:4 selects transfer number 0 to
                               15 and bits 3:0 selects device number 0 to 9.
                            */
    UINT32 error : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is set when the enable of the pcls csr
                               is true but there is change in the
                               address/nibble offset content. When BIOS is
                               setting 0 to the enable of a pcls csr, this
                               should also be set to 0 so as to clear the error
                               indication
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_0_CFG_DATA_INFO_N1_MCDDC_DP_STRUCT;

/* PCLS_1_CFG_DATA_INFO_N0_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230a8)                                                      */
/*      SPRB0 (0x200230a8)                                                      */
/*      SPRHBM (0x200230a8)                                                     */
/*      SPRC0 (0x200230a8)                                                      */
/*      SPRMCC (0x200230a8)                                                     */
/*      SPRUCC (0x200230a8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_1_CFG_DATA_INFO_N0_MCDDC_DP_REG 0x0B1230A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pcls_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enable which is RW only by BIOS.Also when the
                               enable of the pcls csr is true but there is
                               change in the address/nibble offset content
                               hardware will write 0 to the enable to prevent
                               future pcls match to this.
                            */
    UINT32 chip_select : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /* Rank CS0-CS7 (encoded chip select) of address */
    UINT32 cbit : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* C0-C2 (encoded subrank) of address */
    UINT32 bg : 3;

                            /* Bits[9:7], Access Type=RW, default=0x00000000*/

                            /* Bank Group */
    UINT32 ba : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /* Bank Address */
    UINT32 row : 18;

                            /* Bits[29:12], Access Type=RW, default=0x00000000*/

                            /* Row address */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_1_CFG_DATA_INFO_N0_MCDDC_DP_STRUCT;

/* PCLS_1_CFG_DATA_INFO_N1_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230ac)                                                      */
/*      SPRB0 (0x200230ac)                                                      */
/*      SPRHBM (0x200230ac)                                                     */
/*      SPRC0 (0x200230ac)                                                      */
/*      SPRMCC (0x200230ac)                                                     */
/*      SPRUCC (0x200230ac)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_1_CFG_DATA_INFO_N1_MCDDC_DP_REG 0x0B1230AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 col : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Column address bits 9:2 */
    UINT32 data_offset : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Offset for the nibble of data to be spared; for
                               DDR4 or HBM, bits 7:5 selects transfer number 0
                               to 7 and bits 4:0 selects device number 0 to 17;
                               for DDR5, bits 7:4 selects transfer number 0 to
                               15 and bits 3:0 selects device number 0 to 9.
                            */
    UINT32 error : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is set when the enable of the pcls csr
                               is true but there is change in the
                               address/nibble offset content. When BIOS is
                               setting 0 to the enable of a pcls csr, this
                               should also be set to 0 so as to clear the error
                               indication
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_1_CFG_DATA_INFO_N1_MCDDC_DP_STRUCT;

/* PCLS_2_CFG_DATA_INFO_N0_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230b0)                                                      */
/*      SPRB0 (0x200230b0)                                                      */
/*      SPRHBM (0x200230b0)                                                     */
/*      SPRC0 (0x200230b0)                                                      */
/*      SPRMCC (0x200230b0)                                                     */
/*      SPRUCC (0x200230b0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_2_CFG_DATA_INFO_N0_MCDDC_DP_REG 0x0B1230B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pcls_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enable which is RW only by BIOS.Also when the
                               enable of the pcls csr is true but there is
                               change in the address/nibble offset content
                               hardware will write 0 to the enable to prevent
                               future pcls match to this.
                            */
    UINT32 chip_select : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /* Rank CS0-CS7 (encoded chip select) of address */
    UINT32 cbit : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* C0-C2 (encoded subrank) of address */
    UINT32 bg : 3;

                            /* Bits[9:7], Access Type=RW, default=0x00000000*/

                            /* Bank Group */
    UINT32 ba : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /* Bank Address */
    UINT32 row : 18;

                            /* Bits[29:12], Access Type=RW, default=0x00000000*/

                            /* Row address */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_2_CFG_DATA_INFO_N0_MCDDC_DP_STRUCT;

/* PCLS_2_CFG_DATA_INFO_N1_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230b4)                                                      */
/*      SPRB0 (0x200230b4)                                                      */
/*      SPRHBM (0x200230b4)                                                     */
/*      SPRC0 (0x200230b4)                                                      */
/*      SPRMCC (0x200230b4)                                                     */
/*      SPRUCC (0x200230b4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_2_CFG_DATA_INFO_N1_MCDDC_DP_REG 0x0B1230B4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 col : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Column address bits 9:2 */
    UINT32 data_offset : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Offset for the nibble of data to be spared; for
                               DDR4 or HBM, bits 7:5 selects transfer number 0
                               to 7 and bits 4:0 selects device number 0 to 17;
                               for DDR5, bits 7:4 selects transfer number 0 to
                               15 and bits 3:0 selects device number 0 to 9.
                            */
    UINT32 error : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is set when the enable of the pcls csr
                               is true but there is change in the
                               address/nibble offset content. When BIOS is
                               setting 0 to the enable of a pcls csr, this
                               should also be set to 0 so as to clear the error
                               indication
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_2_CFG_DATA_INFO_N1_MCDDC_DP_STRUCT;

/* PCLS_3_CFG_DATA_INFO_N0_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230b8)                                                      */
/*      SPRB0 (0x200230b8)                                                      */
/*      SPRHBM (0x200230b8)                                                     */
/*      SPRC0 (0x200230b8)                                                      */
/*      SPRMCC (0x200230b8)                                                     */
/*      SPRUCC (0x200230b8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_3_CFG_DATA_INFO_N0_MCDDC_DP_REG 0x0B1230B8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pcls_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enable which is RW only by BIOS.Also when the
                               enable of the pcls csr is true but there is
                               change in the address/nibble offset content
                               hardware will write 0 to the enable to prevent
                               future pcls match to this.
                            */
    UINT32 chip_select : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /* Rank CS0-CS7 (encoded chip select) of address */
    UINT32 cbit : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* C0-C2 (encoded subrank) of address */
    UINT32 bg : 3;

                            /* Bits[9:7], Access Type=RW, default=0x00000000*/

                            /* Bank Group */
    UINT32 ba : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /* Bank Address */
    UINT32 row : 18;

                            /* Bits[29:12], Access Type=RW, default=0x00000000*/

                            /* Row address */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_3_CFG_DATA_INFO_N0_MCDDC_DP_STRUCT;

/* PCLS_3_CFG_DATA_INFO_N1_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230bc)                                                      */
/*      SPRB0 (0x200230bc)                                                      */
/*      SPRHBM (0x200230bc)                                                     */
/*      SPRC0 (0x200230bc)                                                      */
/*      SPRMCC (0x200230bc)                                                     */
/*      SPRUCC (0x200230bc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_3_CFG_DATA_INFO_N1_MCDDC_DP_REG 0x0B1230BC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 col : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Column address bits 9:2 */
    UINT32 data_offset : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Offset for the nibble of data to be spared; for
                               DDR4 or HBM, bits 7:5 selects transfer number 0
                               to 7 and bits 4:0 selects device number 0 to 17;
                               for DDR5, bits 7:4 selects transfer number 0 to
                               15 and bits 3:0 selects device number 0 to 9.
                            */
    UINT32 error : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is set when the enable of the pcls csr
                               is true but there is change in the
                               address/nibble offset content. When BIOS is
                               setting 0 to the enable of a pcls csr, this
                               should also be set to 0 so as to clear the error
                               indication
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_3_CFG_DATA_INFO_N1_MCDDC_DP_STRUCT;

/* PCLS_4_CFG_DATA_INFO_N0_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230c0)                                                      */
/*      SPRB0 (0x200230c0)                                                      */
/*      SPRHBM (0x200230c0)                                                     */
/*      SPRC0 (0x200230c0)                                                      */
/*      SPRMCC (0x200230c0)                                                     */
/*      SPRUCC (0x200230c0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_4_CFG_DATA_INFO_N0_MCDDC_DP_REG 0x0B1230C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pcls_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enable which is RW only by BIOS.Also when the
                               enable of the pcls csr is true but there is
                               change in the address/nibble offset content
                               hardware will write 0 to the enable to prevent
                               future pcls match to this.
                            */
    UINT32 chip_select : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /* Rank CS0-CS7 (encoded chip select) of address */
    UINT32 cbit : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* C0-C2 (encoded subrank) of address */
    UINT32 bg : 3;

                            /* Bits[9:7], Access Type=RW, default=0x00000000*/

                            /* Bank Group */
    UINT32 ba : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /* Bank Address */
    UINT32 row : 18;

                            /* Bits[29:12], Access Type=RW, default=0x00000000*/

                            /* Row address */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_4_CFG_DATA_INFO_N0_MCDDC_DP_STRUCT;

/* PCLS_4_CFG_DATA_INFO_N1_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230c4)                                                      */
/*      SPRB0 (0x200230c4)                                                      */
/*      SPRHBM (0x200230c4)                                                     */
/*      SPRC0 (0x200230c4)                                                      */
/*      SPRMCC (0x200230c4)                                                     */
/*      SPRUCC (0x200230c4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_4_CFG_DATA_INFO_N1_MCDDC_DP_REG 0x0B1230C4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 col : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Column address bits 9:2 */
    UINT32 data_offset : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Offset for the nibble of data to be spared; for
                               DDR4 or HBM, bits 7:5 selects transfer number 0
                               to 7 and bits 4:0 selects device number 0 to 17;
                               for DDR5, bits 7:4 selects transfer number 0 to
                               15 and bits 3:0 selects device number 0 to 9.
                            */
    UINT32 error : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is set when the enable of the pcls csr
                               is true but there is change in the
                               address/nibble offset content. When BIOS is
                               setting 0 to the enable of a pcls csr, this
                               should also be set to 0 so as to clear the error
                               indication
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_4_CFG_DATA_INFO_N1_MCDDC_DP_STRUCT;

/* PCLS_5_CFG_DATA_INFO_N0_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230c8)                                                      */
/*      SPRB0 (0x200230c8)                                                      */
/*      SPRHBM (0x200230c8)                                                     */
/*      SPRC0 (0x200230c8)                                                      */
/*      SPRMCC (0x200230c8)                                                     */
/*      SPRUCC (0x200230c8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_5_CFG_DATA_INFO_N0_MCDDC_DP_REG 0x0B1230C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pcls_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enable which is RW only by BIOS.Also when the
                               enable of the pcls csr is true but there is
                               change in the address/nibble offset content
                               hardware will write 0 to the enable to prevent
                               future pcls match to this.
                            */
    UINT32 chip_select : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /* Rank CS0-CS7 (encoded chip select) of address */
    UINT32 cbit : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* C0-C2 (encoded subrank) of address */
    UINT32 bg : 3;

                            /* Bits[9:7], Access Type=RW, default=0x00000000*/

                            /* Bank Group */
    UINT32 ba : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /* Bank Address */
    UINT32 row : 18;

                            /* Bits[29:12], Access Type=RW, default=0x00000000*/

                            /* Row address */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_5_CFG_DATA_INFO_N0_MCDDC_DP_STRUCT;

/* PCLS_5_CFG_DATA_INFO_N1_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230cc)                                                      */
/*      SPRB0 (0x200230cc)                                                      */
/*      SPRHBM (0x200230cc)                                                     */
/*      SPRC0 (0x200230cc)                                                      */
/*      SPRMCC (0x200230cc)                                                     */
/*      SPRUCC (0x200230cc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_5_CFG_DATA_INFO_N1_MCDDC_DP_REG 0x0B1230CC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 col : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Column address bits 9:2 */
    UINT32 data_offset : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Offset for the nibble of data to be spared; for
                               DDR4 or HBM, bits 7:5 selects transfer number 0
                               to 7 and bits 4:0 selects device number 0 to 17;
                               for DDR5, bits 7:4 selects transfer number 0 to
                               15 and bits 3:0 selects device number 0 to 9.
                            */
    UINT32 error : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is set when the enable of the pcls csr
                               is true but there is change in the
                               address/nibble offset content. When BIOS is
                               setting 0 to the enable of a pcls csr, this
                               should also be set to 0 so as to clear the error
                               indication
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_5_CFG_DATA_INFO_N1_MCDDC_DP_STRUCT;

/* PCLS_6_CFG_DATA_INFO_N0_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230d0)                                                      */
/*      SPRB0 (0x200230d0)                                                      */
/*      SPRHBM (0x200230d0)                                                     */
/*      SPRC0 (0x200230d0)                                                      */
/*      SPRMCC (0x200230d0)                                                     */
/*      SPRUCC (0x200230d0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_6_CFG_DATA_INFO_N0_MCDDC_DP_REG 0x0B1230D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pcls_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enable which is RW only by BIOS.Also when the
                               enable of the pcls csr is true but there is
                               change in the address/nibble offset content
                               hardware will write 0 to the enable to prevent
                               future pcls match to this.
                            */
    UINT32 chip_select : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /* Rank CS0-CS7 (encoded chip select) of address */
    UINT32 cbit : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* C0-C2 (encoded subrank) of address */
    UINT32 bg : 3;

                            /* Bits[9:7], Access Type=RW, default=0x00000000*/

                            /* Bank Group */
    UINT32 ba : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /* Bank Address */
    UINT32 row : 18;

                            /* Bits[29:12], Access Type=RW, default=0x00000000*/

                            /* Row address */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_6_CFG_DATA_INFO_N0_MCDDC_DP_STRUCT;

/* PCLS_6_CFG_DATA_INFO_N1_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230d4)                                                      */
/*      SPRB0 (0x200230d4)                                                      */
/*      SPRHBM (0x200230d4)                                                     */
/*      SPRC0 (0x200230d4)                                                      */
/*      SPRMCC (0x200230d4)                                                     */
/*      SPRUCC (0x200230d4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_6_CFG_DATA_INFO_N1_MCDDC_DP_REG 0x0B1230D4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 col : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Column address bits 9:2 */
    UINT32 data_offset : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Offset for the nibble of data to be spared; for
                               DDR4 or HBM, bits 7:5 selects transfer number 0
                               to 7 and bits 4:0 selects device number 0 to 17;
                               for DDR5, bits 7:4 selects transfer number 0 to
                               15 and bits 3:0 selects device number 0 to 9.
                            */
    UINT32 error : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is set when the enable of the pcls csr
                               is true but there is change in the
                               address/nibble offset content. When BIOS is
                               setting 0 to the enable of a pcls csr, this
                               should also be set to 0 so as to clear the error
                               indication
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_6_CFG_DATA_INFO_N1_MCDDC_DP_STRUCT;

/* PCLS_7_CFG_DATA_INFO_N0_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230d8)                                                      */
/*      SPRB0 (0x200230d8)                                                      */
/*      SPRHBM (0x200230d8)                                                     */
/*      SPRC0 (0x200230d8)                                                      */
/*      SPRMCC (0x200230d8)                                                     */
/*      SPRUCC (0x200230d8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_7_CFG_DATA_INFO_N0_MCDDC_DP_REG 0x0B1230D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pcls_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enable which is RW only by BIOS.Also when the
                               enable of the pcls csr is true but there is
                               change in the address/nibble offset content
                               hardware will write 0 to the enable to prevent
                               future pcls match to this.
                            */
    UINT32 chip_select : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /* Rank CS0-CS7 (encoded chip select) of address */
    UINT32 cbit : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* C0-C2 (encoded subrank) of address */
    UINT32 bg : 3;

                            /* Bits[9:7], Access Type=RW, default=0x00000000*/

                            /* Bank Group */
    UINT32 ba : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /* Bank Address */
    UINT32 row : 18;

                            /* Bits[29:12], Access Type=RW, default=0x00000000*/

                            /* Row address */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_7_CFG_DATA_INFO_N0_MCDDC_DP_STRUCT;

/* PCLS_7_CFG_DATA_INFO_N1_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230dc)                                                      */
/*      SPRB0 (0x200230dc)                                                      */
/*      SPRHBM (0x200230dc)                                                     */
/*      SPRC0 (0x200230dc)                                                      */
/*      SPRMCC (0x200230dc)                                                     */
/*      SPRUCC (0x200230dc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_7_CFG_DATA_INFO_N1_MCDDC_DP_REG 0x0B1230DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 col : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Column address bits 9:2 */
    UINT32 data_offset : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Offset for the nibble of data to be spared; for
                               DDR4 or HBM, bits 7:5 selects transfer number 0
                               to 7 and bits 4:0 selects device number 0 to 17;
                               for DDR5, bits 7:4 selects transfer number 0 to
                               15 and bits 3:0 selects device number 0 to 9.
                            */
    UINT32 error : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is set when the enable of the pcls csr
                               is true but there is change in the
                               address/nibble offset content. When BIOS is
                               setting 0 to the enable of a pcls csr, this
                               should also be set to 0 so as to clear the error
                               indication
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_7_CFG_DATA_INFO_N1_MCDDC_DP_STRUCT;

/* PCLS_8_CFG_DATA_INFO_N0_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230e0)                                                      */
/*      SPRB0 (0x200230e0)                                                      */
/*      SPRHBM (0x200230e0)                                                     */
/*      SPRC0 (0x200230e0)                                                      */
/*      SPRMCC (0x200230e0)                                                     */
/*      SPRUCC (0x200230e0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_8_CFG_DATA_INFO_N0_MCDDC_DP_REG 0x0B1230E0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pcls_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enable which is RW only by BIOS.Also when the
                               enable of the pcls csr is true but there is
                               change in the address/nibble offset content
                               hardware will write 0 to the enable to prevent
                               future pcls match to this.
                            */
    UINT32 chip_select : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /* Rank CS0-CS7 (encoded chip select) of address */
    UINT32 cbit : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* C0-C2 (encoded subrank) of address */
    UINT32 bg : 3;

                            /* Bits[9:7], Access Type=RW, default=0x00000000*/

                            /* Bank Group */
    UINT32 ba : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /* Bank Address */
    UINT32 row : 18;

                            /* Bits[29:12], Access Type=RW, default=0x00000000*/

                            /* Row address */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_8_CFG_DATA_INFO_N0_MCDDC_DP_STRUCT;

/* PCLS_8_CFG_DATA_INFO_N1_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230e4)                                                      */
/*      SPRB0 (0x200230e4)                                                      */
/*      SPRHBM (0x200230e4)                                                     */
/*      SPRC0 (0x200230e4)                                                      */
/*      SPRMCC (0x200230e4)                                                     */
/*      SPRUCC (0x200230e4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_8_CFG_DATA_INFO_N1_MCDDC_DP_REG 0x0B1230E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 col : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Column address bits 9:2 */
    UINT32 data_offset : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Offset for the nibble of data to be spared; for
                               DDR4 or HBM, bits 7:5 selects transfer number 0
                               to 7 and bits 4:0 selects device number 0 to 17;
                               for DDR5, bits 7:4 selects transfer number 0 to
                               15 and bits 3:0 selects device number 0 to 9.
                            */
    UINT32 error : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is set when the enable of the pcls csr
                               is true but there is change in the
                               address/nibble offset content. When BIOS is
                               setting 0 to the enable of a pcls csr, this
                               should also be set to 0 so as to clear the error
                               indication
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_8_CFG_DATA_INFO_N1_MCDDC_DP_STRUCT;

/* PCLS_9_CFG_DATA_INFO_N0_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230e8)                                                      */
/*      SPRB0 (0x200230e8)                                                      */
/*      SPRHBM (0x200230e8)                                                     */
/*      SPRC0 (0x200230e8)                                                      */
/*      SPRMCC (0x200230e8)                                                     */
/*      SPRUCC (0x200230e8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_9_CFG_DATA_INFO_N0_MCDDC_DP_REG 0x0B1230E8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pcls_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enable which is RW only by BIOS.Also when the
                               enable of the pcls csr is true but there is
                               change in the address/nibble offset content
                               hardware will write 0 to the enable to prevent
                               future pcls match to this.
                            */
    UINT32 chip_select : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /* Rank CS0-CS7 (encoded chip select) of address */
    UINT32 cbit : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* C0-C2 (encoded subrank) of address */
    UINT32 bg : 3;

                            /* Bits[9:7], Access Type=RW, default=0x00000000*/

                            /* Bank Group */
    UINT32 ba : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /* Bank Address */
    UINT32 row : 18;

                            /* Bits[29:12], Access Type=RW, default=0x00000000*/

                            /* Row address */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_9_CFG_DATA_INFO_N0_MCDDC_DP_STRUCT;

/* PCLS_9_CFG_DATA_INFO_N1_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x200230ec)                                                      */
/*      SPRB0 (0x200230ec)                                                      */
/*      SPRHBM (0x200230ec)                                                     */
/*      SPRC0 (0x200230ec)                                                      */
/*      SPRMCC (0x200230ec)                                                     */
/*      SPRUCC (0x200230ec)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_9_CFG_DATA_INFO_N1_MCDDC_DP_REG 0x0B1230EC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 col : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Column address bits 9:2 */
    UINT32 data_offset : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Offset for the nibble of data to be spared; for
                               DDR4 or HBM, bits 7:5 selects transfer number 0
                               to 7 and bits 4:0 selects device number 0 to 17;
                               for DDR5, bits 7:4 selects transfer number 0 to
                               15 and bits 3:0 selects device number 0 to 9.
                            */
    UINT32 error : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is set when the enable of the pcls csr
                               is true but there is change in the
                               address/nibble offset content. When BIOS is
                               setting 0 to the enable of a pcls csr, this
                               should also be set to 0 so as to clear the error
                               indication
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_9_CFG_DATA_INFO_N1_MCDDC_DP_STRUCT;

/* PCLS_10_CFG_DATA_INFO_N0_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x200230f0)                                                      */
/*      SPRB0 (0x200230f0)                                                      */
/*      SPRHBM (0x200230f0)                                                     */
/*      SPRC0 (0x200230f0)                                                      */
/*      SPRMCC (0x200230f0)                                                     */
/*      SPRUCC (0x200230f0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_10_CFG_DATA_INFO_N0_MCDDC_DP_REG 0x0B1230F0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pcls_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enable which is RW only by BIOS.Also when the
                               enable of the pcls csr is true but there is
                               change in the address/nibble offset content
                               hardware will write 0 to the enable to prevent
                               future pcls match to this.
                            */
    UINT32 chip_select : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /* Rank CS0-CS7 (encoded chip select) of address */
    UINT32 cbit : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* C0-C2 (encoded subrank) of address */
    UINT32 bg : 3;

                            /* Bits[9:7], Access Type=RW, default=0x00000000*/

                            /* Bank Group */
    UINT32 ba : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /* Bank Address */
    UINT32 row : 18;

                            /* Bits[29:12], Access Type=RW, default=0x00000000*/

                            /* Row address */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_10_CFG_DATA_INFO_N0_MCDDC_DP_STRUCT;

/* PCLS_10_CFG_DATA_INFO_N1_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x200230f4)                                                      */
/*      SPRB0 (0x200230f4)                                                      */
/*      SPRHBM (0x200230f4)                                                     */
/*      SPRC0 (0x200230f4)                                                      */
/*      SPRMCC (0x200230f4)                                                     */
/*      SPRUCC (0x200230f4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_10_CFG_DATA_INFO_N1_MCDDC_DP_REG 0x0B1230F4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 col : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Column address bits 9:2 */
    UINT32 data_offset : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Offset for the nibble of data to be spared; for
                               DDR4 or HBM, bits 7:5 selects transfer number 0
                               to 7 and bits 4:0 selects device number 0 to 17;
                               for DDR5, bits 7:4 selects transfer number 0 to
                               15 and bits 3:0 selects device number 0 to 9.
                            */
    UINT32 error : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is set when the enable of the pcls csr
                               is true but there is change in the
                               address/nibble offset content. When BIOS is
                               setting 0 to the enable of a pcls csr, this
                               should also be set to 0 so as to clear the error
                               indication
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_10_CFG_DATA_INFO_N1_MCDDC_DP_STRUCT;

/* PCLS_11_CFG_DATA_INFO_N0_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x200230f8)                                                      */
/*      SPRB0 (0x200230f8)                                                      */
/*      SPRHBM (0x200230f8)                                                     */
/*      SPRC0 (0x200230f8)                                                      */
/*      SPRMCC (0x200230f8)                                                     */
/*      SPRUCC (0x200230f8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_11_CFG_DATA_INFO_N0_MCDDC_DP_REG 0x0B1230F8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pcls_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enable which is RW only by BIOS.Also when the
                               enable of the pcls csr is true but there is
                               change in the address/nibble offset content
                               hardware will write 0 to the enable to prevent
                               future pcls match to this.
                            */
    UINT32 chip_select : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /* Rank CS0-CS7 (encoded chip select) of address */
    UINT32 cbit : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* C0-C2 (encoded subrank) of address */
    UINT32 bg : 3;

                            /* Bits[9:7], Access Type=RW, default=0x00000000*/

                            /* Bank Group */
    UINT32 ba : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /* Bank Address */
    UINT32 row : 18;

                            /* Bits[29:12], Access Type=RW, default=0x00000000*/

                            /* Row address */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_11_CFG_DATA_INFO_N0_MCDDC_DP_STRUCT;

/* PCLS_11_CFG_DATA_INFO_N1_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x200230fc)                                                      */
/*      SPRB0 (0x200230fc)                                                      */
/*      SPRHBM (0x200230fc)                                                     */
/*      SPRC0 (0x200230fc)                                                      */
/*      SPRMCC (0x200230fc)                                                     */
/*      SPRUCC (0x200230fc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_11_CFG_DATA_INFO_N1_MCDDC_DP_REG 0x0B1230FC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 col : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Column address bits 9:2 */
    UINT32 data_offset : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Offset for the nibble of data to be spared; for
                               DDR4 or HBM, bits 7:5 selects transfer number 0
                               to 7 and bits 4:0 selects device number 0 to 17;
                               for DDR5, bits 7:4 selects transfer number 0 to
                               15 and bits 3:0 selects device number 0 to 9.
                            */
    UINT32 error : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is set when the enable of the pcls csr
                               is true but there is change in the
                               address/nibble offset content. When BIOS is
                               setting 0 to the enable of a pcls csr, this
                               should also be set to 0 so as to clear the error
                               indication
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_11_CFG_DATA_INFO_N1_MCDDC_DP_STRUCT;

/* PCLS_12_CFG_DATA_INFO_N0_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x20023100)                                                      */
/*      SPRB0 (0x20023100)                                                      */
/*      SPRHBM (0x20023100)                                                     */
/*      SPRC0 (0x20023100)                                                      */
/*      SPRMCC (0x20023100)                                                     */
/*      SPRUCC (0x20023100)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_12_CFG_DATA_INFO_N0_MCDDC_DP_REG 0x0B123100

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pcls_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enable which is RW only by BIOS.Also when the
                               enable of the pcls csr is true but there is
                               change in the address/nibble offset content
                               hardware will write 0 to the enable to prevent
                               future pcls match to this.
                            */
    UINT32 chip_select : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /* Rank CS0-CS7 (encoded chip select) of address */
    UINT32 cbit : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* C0-C2 (encoded subrank) of address */
    UINT32 bg : 3;

                            /* Bits[9:7], Access Type=RW, default=0x00000000*/

                            /* Bank Group */
    UINT32 ba : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /* Bank Address */
    UINT32 row : 18;

                            /* Bits[29:12], Access Type=RW, default=0x00000000*/

                            /* Row address */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_12_CFG_DATA_INFO_N0_MCDDC_DP_STRUCT;

/* PCLS_12_CFG_DATA_INFO_N1_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x20023104)                                                      */
/*      SPRB0 (0x20023104)                                                      */
/*      SPRHBM (0x20023104)                                                     */
/*      SPRC0 (0x20023104)                                                      */
/*      SPRMCC (0x20023104)                                                     */
/*      SPRUCC (0x20023104)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_12_CFG_DATA_INFO_N1_MCDDC_DP_REG 0x0B123104

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 col : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Column address bits 9:2 */
    UINT32 data_offset : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Offset for the nibble of data to be spared; for
                               DDR4 or HBM, bits 7:5 selects transfer number 0
                               to 7 and bits 4:0 selects device number 0 to 17;
                               for DDR5, bits 7:4 selects transfer number 0 to
                               15 and bits 3:0 selects device number 0 to 9.
                            */
    UINT32 error : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is set when the enable of the pcls csr
                               is true but there is change in the
                               address/nibble offset content. When BIOS is
                               setting 0 to the enable of a pcls csr, this
                               should also be set to 0 so as to clear the error
                               indication
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_12_CFG_DATA_INFO_N1_MCDDC_DP_STRUCT;

/* PCLS_13_CFG_DATA_INFO_N0_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x20023108)                                                      */
/*      SPRB0 (0x20023108)                                                      */
/*      SPRHBM (0x20023108)                                                     */
/*      SPRC0 (0x20023108)                                                      */
/*      SPRMCC (0x20023108)                                                     */
/*      SPRUCC (0x20023108)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_13_CFG_DATA_INFO_N0_MCDDC_DP_REG 0x0B123108

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pcls_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enable which is RW only by BIOS.Also when the
                               enable of the pcls csr is true but there is
                               change in the address/nibble offset content
                               hardware will write 0 to the enable to prevent
                               future pcls match to this
                            */
    UINT32 chip_select : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /* Rank CS0-CS7 (encoded chip select) of address */
    UINT32 cbit : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* C0-C2 (encoded subrank) of address */
    UINT32 bg : 3;

                            /* Bits[9:7], Access Type=RW, default=0x00000000*/

                            /* Bank Group */
    UINT32 ba : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /* Bank Address */
    UINT32 row : 18;

                            /* Bits[29:12], Access Type=RW, default=0x00000000*/

                            /* Row address */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_13_CFG_DATA_INFO_N0_MCDDC_DP_STRUCT;

/* PCLS_13_CFG_DATA_INFO_N1_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x2002310c)                                                      */
/*      SPRB0 (0x2002310c)                                                      */
/*      SPRHBM (0x2002310c)                                                     */
/*      SPRC0 (0x2002310c)                                                      */
/*      SPRMCC (0x2002310c)                                                     */
/*      SPRUCC (0x2002310c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_13_CFG_DATA_INFO_N1_MCDDC_DP_REG 0x0B12310C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 col : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Column address bits 9:2 */
    UINT32 data_offset : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Offset for the nibble of data to be spared; for
                               DDR4 or HBM, bits 7:5 selects transfer number 0
                               to 7 and bits 4:0 selects device number 0 to 17;
                               for DDR5, bits 7:4 selects transfer number 0 to
                               15 and bits 3:0 selects device number 0 to 9.
                            */
    UINT32 error : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is set when the enable of the pcls csr
                               is true but there is change in the
                               address/nibble offset content. When BIOS is
                               setting 0 to the enable of a pcls csr, this
                               should also be set to 0 so as to clear the error
                               indication
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_13_CFG_DATA_INFO_N1_MCDDC_DP_STRUCT;

/* PCLS_14_CFG_DATA_INFO_N0_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x20023110)                                                      */
/*      SPRB0 (0x20023110)                                                      */
/*      SPRHBM (0x20023110)                                                     */
/*      SPRC0 (0x20023110)                                                      */
/*      SPRMCC (0x20023110)                                                     */
/*      SPRUCC (0x20023110)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_14_CFG_DATA_INFO_N0_MCDDC_DP_REG 0x0B123110

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pcls_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enable which is RW only by BIOS.Also when the
                               enable of the pcls csr is true but there is
                               change in the address/nibble offset content
                               hardware will write 0 to the enable to prevent
                               future pcls match to this
                            */
    UINT32 chip_select : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /* Rank CS0-CS7 (encoded chip select) of address */
    UINT32 cbit : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* C0-C2 (encoded subrank) of address */
    UINT32 bg : 3;

                            /* Bits[9:7], Access Type=RW, default=0x00000000*/

                            /* Bank Group */
    UINT32 ba : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /* Bank Address */
    UINT32 row : 18;

                            /* Bits[29:12], Access Type=RW, default=0x00000000*/

                            /* Row address */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_14_CFG_DATA_INFO_N0_MCDDC_DP_STRUCT;

/* PCLS_14_CFG_DATA_INFO_N1_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x20023114)                                                      */
/*      SPRB0 (0x20023114)                                                      */
/*      SPRHBM (0x20023114)                                                     */
/*      SPRC0 (0x20023114)                                                      */
/*      SPRMCC (0x20023114)                                                     */
/*      SPRUCC (0x20023114)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_14_CFG_DATA_INFO_N1_MCDDC_DP_REG 0x0B123114

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 col : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Column address bits 9:2 */
    UINT32 data_offset : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Offset for the nibble of data to be spared; for
                               DDR4 or HBM, bits 7:5 selects transfer number 0
                               to 7 and bits 4:0 selects device number 0 to 17;
                               for DDR5, bits 7:4 selects transfer number 0 to
                               15 and bits 3:0 selects device number 0 to 9.
                            */
    UINT32 error : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is set when the enable of the pcls csr
                               is true but there is change in the
                               address/nibble offset content. When BIOS is
                               setting 0 to the enable of a pcls csr, this
                               should also be set to 0 so as to clear the error
                               indication
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_14_CFG_DATA_INFO_N1_MCDDC_DP_STRUCT;

/* PCLS_15_CFG_DATA_INFO_N0_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x20023118)                                                      */
/*      SPRB0 (0x20023118)                                                      */
/*      SPRHBM (0x20023118)                                                     */
/*      SPRC0 (0x20023118)                                                      */
/*      SPRMCC (0x20023118)                                                     */
/*      SPRUCC (0x20023118)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_15_CFG_DATA_INFO_N0_MCDDC_DP_REG 0x0B123118

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pcls_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Enable which is RW only by BIOS.Also when the
                               enable of the pcls csr is true but there is
                               change in the address/nibble offset content
                               hardware will write 0 to the enable to prevent
                               future pcls match to this
                            */
    UINT32 chip_select : 3;

                            /* Bits[3:1], Access Type=RW, default=0x00000000*/

                            /* Rank CS0-CS7 (encoded chip select) of address */
    UINT32 cbit : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* C0-C2 (encoded subrank) of address */
    UINT32 bg : 3;

                            /* Bits[9:7], Access Type=RW, default=0x00000000*/

                            /* Bank Group */
    UINT32 ba : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /* Bank Address */
    UINT32 row : 18;

                            /* Bits[29:12], Access Type=RW, default=0x00000000*/

                            /* Row address */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_15_CFG_DATA_INFO_N0_MCDDC_DP_STRUCT;

/* PCLS_15_CFG_DATA_INFO_N1_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x2002311c)                                                      */
/*      SPRB0 (0x2002311c)                                                      */
/*      SPRHBM (0x2002311c)                                                     */
/*      SPRC0 (0x2002311c)                                                      */
/*      SPRMCC (0x2002311c)                                                     */
/*      SPRUCC (0x2002311c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Includes info for PCLS: enable,address,offset,valid
*/


#define PCLS_15_CFG_DATA_INFO_N1_MCDDC_DP_REG 0x0B12311C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 col : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Column address bits 9:2 */
    UINT32 data_offset : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Offset for the nibble of data to be spared; for
                               DDR4 or HBM, bits 7:5 selects transfer number 0
                               to 7 and bits 4:0 selects device number 0 to 17;
                               for DDR5, bits 7:4 selects transfer number 0 to
                               15 and bits 3:0 selects device number 0 to 9.
                            */
    UINT32 error : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is set when the enable of the pcls csr
                               is true but there is change in the
                               address/nibble offset content. When BIOS is
                               setting 0 to the enable of a pcls csr, this
                               should also be set to 0 so as to clear the error
                               indication
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_15_CFG_DATA_INFO_N1_MCDDC_DP_STRUCT;

/* PCLS_SPAREDNIBBLE_CAPTURE_DELAY_MCDDC_DP_REG supported on:                   */
/*      SPRA0 (0x20023120)                                                      */
/*      SPRB0 (0x20023120)                                                      */
/*      SPRHBM (0x20023120)                                                     */
/*      SPRC0 (0x20023120)                                                      */
/*      SPRMCC (0x20023120)                                                     */
/*      SPRUCC (0x20023120)                                                     */
/* Register default value on SPRA0: 0x00000025                                  */
/* Register default value on SPRB0: 0x00000025                                  */
/* Register default value on SPRHBM: 0x00000025                                 */
/* Register default value on SPRC0: 0x00000025                                  */
/* Register default value on SPRMCC: 0x00000025                                 */
/* Register default value on SPRUCC: 0x00000025                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This is IO tx delay + IO Rx Delay - programmed by BIOS during training, and this is the delay by which we delay capturing the write data
*/


#define PCLS_SPAREDNIBBLE_CAPTURE_DELAY_MCDDC_DP_REG 0x0B123120

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 capture_delay : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000025*/

                            /*
                               Indicates delay value to delay capturing PCLS
                               spared nibble for writes
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCLS_SPAREDNIBBLE_CAPTURE_DELAY_MCDDC_DP_STRUCT;

/* MCDP_CMI_ERR_INJ_CFG_N0_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x20023128)                                                      */
/*      SPRB0 (0x20023128)                                                      */
/*      SPRHBM (0x20023128)                                                     */
/*      SPRC0 (0x20023128)                                                      */
/*      SPRMCC (0x20023128)                                                     */
/*      SPRUCC (0x20023128)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: ERR_INJ                                          */
/* SPRB0 Security PolicyGroup: ERR_INJ                                          */
/* SPRHBM Security PolicyGroup: ERR_INJ                                         */
/* SPRC0 Security PolicyGroup: ERR_INJ                                          */
/* SPRMCC Security PolicyGroup: ERR_INJ                                         */
/* SPRUCC Security PolicyGroup: ERR_INJ                                         */
/* MC dp CMI error injection configuration register.
*/


#define MCDP_CMI_ERR_INJ_CFG_N0_MCDDC_DP_REG 0x0B123128

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rd_cpl_data_ecc_xor_vec : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               4B vector of bits to flip for ECC error
                               injection
                            */

  } Bits;
  UINT32 Data;

} MCDP_CMI_ERR_INJ_CFG_N0_MCDDC_DP_STRUCT;

/* MCDP_CMI_ERR_INJ_CFG_N1_MCDDC_DP_REG supported on:                           */
/*      SPRA0 (0x2002312c)                                                      */
/*      SPRB0 (0x2002312c)                                                      */
/*      SPRHBM (0x2002312c)                                                     */
/*      SPRC0 (0x2002312c)                                                      */
/*      SPRMCC (0x2002312c)                                                     */
/*      SPRUCC (0x2002312c)                                                     */
/* Register default value on SPRA0: 0x000C02C0                                  */
/* Register default value on SPRB0: 0x000C02C0                                  */
/* Register default value on SPRHBM: 0x000C02C0                                 */
/* Register default value on SPRC0: 0x000C02C0                                  */
/* Register default value on SPRMCC: 0x000C02C0                                 */
/* Register default value on SPRUCC: 0x000C02C0                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: ERR_INJ                                          */
/* SPRB0 Security PolicyGroup: ERR_INJ                                          */
/* SPRHBM Security PolicyGroup: ERR_INJ                                         */
/* SPRC0 Security PolicyGroup: ERR_INJ                                          */
/* SPRMCC Security PolicyGroup: ERR_INJ                                         */
/* SPRUCC Security PolicyGroup: ERR_INJ                                         */
/* MC dp CMI error injection configuration register.
*/


#define MCDP_CMI_ERR_INJ_CFG_N1_MCDDC_DP_REG 0x0B12312C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rd_cpl_data_ecc_inj_type : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* 0: Inject on data, 1: inject on ECC */
    UINT32 rd_cpl_data_ecc_inj_pump_index : 2;

                            /* Bits[2:1], Access Type=RW, default=0x00000000*/

                            /*
                               Which of the 4 16B data pumps to inject on. If
                               injecting on ECC, only the LSB is considered to
                               designate which 32B half to inject an error into
                               the ECC code.
                            */
    UINT32 rd_cpl_data_ecc_inj_quad_index : 2;

                            /* Bits[4:3], Access Type=RW, default=0x00000000*/

                            /*
                               Which of the 4 4B quadrants to inject on per 16B
                               pump
                            */
    UINT32 rd_cpl_data_ecc_inj_enable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable bit to control rd_cpl data ecc error
                               injection
                            */
    UINT32 rd_cpl_data_ecc_inj_once : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /*
                               When set, only one ecc error will be injected.
                               When cleared, errors will be continually
                               injected via the lfsr.
                            */
    UINT32 rd_cpl_data_parity_inj_lfsr_seed : 10;

                            /* Bits[16:7], Access Type=RW, default=0x00000005*/

                            /* Seed for parity injection lfsr */
    UINT32 rd_cpl_data_ecc_inj_lfsr_width : 4;

                            /* Bits[20:17], Access Type=RW, default=0x00000006*/

                            /* Width of ecc injection lfsr */
    UINT32 rd_cpl_data_err_inj_type : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* 0: Inject on data, 1: inject on ECC syndrome */
    UINT32 rsvd : 9;

                            /* Bits[30:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 vld : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Valid bit to signify firmware has programmed the
                               necessary fields
                            */

  } Bits;
  UINT32 Data;

} MCDP_CMI_ERR_INJ_CFG_N1_MCDDC_DP_STRUCT;

/* MCWDB_DDRIO_MCDDC_DP_REG supported on:                                       */
/*      SPRA0 (0x20023130)                                                      */
/*      SPRB0 (0x20023130)                                                      */
/*      SPRHBM (0x20023130)                                                     */
/*      SPRC0 (0x20023130)                                                      */
/*      SPRMCC (0x20023130)                                                     */
/*      SPRUCC (0x20023130)                                                     */
/* Register default value on SPRA0: 0x00000001                                  */
/* Register default value on SPRB0: 0x00000001                                  */
/* Register default value on SPRHBM: 0x00000001                                 */
/* Register default value on SPRC0: 0x00000001                                  */
/* Register default value on SPRMCC: 0x00000001                                 */
/* Register default value on SPRUCC: 0x00000001                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Write data timing configuration for ddrio
*/


#define MCWDB_DDRIO_MCDDC_DP_REG 0x0B123130

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_ddrio_earlywdata : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Disable sending write data early to ddrio for
                               anti cross talk logic; If 0, data will be sent
                               early one Dclock so ddrio has time to do cross
                               talk cancelation logic. If set to 1, write data
                               will be sent with normal timing and ddrio will
                               have no time to do cross talk cancelation logic.
                            */
    UINT32 rsvd : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCWDB_DDRIO_MCDDC_DP_STRUCT;

/* ECC_MODE_DP_MCDDC_DP_REG supported on:                                       */
/*      SPRA0 (0x20023138)                                                      */
/*      SPRB0 (0x20023138)                                                      */
/*      SPRHBM (0x20023138)                                                     */
/*      SPRC0 (0x20023138)                                                      */
/*      SPRMCC (0x20023138)                                                     */
/*      SPRUCC (0x20023138)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This register specifies the current ECC configuration for each rank.
*/


#define ECC_MODE_DP_MCDDC_DP_REG 0x0B123138

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mode : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the ECC in use for the
                               corresponding rank. Bit 0 is for rank and bit 7
                               is for rank 7. For each bit, 0 = No failure 1 =
                               Parity substitution. EP: Detect only, EX: Single
                               bit correction This field is set by software at
                               the beginning of a sparing flow. It is used only
                               for detecting configuration error and is not
                               used for actual substitution.
                            */
    UINT32 enable_32b_intlv_ddr5 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to enable 32B interleave mode
                               for DDR5. 1-> 32B interleave mode enabled 0->
                               32B interleave mode disabled
                            */
    UINT32 rsvd : 22;

                            /* Bits[30:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mirror_mode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Mirror enable indication; used to disable fatal
                               error logging/signaling for link fail condition.
                            */

  } Bits;
  UINT32 Data;

} ECC_MODE_DP_MCDDC_DP_STRUCT;

/* MCDP_CMI_CFG_MCDDC_DP_REG supported on:                                      */
/*      SPRA0 (0x20023140)                                                      */
/*      SPRB0 (0x20023140)                                                      */
/*      SPRHBM (0x20023140)                                                     */
/*      SPRC0 (0x20023140)                                                      */
/*      SPRMCC (0x20023140)                                                     */
/*      SPRUCC (0x20023140)                                                     */
/* Register default value on SPRA0: 0x0000003F                                  */
/* Register default value on SPRB0: 0x0000003F                                  */
/* Register default value on SPRHBM: 0x0000003F                                 */
/* Register default value on SPRC0: 0x0000003F                                  */
/* Register default value on SPRMCC: 0x0000003F                                 */
/* Register default value on SPRUCC: 0x0000003F                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* mcdp CMI config bits
*/


#define MCDP_CMI_CFG_MCDDC_DP_REG 0x0B123140

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rd_cpl_data_ecc_vld : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /* Valid bit to qualify rd_cpl data ecc generation */
    UINT32 rd_cpl_data_parity_vld : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /* Valid bit to qualify rd_cpl data parity bit */
    UINT32 rsp_overflow_err_enable : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /* cmi error enable bit */
    UINT32 rsp_underflow_err_enable : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000001*/

                            /* cmi error enable bit */
    UINT32 rd_cpl_overflow_err_enable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /* cmi error enable bit */
    UINT32 rd_cpl_underflow_err_enable : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /* cmi error enable bit */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCDP_CMI_CFG_MCDDC_DP_STRUCT;

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* POISON_PATTERN_MCDDC_DP_REG supported on:                                    */
/*      SPRC0 (0x20023144)                                                      */
/*      SPRMCC (0x20023144)                                                     */
/*      SPRUCC (0x20023144)                                                     */
/* Register default value on SPRC0: 0xFFFFFFEE                                  */
/* Register default value on SPRMCC: 0xFFFFFFEE                                 */
/* Register default value on SPRUCC: 0xFFFFFFEE                                 */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRC0 BDF: 0_0_0                                       */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains programmable poison pattern
*/

#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

/* MCDP_CMI_QDEPTH_CFG_MCDDC_DP_REG supported on:                               */
/*      SPRA0 (0x20023148)                                                      */
/*      SPRB0 (0x20023148)                                                      */
/*      SPRHBM (0x20023148)                                                     */
/*      SPRC0 (0x20023148)                                                      */
/*      SPRMCC (0x20023148)                                                     */
/*      SPRUCC (0x20023148)                                                     */
/* Register default value on SPRA0: 0x1E046666                                  */
/* Register default value on SPRB0: 0x1E046666                                  */
/* Register default value on SPRHBM: 0x1E046666                                 */
/* Register default value on SPRC0: 0x1E046666                                  */
/* Register default value on SPRMCC: 0x1E046666                                 */
/* Register default value on SPRUCC: 0x1E046666                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* mcdp CMI qdepth configuration
*/


#define MCDP_CMI_QDEPTH_CFG_MCDDC_DP_REG 0x0B123148

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vc0_rd_cpl_credits : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000006*/

                            /* VC0 read completion qdepth credits */
    UINT32 vc1_rd_cpl_credits : 4;

                            /* Bits[7:4], Access Type=RW, default=0x00000006*/

                            /* VC1 read completion qdepth credits */
    UINT32 vc2_rd_cpl_credits : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000006*/

                            /* VC2 read completion qdepth credits */
    UINT32 vc3_rd_cpl_credits : 4;

                            /* Bits[15:12], Access Type=RW, default=0x00000006*/

                            /* VC3 read completion qdepth credits */
    UINT32 rd_cpl_shared_credits : 9;

                            /* Bits[24:16], Access Type=RW, default=0x00000004*/

                            /* Shared rd_cpl qdepth credits */
    UINT32 rd_cpl_qdepth_vc_vec : 4;

                            /* Bits[28:25], Access Type=RW, default=0x0000000F*/

                            /*
                               Qdepth vector to qualify which vcs obey qdepth
                               in rd_cpl crediting
                            */
    UINT32 rsvd : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCDP_CMI_QDEPTH_CFG_MCDDC_DP_STRUCT;

/* DIS_MC_FIFO_ERROR_MCDDC_DP_REG supported on:                                 */
/*      SPRA0 (0x2002314c)                                                      */
/*      SPRB0 (0x2002314c)                                                      */
/*      SPRHBM (0x2002314c)                                                     */
/*      SPRC0 (0x2002314c)                                                      */
/*      SPRMCC (0x2002314c)                                                     */
/*      SPRUCC (0x2002314c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains disable bits for each error condition for MC FIFO error
*/


#define DIS_MC_FIFO_ERROR_MCDDC_DP_REG 0x0B12314C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_byte_en_wr_fifo_err : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by byte enable FIFO for
                               writes
                            */
    UINT32 dis_byte_en_ufill_fifo_err : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by byte enable FIFO for
                               ufill
                            */
    UINT32 dis_wid_fifo_err : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Disable error caused by WID FIFO */
    UINT32 dis_pcls_fifo_err : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* Disable error caused by PCLS FIFO */
    UINT32 rsvd : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIS_MC_FIFO_ERROR_MCDDC_DP_STRUCT;

/* MC_FIFO_ERROR_MCDDC_DP_REG supported on:                                     */
/*      SPRA0 (0x20023150)                                                      */
/*      SPRB0 (0x20023150)                                                      */
/*      SPRHBM (0x20023150)                                                     */
/*      SPRC0 (0x20023150)                                                      */
/*      SPRMCC (0x20023150)                                                     */
/*      SPRUCC (0x20023150)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains each error condition for MC FIFO error
*/


#define MC_FIFO_ERROR_MCDDC_DP_REG 0x0B123150

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 byte_en_wr_fifo_err : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /* Error caused by byte enable FIFO for writes */
    UINT32 byte_en_ufill_fifo_err : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /* Error caused by byte enable FIFO for ufill */
    UINT32 wid_fifo_err : 1;

                            /* Bits[2:2], Access Type=RO/V, default=0x00000000*/

                            /* Error caused by WID FIFO */
    UINT32 pcls_fifo_err : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000000*/

                            /* Error caused by PCLS FIFO */
    UINT32 rsvd : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MC_FIFO_ERROR_MCDDC_DP_STRUCT;

/* MC_CPGC_ECC_MCDDC_DP_REG supported on:                                       */
/*      SPRA0 (0x20023158)                                                      */
/*      SPRB0 (0x20023158)                                                      */
/*      SPRHBM (0x20023158)                                                     */
/*      SPRC0 (0x20023158)                                                      */
/*      SPRMCC (0x20023158)                                                     */
/*      SPRUCC (0x20023158)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR       */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wdb_crnode/MEM_MCDP_CSR      */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* MC Datapath Controls for CPGC operation
*/


#define MC_CPGC_ECC_MCDDC_DP_REG 0x0B123158

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cpgc_ecc_generate_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               0x0 = Use CPGC Metadata Pattern 0x1 = Use Native
                               ECC Calculated Value
                            */
    UINT32 cpgc_ecc_check_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               If set, check return ecc data against native ECC
                               calculated value while in CPGC mode
                            */
    UINT32 rsvd : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MC_CPGC_ECC_MCDDC_DP_STRUCT;

/* LINK_ERROR_MCDDC_DP_REG supported on:                                        */
/*      SPRA0 (0x20023400)                                                      */
/*      SPRB0 (0x20023400)                                                      */
/*      SPRHBM (0x20023400)                                                     */
/*      SPRC0 (0x20023400)                                                      */
/*      SPRMCC (0x20023400)                                                     */
/*      SPRUCC (0x20023400)                                                     */
/* Register default value on SPRA0: 0x00000020                                  */
/* Register default value on SPRB0: 0x00000020                                  */
/* Register default value on SPRHBM: 0x00000020                                 */
/* Register default value on SPRC0: 0x00000020                                  */
/* Register default value on SPRMCC: 0x00000020                                 */
/* Register default value on SPRUCC: 0x00000020                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register holds the status and configuration of the
link_ERR# signal.
*/


#define LINK_ERROR_MCDDC_DP_REG 0x0B123400

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 link_err_latency : 7;

                            /* Bits[6:0], Access Type=RW/P, default=0x00000020*/

                            /*
                               This register is not used by RTL. Use the
                               formula here to calculate the value for
                               scheduler_delay.write_err_latency. The maximum
                               delay (in DCLKs) between a command or data with
                               an error and the observed assertion of SMI_ERR#.
                               Without WrCRC enabled, the value should be CA-
                               parity-latency = DDRIO-pipeline-forward +
                               Forward-board-delay + tPAR_alert + return-board-
                               delay + DDRIO-pipeline-return. With WrCRC
                               enabled, the value should be CRC-alert-latency =
                               DDRIO-pipeline-forward + Forward-board-delay +
                               tCWL + 5(data burst length) + tCRC_alert +
                               return-board-delay + DDRIO-pipeline-return. The
                               maximum value of the CSR field should be less
                               than 17 + tCWL + tWTR + DDRIO-pipeline-forward +
                               Forward-board-delay + tCL + return-board-delay +
                               DDRIO-pipeline-return or 17 + tCWL + tWTR +
                               round trip latency.
                            */
    UINT32 rsvd : 25;

                            /* Bits[31:7], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LINK_ERROR_MCDDC_DP_STRUCT;

/* DDR4_CA_CTL_MCDDC_DP_REG supported on:                                       */
/*      SPRA0 (0x20023404)                                                      */
/*      SPRB0 (0x20023404)                                                      */
/*      SPRHBM (0x20023404)                                                     */
/*      SPRC0 (0x20023404)                                                      */
/*      SPRMCC (0x20023404)                                                     */
/*      SPRUCC (0x20023404)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00016000                                  */
/* Register default value on SPRMCC: 0x00016000                                 */
/* Register default value on SPRUCC: 0x00016000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register holds theControl bits for DDR4 C/A parity error flow logic
*/


#define DDR4_CA_CTL_MCDDC_DP_REG 0x0B123404

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 erf_en0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               This should be set to 1 to enable error flow.
                               Keep this bit at 0 if only DDRT is present on
                               the channel.
                            */
    UINT32 erf_regpart0 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               This should be set to 1 if RDIMM/LRDIMMs are
                               populated in the channel
                            */
    UINT32 rsvd : 2;

                            /* Bits[3:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tpar_recov : 8;

                            /* Bits[11:4], Access Type=RW, default=0x00000000*/

                            /*
                               largest ( tPAR_ALERT_ON + tPAR_ALERT_PW ) value
                               of a rank populated in the channel in DCLK.
                            */
    UINT32 rsvd_12 : 20;

                            /* Bits[31:12], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDR4_CA_CTL_MCDDC_DP_SPRA0_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 erf_en0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               This should be set to 1 to enable error flow.
                               Keep this bit at 0 if only DDRT is present on
                               the channel.
                            */
    UINT32 erf_regpart0 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               This should be set to 1 if RDIMM/LRDIMMs are
                               populated in the channel
                            */
    UINT32 rsvd : 2;

                            /* Bits[3:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tpar_recov : 8;

                            /* Bits[11:4], Access Type=RW, default=0x00000000*/

                            /*
                               largest ( tPAR_ALERT_ON + tPAR_ALERT_PW ) value
                               of a rank populated in the channel in DCLK.
                            */
    UINT32 bus_quiet_rdb_block_dly : 7;

                            /* Bits[18:12], Access Type=RW, default=0x00000016*/

                            /*
                               Delay to start block of reading data from RDB
                               after rcomp or DQS block is set, in terms of
                               Hclk. This value is expected to be equal to
                               roundtrip delay.
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDR4_CA_CTL_MCDDC_DP_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 erf_en0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               This should be set to 1 to enable error flow.
                               Keep this bit at 0 if only DDRT is present on
                               the channel.
                            */
    UINT32 erf_regpart0 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               This should be set to 1 if RDIMM/LRDIMMs are
                               populated in the channel
                            */
    UINT32 rsvd : 2;

                            /* Bits[3:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tpar_recov : 8;

                            /* Bits[11:4], Access Type=RW, default=0x00000000*/

                            /*
                               largest ( tPAR_ALERT_ON + tPAR_ALERT_PW ) value
                               of a rank populated in the channel in DCLK.
                            */
    UINT32 rsvd_12 : 20;

                            /* Bits[31:12], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDR4_CA_CTL_MCDDC_DP_STRUCT;

/* MCDP_RCB_GATE_CTL_MCDDC_DP_REG supported on:                                 */
/*      SPRA0 (0x20023408)                                                      */
/*      SPRB0 (0x20023408)                                                      */
/*      SPRHBM (0x20023408)                                                     */
/*      SPRC0 (0x20023408)                                                      */
/*      SPRMCC (0x20023408)                                                     */
/*      SPRUCC (0x20023408)                                                     */
/* Register default value on SPRA0: 0x00000040                                  */
/* Register default value on SPRB0: 0x00000040                                  */
/* Register default value on SPRHBM: 0x00000040                                 */
/* Register default value on SPRC0: 0x00000040                                  */
/* Register default value on SPRMCC: 0x00000040                                 */
/* Register default value on SPRUCC: 0x00000040                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Control information for RCB clock gating in mcdp
*/


#define MCDP_RCB_GATE_CTL_MCDDC_DP_REG 0x0B123408

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rcb_gate_mcdp_timer : 10;

                            /* Bits[9:0], Access Type=RW, default=0x00000040*/

                            /* Time clock keeps running after triggering events */
    UINT32 rsvd : 22;

                            /* Bits[31:10], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCDP_RCB_GATE_CTL_MCDDC_DP_STRUCT;


/* MC0_DP_CHKN_BIT_MCDDC_DP_REG supported on:                                   */
/*      SPRA0 (0x20023414)                                                      */
/*      SPRB0 (0x20023414)                                                      */
/*      SPRHBM (0x20023414)                                                     */
/*      SPRC0 (0x20023414)                                                      */
/*      SPRMCC (0x20023414)                                                     */
/*      SPRUCC (0x20023414)                                                     */
/* Register default value on SPRA0: 0x01400000                                  */
/* Register default value on SPRB0: 0x01400000                                  */
/* Register default value on SPRHBM: 0x01400000                                 */
/* Register default value on SPRC0: 0x01400000                                  */
/* Register default value on SPRMCC: 0x01400000                                 */
/* Register default value on SPRUCC: 0x01400000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Note: some defeatures are only present in MC0 register
*/


#define MC0_DP_CHKN_BIT_MCDDC_DP_REG 0x0B123414

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_ecc_chk : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Disable ECC checking */
    UINT32 dis_rdimm_par_chk : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Disable rdimm par check */
    UINT32 dis_ha_par_chk : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Disable HA par check */
    UINT32 dis_ha_par_gen : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* Disable HA par gen */
    UINT32 dis_ha_be_par_chk : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Disable HA BE par check */
    UINT32 dis_cmi_ucecc_err_log : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /* Disable CMI UC Ecc Error */
    UINT32 dis_cmi_correcc_err_log : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* Disable CMI Correctable Ecc Error */
    UINT32 dis_err_det_prtl_wr_underfl : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error detection for partial write
                               underfills
                            */
    UINT32 ovrd_trng_rank_to_io : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* Override training rank output to IO */
    UINT32 dis_2lm_metadata_fatal : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* Disable fatal error on 2LM metadata error */
    UINT32 dis_ck_gate_dp : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Disable clock gating - read and write data path */
    UINT32 dis_sched_parity_err_log : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /* Disable Scheduler Parity Error logging */
    UINT32 cfglateerr : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /* Configure Err return to HA one cycle late */
    UINT32 mcforcercvend3nnh : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /* Reserve - unused. */
    UINT32 dis_poison_err_log : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error logging for the case when poison
                               is being sent to m2m when poison_enable=0
                            */
    UINT32 ign_ptrl_uc : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Downgrades patrol scrubbing uncorrectable errors
                               to correactable.
                            */
    UINT32 ign_mca_ovrd : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, disables the MCA regular override
                               mechanism and keeps current logs
                            */
    UINT32 dis_uc_ufill_err_log : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Enables logging of uncorrectable read errors in
                               ufill reads to MCA banks
                            */
    UINT32 dis_uc_err_log : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Disables logging of uncorrectable read errors to
                               MCA banks.
                            */
    UINT32 dis_corr_err_log : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Disables logging of correctable read errors to
                               MCA banks.
                            */
    UINT32 dis_wdb_par_chk : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /* Disable Write Data Buffer parity checking */
    UINT32 dis_hbm_derr_log : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* Disable HBM write data parity error logging. */
    UINT32 no_over_ce : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               Set to 1 to avoid CE to override CE in MCA
                               banks.
                            */
    UINT32 dis_link_link_fail : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /* Disable link link fail. */
    UINT32 en_rdimm_par_err_log : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000001*/

                            /* Enable RDIMM parity error logging. */
    UINT32 dis_rrd_psn : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /* Disable poison detection in the RRD. */
    UINT32 dis_verr_ecc_trials : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /* Disable verr ECC trials. */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_uncorr_rd_err_log : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /* Disable uncorrectable demand read error logging. */
    UINT32 dis_uncorr_ufill_rd_err_log : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* Disable UC error for ufill read logging. */
    UINT32 dis_transient_rd_err_log : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* Disable transient error logging. */
    UINT32 dis_appp_err_log : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Disable APPP error logging. */

  } Bits;
  UINT32 Data;

} MC0_DP_CHKN_BIT_MCDDC_DP_STRUCT;

/* LINK_RETRY_TIMER2_MCDDC_DP_REG supported on:                                 */
/*      SPRA0 (0x20023418)                                                      */
/*      SPRB0 (0x20023418)                                                      */
/*      SPRHBM (0x20023418)                                                     */
/*      SPRC0 (0x20023418)                                                      */
/*      SPRMCC (0x20023418)                                                     */
/*      SPRUCC (0x20023418)                                                     */
/* Register default value on SPRA0: 0xF87FFFFF                                  */
/* Register default value on SPRB0: 0xF87FFFFF                                  */
/* Register default value on SPRHBM: 0xF87FFFFF                                 */
/* Register default value on SPRC0: 0xF87FFFFF                                  */
/* Register default value on SPRMCC: 0xF87FFFFF                                 */
/* Register default value on SPRUCC: 0xF87FFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Configuration settings for the timers for Intel LINK 2 Retry
*/


#define LINK_RETRY_TIMER2_MCDDC_DP_REG 0x0B123418

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd_0 : 15;

                            /* Bits[14:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_cmpl_time : 11;

                            /* Bits[25:15], Access Type=RW/P, default=0x000000FF*/

                            /*
                               Wait time in DRAIN_RD state to allow command
                               completion. Value of this field is equal to
                               tZQOPER minus train_reset_time
                            */
    UINT32 rd_drain_time : 6;

                            /* Bits[31:26], Access Type=RW/P, default=0x0000003E*/

                            /*
                               Wait time in DRAIN_RD state for in flight reads
                               to complete
                            */

  } Bits;
  UINT32 Data;

} LINK_RETRY_TIMER2_MCDDC_DP_STRUCT;

/* LINK_RETRY_ERR_LIMITS_MCDDC_DP_REG supported on:                             */
/*      SPRA0 (0x2002341c)                                                      */
/*      SPRB0 (0x2002341c)                                                      */
/*      SPRHBM (0x2002341c)                                                     */
/*      SPRC0 (0x2002345c)                                                      */
/*      SPRMCC (0x2002345c)                                                     */
/*      SPRUCC (0x2002345c)                                                     */
/* Register default value on SPRA0: 0x00100000                                  */
/* Register default value on SPRB0: 0x00100000                                  */
/* Register default value on SPRHBM: 0x00100000                                 */
/* Register default value on SPRC0: 0x00100000                                  */
/* Register default value on SPRMCC: 0x00100000                                 */
/* Register default value on SPRUCC: 0x00100000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Thresholds at which transient errors are considered persistent and trigger a link width change.  
*/


#define LINK_RETRY_ERR_LIMITS_MCDDC_DP_REG 0x0B1A0001

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 16;

                            /* Bits[15:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sb_err_limit : 15;

                            /* Bits[30:16], Access Type=RW/P, default=0x00000010*/

                            /*
                               Number of transient errors
                               (link_retry_sb_err_count.transient_err_cnt)
                               allowed before the SB error is declared
                               persistent.
                            */
    UINT32 sb_err_enable : 1;

                            /* Bits[31:31], Access Type=RW/P, default=0x00000000*/

                            /* Enable persistent condition. */

  } Bits;
  UINT32 Data;

} LINK_RETRY_ERR_LIMITS_MCDDC_DP_STRUCT;

/* LINK_RETRY_TIMER_MCDDC_DP_REG supported on:                                  */
/*      SPRA0 (0x20023420)                                                      */
/*      SPRB0 (0x20023420)                                                      */
/*      SPRHBM (0x20023420)                                                     */
/*      SPRC0 (0x20023420)                                                      */
/*      SPRMCC (0x20023420)                                                     */
/*      SPRUCC (0x20023420)                                                     */
/* Register default value on SPRA0: 0x84000C00                                  */
/* Register default value on SPRB0: 0x84000C00                                  */
/* Register default value on SPRHBM: 0x84000C00                                 */
/* Register default value on SPRC0: 0x84000C00                                  */
/* Register default value on SPRMCC: 0x84000C00                                 */
/* Register default value on SPRUCC: 0x84000C00                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Configuration settings for the timers for Intel SMI 2 Retry
*/


#define LINK_RETRY_TIMER_MCDDC_DP_REG 0x0B123420

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 link_err_flow_time_unit : 10;

                            /* Bits[9:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Holds the tick amount (specified in DCLKs) for
                               the error observation window timers.
                            */
    UINT32 rsvd_10 : 1;

                            /* Bits[10:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sb_err_observation_time : 5;

                            /* Bits[15:11], Access Type=RW/P, default=0x00000001*/

                            /*
                               Error observation window (in units
                               oflink_err_flow_time_unit *
                               2sb_err_observation_time) during which Intel
                               LINK 2 Command and SB Data transient errors are
                               counted. The value programmed in this register
                               gets divided by 2 in hardware to convert it to
                               Hclk value. As a result a value of 0 is not
                               allowed.
                            */
    UINT32 rsvd : 10;

                            /* Bits[25:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 link_fail_observation_time : 5;

                            /* Bits[30:26], Access Type=RW/P, default=0x00000001*/

                            /*
                               Error observation window (in units of
                               link_err_flow_time_unit *
                               2link_fail_observation_time) during which link
                               fail events are counted. The value programmed in
                               this register gets divided by 2 in hardware to
                               convert it to Hclk value. As a result a value of
                               0 is not allowed.
                            */
    UINT32 reset_verr_err_cnt : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               Hardware resets the error transient and
                               persistent counters as well as the link fail
                               counters when this bit changes from a 0 to 1.
                            */

  } Bits;
  UINT32 Data;

} LINK_RETRY_TIMER_MCDDC_DP_STRUCT;

/* LINK_LINK_FAIL_MCDDC_DP_REG supported on:                                    */
/*      SPRA0 (0x20023424)                                                      */
/*      SPRB0 (0x20023424)                                                      */
/*      SPRHBM (0x20023424)                                                     */
/*      SPRC0 (0x20023424)                                                      */
/*      SPRMCC (0x20023424)                                                     */
/*      SPRUCC (0x20023424)                                                     */
/* Register default value on SPRA0: 0x00000100                                  */
/* Register default value on SPRB0: 0x00000100                                  */
/* Register default value on SPRHBM: 0x00000100                                 */
/* Register default value on SPRC0: 0x00000100                                  */
/* Register default value on SPRMCC: 0x00000100                                 */
/* Register default value on SPRUCC: 0x00000100                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Configuration settings for the Intel LINK 2 Retry link fail state
*/


#define LINK_LINK_FAIL_MCDDC_DP_REG 0x0B123424

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd_0 : 8;

                            /* Bits[7:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fail_threshold : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000001*/

                            /*
                               Threshold of link_link_fail.fail_count for which
                               the link will go to the Link fail state.
                               fail_threshold = 0 means the first persistent
                               failure in the Half Width C - SB state will
                               cause Link Fail.
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LINK_LINK_FAIL_MCDDC_DP_STRUCT;

/* LINK_ERR_FSM_TRIGGER_CTL_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x20023428)                                                      */
/*      SPRB0 (0x20023428)                                                      */
/*      SPRHBM (0x20023428)                                                     */
/*      SPRC0 (0x20023428)                                                      */
/*      SPRMCC (0x20023428)                                                     */
/*      SPRUCC (0x20023428)                                                     */
/* Register default value on SPRA0: 0x00022000                                  */
/* Register default value on SPRB0: 0x00022000                                  */
/* Register default value on SPRHBM: 0x00022000                                 */
/* Register default value on SPRC0: 0x00022000                                  */
/* Register default value on SPRMCC: 0x00022000                                 */
/* Register default value on SPRUCC: 0x00022000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Register to program triggers from the Intel LINK 2 FSM
*/


#define LINK_ERR_FSM_TRIGGER_CTL_MCDDC_DP_REG 0x0B123428

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd_0 : 1;

                            /* Bits[0:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ctl_enable_trigger : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Generate the Intel LINK 2 Error FSM trigger
                               event if any of the programmed triggers occur.
                            */
    UINT32 rsvd : 2;

                            /* Bits[3:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 trigger_sb_pers_lmt : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Trigger if a SB persistent event is seen. */
    UINT32 rsvd_5 : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 trigger_sb_uncorr_lmt : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger if a SB persistent errors hit the SB
                               uncorrectable limit.
                            */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 trigger_sb_trns_err : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger if CAP Error FSM sees a SB transient
                               error
                            */
    UINT32 trigger_inj_link_err : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* Trigger if a CAP error is injected by the MC */
    UINT32 trigger_link_state_1 : 4;

                            /* Bits[13:10], Access Type=RW, default=0x00000008*/

                            /*
                               Trigger if the CAP Error FSM enter a specific
                               state. trigger_link_state_1 and
                               trigger_link_state_2 provide the ability to
                               trigger on two different states. The encoding
                               for the states is shown below. Since encoding of
                               0b1000 is unused, the field must be programmed
                               to 0x8 to disable matching with the IDLE state.
                               IDLE : 0000 DRAIN_RD : 0010 DRAIN_WR_INIT : 0011
                               RESTART : 0100 WAKE_DRAM : 0101 DRAIN_WR : 0110
                               POST_DRAIN_WR : 0111 LINK_FAIL : 1001 TRIAL :
                               1010 SCRAMBLE_SYNC : 1011 SUCCESS : 1101 FAILURE
                               : 1111
                            */
    UINT32 trigger_link_state_2 : 4;

                            /* Bits[17:14], Access Type=RW, default=0x00000008*/

                            /*
                               Trigger if the CAP Error FSM enter a specific
                               state. trigger_link_state_1 and
                               trigger_link_state_2 provide the ability to
                               trigger on two different states. The encoding
                               for the states is shown below. Since encoding of
                               0b1000 is unused, the field must be programmed
                               to 0x8 to disable matching with the IDLE state.
                               IDLE : 4'b0000 DRAIN_RD : 4'b0010 DRAIN_WR_INIT
                               : 4'b0011 DRAIN_RD_WAIT : 4'b0100 WAKE_DRAM :
                               4'b0101 DRAIN_WR : 4'b0110 POST_DRAIN_WR :
                               4'b0111 LINK_FAIL : 4'b1001 SUCCESS : 4'b1101
                               FAILURE : 4'b1111 DDR4_MRS_WR : 4'b1100
                            */
    UINT32 triger_link_err_assert : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /* Trigger when MC sees CAP error asserted. */
    UINT32 triger_link_err_deassert : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /* Trigger when MC sees CAP error de-asserted. */
    UINT32 rsvd_20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LINK_ERR_FSM_TRIGGER_CTL_MCDDC_DP_STRUCT;

/* IMC0_MC_STATUS_SHADOW_N0_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x20023430)                                                      */
/*      SPRB0 (0x20023430)                                                      */
/*      SPRHBM (0x20023430)                                                     */
/*      SPRC0 (0x20023430)                                                      */
/*      SPRMCC (0x20023430)                                                     */
/*      SPRUCC (0x20023430)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* The MCiSTATUS MSR contains information related to a machine check error if its VAL (valid) flag is set. Software is responsible for clearing the MCiSTATUS register by writing it with all 0s. Writing 1s to this register will cause a general protection fault to be generated. This is enforced by the combination of WRMSR microcode and the CregPLA features.
*/


#define IMC0_MC_STATUS_SHADOW_N0_MCDDC_DP_REG 0x0B123430

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mcacod : 16;

                            /* Bits[15:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Specifies the machine check architecture defined
                               error code for the machine check error condition
                               detected: bit[15:8] : always zeros bit[7:0] =
                               0000 0101: Parity error on structures bit[7]=1:
                               Memory Controller Errors and the bit[6:4] and
                               bit[3:0] further sub-classify the errors:
                               bit[6:4] = 000: Generic undefined request
                               bit[6:4] = 001: Memory Read Error bit[6:4] =
                               010: Memory Write Error bit[6:4] = 011:
                               Address/Command Error bit[6:4] = 100: Memory
                               Scrubbing Error bit[6:4] = 101-111: reserved
                               bit[3:0] = 0000-1110: Channel Number. // note:
                               JKT will have value of 0-3 for the corresponding
                               chn encoding in every socket. bit[3:0] = 1111:
                               Channel not specified.
                            */
    UINT32 mscod : 16;

                            /* Bits[31:16], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Specifies a model specific error code that
                               uniquely identifies the machine check error
                               condition that has been detected. Bit 15
                               indicates DDR controller (0) or HBM controller
                               (1). 0x0001 - Address Parity Error (APPP) 0x0002
                               - Ha Wr data parity Error 0x0003 - CMI
                               Uncorr/Corr Ecc error 0x0004 - Ha Wr BE parity
                               Error 0x0007 - TID Parity Error (APPP) 0x0008 -
                               Corr Patrol Scrub Error (Non-Mirror or Mirror
                               Primary) 0x1008 - Corr Patrol Scrub Error
                               (Mirror Secondary) 0x0010 - UnCorr Patrol Scrub
                               Error (Non-Mirror or Mirror Primary) 0x1010 -
                               UnCorr Patrol Scrub Error (Mirror Secondary)
                               0x0111 - PCLS Address CSR Parity Error 0x0112 -
                               PCLS Illegal ADDDC Configuraiton Error 0x0113 -
                               PCLS Illegal SDDC Configuraiton Error 0x0020 -
                               Corr Spare Error (Non-Mirror or Mirror Primary)
                               0x1020 - Corr Spare Error (Mirror Secondary)
                               0x0040 - UnCorr Spare Error (Non-Mirror or
                               Mirror Primary) 0x1040 - UnCorr Spare Error
                               (Mirror Secondary) 0x0080 - Transient or
                               Correctable Error for Demand or Underfill Reads
                               (Non-Mirror or Mirror Primary) 0x1080 -
                               Transient or Correctable Error for Demand or
                               Underfill Reads (Mirror Secondary) 0x0100 - WDB
                               Read Parity Error 0x00C0 - Read 2LM MetaData
                               Error 0x00A0 - Uncorrectable Error for Demand or
                               Underfill Reads (Non-Mirror or Mirror Primary)
                               0x10A0 - Uncorrectable Error for Demand or
                               Underfill Reads (Mirror Secondary) 0x0108 -
                               DDR/DDRT Link Fail 0x0200 - DDR4 CAParity or
                               WrCRC Error 0x0220 - HBM CAParity Error 0x0221 -
                               HBM Data Parity (DQ Parity) Error 0x0400 -
                               Scheduler address parity error 0x0800 - 2LM
                               unrecognized request type 0x0801 - 2LM read
                               response to an invalid scoreboard entry 0x0802 -
                               2LM unexpected read response 0x0803 - 2LM DDR4
                               completion to an invalid scoreboard entry 0x0804
                               - 2LM DDRt completion to an invalid scoreboard
                               entry 0x0805 - 2LM completion FIFO overflow
                               0x0806 - DDRT ERID correctable parity error
                               0x0807 - DDRT ERID Uncorrectable error. 0x0808 -
                               DDRT interrupt received while outstanding
                               interrupt was not ACKed 0x0809 - DDRT ERID FIFO
                               overflow 0x080A - DDRT Error on FNV Write
                               credits 0x080B - DDRT Error on FNV Read credits
                               0x080C - DDRT Scheduler error 0x080D - DDRT FNV
                               Error (CAParity or WrECC Error) 0x080E - DDRT
                               FNV Thermal Error 0x080F - DDRT Unexpected Data
                               Packet During CMI Idle 0x0810 - DDRT RPQ Request
                               Parity Error 0x0811 - DDRT WPQ Request Parity
                               Error 0x0812 - 2LM NmFillWr CAM Multiple Hit
                               Error 0x0813 - CMI Credit Oversubscription Error
                               0x0814 - CMI Total Credit Count Error 0x0815 -
                               CMI Reserved Credit Pool Error 0x0816 - DDRT
                               Read Error 0x0817 - WDB FIFO Overflow or
                               Underflow Errors 0x0818 - CMI Request FIFO
                               Overflow Error 0x0819 - CMI Request FIFO
                               Underflow Error 0x081A - CMI Response FIFO
                               Overflow Error 0x081B - CMI Response FIFO
                               Underflow Error 0x081C - CMI Miscellanous Credit
                               Errors 0x081D - CMI MC Arbiter Errors 0x081E -
                               DDRT Write Completion FIFO Overflow Error 0x081F
                               - DDRT Write Completion FIFO Underflow Error
                               0x0820 - CMI Read Completion FIFO Overflow Error
                               0x0821 - CMI Read Completion FIFO Underflow
                               Error 0x0822 - TME Key RF Parity Error 0x0823 -
                               TME Miscellanous CMI Errors 0x0824 - TME CMI
                               Overflow Error 0x0825 - TME CMI Underflow Error
                               0x0826 - SGX-TEM Secure Bit Mismatch Detected on
                               Demand Read 0x0827 - TME Detected Underfill Read
                               Completion Data Parity Error 0x0828 - DRA
                               Internal Errors 0x0829 - MC Internal Errors
                               0x082A - TME Detects Integrity Error 0x082C -
                               SGX-TEM Secure Bit Mismatch Detected on
                               Underfill Read
                            */

  } Bits;
  UINT32 Data;

} IMC0_MC_STATUS_SHADOW_N0_MCDDC_DP_STRUCT;

/* IMC0_MC_STATUS_SHADOW_N1_MCDDC_DP_REG supported on:                          */
/*      SPRA0 (0x20023434)                                                      */
/*      SPRB0 (0x20023434)                                                      */
/*      SPRHBM (0x20023434)                                                     */
/*      SPRC0 (0x20023434)                                                      */
/*      SPRMCC (0x20023434)                                                     */
/*      SPRUCC (0x20023434)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* The MCiSTATUS MSR contains information related to a machine check error if its VAL (valid) flag is set. Software is responsible for clearing the MCiSTATUS register by writing it with all 0s. Writing 1s to this register will cause a general protection fault to be generated. This is enforced by the combination of WRMSR microcode and the CregPLA features.
*/


#define IMC0_MC_STATUS_SHADOW_N1_MCDDC_DP_REG 0x0B123434

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 other_info : 5;

                            /* Bits[4:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               The functions of the bits in this field are
                               implementation specific and are not part of the
                               machine check architecture. //Bit[36] - HBM DQ
                               parity error //Bit[35] - PCLS data parity error
                               //Bit[34] - corr mirror failover //Bit[33] -
                               valid bit for extra_err_info //Bit[32] - corr
                               mirror //For DDRT only bits 33/32 will apply
                            */
    UINT32 fw_upd : 1;

                            /* Bits[5:5], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates that the BIOS has updated the contents
                               of the MC Bank. HW should set this to 0 for any
                               new error that updates Machine Check Bank.
                            */
    UINT32 cor_err_cnt : 15;

                            /* Bits[20:6], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               A 15 bit counter that is incremented each time a
                               corrected (or uncorrected but ignorable) error
                               is observed by the MCA recording bank
                            */
    UINT32 cor_err_stat : 2;

                            /* Bits[22:21], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               These bits are used to indicate when the number
                               of corrected errors has exceeded the safe
                               threshold to the point where an uncorrected
                               error has become more likely to happen
                               CORR_ERR_STAT does not apply to IMC and is
                               marked as reserved attribute
                            */
    UINT32 ar : 1;

                            /* Bits[23:23], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               AR - Action REquired. When set it indicates that
                               SW needs to take immediate recovery action for
                               the error. When clear, SW does not need to take
                               immediate action. Similar to the S bit, the AR
                               bit has meaning only when an error is logged
                               with UC=1 and PCC=0.
                            */
    UINT32 s : 1;

                            /* Bits[24:24], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               S - Signaling. When set it indicates that the
                               error was signaled with an MCERR. When clear it
                               indicates that the error was signaled via a
                               CMCI. The S bit has meaning only when an error
                               is logged with UC=1 and PCC=0.
                            */
    UINT32 pcc : 1;

                            /* Bits[25:25], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates (when set) that the state of the
                               processor might have been corrupted by the error
                               condition detected and that reliable restarting
                               of the processor may not be possible
                            */
    UINT32 addrv : 1;

                            /* Bits[26:26], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               indicates (when set) that the MCiADDR register
                               contains the address where the error occurred
                            */
    UINT32 miscv : 1;

                            /* Bits[27:27], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates (when set) that the MCiMISC register
                               contains additional information regarding the
                               error.
                            */
    UINT32 en : 1;

                            /* Bits[28:28], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Indicates (when set) that signaling of the
                               machine check exception for this error was
                               enabled by an associated flag bit of the MCiCTL
                               register
                            */
    UINT32 uc : 1;

                            /* Bits[29:29], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Error logged in this banks is an uncorrected
                               error.
                            */
    UINT32 over : 1;

                            /* Bits[30:30], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               (Overflow) Indicates (when set) that a machine
                               check error occurred while the results of a
                               previous error were still in the register bank
                            */
    UINT32 valid : 1;

                            /* Bits[31:31], Access Type=RW/V/P, default=0x00000000*/

                            /* Error logged in this bank is valid */

  } Bits;
  UINT32 Data;

} IMC0_MC_STATUS_SHADOW_N1_MCDDC_DP_STRUCT;

/* IMC0_MC_MISC_SHADOW_N0_MCDDC_DP_REG supported on:                            */
/*      SPRA0 (0x20023440)                                                      */
/*      SPRB0 (0x20023440)                                                      */
/*      SPRHBM (0x20023440)                                                     */
/*      SPRC0 (0x20023440)                                                      */
/*      SPRMCC (0x20023440)                                                     */
/*      SPRUCC (0x20023440)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* The MCiMISC MSR contains additional micro-architecture specific information describing the machine check error if the MISCV flag in the MCiSTATUS register is set. It is also possible to use the Other Info field in the MCiSTATUS register for the same type of model specific error reporting
*/


#define IMC0_MC_MISC_SHADOW_N0_MCDDC_DP_REG 0x0B123440

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rec_err_lsb : 6;

                            /* Bits[5:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               The lowest valid recoverable address bit.
                               Indicates the position of the least significant
                               bit (LSB) of the recoverable error address.
                            */
    UINT32 addr_mode : 3;

                            /* Bits[8:6], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               defines the type of address captured in the
                               MC5ADDR MSR. Set by hardware, Clear by
                               programming. 000: Segment Offset 001: Linear
                               Address 010: Physical (system) Address 011:
                               Memory Address 111: Generic
                            */
    UINT32 extra_err_info : 23;

                            /* Bits[31:9], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               //Below is SKX legacy logging which is now
                               changed //Bits[13:9]: If the error logged is WDB
                               Read Parity Error, this field is the WDB ID that
                               has the parity error. OR if the second error
                               logged is a correctable read error, In Mode-1 or
                               Mode-2, MC logs the second error device in this
                               field. ////HSD209224 //WDB ID is 6 bits wide and
                               bit[5] is logged in extra_err_info[46].
                               //Bits[29:14]: In Mode-1 or Mode-2, MC logs the
                               first error bit mask here. This is the per bit
                               error indication in the failing device. Any bit
                               set to 1 indicates that the data bit
                               corresponding to this location had to be flipped
                               to correct the device. In lockstep mode, each
                               transfer is 4-bits from the device and the first
                               transfer is at the LSB of this mask
                               //Bits[45:30]: In Mode-1 or Mode-2, MC logs the
                               second error bit mask here. This is the per bit
                               error indication in the failing device. Any bit
                               set to 1 indicates that the data bit
                               corresponding to this location had to be flipped
                               to correct the device. In lockstep mode, each
                               transfer is 4-bits from the device and the first
                               transfer is at the LSB of this mask
                               //Bits[50:46]: In Mode-1 or Mode-2, MC logs the
                               first error failing rank ////HSD209224 //bit[46]
                               will show WDB ID bit 5 for WDB Read Parity
                               Error. //Bits[55:51]: In Mode-1 or Mode-2, MC
                               logs the second error failing rank
                               //Bits[58:56]: In Mode-1 or Mode-2, MC logs the
                               first error failing dimm slot //Bits[61:59]: In
                               Mode-1 or Mode-2, MC logs the second error
                               failing dimm slot //Bits[62]: In Mode-2, MC logs
                               a valid bit that tells if the information in
                               first correctable error device and the first
                               bit-error mask is useable. Only use the
                               information if the first error logged is
                               correctable read error. //Bits[63]: In Mode-2,
                               MC logs a valid bit that tells if the
                               information in second correctable error device
                               and the second bit-error mask is useable. Only
                               use the information if the first error logged is
                               correctable read error. //Following fields are
                               now being logged. Few taken from
                               retry_Rd_Err_log This field is only valid for
                               patrol/sparing ECC errors, m2m read ECC errors,
                               underfill read ECC errors, WDB parity error,
                               DDRT ECC error when correction path is used, and
                               also 2LM/DDRT/CMI errors. Bits[54] : Indicates
                               if the error was transient error; transient
                               error only indicated for demand reads, ufill
                               reads, and patrol. If there was a WDBParity
                               Error, this field indicates the WDB ID bit 6
                               Bits[53:50] : indicate the ecc mode the register
                               is logging for DDR mode: 4b0000 => sddc 2LM
                               4b0001 => sddc 1LM 4b0010 => sddc +1 2LM 4b0011
                               => sddc +1 1LM 4b0100 => adddc 2LM 4b0101 =>
                               adddc 1LM 4b0110 => adddc +1 2LM 4b0111 => adddc
                               +1 1LM 4b1000 => read is from ddrt dimm 4b1011
                               => not a valid ecc mode For HBM mode: 4b0001 =>
                               64B read 4b1001 => 32B read Bits[49:47] : Chip
                               Select Bits[46:43] : In DDR mode, CBit with bit
                               46 as spare to accomodate possible future growth
                               in size for DDR5 Logged value:
                               {1'b0,sub_rank[2:0]} Bits[46:42] : In HBM mode,
                               holds the failed device number for upper 32
                               bytes Bits[39:34] : Holds the failed device
                               number: for sddc/ddrt/HBM the device number is
                               between 0-17. for adddc device number between
                               0-16 and 18-35 (dev 17 is the spare device) If
                               there was a WDBParity Error, this field
                               indicates the WDB ID bits 5:0 Bits[33:28] : Bank
                               ID. Bit 33 is spare to accomodate possible
                               future growth in size for DDR5 Logged value: {1'
                               b0,bank_group[2],bank_address[1:0],bank_group[1:
                               0]} Bits[27:10] : Row Address Bits 30,29,28 as
                               spare to accomodate possible future growth in
                               size for DDR5 Bits[9:0] : Column address for the
                               last retry Logged value is DDR -
                               {2'b0,Column_addr[9:3],1'b0}. Column_addr[2]
                               indicates Critical chunk, so making that as 0
                               HBM - {2'b0,Column_addr[9:2]} Bits 9 and 8 as
                               spare to accomodate possible future growth in
                               size for DDR5 In DDR - Actual Column address =
                               {Column_addr[9:3],3'b0} Column_addr[2] indicates
                               Critical chunk In HBM - Actual Column address =
                               {Column_addr[9:2],2'b0} For 2LM/DDRT/CMI errors,
                               bits [54:23] are '0 and [22:0] will hold misc
                               error info. For PCLS CSR parity error, bits
                               [54:16] are '0 and [15:0] holds the failing CSR
                               index, one bit per CSR.
                            */

  } Bits;
  UINT32 Data;

} IMC0_MC_MISC_SHADOW_N0_MCDDC_DP_STRUCT;

/* IMC0_MC_MISC_SHADOW_N1_MCDDC_DP_REG supported on:                            */
/*      SPRA0 (0x20023444)                                                      */
/*      SPRB0 (0x20023444)                                                      */
/*      SPRHBM (0x20023444)                                                     */
/*      SPRC0 (0x20023444)                                                      */
/*      SPRMCC (0x20023444)                                                     */
/*      SPRUCC (0x20023444)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* The MCiMISC MSR contains additional micro-architecture specific information describing the machine check error if the MISCV flag in the MCiSTATUS register is set. It is also possible to use the Other Info field in the MCiSTATUS register for the same type of model specific error reporting
*/


#define IMC0_MC_MISC_SHADOW_N1_MCDDC_DP_REG 0x0B123444

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 extra_err_info : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               //Below is SKX legacy logging which is now
                               changed //Bits[13:9]: If the error logged is WDB
                               Read Parity Error, this field is the WDB ID that
                               has the parity error. OR if the second error
                               logged is a correctable read error, In Mode-1 or
                               Mode-2, MC logs the second error device in this
                               field. ////HSD209224 //WDB ID is 6 bits wide and
                               bit[5] is logged in extra_err_info[46].
                               //Bits[29:14]: In Mode-1 or Mode-2, MC logs the
                               first error bit mask here. This is the per bit
                               error indication in the failing device. Any bit
                               set to 1 indicates that the data bit
                               corresponding to this location had to be flipped
                               to correct the device. In lockstep mode, each
                               transfer is 4-bits from the device and the first
                               transfer is at the LSB of this mask
                               //Bits[45:30]: In Mode-1 or Mode-2, MC logs the
                               second error bit mask here. This is the per bit
                               error indication in the failing device. Any bit
                               set to 1 indicates that the data bit
                               corresponding to this location had to be flipped
                               to correct the device. In lockstep mode, each
                               transfer is 4-bits from the device and the first
                               transfer is at the LSB of this mask
                               //Bits[50:46]: In Mode-1 or Mode-2, MC logs the
                               first error failing rank ////HSD209224 //bit[46]
                               will show WDB ID bit 5 for WDB Read Parity
                               Error. //Bits[55:51]: In Mode-1 or Mode-2, MC
                               logs the second error failing rank
                               //Bits[58:56]: In Mode-1 or Mode-2, MC logs the
                               first error failing dimm slot //Bits[61:59]: In
                               Mode-1 or Mode-2, MC logs the second error
                               failing dimm slot //Bits[62]: In Mode-2, MC logs
                               a valid bit that tells if the information in
                               first correctable error device and the first
                               bit-error mask is useable. Only use the
                               information if the first error logged is
                               correctable read error. //Bits[63]: In Mode-2,
                               MC logs a valid bit that tells if the
                               information in second correctable error device
                               and the second bit-error mask is useable. Only
                               use the information if the first error logged is
                               correctable read error. //Following fields are
                               now being logged. Few taken from
                               retry_Rd_Err_log This field is only valid for
                               patrol/sparing ECC errors, m2m read ECC errors,
                               underfill read ECC errors, WDB parity error,
                               DDRT ECC error when correction path is used, and
                               also 2LM/DDRT/CMI errors. Bits[54] : Indicates
                               if the error was transient error; transient
                               error only indicated for demand reads, ufill
                               reads, and patrol. If there was a WDBParity
                               Error, this field indicates the WDB ID bit 6
                               Bits[53:50] : indicate the ecc mode the register
                               is logging for DDR mode: 4b0000 => sddc 2LM
                               4b0001 => sddc 1LM 4b0010 => sddc +1 2LM 4b0011
                               => sddc +1 1LM 4b0100 => adddc 2LM 4b0101 =>
                               adddc 1LM 4b0110 => adddc +1 2LM 4b0111 => adddc
                               +1 1LM 4b1000 => read is from ddrt dimm 4b1011
                               => not a valid ecc mode For HBM mode: 4b0001 =>
                               64B read 4b1001 => 32B read Bits[49:47] : Chip
                               Select Bits[46:43] : In DDR mode, CBit with bit
                               46 as spare to accomodate possible future growth
                               in size for DDR5 Logged value:
                               {1'b0,sub_rank[2:0]} Bits[46:42] : In HBM mode,
                               holds the failed device number for upper 32
                               bytes Bits[39:34] : Holds the failed device
                               number: for sddc/ddrt/HBM the device number is
                               between 0-17. for adddc device number between
                               0-16 and 18-35 (dev 17 is the spare device) If
                               there was a WDBParity Error, this field
                               indicates the WDB ID bits 5:0 Bits[33:28] : Bank
                               ID. Bit 33 is spare to accomodate possible
                               future growth in size for DDR5 Logged value: {1'
                               b0,bank_group[2],bank_address[1:0],bank_group[1:
                               0]} Bits[27:10] : Row Address Bits 30,29,28 as
                               spare to accomodate possible future growth in
                               size for DDR5 Bits[9:0] : Column address for the
                               last retry Logged value is DDR -
                               {2'b0,Column_addr[9:3],1'b0}. Column_addr[2]
                               indicates Critical chunk, so making that as 0
                               HBM - {2'b0,Column_addr[9:2]} Bits 9 and 8 as
                               spare to accomodate possible future growth in
                               size for DDR5 In DDR - Actual Column address =
                               {Column_addr[9:3],3'b0} Column_addr[2] indicates
                               Critical chunk In HBM - Actual Column address =
                               {Column_addr[9:2],2'b0} For 2LM/DDRT/CMI errors,
                               bits [54:23] are '0 and [22:0] will hold misc
                               error info. For PCLS CSR parity error, bits
                               [54:16] are '0 and [15:0] holds the failing CSR
                               index, one bit per CSR.
                            */

  } Bits;
  UINT32 Data;

} IMC0_MC_MISC_SHADOW_N1_MCDDC_DP_STRUCT;

/* MC0_DP_CHKN_BIT_LMCE_PAT_DOWNGRADE_MCDDC_DP_REG supported on:                */
/*      SPRA0 (0x23450)                                                         */
/*      SPRB0 (0x23450)                                                         */
/*      SPRHBM (0x23450)                                                        */
/*      SPRC0 (0x23450)                                                         */
/*      SPRMCC (0x23450)                                                        */
/*      SPRUCC (0x23450)                                                        */
/* Register default value on SPRA0: 0x00000001                                  */
/* Register default value on SPRB0: 0x00000001                                  */
/* Register default value on SPRHBM: 0x00000001                                 */
/* Register default value on SPRC0: 0x00000001                                  */
/* Register default value on SPRMCC: 0x00000001                                 */
/* Register default value on SPRUCC: 0x00000001                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* It is dual mapped to ucr and csr
*/


#define MC0_DP_CHKN_BIT_LMCE_PAT_DOWNGRADE_MCDDC_DP_REG 0x0B103450

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 lmcedowngrade : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               LMCE downgrade bit with default set to 1i.e. we
                               will always log patrol errors with posion=1 and
                               recovery_fuse=1 as UCNA and not SRAO. OEM can
                               program the LMCEdowngrade to 0 if they want SRAO
                               error logging.
                            */
    UINT8 reserved : 7;

                            /* Bits[7:1], Access Type=RW, default=0x00000000*/

                            /* Reserved for future use. */

  } Bits;
  UINT8 Data;

} MC0_DP_CHKN_BIT_LMCE_PAT_DOWNGRADE_MCDDC_DP_STRUCT;

/* MC0_DP_CHKN_BIT2_MCDDC_DP_REG supported on:                                  */
/*      SPRA0 (0x20023454)                                                      */
/*      SPRB0 (0x20023454)                                                      */
/*      SPRHBM (0x20023454)                                                     */
/*      SPRC0 (0x20023454)                                                      */
/*      SPRMCC (0x20023454)                                                     */
/*      SPRUCC (0x20023454)                                                     */
/* Register default value on SPRA0: 0x00100A00                                  */
/* Register default value on SPRB0: 0x00100A10                                  */
/* Register default value on SPRHBM: 0x00100A10                                 */
/* Register default value on SPRC0: 0x00100A10                                  */
/* Register default value on SPRMCC: 0x00100A10                                 */
/* Register default value on SPRUCC: 0x00100A10                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Note: some defeatures are only present in MC0 register
*/


#define MC0_DP_CHKN_BIT2_MCDDC_DP_REG 0x0B123454

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_corr_ufill_err_log : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Disable Correctable err logging for ufill */
    UINT32 dis_illegalcmiopcode_err_log : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Disable CMI unrecognized opcode err logging */
    UINT32 dis_rpb_parity_err_log : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Disable RPB Parity err logging */
    UINT32 rsvd_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mask_adddc_trans_specrd_only : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to disable transient error logging for
                               ADDDC transactions only for SpecRead. It can be
                               set to 1 when EarlyCmp is not enabled in M2Mem.
                               In this case, SpecRead will be the only case
                               causing unexpected transient error logging on
                               ADDDC reads.
                            */
    UINT32 rsvd_5 : 14;

                            /* Bits[18:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_rdb_byp : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /* If set, RDB will not be bypassed */
    UINT32 rsvd_20 : 11;

                            /* Bits[30:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fnv_viral_received : 1;

                            /* Bits[31:31], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               This bit is set when a Viral bit is seen in a
                               FNV read packet
                            */

  } Bits;
  UINT32 Data;

} MC0_DP_CHKN_BIT2_MCDDC_DP_STRUCT;

/* LINK_CFG_READ_1_MCDDC_DP_REG supported on:                                   */
/*      SPRA0 (0x20023458)                                                      */
/*      SPRB0 (0x20023458)                                                      */
/*      SPRHBM (0x20023458)                                                     */
/*      SPRC0 (0x20023458)                                                      */
/*      SPRMCC (0x20023458)                                                     */
/*      SPRUCC (0x20023458)                                                     */
/* Register default value on SPRA0: 0x00000205                                  */
/* Register default value on SPRB0: 0x00000205                                  */
/* Register default value on SPRHBM: 0x00000205                                 */
/* Register default value on SPRC0: 0x00000205                                  */
/* Register default value on SPRMCC: 0x00000205                                 */
/* Register default value on SPRUCC: 0x0000020D                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Register does not hold any config read data. Instead it is used for various defeature bits for MC bug fixes.
*/


#define LINK_CFG_READ_1_MCDDC_DP_REG 0x0B123458

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 read_data : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000205*/

                            /*
                               Bits used to enable bug fixes. Bit 0: When set
                               to 1, log actual channel number in MCACOD in HBM
                               mode; when set to 0, logged channel number is
                               fixed at value of 14 in HBM mode. Bits 2:1:
                               Disable starvation check for corresponding out
                               of VC credit condition. Bit 1 is for VC1 and bit
                               2 is for VC3. Bit 7: Set to 1 to ignore patrol
                               and spare fsm idle in DDR4 mode to exit DRAIN_RD
                               state. Bit 8: Disable poison to patrol/spare
                               write. Bit 9: Disable going into link fail due
                               to viral condition. Bit 26: to disable usage of
                               sub device for handling DUE during sparing. Bit
                               27: disable 1LM column correction. Bit 28: force
                               the correction datapath for all transactions
                               when set 1. Bit 29: Disable RRD RCB clock gating
                               when set 1. Bit 30: Disable WDB RCB clock gating
                               when set 1. Bit 31: Disable RT RCB clock gating
                               when set 1.
                            */

  } Bits;
  UINT32 Data;

} LINK_CFG_READ_1_MCDDC_DP_STRUCT;

/* LINK_ERR_FSM_STATE_MCDDC_DP_REG supported on:                                */
/*      SPRA0 (0x20023460)                                                      */
/*      SPRB0 (0x20023460)                                                      */
/*      SPRHBM (0x20023460)                                                     */
/*      SPRC0 (0x20023460)                                                      */
/*      SPRMCC (0x20023460)                                                     */
/*      SPRUCC (0x20023460)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* State of the Intel LINK 2 Error flow FSM.
*/


#define LINK_ERR_FSM_STATE_MCDDC_DP_REG 0x0B123460

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 current_state : 4;

                            /* Bits[3:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current state of the Intel LINK 2 Error flow
                               FSM.
                            */
    UINT32 rsvd : 12;

                            /* Bits[15:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 previous_state : 4;

                            /* Bits[19:16], Access Type=RO/V, default=0x00000000*/

                            /*
                               The state of the Intel LINK 2 Error flow FSM
                               before the current state.
                            */
    UINT32 rsvd_20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LINK_ERR_FSM_STATE_MCDDC_DP_STRUCT;

/* CSMI_CTL_MCDDC_DP_REG supported on:                                          */
/*      SPRA0 (0x20023468)                                                      */
/*      SPRB0 (0x20023468)                                                      */
/*      SPRHBM (0x20023468)                                                     */
/*      SPRC0 (0x20023468)                                                      */
/*      SPRMCC (0x20023468)                                                     */
/*      SPRUCC (0x20023468)                                                     */
/* Register default value on SPRA0: 0x00020001                                  */
/* Register default value on SPRB0: 0x00020001                                  */
/* Register default value on SPRHBM: 0x00020001                                 */
/* Register default value on SPRC0: 0x00020001                                  */
/* Register default value on SPRMCC: 0x00020001                                 */
/* Register default value on SPRUCC: 0x00020001                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Control CSMI signalling
*/


#define CSMI_CTL_MCDDC_DP_REG 0x0B123468

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 csmi_cor_err_cnt_th : 15;

                            /* Bits[14:0], Access Type=RW/P, default=0x00000001*/

                            /* Corrected error count threshold for CSMI. */
    UINT32 csmi_en_cor : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* CSMI enable for corrected error. */
    UINT32 csmi_dis_ucna : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* CSMI disable for UCNA error. */
    UINT32 cor_err_cnt_th_en : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000001*/

                            /*
                               When set, MC will signal correctable error only
                               when the threshold is met. Value of 0 meaning MC
                               will signal every correctable error.
                            */
    UINT32 cmci_en_cor : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /* CMCI enable for corrected error. */
    UINT32 rsvd : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CSMI_CTL_MCDDC_DP_STRUCT;

/* NO_VCCR_STARVE_CTL_MCDDC_DP_REG supported on:                                */
/*      SPRA0 (0x20023470)                                                      */
/*      SPRB0 (0x20023470)                                                      */
/*      SPRHBM (0x20023470)                                                     */
/*      SPRC0 (0x20023470)                                                      */
/*      SPRMCC (0x20023470)                                                     */
/*      SPRUCC (0x20023470)                                                     */
/* Register default value on SPRA0: 0x00000112                                  */
/* Register default value on SPRB0: 0x00000112                                  */
/* Register default value on SPRHBM: 0x00000112                                 */
/* Register default value on SPRC0: 0x00000112                                  */
/* Register default value on SPRMCC: 0x00000112                                 */
/* Register default value on SPRUCC: 0x00000112                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Control to trig error flow to reset credit when there is VC credit starvation
*/


#define NO_VCCR_STARVE_CTL_MCDDC_DP_REG 0x0B123470

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 starve_timer : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000012*/

                            /*
                               Threshold for number of cycles of in base timer.
                               The threshold field is incremented every
                               (2^timer) DCLK ticks.
                            */
    UINT32 starve_threshold : 8;

                            /* Bits[13:6], Access Type=RW, default=0x00000004*/

                            /*
                               Threshold for starvation indication in unit for
                               the base timer to wrap around
                            */
    UINT32 rst_cnt : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, this bit resets the counter used
                               for anti-starvation logic. This bit should be
                               set to 1 when threshold or timer field is
                               changed.
                            */
    UINT32 rsvd : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 en_vc0 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Anti-starvation enable for VC0. When set to 1,
                               if VC0 has been out of VC credit for the time
                               defined by threshold, then trig ECC retry flow
                            */
    UINT32 en_vc1 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Anti-starvation enable for VC1. When set to 1,
                               if VC1 has been out of VC credit for the time
                               defined by threshold, then trig ECC retry flow
                            */
    UINT32 en_vc2 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Anti-starvation enable for VC2. When set to 1,
                               if VC2 has been out of VC credit for the time
                               defined by threshold, then trig ECC retry flow
                            */
    UINT32 en_vc3 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Anti-starvation enable for VC3. When set to 1,
                               if VC3 has been out of VC credit for the time
                               defined by threshold, then trig ECC retry flow
                            */
    UINT32 en_rid_vc0 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Anti-starvation enable for VC0 RDB. When set to
                               1, if VC0 has been out of RDB credit for the
                               time defined by threshold, then trig ECC retry
                               flow
                            */
    UINT32 en_rid_vc1 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Anti-starvation enable for VC1 RDB. When set to
                               1, if VC1 has been out of RDB credit for the
                               time defined by threshold, then trig ECC retry
                               flow
                            */
    UINT32 en_rid_vc2 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Anti-starvation enable for VC2 RDB. When set to
                               1, if VC2 has been out of RDB credit for the
                               time defined by threshold, then trig ECC retry
                               flow
                            */
    UINT32 en_rid_vc3 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Anti-starvation enable for VC3 RDB. When set to
                               1, if VC3 has been out of RDB credit for the
                               time defined by threshold, then trig ECC retry
                               flow
                            */
    UINT32 en_link_vc0 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, and when en_vc0 is set to 1, if
                               VC0 has been out of VC credit for the time
                               defined by threshold, then trig link error flow
                               instead of ECC retry flow.
                            */
    UINT32 en_link_vc1 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, and when en_vc1 is set to 1, if
                               VC1 has been out of VC credit for the time
                               defined by threshold, then trig link error flow
                               instead of ECC retry flow.
                            */
    UINT32 en_link_vc2 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, and when en_vc2 is set to 1, if
                               VC2 has been out of VC credit for the time
                               defined by threshold, then trig link error flow
                               instead of ECC retry flow.
                            */
    UINT32 en_link_vc3 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, and when en_vc3 is set to 1, if
                               VC3 has been out of VC credit for the time
                               defined by threshold, then trig link error flow
                               instead of ECC retry flow.
                            */
    UINT32 en_link_rid_vc0 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, and when en_rid_vc0 is set to 1,
                               if VC0 has been out of RDB credit for the time
                               defined by threshold, then trig link error flow
                               instead of ECC retry flow.
                            */
    UINT32 en_link_rid_vc1 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, and when en_rid_vc1 is set to 1,
                               if VC1 has been out of RDB credit for the time
                               defined by threshold, then trig link error flow
                               instead of ECC retry flow.
                            */
    UINT32 en_link_rid_vc2 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, and when en_rid_vc2 is set to 1,
                               if VC2 has been out of RDB credit for the time
                               defined by threshold, then trig link error flow
                               instead of ECC retry flow.
                            */
    UINT32 en_link_rid_vc3 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, and when en_rid_vc3 is set to 1,
                               if VC3 has been out of RDB credit for the time
                               defined by threshold, then trig link error flow
                               instead of ECC retry flow.
                            */

  } Bits;
  UINT32 Data;

} NO_VCCR_STARVE_CTL_MCDDC_DP_STRUCT;

/* MC0_DP_CHKN_BIT3_MCDDC_DP_REG supported on:                                  */
/*      SPRA0 (0x20023478)                                                      */
/*      SPRB0 (0x20023478)                                                      */
/*      SPRHBM (0x20023478)                                                     */
/*      SPRC0 (0x20023478)                                                      */
/*      SPRMCC (0x20023478)                                                     */
/*      SPRUCC (0x20023478)                                                     */
/* Register default value on SPRA0: 0x00E10000                                  */
/* Register default value on SPRB0: 0x00E10000                                  */
/* Register default value on SPRHBM: 0x00E10000                                 */
/* Register default value on SPRC0: 0x80E00000                                  */
/* Register default value on SPRMCC: 0x80E00000                                 */
/* Register default value on SPRUCC: 0x00E00000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Note: some defeatures are only present in MC0 register
*/


#define MC0_DP_CHKN_BIT3_MCDDC_DP_REG 0x0B123478

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_pcls_illegal_cfg_adddc_err_log : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Disable err logging for PCLS in ADDDC region */
    UINT32 dis_pcls_illegal_cfg_sddc_err_log : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Disable err logging for PCLS in SDDC region */
    UINT32 rsvd_2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_hit_uc_metadata_err : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Disable forced hit for UC metadata errors; if
                               set, MC will force miss
                            */
    UINT32 dis_pat_poison_scrub_dirty : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               If set, patrol scrub with poison will not change
                               cache state from clean to dirty
                            */
    UINT32 dis_ddrt_scr_lfsr_fix : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               If set, disables DDRT receive scrambler lfsr to
                               shift twice upon reset
                            */
    UINT32 dis_mc_internal_err : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               If set, MC internal assertion errors will not be
                               logged
                            */
    UINT32 dis_esddc_poison : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set, eSDDC mode will not support poison.
                               Shouldn't be set without setting dis_esddc_dir
                               to 1.
                            */
    UINT32 dis_esddc_dir : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* If set, eSDDC mode will not support directory */
    UINT32 dis_esddc_ns : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* If set, eSDDC mode will not support NS bit */
    UINT32 rsvd_10 : 6;

                            /* Bits[15:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_meta_ecc_corr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000001*/

                            /* When set to 1, disable metadata ECC correction */
    UINT32 dis_rrl_patspr_ucmeta_overwrite : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               If set, for patrol/sparing 2lm meta errors
                               following a non meta error, the meta error will
                               overwrite the non meta error.
                            */
    UINT32 rsvd_18 : 8;

                            /* Bits[25:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_hphase_and_odd_delay_fix_for_wrcrc : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Defeature bit for a bug fix to move high phase
                               and odd tcwl delays to previous pipeline stage
                               to support wrcrc. 0 -> Bug fix enabled. 1 -> Bug
                               fix disabled. If this bug fix is disabled, wrcrc
                               will not work.
                            */
    UINT32 rsvd_27 : 4;

                            /* Bits[30:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MC0_DP_CHKN_BIT3_MCDDC_DP_SPRA0_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_pcls_illegal_cfg_adddc_err_log : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Disable err logging for PCLS in ADDDC region */
    UINT32 dis_pcls_illegal_cfg_sddc_err_log : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Disable err logging for PCLS in SDDC region */
    UINT32 rsvd_2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_hit_uc_metadata_err : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Disable forced hit for UC metadata errors; if
                               set, MC will force miss
                            */
    UINT32 dis_pat_poison_scrub_dirty : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               If set, patrol scrub with poison will not change
                               cache state from clean to dirty
                            */
    UINT32 dis_ddrt_scr_lfsr_fix : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               If set, disables DDRT receive scrambler lfsr to
                               shift twice upon reset
                            */
    UINT32 dis_mc_internal_err : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               If set, MC internal assertion errors will not be
                               logged
                            */
    UINT32 dis_esddc_poison : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set, eSDDC mode will not support poison.
                               Shouldn't be set without setting dis_esddc_dir
                               to 1.
                            */
    UINT32 dis_esddc_dir : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* If set, eSDDC mode will not support directory */
    UINT32 dis_esddc_ns : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* If set, eSDDC mode will not support NS bit */
    UINT32 rsvd_10 : 6;

                            /* Bits[15:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_meta_ecc_corr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* When set to 1, disable metadata ECC correction */
    UINT32 dis_rrl_patspr_ucmeta_overwrite : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               If set, for patrol/sparing 2lm meta errors
                               following a non meta error, the meta error will
                               overwrite the non meta error.
                            */
    UINT32 rsvd_18 : 8;

                            /* Bits[25:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_hphase_and_odd_delay_fix_for_wrcrc : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Defeature bit for a bug fix to move high phase
                               and odd tcwl delays to previous pipeline stage
                               to support wrcrc. 0 -> Bug fix enabled. 1 -> Bug
                               fix disabled. If this bug fix is disabled, wrcrc
                               will not work.
                            */
    UINT32 rsvd_27 : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MC0_DP_CHKN_BIT3_MCDDC_DP_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_pcls_illegal_cfg_adddc_err_log : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Disable err logging for PCLS in ADDDC region */
    UINT32 dis_pcls_illegal_cfg_sddc_err_log : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Disable err logging for PCLS in SDDC region */
    UINT32 rsvd_2 : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_hit_uc_metadata_err : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Disable forced hit for UC metadata errors; if
                               set, MC will force miss
                            */
    UINT32 dis_pat_poison_scrub_dirty : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               If set, patrol scrub with poison will not change
                               cache state from clean to dirty
                            */
    UINT32 dis_ddrt_scr_lfsr_fix : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               If set, disables DDRT receive scrambler lfsr to
                               shift twice upon reset
                            */
    UINT32 dis_mc_internal_err : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               If set, MC internal assertion errors will not be
                               logged
                            */
    UINT32 dis_esddc_poison : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set, eSDDC mode will not support poison.
                               Shouldn't be set without setting dis_esddc_dir
                               to 1.
                            */
    UINT32 dis_esddc_dir : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* If set, eSDDC mode will not support directory */
    UINT32 dis_esddc_ns : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /* If set, eSDDC mode will not support NS bit */
    UINT32 rsvd_10 : 6;

                            /* Bits[15:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_meta_ecc_corr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000001*/

                            /* When set to 1, disable metadata ECC correction */
    UINT32 dis_rrl_patspr_ucmeta_overwrite : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               If set, for patrol/sparing 2lm meta errors
                               following a non meta error, the meta error will
                               overwrite the non meta error.
                            */
    UINT32 rsvd_18 : 8;

                            /* Bits[25:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_hphase_and_odd_delay_fix_for_wrcrc : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Defeature bit for a bug fix to move high phase
                               and odd tcwl delays to previous pipeline stage
                               to support wrcrc. 0 -> Bug fix enabled. 1 -> Bug
                               fix disabled. If this bug fix is disabled, wrcrc
                               will not work.
                            */
    UINT32 rsvd_27 : 4;

                            /* Bits[30:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MC0_DP_CHKN_BIT3_MCDDC_DP_STRUCT;



/* CRDEFEATURE1_DP_MCDDC_DP_REG supported on:                                   */
/*      SPRA0 (0x10023490)                                                      */
/*      SPRB0 (0x10023490)                                                      */
/*      SPRHBM (0x10023490)                                                     */
/*      SPRC0 (0x10023490)                                                      */
/*      SPRMCC (0x10023490)                                                     */
/*      SPRUCC (0x10023490)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* spare
*/


#define CRDEFEATURE1_DP_MCDDC_DP_REG 0x0B113490

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 spare : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* spare */

  } Bits;
  UINT16 Data;

} CRDEFEATURE1_DP_MCDDC_DP_STRUCT;

/* CRDEFEATURE2_DP_MCDDC_DP_REG supported on:                                   */
/*      SPRA0 (0x10023498)                                                      */
/*      SPRB0 (0x10023498)                                                      */
/*      SPRHBM (0x10023498)                                                     */
/*      SPRC0 (0x10023498)                                                      */
/*      SPRMCC (0x10023498)                                                     */
/*      SPRUCC (0x10023498)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* spare
*/


#define CRDEFEATURE2_DP_MCDDC_DP_REG 0x0B113498

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 spare : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* spare */

  } Bits;
  UINT16 Data;

} CRDEFEATURE2_DP_MCDDC_DP_STRUCT;

/* CRDEFEATURE3_DP_MCDDC_DP_REG supported on:                                   */
/*      SPRA0 (0x100234a0)                                                      */
/*      SPRB0 (0x100234a0)                                                      */
/*      SPRHBM (0x100234a0)                                                     */
/*      SPRC0 (0x100234a0)                                                      */
/*      SPRMCC (0x100234a0)                                                     */
/*      SPRUCC (0x100234a0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* spare
*/


#define CRDEFEATURE3_DP_MCDDC_DP_REG 0x0B1134A0

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 spare : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* spare */

  } Bits;
  UINT16 Data;

} CRDEFEATURE3_DP_MCDDC_DP_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 integrity_enabled : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Integrity enable configuration; should only be
                               set for DDR5 mode
                            */
    UINT16 spare : 15;

                            /* Bits[15:1], Access Type=RW, default=0x00000000*/

                            /* spare */

  } Bits;
  UINT16 Data;

} CRDEFEATURE3_DP_MCDDC_DP_SPRB0_SPRHBM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

/* DDR4_GLBRSP_CTL_MCDDC_DP_REG supported on:                                   */
/*      SPRA0 (0x20023500)                                                      */
/*      SPRB0 (0x20023500)                                                      */
/*      SPRHBM (0x20023500)                                                     */
/*      SPRC0 (0x20023500)                                                      */
/*      SPRMCC (0x20023500)                                                     */
/*      SPRUCC (0x20023500)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR        */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_wp_crnode/MEM_MCDP_CSR       */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/*  
     This register contains control DDR4 logic to handle Global
     Response logic. Each 2b field control the response to the trigger
     using the following encoding
     00 - Dont inject
     01 - Use Trigger 0
     10 - Use Trigger 1
     11 - Use Trigger 2
    
*/


#define DDR4_GLBRSP_CTL_MCDDC_DP_REG 0x0B123500

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 trigger_retry_fsm : 2;

                            /* Bits[1:0], Access Type=RW/L, default=0x00000000*/

                            /* Kick off the CAP Retry FSM */
    UINT32 trigger_block_rdb : 2;

                            /* Bits[3:2], Access Type=RW/L, default=0x00000000*/

                            /* RDB block when match - no data return to m2m */
    UINT32 trigger_ecc_retry_fsm : 2;

                            /* Bits[5:4], Access Type=RW/L, default=0x00000000*/

                            /* Kick off the ECC Retry FSM */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDR4_GLBRSP_CTL_MCDDC_DP_STRUCT;
#endif /* _MCDDC_DP_h */
