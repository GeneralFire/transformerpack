
/** @file
  MC_2LM.h

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2007 - 2020 Intel Corporation. <BR>
  
  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.
  
  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.
  
  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
  
  This file contains Silicon register definitions.
  
  This is a generated file; please do not modify it directly.
  
**/

/* The following security policy groups are used by registers in this file:     */

/* SPRA0 Security Policy Groups:                                                */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* HW_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRB0 Security Policy Groups:                                                */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* HW_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRHBM Security Policy Groups:                                               */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* HW_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRC0 Security Policy Groups:                                                */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* HW_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRMCC Security Policy Groups:                                               */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* HW_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRUCC Security Policy Groups:                                               */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* HW_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */


#ifndef _MC_2LM_h
#define _MC_2LM_h
#include <Base.h>

/* PXPCAP_MC_2LM_REG supported on:                                              */
/*      SPRA0 (0x20020008)                                                      */
/*      SPRB0 (0x20020008)                                                      */
/*      SPRHBM (0x20020008)                                                     */
/*      SPRC0 (0x20020008)                                                      */
/*      SPRMCC (0x20020008)                                                     */
/*      SPRUCC (0x20020008)                                                     */
/* Register default value on SPRA0: 0x00910010                                  */
/* Register default value on SPRB0: 0x00910010                                  */
/* Register default value on SPRHBM: 0x00910010                                 */
/* Register default value on SPRC0: 0x00910010                                  */
/* Register default value on SPRMCC: 0x00910010                                 */
/* Register default value on SPRUCC: 0x00910010                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x040
*/


#define PXPCAP_MC_2LM_REG 0x07120008

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 capability_id : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000010*/

                            /*
                               Provides the PCI Express capability ID assigned
                               by PCI-SIG.
                            */
    UINT32 next_ptr : 8;

                            /* Bits[15:8], Access Type=RO, default=0x00000000*/

                            /*
                               Pointer to the next capability. Set to 0 to
                               indicate there are no more capability
                               structures.
                            */
    UINT32 capability_version : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               PCI Express Capability is Compliant with Version
                               1.0 of the PCI Express Spec. Note: This
                               capability structure is not compliant with
                               Versions beyond 1.0, since they require
                               additional capability registers to be reserved.
                               The only purpose for this capability structure
                               is to make enhanced configuration space
                               available. Minimizing the size of this structure
                               is accomplished by reporting version 1.0
                               compliancy and reporting that this is an
                               integrated root port device. As such, only three
                               Dwords of configuration space are required for
                               this structure.
                            */
    UINT32 device_port_type : 4;

                            /* Bits[23:20], Access Type=RO, default=0x00000009*/

                            /* Device type is Root Complex Integrated Endpoint */
    UINT32 slot_implemented : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000000*/

                            /* N/A for integrated endpoints */
    UINT32 interrupt_message_number : 5;

                            /* Bits[29:25], Access Type=RO, default=0x00000000*/

                            /* N/A for this device */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PXPCAP_MC_2LM_STRUCT;

/* MCNMCACHINGINTLV_MC_2LM_REG supported on:                                    */
/*      SPRA0 (0x20020010)                                                      */
/*      SPRB0 (0x20020010)                                                      */
/*      SPRHBM (0x20020010)                                                     */
/*      SPRC0 (0x20020010)                                                      */
/*      SPRMCC (0x20020010)                                                     */
/*      SPRUCC (0x20020010)                                                     */
/* Register default value on SPRA0: 0x00000480                                  */
/* Register default value on SPRB0: 0x00000480                                  */
/* Register default value on SPRHBM: 0x00000480                                 */
/* Register default value on SPRC0: 0x00000480                                  */
/* Register default value on SPRMCC: 0x00000480                                 */
/* Register default value on SPRUCC: 0x00000480                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* MC NMCaching Configuration Register
*/


#define MCNMCACHINGINTLV_MC_2LM_REG 0x07120010

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 nm_target_ways : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               NmTargetWays - Target interleave wayness: 000 -
                               1 way no socket interleaving 001 - 2 way
                               interleave 010 - 4 way interleave 011 - 8 way
                               interleave 100 - 16 way interleave This field is
                               programmed on the per iMC basis, i.e. need to
                               maintain consistency with other populated
                               channels in this iMC.
                            */
    UINT32 nm_chn_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnWays - Channel interleave wayness. This
                               field is programmed on the per channel basis,
                               i.e. need to maintain consistency with other
                               populated channels in this iMC. 000 = 1 way or 3
                               way 001 = 2 way 011 = 8 way (for IPM) 100 = 4
                               way (for Xtile) Other = Reserved
                            */
    UINT32 nm_target_gran : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000002*/

                            /*
                               NmTargetGran - Target interleave granularity.
                               Default value is 4k b000 64B (based off PA[6]
                               and up) (used for DDR4 legacy 1LM, DDR4 FM and
                               HBM) b001 256B (based off PA[8] and up) (used
                               for DDR4 legacy 1LM, DDR4 FM and HBM) b010 4KB
                               (based off PA[12] and up) (used for DDR4 2LM,
                               PMem, and Block/DDRT_CSR) b011 Reserved b100
                               128B (based off PA[7] and up) (used for DDR4 FM
                               and HBM) b101 512B (based off PA[9] and up)
                               (used for DDR4 FM and HBM) b110 1KB (based off
                               PA[10] and up) (used for DDR4 FM and HBM) b111
                               2KB (based off PA[11] and up) (used for DDR4 FM
                               and HBM)
                            */
    UINT32 nm_chn_gran : 4;

                            /* Bits[13:10], Access Type=RW, default=0x00000001*/

                            /*
                               NMChnGran - Channel interleave granularity.
                               Default value is 256B b000 64B (based off PA[6]
                               and up) (used for DDR4 legacy 1LM and HBM) b001
                               256B (based off PA[8] and up) (used for DDR4
                               1LM, DDR4 2LM, HBM, DDRT Block, and DDRT 2LM.
                               the latter only in mirror mode) b010 4KB (based
                               off PA[12] and up) (used for DDR4 FM, DDRT 2LM
                               and DDRT PMem) b011 Reserved b100 128B (based
                               off PA[7] and up) (used for HBM) b101 512B
                               (based off PA[9] and up) (used for HBM) b110 1KB
                               (based off PA[10] and up) (used for HBM) b111
                               2KB (based off PA[11] and up) (used for HBM)
                               Note: using the same ch_granularity encoding for
                               both DDRT and DDR4 even though 64B only applies
                               for DDR4 and 4KB only applies for DDRT.
                            */
    UINT32 nm_target_lid : 4;

                            /* Bits[17:14], Access Type=RW, default=0x00000000*/

                            /*
                               NMTargetLID - Target logical ID. The value of
                               bits socket bits for this MC. Used for reverse
                               address decode. This field is programmed on the
                               per iMC basis, i.e. need to maintain consistency
                               with other populated channels in this iMC.
                            */
    UINT32 nm_chn_lid : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnLID: Channel logical ID. The value of
                               channel bits for this channel. Used for reverse
                               address decode. This field is programmed on the
                               per channel basis.
                            */
    UINT32 rsvd : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCNMCACHINGINTLV_MC_2LM_STRUCT;

/* MCNMCACHINGOFFSET_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x20020018)                                                      */
/*      SPRB0 (0x20020018)                                                      */
/*      SPRHBM (0x20020018)                                                     */
/*      SPRC0 (0x20020018)                                                      */
/*      SPRMCC (0x20020018)                                                     */
/*      SPRUCC (0x20020018)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* MC NMCaching Configuration Register.
*/


#define MCNMCACHINGOFFSET_MC_2LM_REG 0x07120018

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mcnmcachingoffsetlower : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               NmCachingOffsetLower - Lower 5 bits of NM
                               offset; use in conjunction with NmCachingOffset,
                               applied to SA[34:30]. Granularity of 1GB.
                            */
    UINT32 mcnmcachingoffset : 17;

                            /* Bits[21:5], Access Type=RW, default=0x00000000*/

                            /*
                               NmCachingOffset - NM offset, applied to
                               SA[51:35]. Granularity of 32GB.
                            */
    UINT32 rsvd : 9;

                            /* Bits[30:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mcnmcachingoffseten : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               NmCachingOffsetEn - Enable bit for NM offset.
                               When this bit is 0, NmCachingOffset should also
                               be 0. When this bit is set to 1, make sure
                               amap.force_lat is set to 1 also.
                            */

  } Bits;
  UINT32 Data;

} MCNMCACHINGOFFSET_MC_2LM_STRUCT;

/* MCNMCACHINGCFG_MC_2LM_REG supported on:                                      */
/*      SPRA0 (0x2002001c)                                                      */
/*      SPRB0 (0x2002001c)                                                      */
/*      SPRHBM (0x2002001c)                                                     */
/*      SPRC0 (0x2002001c)                                                      */
/*      SPRMCC (0x2002001c)                                                     */
/*      SPRUCC (0x2002001c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* MC NMCaching Configuration Register.  A related register - McNMCachingCfg - is per channel
*/


#define MCNMCACHINGCFG_MC_2LM_REG 0x0712001C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 chn_cap : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               ChnCap - Per Channel Memory Capacity. 4h0 - 4GB
                               (DDR4 only) 4h1 - 8GB (DDR4 only) 4h2 - 16GB
                               (DDR4 only) 4h3 - 32GB (DDR4 only) 4h4 - 64GB
                               (DDR4 only) 4h5 - 128GB (DDR4 only) 4h6 - 256GB
                               (DDR4 only) 4h7 - Reserved 4h8 - 256MB (HBM
                               only) 4h9 - 512MB (HBM only) 4hA - 1GB (HBM
                               only) others - Reserved This field can be
                               programmed on the per-channel basis.
                            */
    UINT32 nm_ratio_chn_cap : 6;

                            /* Bits[9:4], Access Type=RW, default=0x00000000*/

                            /*
                               NmRatioChnCap = portion of ChnCap used for 2LM
                               NM, in granularity of 1/32. 0 (default) = non-
                               power-of-2 ChnCap is disabled, or all channel
                               capacity is used for 2LM HBM mode only
                               (combination with McNMCachingNmChnCap should
                               result in at least 32MB): 1 = 1/32 of ChnCap
                               allocated to 2LM NM 2 = 1/16 of ChnCap allocated
                               to 2LM NM 3 = 1/8 of ChnCap allocated to 2LM NM
                               4 = 1/4 of ChnCap allocated to 2LM NM 5 = 1/2 of
                               ChnCap allocated to 2LM NM 6-31 = Reserved DDR
                               mode only (exception: value of 62 (30/32 of
                               ChnCap) can be used for HBM bank sparing mode
                               with the full ChnCap as NM): 32 = non-power-of-2
                               ChnCap is disabled, or all channel capacity is
                               used for 2LM 33-63 = 1/32 to 31/32 of ChnCap
                               allocated to 2LM NM (only value >= 49 is valid)
                            */
    UINT32 en_2way : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Enable 2 way cache */
    UINT32 prefer_way_sel : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Select address bit as preferred way. 0 = bit 37;
                               1 = bit 31
                            */
    UINT32 rsvd : 20;

                            /* Bits[31:12], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCNMCACHINGCFG_MC_2LM_STRUCT;

/* SCRATCHPAD_2LMCNTL_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x20020020)                                                      */
/*      SPRB0 (0x20020020)                                                      */
/*      SPRHBM (0x20020020)                                                     */
/*      SPRC0 (0x20020020)                                                      */
/*      SPRMCC (0x20020020)                                                     */
/*      SPRUCC (0x20020020)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* dummy register
*/


#define SCRATCHPAD_2LMCNTL_MC_2LM_REG 0x07120020

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 bit_field : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /* Reserved bits for ECOs. */

  } Bits;
  UINT32 Data;

} SCRATCHPAD_2LMCNTL_MC_2LM_STRUCT;

/* PXPENHCAP_MC_2LM_REG supported on:                                           */
/*      SPRA0 (0x20020024)                                                      */
/*      SPRB0 (0x20020024)                                                      */
/*      SPRHBM (0x20020024)                                                     */
/*      SPRC0 (0x20020024)                                                      */
/*      SPRMCC (0x20020024)                                                     */
/*      SPRUCC (0x20020024)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This field points to the next Capability in extended configuration space.
*/


#define PXPENHCAP_MC_2LM_REG 0x07120024

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 capability_id : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates there are no capability structures in
                               the enhanced configuration space.
                            */
    UINT32 capability_version : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates there are no capability structures in
                               the enhanced configuration space.
                            */
    UINT32 next_capability_offset : 12;

                            /* Bits[31:20], Access Type=RO, default=0x00000000*/

                            /* next capability offset. */

  } Bits;
  UINT32 Data;

} PXPENHCAP_MC_2LM_STRUCT;

/* SYSFEATURES0_MC_2LM_REG supported on:                                        */
/*      SPRA0 (0x20020028)                                                      */
/*      SPRB0 (0x20020028)                                                      */
/*      SPRHBM (0x20020028)                                                     */
/*      SPRC0 (0x20020028)                                                      */
/*      SPRMCC (0x20020028)                                                     */
/*      SPRUCC (0x20020028)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
      This register contains MC features which BIOS might need to set differently based on 
      the system topology/configuration or for performance/power reasons.

      A single socket system is expected to at least configure following (different from reset values):
        CHA HA_COH_CFG[Dis_Directory] = 1 (functionality)
        M2M SysFeatures[FrcDirI]      = 1 (functionality)
        M2M SysFeatures[DirWrDisable] = 1 (performance)

      A multi-socket directory disabled system is expected to at least configure following (different from reset values):
        CHA HA_COH_CFG[Dis_Directory] = 1 (functionality)
        M2M SysFeatures[DirWrDisable] = 1 (performance)

      These CSRs mirror SysFeatures0 in M2M and must be set consistently with that.
      
*/


#define SYSFEATURES0_MC_2LM_REG 0x07120028

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd0 : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 frcpmemdirupdate2ddrt : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Force NM Pmem dir updates to DDR-T
                               (FrcPmemDirUpdate2ddrt): By default, for multi-
                               socket performance reasons, directory only
                               updates in NM for PMem Write-Through regions are
                               not propagated to DDR-T. 0: Dont propagate PMem
                               NM dir-only updates to DDR-T (default). 1: Force
                               propagation of NM PMem dir updates to DDR-T
                               (debug). This bit is only relevant in
                               PMemCaching mode (Mode.PmemCaching==1).
                            */
    UINT32 dirwrdisable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Must be set consistently with
                               SysFeatures0.DirWrDisable in M2Mem. Disable
                               directory writes (DirWrDisable): 0: MC directory
                               writes are enabled (default). 1: MC directory
                               writes are disabled. Only legal configs where MC
                               directory writes can be disabled are: - when
                               single socket system, or - when directory
                               disabled in the system. BIOS should set this bit
                               to 1 for above configs (for performance).
                            */
    UINT32 frcdiri : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Must be set consistently with
                               SysFeatures0.FrcDirI in M2Mem. Force dirI
                               (FrcDirI): Force the directory state read from
                               memory to Invalid, for new dir calculation
                               (exception: poison/uncorr stays poison) and for
                               dir delivery to CHA (here Invalid will override
                               poison). 0: interpret directory from memory as-
                               is. 1: override directory S/A/(P) read from
                               memory with I. BIOS needs to set this bit to 1
                               if single socket.
                            */
    UINT32 mapdirstodira : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Must be set consistently with
                               SysFeatures0.MapDirStoDirA in M2Mem. Map dirS to
                               dirA (MapDirStoDirA): Upgrade dirS to memory to
                               dirA. It also prevents DataC_S_CmpO D2K (when
                               dirS no longer present in memory). 0: dont
                               override dirS with dirA (default). 1: dirS wr to
                               memory gets replaced with dirA wr. Guideline is
                               to keep at 0 for performance. Note that taking
                               out directory shared state might result in less
                               directory writes. Some usage models might prefer
                               less directory writes.
                            */
    UINT32 reconstructaddronhit : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Reconstruct the fill/evict address on all read
                               returns, not just on a miss. 0: only reconstruct
                               the address on a miss 1: reconstruct the address
                               on all read returns (for debug)
                            */
    UINT32 buriedm : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Must be set consistently with
                               SysFeatures0.BuriedM in M2Mem. XNC BuriedM mode:
                               When this bit is set to 1, it indicates to M2M
                               that the system is in an XNC configuration with
                               the possibility of BuriedM. On receiving a
                               MemRdXtoS request, M2M will transition directory
                               state from A to S only if this bit is not set.
                            */
    UINT32 srubwr : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Disable Scrub write in SB. Must be set
                               consistently with scrub write disable in DDR
                               scheduler and M2M.
                            */
    UINT32 sbempty : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               When set, SB will signal that it is empty when
                               no request is allocated. When clear, SB will
                               signal that it is empty when no non-patrol
                               request is allocated.
                            */
    UINT32 enearlycmp : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /* Set to 1 to enable Early Cmp. */
    UINT32 rsvd1 : 20;

                            /* Bits[31:12], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SYSFEATURES0_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_COR_CNT_PG_RD_POLICY_N0_MC_2LM_REG supported on:              */
/*      SPRA0 (0x20020040)                                                      */
/*      SPRB0 (0x20020040)                                                      */
/*      SPRHBM (0x20020040)                                                     */
/*      SPRC0 (0x20020040)                                                      */
/*      SPRMCC (0x20020040)                                                     */
/*      SPRUCC (0x20020040)                                                     */
/* Register default value on SPRA0: 0x0300021F                                  */
/* Register default value on SPRB0: 0x0300021F                                  */
/* Register default value on SPRHBM: 0x0300021F                                 */
/* Register default value on SPRC0: 0x0300021F                                  */
/* Register default value on SPRMCC: 0x0300021F                                 */
/* Register default value on SPRUCC: 0x0300021F                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* This register configures the read access to registers in COR_CNT security policy group. That is, read access is permitted to all IPs for registers in this group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define MC_2LMCNTL_SAI_COR_CNT_PG_RD_POLICY_N0_MC_2LM_REG 0x07120040

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_cnt_sai_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_COR_CNT_PG_RD_POLICY_N0_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_COR_CNT_PG_RD_POLICY_N1_MC_2LM_REG supported on:              */
/*      SPRA0 (0x20020044)                                                      */
/*      SPRB0 (0x20020044)                                                      */
/*      SPRHBM (0x20020044)                                                     */
/*      SPRC0 (0x20020044)                                                      */
/*      SPRMCC (0x20020044)                                                     */
/*      SPRUCC (0x20020044)                                                     */
/* Register default value on SPRA0: 0x20000D00                                  */
/* Register default value on SPRB0: 0x20000D00                                  */
/* Register default value on SPRHBM: 0x20000D00                                 */
/* Register default value on SPRC0: 0x20000D00                                  */
/* Register default value on SPRMCC: 0x20000D00                                 */
/* Register default value on SPRUCC: 0x20000D00                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* This register configures the read access to registers in COR_CNT security policy group. That is, read access is permitted to all IPs for registers in this group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define MC_2LMCNTL_SAI_COR_CNT_PG_RD_POLICY_N1_MC_2LM_REG 0x07120044

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_cnt_sai_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_COR_CNT_PG_RD_POLICY_N1_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_COR_CNT_PG_WR_POLICY_N0_MC_2LM_REG supported on:              */
/*      SPRA0 (0x20020048)                                                      */
/*      SPRB0 (0x20020048)                                                      */
/*      SPRHBM (0x20020048)                                                     */
/*      SPRC0 (0x20020048)                                                      */
/*      SPRMCC (0x20020048)                                                     */
/*      SPRUCC (0x20020048)                                                     */
/* Register default value on SPRA0: 0x0300021F                                  */
/* Register default value on SPRB0: 0x0300021F                                  */
/* Register default value on SPRHBM: 0x0300021F                                 */
/* Register default value on SPRC0: 0x0300021F                                  */
/* Register default value on SPRMCC: 0x0300021F                                 */
/* Register default value on SPRUCC: 0x0300021F                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* This register configures the write access to registers in COR_CNT security policy group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define MC_2LMCNTL_SAI_COR_CNT_PG_WR_POLICY_N0_MC_2LM_REG 0x07120048

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_cnt_sai_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_COR_CNT_PG_WR_POLICY_N0_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_COR_CNT_PG_WR_POLICY_N1_MC_2LM_REG supported on:              */
/*      SPRA0 (0x2002004c)                                                      */
/*      SPRB0 (0x2002004c)                                                      */
/*      SPRHBM (0x2002004c)                                                     */
/*      SPRC0 (0x2002004c)                                                      */
/*      SPRMCC (0x2002004c)                                                     */
/*      SPRUCC (0x2002004c)                                                     */
/* Register default value on SPRA0: 0x20000C00                                  */
/* Register default value on SPRB0: 0x20000C00                                  */
/* Register default value on SPRHBM: 0x20000C00                                 */
/* Register default value on SPRC0: 0x20000C00                                  */
/* Register default value on SPRMCC: 0x20000C00                                 */
/* Register default value on SPRUCC: 0x20000C00                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* This register configures the write access to registers in COR_CNT security policy group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define MC_2LMCNTL_SAI_COR_CNT_PG_WR_POLICY_N1_MC_2LM_REG 0x0712004C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_cnt_sai_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 cor_cnt_sai_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in COR_CNT
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_COR_CNT_PG_WR_POLICY_N1_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_COR_CNT_PG_CR_POLICY_N0_MC_2LM_REG supported on:              */
/*      SPRA0 (0x20020050)                                                      */
/*      SPRB0 (0x20020050)                                                      */
/*      SPRHBM (0x20020050)                                                     */
/*      SPRC0 (0x20020050)                                                      */
/*      SPRMCC (0x20020050)                                                     */
/*      SPRUCC (0x20020050)                                                     */
/* Register default value on SPRA0: 0x0100021E                                  */
/* Register default value on SPRB0: 0x0100021E                                  */
/* Register default value on SPRHBM: 0x0100021E                                 */
/* Register default value on SPRC0: 0x0100021E                                  */
/* Register default value on SPRMCC: 0x0100021E                                 */
/* Register default value on SPRUCC: 0x0100021E                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* This register configures the write access to RAC, WAC and CP registers for COR_CNT security policy group. This policy group is expected to be used for registers that log corrected error counts. BIOS is in the policy group for this register (BOOT and SMM). Bits corresponding to trusted sources (pcode, ucode, Intel Dfx) are made read-only in the CP/RAC/WAC to prevent BIOS from accidentally/maliciously removing access to the trusted sources
*/


#define MC_2LMCNTL_SAI_COR_CNT_PG_CR_POLICY_N0_MC_2LM_REG 0x07120050

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_cnt_ctrl_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_1 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_COR_CNT_PG_CR_POLICY_N0_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_COR_CNT_PG_CR_POLICY_N1_MC_2LM_REG supported on:              */
/*      SPRA0 (0x20020054)                                                      */
/*      SPRB0 (0x20020054)                                                      */
/*      SPRHBM (0x20020054)                                                     */
/*      SPRC0 (0x20020054)                                                      */
/*      SPRMCC (0x20020054)                                                     */
/*      SPRUCC (0x20020054)                                                     */
/* Register default value on SPRA0: 0x00000400                                  */
/* Register default value on SPRB0: 0x00000400                                  */
/* Register default value on SPRHBM: 0x00000400                                 */
/* Register default value on SPRC0: 0x00000400                                  */
/* Register default value on SPRMCC: 0x00000400                                 */
/* Register default value on SPRUCC: 0x00000400                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* This register configures the write access to RAC, WAC and CP registers for COR_CNT security policy group. This policy group is expected to be used for registers that log corrected error counts. BIOS is in the policy group for this register (BOOT and SMM). Bits corresponding to trusted sources (pcode, ucode, Intel Dfx) are made read-only in the CP/RAC/WAC to prevent BIOS from accidentally/maliciously removing access to the trusted sources
*/


#define MC_2LMCNTL_SAI_COR_CNT_PG_CR_POLICY_N1_MC_2LM_REG 0x07120054

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cor_cnt_ctrl_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 cor_cnt_ctrl_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to COR_CNT WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_COR_CNT_PG_CR_POLICY_N1_MC_2LM_STRUCT;













/* MC_2LMCNTL_SAI_DFX_PG_RD_POLICY_N0_MC_2LM_REG supported on:                  */
/*      SPRA0 (0x20020088)                                                      */
/*      SPRB0 (0x20020088)                                                      */
/*      SPRHBM (0x20020088)                                                     */
/*      SPRC0 (0x20020088)                                                      */
/*      SPRMCC (0x20020088)                                                     */
/*      SPRUCC (0x20020088)                                                     */
/* Register default value on SPRA0: 0x0100020A                                  */
/* Register default value on SPRB0: 0x0100020A                                  */
/* Register default value on SPRHBM: 0x0100020A                                 */
/* Register default value on SPRC0: 0x0100020A                                  */
/* Register default value on SPRMCC: 0x0100020A                                 */
/* Register default value on SPRUCC: 0x0100020A                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* This register configures the read access to registers in DFX security policy group. That is, read access is permitted to all IPs for registers in this group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define MC_2LMCNTL_SAI_DFX_PG_RD_POLICY_N0_MC_2LM_REG 0x07120088

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfx_sai_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_DFX_PG_RD_POLICY_N0_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_DFX_PG_RD_POLICY_N1_MC_2LM_REG supported on:                  */
/*      SPRA0 (0x2002008c)                                                      */
/*      SPRB0 (0x2002008c)                                                      */
/*      SPRHBM (0x2002008c)                                                     */
/*      SPRC0 (0x2002008c)                                                      */
/*      SPRMCC (0x2002008c)                                                     */
/*      SPRUCC (0x2002008c)                                                     */
/* Register default value on SPRA0: 0x20000500                                  */
/* Register default value on SPRB0: 0x20000500                                  */
/* Register default value on SPRHBM: 0x20000500                                 */
/* Register default value on SPRC0: 0x20000500                                  */
/* Register default value on SPRMCC: 0x20000500                                 */
/* Register default value on SPRUCC: 0x20000500                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* This register configures the read access to registers in DFX security policy group. That is, read access is permitted to all IPs for registers in this group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define MC_2LMCNTL_SAI_DFX_PG_RD_POLICY_N1_MC_2LM_REG 0x0712008C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfx_sai_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_DFX_PG_RD_POLICY_N1_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_DFX_PG_WR_POLICY_N0_MC_2LM_REG supported on:                  */
/*      SPRA0 (0x20020090)                                                      */
/*      SPRB0 (0x20020090)                                                      */
/*      SPRHBM (0x20020090)                                                     */
/*      SPRC0 (0x20020090)                                                      */
/*      SPRMCC (0x20020090)                                                     */
/*      SPRUCC (0x20020090)                                                     */
/* Register default value on SPRA0: 0x0100020A                                  */
/* Register default value on SPRB0: 0x0100020A                                  */
/* Register default value on SPRHBM: 0x0100020A                                 */
/* Register default value on SPRC0: 0x0100020A                                  */
/* Register default value on SPRMCC: 0x0100020A                                 */
/* Register default value on SPRUCC: 0x0100020A                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* This register configures the write access to registers in DFX security policy group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define MC_2LMCNTL_SAI_DFX_PG_WR_POLICY_N0_MC_2LM_REG 0x07120090

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfx_sai_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_DFX_PG_WR_POLICY_N0_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_DFX_PG_WR_POLICY_N1_MC_2LM_REG supported on:                  */
/*      SPRA0 (0x20020094)                                                      */
/*      SPRB0 (0x20020094)                                                      */
/*      SPRHBM (0x20020094)                                                     */
/*      SPRC0 (0x20020094)                                                      */
/*      SPRMCC (0x20020094)                                                     */
/*      SPRUCC (0x20020094)                                                     */
/* Register default value on SPRA0: 0x20000400                                  */
/* Register default value on SPRB0: 0x20000400                                  */
/* Register default value on SPRHBM: 0x20000400                                 */
/* Register default value on SPRC0: 0x20000400                                  */
/* Register default value on SPRMCC: 0x20000400                                 */
/* Register default value on SPRUCC: 0x20000400                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* This register configures the write access to registers in DFX security policy group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define MC_2LMCNTL_SAI_DFX_PG_WR_POLICY_N1_MC_2LM_REG 0x07120094

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfx_sai_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 dfx_sai_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in DFX policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_DFX_PG_WR_POLICY_N1_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_DFX_PG_CR_POLICY_N0_MC_2LM_REG supported on:                  */
/*      SPRA0 (0x20020098)                                                      */
/*      SPRB0 (0x20020098)                                                      */
/*      SPRHBM (0x20020098)                                                     */
/*      SPRC0 (0x20020098)                                                      */
/*      SPRMCC (0x20020098)                                                     */
/*      SPRUCC (0x20020098)                                                     */
/* Register default value on SPRA0: 0x01000218                                  */
/* Register default value on SPRB0: 0x01000218                                  */
/* Register default value on SPRHBM: 0x01000218                                 */
/* Register default value on SPRC0: 0x01000218                                  */
/* Register default value on SPRMCC: 0x01000218                                 */
/* Register default value on SPRUCC: 0x01000218                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* This register configures the write access to RAC, WAC and CP registers for DFX security policy group. This policy group is expected to be used for registers that log corrected error counts. BIOS is in the policy group for this register. Bits corresponding to trusted sources (pcode, ucode, Intel Dfx) are made read-only in the CP/RAC/WAC to prevent BIOS from accidentally/maliciously removing access to the trusted sources
*/


#define MC_2LMCNTL_SAI_DFX_PG_CR_POLICY_N0_MC_2LM_REG 0x07120098

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfx_ctrl_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_1 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_DFX_PG_CR_POLICY_N0_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_DFX_PG_CR_POLICY_N1_MC_2LM_REG supported on:                  */
/*      SPRA0 (0x2002009c)                                                      */
/*      SPRB0 (0x2002009c)                                                      */
/*      SPRHBM (0x2002009c)                                                     */
/*      SPRC0 (0x2002009c)                                                      */
/*      SPRMCC (0x2002009c)                                                     */
/*      SPRUCC (0x2002009c)                                                     */
/* Register default value on SPRA0: 0x00000400                                  */
/* Register default value on SPRB0: 0x00000400                                  */
/* Register default value on SPRHBM: 0x00000400                                 */
/* Register default value on SPRC0: 0x00000400                                  */
/* Register default value on SPRMCC: 0x00000400                                 */
/* Register default value on SPRUCC: 0x00000400                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* This register configures the write access to RAC, WAC and CP registers for DFX security policy group. This policy group is expected to be used for registers that log corrected error counts. BIOS is in the policy group for this register. Bits corresponding to trusted sources (pcode, ucode, Intel Dfx) are made read-only in the CP/RAC/WAC to prevent BIOS from accidentally/maliciously removing access to the trusted sources
*/


#define MC_2LMCNTL_SAI_DFX_PG_CR_POLICY_N1_MC_2LM_REG 0x0712009C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dfx_ctrl_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 dfx_ctrl_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to DFX WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_DFX_PG_CR_POLICY_N1_MC_2LM_STRUCT;













/* MC_2LMCNTL_SAI_OS_W_PG_RD_POLICY_N0_MC_2LM_REG supported on:                 */
/*      SPRA0 (0x200200d0)                                                      */
/*      SPRB0 (0x200200d0)                                                      */
/*      SPRHBM (0x200200d0)                                                     */
/*      SPRC0 (0x200200d0)                                                      */
/*      SPRMCC (0x200200d0)                                                     */
/*      SPRUCC (0x200200d0)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register configures the read access to registers in OS_W security policy group.
*/


#define MC_2LMCNTL_SAI_OS_W_PG_RD_POLICY_N0_MC_2LM_REG 0x071200D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 os_w_sai_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_OS_W_PG_RD_POLICY_N0_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_OS_W_PG_RD_POLICY_N1_MC_2LM_REG supported on:                 */
/*      SPRA0 (0x200200d4)                                                      */
/*      SPRB0 (0x200200d4)                                                      */
/*      SPRHBM (0x200200d4)                                                     */
/*      SPRC0 (0x200200d4)                                                      */
/*      SPRMCC (0x200200d4)                                                     */
/*      SPRUCC (0x200200d4)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register configures the read access to registers in OS_W security policy group.
*/


#define MC_2LMCNTL_SAI_OS_W_PG_RD_POLICY_N1_MC_2LM_REG 0x071200D4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 os_w_sai_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_OS_W_PG_RD_POLICY_N1_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_OS_W_PG_WR_POLICY_N0_MC_2LM_REG supported on:                 */
/*      SPRA0 (0x200200d8)                                                      */
/*      SPRB0 (0x200200d8)                                                      */
/*      SPRHBM (0x200200d8)                                                     */
/*      SPRC0 (0x200200d8)                                                      */
/*      SPRMCC (0x200200d8)                                                     */
/*      SPRUCC (0x200200d8)                                                     */
/* Register default value on SPRA0: 0x0300021F                                  */
/* Register default value on SPRB0: 0x0300021F                                  */
/* Register default value on SPRHBM: 0x0300021F                                 */
/* Register default value on SPRC0: 0x0300021F                                  */
/* Register default value on SPRMCC: 0x0300021F                                 */
/* Register default value on SPRUCC: 0x0300021F                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register configures the write access to registers in OS_W security policy group.
*/


#define MC_2LMCNTL_SAI_OS_W_PG_WR_POLICY_N0_MC_2LM_REG 0x071200D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 os_w_sai_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_OS_W_PG_WR_POLICY_N0_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_OS_W_PG_WR_POLICY_N1_MC_2LM_REG supported on:                 */
/*      SPRA0 (0x200200dc)                                                      */
/*      SPRB0 (0x200200dc)                                                      */
/*      SPRHBM (0x200200dc)                                                     */
/*      SPRC0 (0x200200dc)                                                      */
/*      SPRMCC (0x200200dc)                                                     */
/*      SPRUCC (0x200200dc)                                                     */
/* Register default value on SPRA0: 0x20000C00                                  */
/* Register default value on SPRB0: 0x20000C00                                  */
/* Register default value on SPRHBM: 0x20000C00                                 */
/* Register default value on SPRC0: 0x20000C00                                  */
/* Register default value on SPRMCC: 0x20000C00                                 */
/* Register default value on SPRUCC: 0x20000C00                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register configures the write access to registers in OS_W security policy group.
*/


#define MC_2LMCNTL_SAI_OS_W_PG_WR_POLICY_N1_MC_2LM_REG 0x071200DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 os_w_sai_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */
    UINT32 os_w_sai_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in OS_W policy
                               group, based on the value from each agent's 6bit
                               SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_OS_W_PG_WR_POLICY_N1_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_OS_W_PG_CR_POLICY_N0_MC_2LM_REG supported on:                 */
/*      SPRA0 (0x200200e0)                                                      */
/*      SPRB0 (0x200200e0)                                                      */
/*      SPRHBM (0x200200e0)                                                     */
/*      SPRC0 (0x200200e0)                                                      */
/*      SPRMCC (0x200200e0)                                                     */
/*      SPRUCC (0x200200e0)                                                     */
/* Register default value on SPRA0: 0x01000218                                  */
/* Register default value on SPRB0: 0x01000218                                  */
/* Register default value on SPRHBM: 0x01000218                                 */
/* Register default value on SPRC0: 0x01000218                                  */
/* Register default value on SPRMCC: 0x01000218                                 */
/* Register default value on SPRUCC: 0x01000218                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register configures the write access to RAC, WAC and CP registers for OS_W security policy group. This policy group covers registers set by OS, so all IA agents are allowed access in the WAC
*/


#define MC_2LMCNTL_SAI_OS_W_PG_CR_POLICY_N0_MC_2LM_REG 0x071200E0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 os_w_ctrl_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_1 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_OS_W_PG_CR_POLICY_N0_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_OS_W_PG_CR_POLICY_N1_MC_2LM_REG supported on:                 */
/*      SPRA0 (0x200200e4)                                                      */
/*      SPRB0 (0x200200e4)                                                      */
/*      SPRHBM (0x200200e4)                                                     */
/*      SPRC0 (0x200200e4)                                                      */
/*      SPRMCC (0x200200e4)                                                     */
/*      SPRUCC (0x200200e4)                                                     */
/* Register default value on SPRA0: 0x00000400                                  */
/* Register default value on SPRB0: 0x00000400                                  */
/* Register default value on SPRHBM: 0x00000400                                 */
/* Register default value on SPRC0: 0x00000400                                  */
/* Register default value on SPRMCC: 0x00000400                                 */
/* Register default value on SPRUCC: 0x00000400                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register configures the write access to RAC, WAC and CP registers for OS_W security policy group. This policy group covers registers set by OS, so all IA agents are allowed access in the WAC
*/


#define MC_2LMCNTL_SAI_OS_W_PG_CR_POLICY_N1_MC_2LM_REG 0x071200E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 os_w_ctrl_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */
    UINT32 os_w_ctrl_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to OS_W WAC, RAC and CP
                               registers, based on the value from each agent's
                               6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_OS_W_PG_CR_POLICY_N1_MC_2LM_STRUCT;







/* MC_2LMCNTL_SAI_LB_MCHECK_W_PG_RD_POLICY_N0_MC_2LM_REG supported on:          */
/*      SPRA0 (0x20020100)                                                      */
/*      SPRB0 (0x20020100)                                                      */
/*      SPRHBM (0x20020100)                                                     */
/*      SPRC0 (0x20020100)                                                      */
/*      SPRMCC (0x20020100)                                                     */
/*      SPRUCC (0x20020100)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* This register configures the read access to registers in LB_MCHECK_W security policy group. As indicated by the _W in the policy name, the read access for this particular policy includes ALL supported SAI mnemonics. That is, read access is permitted to all IPs for registers in this group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define MC_2LMCNTL_SAI_LB_MCHECK_W_PG_RD_POLICY_N0_MC_2LM_REG 0x07120100

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lb_mcheck_w_sai_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_LB_MCHECK_W_PG_RD_POLICY_N0_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_LB_MCHECK_W_PG_RD_POLICY_N1_MC_2LM_REG supported on:          */
/*      SPRA0 (0x20020104)                                                      */
/*      SPRB0 (0x20020104)                                                      */
/*      SPRHBM (0x20020104)                                                     */
/*      SPRC0 (0x20020104)                                                      */
/*      SPRMCC (0x20020104)                                                     */
/*      SPRUCC (0x20020104)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* This register configures the read access to registers in LB_MCHECK_W security policy group. As indicated by the _W in the policy name, the read access for this particular policy includes ALL supported SAI mnemonics. That is, read access is permitted to all IPs for registers in this group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define MC_2LMCNTL_SAI_LB_MCHECK_W_PG_RD_POLICY_N1_MC_2LM_REG 0x07120104

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lb_mcheck_w_sai_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed read access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_LB_MCHECK_W_PG_RD_POLICY_N1_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_LB_MCHECK_W_PG_WR_POLICY_N0_MC_2LM_REG supported on:          */
/*      SPRA0 (0x20020108)                                                      */
/*      SPRB0 (0x20020108)                                                      */
/*      SPRHBM (0x20020108)                                                     */
/*      SPRC0 (0x20020108)                                                      */
/*      SPRMCC (0x20020108)                                                     */
/*      SPRUCC (0x20020108)                                                     */
/* Register default value on SPRA0: 0x0100021E                                  */
/* Register default value on SPRB0: 0x0100021E                                  */
/* Register default value on SPRHBM: 0x0100021E                                 */
/* Register default value on SPRC0: 0x0100021E                                  */
/* Register default value on SPRMCC: 0x0100021E                                 */
/* Register default value on SPRUCC: 0x0100021E                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* This register configures the write access to registers in LB_MCHECK_W security policy group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define MC_2LMCNTL_SAI_LB_MCHECK_W_PG_WR_POLICY_N0_MC_2LM_REG 0x07120108

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lb_mcheck_w_sai_pol_0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_5 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_6 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_7 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_8 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_10 : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_11 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_12 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_13 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_14 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_15 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_16 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_17 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_18 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_19 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_20 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_23 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_25 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_26 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_27 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_28 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_29 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_30 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_LB_MCHECK_W_PG_WR_POLICY_N0_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_LB_MCHECK_W_PG_WR_POLICY_N1_MC_2LM_REG supported on:          */
/*      SPRA0 (0x2002010c)                                                      */
/*      SPRB0 (0x2002010c)                                                      */
/*      SPRHBM (0x2002010c)                                                     */
/*      SPRC0 (0x2002010c)                                                      */
/*      SPRMCC (0x2002010c)                                                     */
/*      SPRUCC (0x2002010c)                                                     */
/* Register default value on SPRA0: 0x20000400                                  */
/* Register default value on SPRB0: 0x20000400                                  */
/* Register default value on SPRHBM: 0x20000400                                 */
/* Register default value on SPRC0: 0x20000400                                  */
/* Register default value on SPRMCC: 0x20000400                                 */
/* Register default value on SPRUCC: 0x20000400                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* This register configures the write access to registers in LB_MCHECK_W security policy group. SAI bits corresponding to pcode/ucode/Intel Dfx are read only to prevent BIOS from removing access for them.
*/


#define MC_2LMCNTL_SAI_LB_MCHECK_W_PG_WR_POLICY_N1_MC_2LM_REG 0x0712010C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lb_mcheck_w_sai_pol_32 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_33 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_34 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_35 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_36 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_37 : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_38 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_39 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_40 : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_41 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_43 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_44 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_45 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_46 : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_47 : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_48 : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_49 : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_50 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_51 : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_52 : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_53 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_54 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_55 : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_56 : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_57 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_58 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_59 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_60 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_61 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_62 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_sai_pol_63 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to registers in LB_MCHECK_W
                               policy group, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_LB_MCHECK_W_PG_WR_POLICY_N1_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_LB_MCHECK_W_PG_CR_POLICY_N0_MC_2LM_REG supported on:          */
/*      SPRA0 (0x20020110)                                                      */
/*      SPRB0 (0x20020110)                                                      */
/*      SPRHBM (0x20020110)                                                     */
/*      SPRC0 (0x20020110)                                                      */
/*      SPRMCC (0x20020110)                                                     */
/*      SPRUCC (0x20020110)                                                     */
/* Register default value on SPRA0: 0x01000218                                  */
/* Register default value on SPRB0: 0x01000218                                  */
/* Register default value on SPRHBM: 0x01000218                                 */
/* Register default value on SPRC0: 0x01000218                                  */
/* Register default value on SPRMCC: 0x01000218                                 */
/* Register default value on SPRUCC: 0x01000218                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* This register configures the write access to RAC, WAC and CP registers for LB_MCHECK_W security policy group. This policy group is expected to be used for registers that had LB attribute in prior art and need to be checked by MCHECK. BIOS is in the policy group for this register (BOOT and SMM). Bits corresponding to trusted sources (pcode, ucode, Intel Dfx) are made read-only in the CP/RAC/WAC to prevent BIOS from accidentally/maliciously removing access to the trusted sources
*/


#define MC_2LMCNTL_SAI_LB_MCHECK_W_PG_CR_POLICY_N0_MC_2LM_REG 0x07120110

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lb_mcheck_w_ctrl_pol_0 : 1;

                            /* Bits[0:0], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_2 : 1;

                            /* Bits[2:2], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_3 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_4 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_5 : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_6 : 1;

                            /* Bits[6:6], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_8 : 1;

                            /* Bits[8:8], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_10 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_11 : 1;

                            /* Bits[11:11], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_12 : 1;

                            /* Bits[12:12], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_13 : 1;

                            /* Bits[13:13], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_14 : 1;

                            /* Bits[14:14], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_16 : 1;

                            /* Bits[16:16], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_17 : 1;

                            /* Bits[17:17], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_18 : 1;

                            /* Bits[18:18], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_20 : 1;

                            /* Bits[20:20], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_21 : 1;

                            /* Bits[21:21], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_22 : 1;

                            /* Bits[22:22], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_24 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_25 : 1;

                            /* Bits[25:25], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_26 : 1;

                            /* Bits[26:26], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_29 : 1;

                            /* Bits[29:29], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_LB_MCHECK_W_PG_CR_POLICY_N0_MC_2LM_STRUCT;

/* MC_2LMCNTL_SAI_LB_MCHECK_W_PG_CR_POLICY_N1_MC_2LM_REG supported on:          */
/*      SPRA0 (0x20020114)                                                      */
/*      SPRB0 (0x20020114)                                                      */
/*      SPRHBM (0x20020114)                                                     */
/*      SPRC0 (0x20020114)                                                      */
/*      SPRMCC (0x20020114)                                                     */
/*      SPRUCC (0x20020114)                                                     */
/* Register default value on SPRA0: 0x00000400                                  */
/* Register default value on SPRB0: 0x00000400                                  */
/* Register default value on SPRHBM: 0x00000400                                 */
/* Register default value on SPRC0: 0x00000400                                  */
/* Register default value on SPRMCC: 0x00000400                                 */
/* Register default value on SPRUCC: 0x00000400                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* This register configures the write access to RAC, WAC and CP registers for LB_MCHECK_W security policy group. This policy group is expected to be used for registers that had LB attribute in prior art and need to be checked by MCHECK. BIOS is in the policy group for this register (BOOT and SMM). Bits corresponding to trusted sources (pcode, ucode, Intel Dfx) are made read-only in the CP/RAC/WAC to prevent BIOS from accidentally/maliciously removing access to the trusted sources
*/


#define MC_2LMCNTL_SAI_LB_MCHECK_W_PG_CR_POLICY_N1_MC_2LM_REG 0x07120114

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lb_mcheck_w_ctrl_pol_32 : 1;

                            /* Bits[0:0], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_33 : 1;

                            /* Bits[1:1], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_34 : 1;

                            /* Bits[2:2], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_35 : 1;

                            /* Bits[3:3], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_36 : 1;

                            /* Bits[4:4], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_37 : 1;

                            /* Bits[5:5], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_38 : 1;

                            /* Bits[6:6], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_39 : 1;

                            /* Bits[7:7], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_40 : 1;

                            /* Bits[8:8], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_41 : 1;

                            /* Bits[9:9], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_42 : 1;

                            /* Bits[10:10], Access Type=RO, default=0x00000001*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_43 : 1;

                            /* Bits[11:11], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_44 : 1;

                            /* Bits[12:12], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_45 : 1;

                            /* Bits[13:13], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_46 : 1;

                            /* Bits[14:14], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_47 : 1;

                            /* Bits[15:15], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_48 : 1;

                            /* Bits[16:16], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_49 : 1;

                            /* Bits[17:17], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_50 : 1;

                            /* Bits[18:18], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_51 : 1;

                            /* Bits[19:19], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_52 : 1;

                            /* Bits[20:20], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_53 : 1;

                            /* Bits[21:21], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_54 : 1;

                            /* Bits[22:22], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_55 : 1;

                            /* Bits[23:23], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_56 : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_57 : 1;

                            /* Bits[25:25], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_58 : 1;

                            /* Bits[26:26], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_59 : 1;

                            /* Bits[27:27], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_60 : 1;

                            /* Bits[28:28], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_61 : 1;

                            /* Bits[29:29], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_62 : 1;

                            /* Bits[30:30], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */
    UINT32 lb_mcheck_w_ctrl_pol_63 : 1;

                            /* Bits[31:31], Access Type=RO, default=0x00000000*/

                            /*
                               Bit-vector used to determine which agents are
                               allowed write access to LB_MCHECK_W WAC, RAC and
                               CP registers, based on the value from each
                               agent's 6bit SAI field.
                            */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_SAI_LB_MCHECK_W_PG_CR_POLICY_N1_MC_2LM_STRUCT;

/* REG_MCCHAN_CMI_STALL_MC_2LM_REG supported on:                                */
/*      SPRA0 (0x20020118)                                                      */
/*      SPRB0 (0x20020118)                                                      */
/*      SPRHBM (0x20020118)                                                     */
/*      SPRC0 (0x20020118)                                                      */
/*      SPRMCC (0x20020118)                                                     */
/*      SPRUCC (0x20020118)                                                     */
/* Register default value on SPRA0: 0x1AAAAAAA                                  */
/* Register default value on SPRB0: 0x1AAAAAAA                                  */
/* Register default value on SPRHBM: 0x1AAAAAAA                                 */
/* Register default value on SPRC0: 0x1AAAAAAA                                  */
/* Register default value on SPRMCC: 0x1AAAAAAA                                 */
/* Register default value on SPRUCC: 0x1AAAAAAA                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Controls random CMI stall assertion behavior
*/


#define REG_MCCHAN_CMI_STALL_MC_2LM_REG 0x07120118

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 req_stall_assert_seed : 10;

                            /* Bits[9:0], Access Type=RW, default=0x000002AA*/

                            /*
                               Request stall assert LFSR seed. Must have at
                               least one bit set in active width.
                            */
    UINT32 req_stall_delay_seed : 10;

                            /* Bits[19:10], Access Type=RW, default=0x000002AA*/

                            /*
                               Request stall delay LFSR seed. Must have at
                               least one bit set in active width.
                            */
    UINT32 req_stall_assert_width : 4;

                            /* Bits[23:20], Access Type=RW, default=0x0000000A*/

                            /*
                               Request stall assert LFSR width. Must be between
                               5 and 10.
                            */
    UINT32 req_stall_delay_width : 4;

                            /* Bits[27:24], Access Type=RW, default=0x0000000A*/

                            /*
                               Request stall delay LFSR width. Must be between
                               5 and 10.
                            */
    UINT32 use_cmi_stall_for_m2m_stop : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000001*/

                            /* Use CMI stall/ack mechanism for m2m stop flow */
    UINT32 force_req_stall : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Level sensitivie signal to force a CMI stall.
                               Stall will persist until this bit is cleared.
                            */
    UINT32 reg_vld : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* Valid to load register fields */
    UINT32 req_stall_enable : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Bit to enable random req stall injection */

  } Bits;
  UINT32 Data;

} REG_MCCHAN_CMI_STALL_MC_2LM_STRUCT;

/* MCCMICFG_N0_MC_2LM_REG supported on:                                         */
/*      SPRA0 (0x20020120)                                                      */
/*      SPRB0 (0x20020120)                                                      */
/*      SPRHBM (0x20020120)                                                     */
/*      SPRC0 (0x20020120)                                                      */
/*      SPRMCC (0x20020120)                                                     */
/*      SPRUCC (0x20020120)                                                     */
/* Register default value on SPRA0: 0x8059805B                                  */
/* Register default value on SPRB0: 0x8059805B                                  */
/* Register default value on SPRHBM: 0x8059805B                                 */
/* Register default value on SPRC0: 0x8059805B                                  */
/* Register default value on SPRMCC: 0x8059805B                                 */
/* Register default value on SPRUCC: 0x8059805B                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* CMI configuration register
*/


#define MCCMICFG_N0_MC_2LM_REG 0x07120120

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddrt_wr_late_rsp_vld : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               When set, this bit enables non-posted DDRT
                               writes to only issue a write completion once the
                               write is actually issued to FNV. When clear, the
                               write completions behave as other DDR4 writes
                               and the completion will be sent after the
                               request is accepted by the scoreboard.
                            */
    UINT32 ddrt_rd_cpl_tid_parity_vld : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /* Valid bit to qualify rd_cpl tid parity bit */
    UINT32 ddrt_tid_parity_inj_enable : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enable bit to control ddrt rd_cpl tid parity
                               error injection
                            */
    UINT32 ddrt_tid_parity_inj_once : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000001*/

                            /*
                               When set, only one parity error will be
                               injected. When cleared, errors will be
                               continually injected via the lfsr.
                            */
    UINT32 ddrt_tid_parity_inj_lfsr_seed : 10;

                            /* Bits[13:4], Access Type=RW, default=0x00000005*/

                            /* Seed for parity injection lfsr */
    UINT32 ddrt_tid_parity_inj_lfsr_width : 4;

                            /* Bits[17:14], Access Type=RW, default=0x00000006*/

                            /* Width of parity injection lfsr */
    UINT32 rsp_tid_parity_inj_enable : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Enable bit to control rsp tid parity error
                               injection
                            */
    UINT32 rsp_tid_parity_inj_once : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               When set, only one parity error will be
                               injected. When cleared, errors will be
                               continually injected via the lfsr.
                            */
    UINT32 rsp_tid_parity_inj_lfsr_seed : 10;

                            /* Bits[29:20], Access Type=RW, default=0x00000005*/

                            /* Seed for parity injection lfsr */
    UINT32 rsp_tid_parity_inj_lfsr_width : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000002*/

                            /* Width of parity injection lfsr */

  } Bits;
  UINT32 Data;

} MCCMICFG_N0_MC_2LM_STRUCT;

/* MCCMICFG_N1_MC_2LM_REG supported on:                                         */
/*      SPRA0 (0x20020124)                                                      */
/*      SPRB0 (0x20020124)                                                      */
/*      SPRHBM (0x20020124)                                                     */
/*      SPRC0 (0x20020124)                                                      */
/*      SPRMCC (0x20020124)                                                     */
/*      SPRUCC (0x20020124)                                                     */
/* Register default value on SPRA0: 0x01C00005                                  */
/* Register default value on SPRB0: 0x01C00005                                  */
/* Register default value on SPRHBM: 0x01C00005                                 */
/* Register default value on SPRC0: 0x01C00005                                  */
/* Register default value on SPRMCC: 0x01C00005                                 */
/* Register default value on SPRUCC: 0x01C00005                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* CMI configuration register
*/


#define MCCMICFG_N1_MC_2LM_REG 0x07120124

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsp_tid_parity_inj_lfsr_width : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000001*/

                            /* Width of parity injection lfsr */
    UINT32 rsp_tid_parity_vld : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /* Enable bit to control rsp tid parity valid */
    UINT32 req_cmd_fab_credit : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Control behavior of request fabric credit
                               refund. 1: refund credit after processing
                               command only, 0: refund credit after processing
                               full request including both command and data.
                               This bit should only be set to 1 when TME is
                               enabled.
                            */
    UINT32 ism_req_idle_timeout_enable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Enable bit for ISM IDLE_REQ timeout forward
                               progress feature
                            */
    UINT32 ism_req_idle_timeout_error_signal : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable bit to signal error on ISM IDLE_REQ
                               timeout
                            */
    UINT32 ism_req_idle_timeout : 16;

                            /* Bits[21:6], Access Type=RW, default=0x00000000*/

                            /* ISM IDLE_REQ timeout forward progress threshold */
    UINT32 req_ifc_credit_over_sub_error_enable : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               Detect when total structure credits exceeds the
                               physical depth of the structure. The total
                               credit count includes the structure shared
                               credit count plus, across all VCs, the number of
                               reserved credits, refunded credits back to the
                               sender, and the number of credits used but not
                               yet refunded.
                            */
    UINT32 req_ifc_credit_over_sub_cfg_error_enable : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000001*/

                            /*
                               Detect when total structure credits exceeds the
                               total configured credits for that structure. The
                               total credit count includes the structure shared
                               credit count plus, across all VCs, the number of
                               reserved credits, refunded credits back to the
                               sender, and the number of credits used but not
                               yet refunded. The total configured credits
                               includes the configured structure shared count
                               plus the floor count across all VCs.
                            */
    UINT32 req_ifc_misc_credit_error_enable : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000001*/

                            /*
                               Enable errors related to counter overflow or
                               underflow conditions, plus any credit
                               arbitration errors.
                            */
    UINT32 dedup_ddrt_enable : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Dedup is configured to be able to send requests
                               to the DDRT controller
                            */
    UINT32 rsvd : 5;

                            /* Bits[30:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 vld : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Valid bit to signify firmware has programmed the
                               necessary fields
                            */

  } Bits;
  UINT32 Data;

} MCCMICFG_N1_MC_2LM_STRUCT;

/* MEM_MC_PMON_BLOCK_IDENTIFIER_N0_MC_2LM_REG supported on:                     */
/*      SPRA0 (0x20020128)                                                      */
/*      SPRB0 (0x20020128)                                                      */
/*      SPRHBM (0x20020128)                                                     */
/*      SPRC0 (0x20020128)                                                      */
/*      SPRMCC (0x20020128)                                                     */
/*      SPRUCC (0x20020128)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* PMON Block Identifier
*/


#define MEM_MC_PMON_BLOCK_IDENTIFIER_N0_MC_2LM_REG 0x07120128

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 blockidentifier : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* Local PMON Block Identifier */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=0x00000000*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEM_MC_PMON_BLOCK_IDENTIFIER_N0_MC_2LM_STRUCT;

/* MEM_MC_PMON_BLOCK_IDENTIFIER_N1_MC_2LM_REG supported on:                     */
/*      SPRA0 (0x2002012c)                                                      */
/*      SPRB0 (0x2002012c)                                                      */
/*      SPRHBM (0x2002012c)                                                     */
/*      SPRC0 (0x2002012c)                                                      */
/*      SPRMCC (0x2002012c)                                                     */
/*      SPRUCC (0x2002012c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* PMON Block Identifier
*/


#define MEM_MC_PMON_BLOCK_IDENTIFIER_N1_MC_2LM_REG 0x0712012C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEM_MC_PMON_BLOCK_IDENTIFIER_N1_MC_2LM_STRUCT;

/* MEM_MC_PMON_UNIT_DISCOVERY0_N0_MC_2LM_REG supported on:                      */
/*      SPRA0 (0x20020130)                                                      */
/*      SPRB0 (0x20020130)                                                      */
/*      SPRHBM (0x20020130)                                                     */
/*      SPRC0 (0x20020130)                                                      */
/*      SPRMCC (0x20020130)                                                     */
/*      SPRUCC (0x20020130)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* PMON Discovery state register 0
*/


#define MEM_MC_PMON_UNIT_DISCOVERY0_N0_MC_2LM_REG 0x07120130

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 numctrlregs : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Number of Control Registers */
    UINT32 ctrctrl0addr : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /* Counter Ctrl 0 Addr */
    UINT32 counterwidth : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /* Counter Width */
    UINT32 counter0addr : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /* Counter 0 Address */

  } Bits;
  UINT32 Data;

} MEM_MC_PMON_UNIT_DISCOVERY0_N0_MC_2LM_STRUCT;

/* MEM_MC_PMON_UNIT_DISCOVERY0_N1_MC_2LM_REG supported on:                      */
/*      SPRA0 (0x20020134)                                                      */
/*      SPRB0 (0x20020134)                                                      */
/*      SPRHBM (0x20020134)                                                     */
/*      SPRC0 (0x20020134)                                                      */
/*      SPRMCC (0x20020134)                                                     */
/*      SPRUCC (0x20020134)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* PMON Discovery state register 0
*/


#define MEM_MC_PMON_UNIT_DISCOVERY0_N1_MC_2LM_REG 0x07120134

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 unitstatusaddr : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* Unit Status Address */
    UINT32 rsvd2levftbits : 16;

                            /* Bits[23:8], Access Type=RW, default=0x00000000*/

                            /* Reserved 2 level feature bits */
    UINT32 rsvd : 6;

                            /* Bits[29:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 acctype : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /* Access Type */

  } Bits;
  UINT32 Data;

} MEM_MC_PMON_UNIT_DISCOVERY0_N1_MC_2LM_STRUCT;

/* MEM_MC_PMON_UNIT_DISCOVERY1_N0_MC_2LM_REG supported on:                      */
/*      SPRA0 (0x20020138)                                                      */
/*      SPRB0 (0x20020138)                                                      */
/*      SPRHBM (0x20020138)                                                     */
/*      SPRC0 (0x20020138)                                                      */
/*      SPRMCC (0x20020138)                                                     */
/*      SPRUCC (0x20020138)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* PMON Discovery state register 1
*/


#define MEM_MC_PMON_UNIT_DISCOVERY1_N0_MC_2LM_REG 0x07120138

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 unitctrctrladdr : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               Unit Counter Control Address serves as Base
                               Address
                            */

  } Bits;
  UINT32 Data;

} MEM_MC_PMON_UNIT_DISCOVERY1_N0_MC_2LM_STRUCT;

/* MEM_MC_PMON_UNIT_DISCOVERY1_N1_MC_2LM_REG supported on:                      */
/*      SPRA0 (0x2002013c)                                                      */
/*      SPRB0 (0x2002013c)                                                      */
/*      SPRHBM (0x2002013c)                                                     */
/*      SPRC0 (0x2002013c)                                                      */
/*      SPRMCC (0x2002013c)                                                     */
/*      SPRUCC (0x2002013c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* PMON Discovery state register 1
*/


#define MEM_MC_PMON_UNIT_DISCOVERY1_N1_MC_2LM_REG 0x0712013C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 unitctrctrladdr : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               Unit Counter Control Address serves as Base
                               Address
                            */

  } Bits;
  UINT32 Data;

} MEM_MC_PMON_UNIT_DISCOVERY1_N1_MC_2LM_STRUCT;

/* MEM_MC_PMON_UNIT_DISCOVERY2_N0_MC_2LM_REG supported on:                      */
/*      SPRA0 (0x20020140)                                                      */
/*      SPRB0 (0x20020140)                                                      */
/*      SPRHBM (0x20020140)                                                     */
/*      SPRC0 (0x20020140)                                                      */
/*      SPRMCC (0x20020140)                                                     */
/*      SPRUCC (0x20020140)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* PMON Discovery state register 2
*/


#define MEM_MC_PMON_UNIT_DISCOVERY2_N0_MC_2LM_REG 0x07120140

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 unittype : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* Unit Type */
    UINT32 unitid : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Unit ID */

  } Bits;
  UINT32 Data;

} MEM_MC_PMON_UNIT_DISCOVERY2_N0_MC_2LM_STRUCT;

/* MEM_MC_PMON_UNIT_DISCOVERY2_N1_MC_2LM_REG supported on:                      */
/*      SPRA0 (0x20020144)                                                      */
/*      SPRB0 (0x20020144)                                                      */
/*      SPRHBM (0x20020144)                                                     */
/*      SPRC0 (0x20020144)                                                      */
/*      SPRMCC (0x20020144)                                                     */
/*      SPRUCC (0x20020144)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* PMON Discovery state register 2
*/


#define MEM_MC_PMON_UNIT_DISCOVERY2_N1_MC_2LM_REG 0x07120144

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 glstsposition : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* Global Status Postion */
    UINT32 rsvd1levftbits : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /* Reserved 1 Level Feature Bits */

  } Bits;
  UINT32 Data;

} MEM_MC_PMON_UNIT_DISCOVERY2_N1_MC_2LM_STRUCT;

/* MC_2LMCNTL_ECC_RETRY_CFG_MC_2LM_REG supported on:                            */
/*      SPRA0 (0x20020148)                                                      */
/*      SPRB0 (0x20020148)                                                      */
/*      SPRHBM (0x20020148)                                                     */
/*      SPRC0 (0x20020148)                                                      */
/*      SPRMCC (0x20020148)                                                     */
/*      SPRUCC (0x20020148)                                                     */
/* Register default value on SPRA0: 0x16057D32                                  */
/* Register default value on SPRB0: 0x16057D32                                  */
/* Register default value on SPRHBM: 0x16057D32                                 */
/* Register default value on SPRC0: 0x16057D32                                  */
/* Register default value on SPRMCC: 0x16057D32                                 */
/* Register default value on SPRUCC: 0x16057D32                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 2lm control ecc retry configuration register.
*/


#define MC_2LMCNTL_ECC_RETRY_CFG_MC_2LM_REG 0x07120148

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mc_ecc_retry_pending_wait : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000032*/

                            /*
                               Wait time for ECC retry FSM to wait in pending
                               wait state in hclk
                            */
    UINT32 mc_ecc_retry_drain_wait : 8;

                            /* Bits[15:8], Access Type=RW, default=0x0000007D*/

                            /*
                               Wait time for ECC retry FSM to wait in drain
                               wait state in hclk
                            */
    UINT32 mc_ecc_retry_wpq_drain_wait : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000005*/

                            /*
                               Wait time for ECC retry FSM to wait in wpq drain
                               state
                            */
    UINT32 mc_disable_ecc_retry_idle_for_pma_qempty : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /* Disable retry FSM idle check for signals to PMA */
    UINT32 mc_disable_ecc_retry_scrub_a_on_corr : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000001*/

                            /*
                               Disable scrub write with dir=A for correctable
                               errors
                            */
    UINT32 mc_ecc_retry_patrol_drain_wait : 4;

                            /* Bits[29:26], Access Type=RW, default=0x00000005*/

                            /*
                               Wait time for ECC retry FSM to wait in patrol
                               drain state
                            */
    UINT32 mc_enable_ecc_retry_poison_on_mirr_nofailover : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Always scrub poison even if UC & (mirrored & ~
                               mirr_fo) & ~Req2lm
                            */
    UINT32 retry_pending_unblock_ingress : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_ECC_RETRY_CFG_MC_2LM_STRUCT;

/* MCCHAN_SUMMARY_MC_2LM_REG supported on:                                      */
/*      SPRA0 (0x20020150)                                                      */
/*      SPRB0 (0x20020150)                                                      */
/*      SPRHBM (0x20020150)                                                     */
/*      SPRC0 (0x20020150)                                                      */
/*      SPRMCC (0x20020150)                                                     */
/*      SPRUCC (0x20020150)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains structure empty and error FSM information. 
*/


#define MCCHAN_SUMMARY_MC_2LM_REG 0x07120150

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mc_retry_fsm_tag : 6;

                            /* Bits[5:0], Access Type=RO/V, default=0x00000000*/

                            /* Mcscheds ECC retry FSM tag */
    UINT32 mc_mstr_retry_fsm_tag : 6;

                            /* Bits[11:6], Access Type=RO/V, default=0x00000000*/

                            /* Master ECC retry FSM tag */
    UINT32 mc_ddrt_retry_state_tag : 6;

                            /* Bits[17:12], Access Type=RO/V, default=0x00000000*/

                            /* DDRT retry FSM tag */
    UINT32 mc_vee_state_tag : 6;

                            /* Bits[23:18], Access Type=RO/V, default=0x00000000*/

                            /* VEE retry FSM tag */
    UINT32 mc_ddr4_rpq_not_empty : 1;

                            /* Bits[24:24], Access Type=RO/V, default=0x00000000*/

                            /* DDR4 RPQ not empty */
    UINT32 mc_ddr4_wpq_not_empty : 1;

                            /* Bits[25:25], Access Type=RO/V, default=0x00000000*/

                            /* DDR4 WPQ not empty */
    UINT32 mc_ddrt_rpq_not_empty : 1;

                            /* Bits[26:26], Access Type=RO/V, default=0x00000000*/

                            /* DDRT RPQ not empty */
    UINT32 mc_ddrt_wpq_not_empty : 1;

                            /* Bits[27:27], Access Type=RO/V, default=0x00000000*/

                            /* DDRT WPQ not empty */
    UINT32 mc_rdb_not_empty : 1;

                            /* Bits[28:28], Access Type=RO/V, default=0x00000000*/

                            /* RDB not empty */
    UINT32 mc_rt_not_empty : 1;

                            /* Bits[29:29], Access Type=RO/V, default=0x00000000*/

                            /* RT not empty */
    UINT32 mc_sb_not_empty : 1;

                            /* Bits[30:30], Access Type=RO/V, default=0x00000000*/

                            /* SB not empty */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCCHAN_SUMMARY_MC_2LM_STRUCT;

/* SBDEFEATURES0_MC_2LM_REG supported on:                                       */
/*      SPRA0 (0x20020158)                                                      */
/*      SPRB0 (0x20020158)                                                      */
/*      SPRHBM (0x20020158)                                                     */
/*      SPRC0 (0x20020158)                                                      */
/*      SPRMCC (0x20020158)                                                     */
/*      SPRUCC (0x20020158)                                                     */
/* Register default value on SPRA0: 0x0444009E                                  */
/* Register default value on SPRB0: 0x0444009E                                  */
/* Register default value on SPRHBM: 0x0444009E                                 */
/* Register default value on SPRC0: 0x0444009E                                  */
/* Register default value on SPRMCC: 0x0444009E                                 */
/* Register default value on SPRUCC: 0x0444009E                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 2LM scoreboard defeatures
*/


#define SBDEFEATURES0_MC_2LM_REG 0x07120158

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 numsbentries : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x0000009E*/

                            /*
                               Number of enabled SB entries. A value of 0
                               corresponds to all 160 entries being enabled,
                               otherwise entries 0...N-1 are enabled. This must
                               be set to 158 or less, as the upper 2 entries
                               are statically allocated to patrol and anti-
                               starvation.
                            */
    UINT32 spare1 : 2;

                            /* Bits[9:8], Access Type=RW/P, default=0x00000000*/

                            /* Reserved for ECOs. */
    UINT32 sbfrcrejecten : 2;

                            /* Bits[11:10], Access Type=RW/P, default=0x00000000*/

                            /*
                               Force new requests to be rejected when the DFD
                               response function asserts. 00 - Dont throttle 01
                               - Use Trigger-0 10 - Use Trigger-1 11 - Use
                               Trigger-2
                            */
    UINT32 sbfrcrejectmode : 3;

                            /* Bits[14:12], Access Type=RW/P, default=0x00000000*/

                            /*
                               Used in conjunction with SbFrcRejectEn. Type of
                               request to force reject when the DFD response
                               function asserts. 000 - All requests 001 - NM
                               requests 010 - FM requests 011 - Patrol requests
                               100 - Reads 101 - Writes 110 - Non-patrol
                               requests
                            */
    UINT32 pwrdnovrd : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /* Disable clock-gating for 2LM scoreboard control */
    UINT32 msgchpwrdnovrd : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /* Disable clock-gating for 2LM scoreboard MsgChnl */
    UINT32 maskmatchmodeen : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               When set, each scoreboard entry stores the
                               result of the mask/match operation in M2M
                            */
    UINT32 addrantistarvedis : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000001*/

                            /*
                               When set, disables the anti-starvation mechanism
                               for address conflicts. When not disabled,
                               SbDefeatures0.NumSbEntries must be greater than
                               0
                            */
    UINT32 addrantistarvethresh : 5;

                            /* Bits[23:19], Access Type=RW/P, default=0x00000008*/

                            /*
                               Number of times an entry must be rejected before
                               anti-starvation will kick in.
                            */
    UINT32 spare2 : 1;

                            /* Bits[24:24], Access Type=RW/P, default=0x00000000*/

                            /* Reserved for ECOs. */
    UINT32 clrfifoonsbdeallocall : 1;

                            /* Bits[25:25], Access Type=RW/P, default=0x00000000*/

                            /*
                               When set, clears the completion and data return
                               FIFOs on an SbDeallocAll command.
                            */
    UINT32 disdropnodata : 1;

                            /* Bits[26:26], Access Type=RW/P, default=0x00000001*/

                            /*
                               When set, prevents SB from decoding and ignoring
                               no-data packets This bit should be 1 for wave-3
                               (DDRT2).
                            */
    UINT32 dissbcachemode : 1;

                            /* Bits[27:27], Access Type=RW/P, default=0x00000000*/

                            /* Should be set to 1 to disable cache mode in SB. */
    UINT32 dissbretry : 1;

                            /* Bits[28:28], Access Type=RW/P, default=0x00000000*/

                            /* Should be set to 1 to disable Retry */
    UINT32 discmpsrcidtrk : 1;

                            /* Bits[29:29], Access Type=RW/P, default=0x00000000*/

                            /*
                               Set to 1 to disable the SB Tracker. Should not
                               be set to 0 when SGX is not enabled.
                            */
    UINT32 allowdirupdtoblock : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               1: Allow directory updates to the block region
                               (including PAD). 0: Do not allow directory
                               updates to the block region (including PAD).
                               Must be set consistently with
                               m2mem.Defeatures0.AllowDirUpdToBlock.
                            */
    UINT32 disabledir4appdirect : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Disable Directory for 1LM App Direct ranges.
                               Setting this bit the entire App Direct DDRT
                               region into snoopy mode rather than the
                               directory based protocol. The result is that all
                               read accesses to this region will ignore the
                               directory bits returned from MC, SNP_ALL is sent
                               to CHA, and no directory update would occur. All
                               other memory ranges may still be in directory
                               mode 1: Disable Directory for 1LM App Direct
                               region 0: 1LM App Direct region follows the
                               directory enabled or disabled mode of the system
                               Must be set consistently with
                               m2mem.Defeatures0.DisableDir4AppDirect.
                            */

  } Bits;
  UINT32 Data;

} SBDEFEATURES0_MC_2LM_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 numsbentries : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x0000009E*/

                            /*
                               Number of enabled SB entries. A value of 0
                               corresponds to all 160 entries being enabled,
                               otherwise entries 0...N-1 are enabled. This must
                               be set to 158 or less, as the upper 2 entries
                               are statically allocated to patrol and anti-
                               starvation.
                            */
    UINT32 spare1 : 2;

                            /* Bits[9:8], Access Type=RW/P, default=0x00000000*/

                            /* Reserved for ECOs. */
    UINT32 sbfrcrejecten : 2;

                            /* Bits[11:10], Access Type=RW/P, default=0x00000000*/

                            /*
                               Force new requests to be rejected when the DFD
                               response function asserts. 00 - Dont throttle 01
                               - Use Trigger-0 10 - Use Trigger-1 11 - Use
                               Trigger-2
                            */
    UINT32 sbfrcrejectmode : 3;

                            /* Bits[14:12], Access Type=RW/P, default=0x00000000*/

                            /*
                               Used in conjunction with SbFrcRejectEn. Type of
                               request to force reject when the DFD response
                               function asserts. 000 - All requests 001 - NM
                               requests 010 - FM requests 011 - Patrol requests
                               100 - Reads 101 - Writes 110 - Non-patrol
                               requests
                            */
    UINT32 pwrdnovrd : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /* Disable clock-gating for 2LM scoreboard control */
    UINT32 msgchpwrdnovrd : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /* Disable clock-gating for 2LM scoreboard MsgChnl */
    UINT32 maskmatchmodeen : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               When set, each scoreboard entry stores the
                               result of the mask/match operation in M2M
                            */
    UINT32 addrantistarvedis : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000001*/

                            /*
                               When set, disables the anti-starvation mechanism
                               for address conflicts. When not disabled,
                               SbDefeatures0.NumSbEntries must be greater than
                               0
                            */
    UINT32 addrantistarvethresh : 5;

                            /* Bits[23:19], Access Type=RW/P, default=0x00000008*/

                            /*
                               Number of times an entry must be rejected before
                               anti-starvation will kick in.
                            */
    UINT32 distmetdxerr : 1;

                            /* Bits[24:24], Access Type=RW/P, default=0x00000000*/

                            /* Disable TME TD mismatch w/ integrity error. */
    UINT32 clrfifoonsbdeallocall : 1;

                            /* Bits[25:25], Access Type=RW/P, default=0x00000000*/

                            /*
                               When set, clears the completion and data return
                               FIFOs on an SbDeallocAll command.
                            */
    UINT32 disdropnodata : 1;

                            /* Bits[26:26], Access Type=RW/P, default=0x00000001*/

                            /*
                               When set, prevents SB from decoding and ignoring
                               no-data packets This bit should be 1 for wave-3
                               (DDRT2).
                            */
    UINT32 dissbcachemode : 1;

                            /* Bits[27:27], Access Type=RW/P, default=0x00000000*/

                            /* Should be set to 1 to disable cache mode in SB. */
    UINT32 dissbretry : 1;

                            /* Bits[28:28], Access Type=RW/P, default=0x00000000*/

                            /* Should be set to 1 to disable Retry */
    UINT32 discmpsrcidtrk : 1;

                            /* Bits[29:29], Access Type=RW/P, default=0x00000000*/

                            /*
                               Set to 1 to disable the SB Tracker. Should not
                               be set to 0 when SGX is not enabled.
                            */
    UINT32 allowdirupdtoblock : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               1: Allow directory updates to the block region
                               (including PAD). 0: Do not allow directory
                               updates to the block region (including PAD).
                               Must be set consistently with
                               m2mem.Defeatures0.AllowDirUpdToBlock.
                            */
    UINT32 disabledir4appdirect : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Disable Directory for 1LM App Direct ranges.
                               Setting this bit the entire App Direct DDRT
                               region into snoopy mode rather than the
                               directory based protocol. The result is that all
                               read accesses to this region will ignore the
                               directory bits returned from MC, SNP_ALL is sent
                               to CHA, and no directory update would occur. All
                               other memory ranges may still be in directory
                               mode 1: Disable Directory for 1LM App Direct
                               region 0: 1LM App Direct region follows the
                               directory enabled or disabled mode of the system
                               Must be set consistently with
                               m2mem.Defeatures0.DisableDir4AppDirect.
                            */

  } Bits;
  UINT32 Data;

} SBDEFEATURES0_MC_2LM_SPRB0_SPRHBM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 numsbentries : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x0000009E*/

                            /*
                               Number of enabled SB entries. A value of 0
                               corresponds to all 160 entries being enabled,
                               otherwise entries 0...N-1 are enabled. This must
                               be set to 158 or less, as the upper 2 entries
                               are statically allocated to patrol and anti-
                               starvation.
                            */
    UINT32 spare1 : 2;

                            /* Bits[9:8], Access Type=RW/P, default=0x00000000*/

                            /* Reserved for ECOs. */
    UINT32 sbfrcrejecten : 2;

                            /* Bits[11:10], Access Type=RW/P, default=0x00000000*/

                            /*
                               Force new requests to be rejected when the DFD
                               response function asserts. 00 - Dont throttle 01
                               - Use Trigger-0 10 - Use Trigger-1 11 - Use
                               Trigger-2
                            */
    UINT32 sbfrcrejectmode : 3;

                            /* Bits[14:12], Access Type=RW/P, default=0x00000000*/

                            /*
                               Used in conjunction with SbFrcRejectEn. Type of
                               request to force reject when the DFD response
                               function asserts. 000 - All requests 001 - NM
                               requests 010 - FM requests 011 - Patrol requests
                               100 - Reads 101 - Writes 110 - Non-patrol
                               requests
                            */
    UINT32 pwrdnovrd : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /* Disable clock-gating for 2LM scoreboard control */
    UINT32 msgchpwrdnovrd : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /* Disable clock-gating for 2LM scoreboard MsgChnl */
    UINT32 maskmatchmodeen : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               When set, each scoreboard entry stores the
                               result of the mask/match operation in M2M
                            */
    UINT32 addrantistarvedis : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000001*/

                            /*
                               When set, disables the anti-starvation mechanism
                               for address conflicts. When not disabled,
                               SbDefeatures0.NumSbEntries must be greater than
                               0
                            */
    UINT32 addrantistarvethresh : 5;

                            /* Bits[23:19], Access Type=RW/P, default=0x00000008*/

                            /*
                               Number of times an entry must be rejected before
                               anti-starvation will kick in.
                            */
    UINT32 rsvd : 1;

                            /* Bits[24:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 clrfifoonsbdeallocall : 1;

                            /* Bits[25:25], Access Type=RW/P, default=0x00000000*/

                            /*
                               When set, clears the completion and data return
                               FIFOs on an SbDeallocAll command.
                            */
    UINT32 disdropnodata : 1;

                            /* Bits[26:26], Access Type=RW/P, default=0x00000001*/

                            /*
                               When set, prevents SB from decoding and ignoring
                               no-data packets This bit should be 1 for wave-3
                               (DDRT2).
                            */
    UINT32 dissbcachemode : 1;

                            /* Bits[27:27], Access Type=RW/P, default=0x00000000*/

                            /* Should be set to 1 to disable cache mode in SB. */
    UINT32 dissbretry : 1;

                            /* Bits[28:28], Access Type=RW/P, default=0x00000000*/

                            /* Should be set to 1 to disable Retry */
    UINT32 discmpsrcidtrk : 1;

                            /* Bits[29:29], Access Type=RW/P, default=0x00000000*/

                            /*
                               Set to 1 to disable the SB Tracker. Should not
                               be set to 0 when SGX is not enabled.
                            */
    UINT32 allowdirupdtoblock : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               1: Allow directory updates to the block region
                               (including PAD). 0: Do not allow directory
                               updates to the block region (including PAD).
                               Must be set consistently with
                               m2mem.Defeatures0.AllowDirUpdToBlock.
                            */
    UINT32 disabledir4appdirect : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Disable Directory for 1LM App Direct ranges.
                               Setting this bit the entire App Direct DDRT
                               region into snoopy mode rather than the
                               directory based protocol. The result is that all
                               read accesses to this region will ignore the
                               directory bits returned from MC, SNP_ALL is sent
                               to CHA, and no directory update would occur. All
                               other memory ranges may still be in directory
                               mode 1: Disable Directory for 1LM App Direct
                               region 0: 1LM App Direct region follows the
                               directory enabled or disabled mode of the system
                               Must be set consistently with
                               m2mem.Defeatures0.DisableDir4AppDirect.
                            */

  } Bits;
  UINT32 Data;

} SBDEFEATURES0_MC_2LM_STRUCT;

/* MC_ECC_RETRY_SUMMARY_MC_2LM_REG supported on:                                */
/*      SPRA0 (0x20020164)                                                      */
/*      SPRB0 (0x20020164)                                                      */
/*      SPRHBM (0x20020164)                                                     */
/*      SPRC0 (0x20020164)                                                      */
/*      SPRMCC (0x20020164)                                                     */
/*      SPRUCC (0x20020164)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains ecc retry FSM information 
*/


#define MC_ECC_RETRY_SUMMARY_MC_2LM_REG 0x07120164

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 current_state : 4;

                            /* Bits[3:0], Access Type=RO/V, default=0x00000000*/

                            /* Current encoded state of ecc retry FSM */
    UINT32 previous_state : 4;

                            /* Bits[7:4], Access Type=RO/V, default=0x00000000*/

                            /* Previous encoded state of ecc retry FSM */
    UINT32 rsvd : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MC_ECC_RETRY_SUMMARY_MC_2LM_STRUCT;

/* SBVIRALCTL_MC_2LM_REG supported on:                                          */
/*      SPRA0 (0x20020168)                                                      */
/*      SPRB0 (0x20020168)                                                      */
/*      SPRHBM (0x20020168)                                                     */
/*      SPRC0 (0x20020168)                                                      */
/*      SPRMCC (0x20020168)                                                     */
/*      SPRUCC (0x20020168)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Enables for the SB viral triggering
*/


#define SBVIRALCTL_MC_2LM_REG 0x07120168

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reqerrdis : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering of bad request errors */
    UINT32 readrspmisserrdis : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of read data response
                               miss errors
                            */
    UINT32 ddr4cmperrdis : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of DDR4 completion
                               errors
                            */
    UINT32 ddrtcmperrdis : 1;

                            /* Bits[3:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of DDRt completion
                               errors
                            */
    UINT32 readrspopcodeerrdis : 1;

                            /* Bits[4:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of read data response
                               opcode errors
                            */
    UINT32 cmplfifooferrdis : 1;

                            /* Bits[5:5], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of completion FIFO
                               overflows
                            */
    UINT32 cmplfifouferrdis : 1;

                            /* Bits[6:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of completion FIFO
                               underflows
                            */
    UINT32 nmfillwrcamerrdis : 1;

                            /* Bits[7:7], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering of NmFillWr CAM errors */
    UINT32 cmicredtotalviraldis : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI total credit
                               count errors
                            */
    UINT32 cmicredoversubviraldis : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI credit
                               oversubscription
                            */
    UINT32 cmirsvdpoolviraldis : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI reserved credit
                               pool errors
                            */
    UINT32 cmimiscmccrdtviraldis : 1;

                            /* Bits[11:11], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI miscellanous
                               mc_crdt errors; these include overflow and
                               underflow for rsp_fabric_crdt and rsp_vc_crdt
                            */
    UINT32 cmimiscmcarbviraldis : 1;

                            /* Bits[12:12], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI miscellanous
                               mc_arb errors;these include internal errors for
                               non_sgx_refund_arb/refund_arb/sgx_refund_arb/ear
                               ly_rsp_bca/late_ddrt_rsp_bca/late_rsp_bca/late_m
                               essage_arbiter and rd_cpl_credit_acc/rsp_credit_
                               acc/wr_credit_acc/rd_credit_acc
                            */
    UINT32 tmecmiviraldis : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering of CMI errors in TME */
    UINT32 tmetemsecurebitviraldis : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of TEM secure bit
                               errors in TME.
                            */
    UINT32 tmekeyparerrviraldis : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of TME key parity
                               errors
                            */
    UINT32 tmeufillparerrviraldis : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of TME ufill parity
                               errors
                            */
    UINT32 wrcmpddrtfifounderflowviraldis : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of DDRT wr cmpl FIFO
                               underflow errors
                            */
    UINT32 wrcmpddrtfifooverflowviraldis : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of DDRT wr cmpl FIFO
                               overflow errors
                            */
    UINT32 draerrviraldis : 1;

                            /* Bits[19:19], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering of DRA errors */
    UINT32 tmeintegrityviraldis : 1;

                            /* Bits[20:20], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of integrity errors in
                               TME.
                            */
    UINT32 rsvd : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SBVIRALCTL_MC_2LM_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reqerrdis : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering of bad request errors */
    UINT32 readrspmisserrdis : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of read data response
                               miss errors
                            */
    UINT32 ddr4cmperrdis : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of DDR4 completion
                               errors
                            */
    UINT32 ddrtcmperrdis : 1;

                            /* Bits[3:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of DDRt completion
                               errors
                            */
    UINT32 readrspopcodeerrdis : 1;

                            /* Bits[4:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of read data response
                               opcode errors
                            */
    UINT32 cmplfifooferrdis : 1;

                            /* Bits[5:5], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of completion FIFO
                               overflows
                            */
    UINT32 cmplfifouferrdis : 1;

                            /* Bits[6:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of completion FIFO
                               underflows
                            */
    UINT32 nmfillwrcamerrdis : 1;

                            /* Bits[7:7], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering of NmFillWr CAM errors */
    UINT32 cmicredtotalviraldis : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI total credit
                               count errors
                            */
    UINT32 cmicredoversubviraldis : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI credit
                               oversubscription
                            */
    UINT32 cmirsvdpoolviraldis : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI reserved credit
                               pool errors
                            */
    UINT32 cmimiscmccrdtviraldis : 1;

                            /* Bits[11:11], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI miscellanous
                               mc_crdt errors; these include overflow and
                               underflow for rsp_fabric_crdt and rsp_vc_crdt
                            */
    UINT32 cmimiscmcarbviraldis : 1;

                            /* Bits[12:12], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI miscellanous
                               mc_arb errors;these include internal errors for
                               non_sgx_refund_arb/refund_arb/sgx_refund_arb/ear
                               ly_rsp_bca/late_ddrt_rsp_bca/late_rsp_bca/late_m
                               essage_arbiter and rd_cpl_credit_acc/rsp_credit_
                               acc/wr_credit_acc/rd_credit_acc
                            */
    UINT32 tmecmiviraldis : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering of CMI errors in TME */
    UINT32 tmetemsecurebitviraldis : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of TEM secure bit
                               errors in TME.
                            */
    UINT32 tmekeyparerrviraldis : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of TME key parity
                               errors
                            */
    UINT32 tmeufillparerrviraldis : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of TME ufill parity
                               errors
                            */
    UINT32 wrcmpddrtfifounderflowviraldis : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of DDRT wr cmpl FIFO
                               underflow errors
                            */
    UINT32 wrcmpddrtfifooverflowviraldis : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of DDRT wr cmpl FIFO
                               overflow errors
                            */
    UINT32 draerrviraldis : 1;

                            /* Bits[19:19], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering of DRA errors */
    UINT32 tmeintegrityviraldis : 1;

                            /* Bits[20:20], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of integrity errors in
                               TME.
                            */
    UINT32 tmetdxerrviraldis : 1;

                            /* Bits[21:21], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of TD mismatch w/
                               integrity errors in TME.
                            */
    UINT32 tmekeypoisonviraldis : 1;

                            /* Bits[22:22], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of key poison errors in
                               TME.
                            */
    UINT32 rsvd : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SBVIRALCTL_MC_2LM_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reqerrdis : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering of bad request errors */
    UINT32 readrspmisserrdis : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of read data response
                               miss errors
                            */
    UINT32 ddr4cmperrdis : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of DDR4 completion
                               errors
                            */
    UINT32 ddrtcmperrdis : 1;

                            /* Bits[3:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of DDRt completion
                               errors
                            */
    UINT32 readrspopcodeerrdis : 1;

                            /* Bits[4:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of read data response
                               opcode errors
                            */
    UINT32 cmplfifooferrdis : 1;

                            /* Bits[5:5], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of completion FIFO
                               overflows
                            */
    UINT32 cmplfifouferrdis : 1;

                            /* Bits[6:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of completion FIFO
                               underflows
                            */
    UINT32 nmfillwrcamerrdis : 1;

                            /* Bits[7:7], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering of NmFillWr CAM errors */
    UINT32 cmicredtotalviraldis : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI total credit
                               count errors
                            */
    UINT32 cmicredoversubviraldis : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI credit
                               oversubscription
                            */
    UINT32 cmirsvdpoolviraldis : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI reserved credit
                               pool errors
                            */
    UINT32 cmimiscmccrdtviraldis : 1;

                            /* Bits[11:11], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI miscellanous
                               mc_crdt errors; these include overflow and
                               underflow for rsp_fabric_crdt and rsp_vc_crdt
                            */
    UINT32 cmimiscmcarbviraldis : 1;

                            /* Bits[12:12], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI miscellanous
                               mc_arb errors;these include internal errors for
                               non_sgx_refund_arb/refund_arb/sgx_refund_arb/ear
                               ly_rsp_bca/late_ddrt_rsp_bca/late_rsp_bca/late_m
                               essage_arbiter and rd_cpl_credit_acc/rsp_credit_
                               acc/wr_credit_acc/rd_credit_acc
                            */
    UINT32 tmecmiviraldis : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering of CMI errors in TME */
    UINT32 tmetemsecurebitviraldis : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of TEM secure bit
                               errors in TME.
                            */
    UINT32 tmekeyparerrviraldis : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of TME key parity
                               errors
                            */
    UINT32 tmeufillparerrviraldis : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of TME ufill parity
                               errors
                            */
    UINT32 wrcmpddrtfifounderflowviraldis : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of DDRT wr cmpl FIFO
                               underflow errors
                            */
    UINT32 wrcmpddrtfifooverflowviraldis : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of DDRT wr cmpl FIFO
                               overflow errors
                            */
    UINT32 draerrviraldis : 1;

                            /* Bits[19:19], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering of DRA errors */
    UINT32 tmeintegrityviraldis : 1;

                            /* Bits[20:20], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of integrity errors in
                               TME.
                            */
    UINT32 tmetdxerrviraldis : 1;

                            /* Bits[21:21], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of TD mismatch w/
                               integrity errors in TME.
                            */
    UINT32 tmekeypoisonviraldis : 1;

                            /* Bits[22:22], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of key poison errors in
                               TME.
                            */
    UINT32 tmesecurityengineerrviraldis : 1;

                            /* Bits[23:23], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of security engine
                               errors in TME.
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SBVIRALCTL_MC_2LM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reqerrdis : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering of bad request errors */
    UINT32 readrspmisserrdis : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of read data response
                               miss errors
                            */
    UINT32 ddr4cmperrdis : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of DDR4 completion
                               errors
                            */
    UINT32 ddrtcmperrdis : 1;

                            /* Bits[3:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of DDRt completion
                               errors
                            */
    UINT32 readrspopcodeerrdis : 1;

                            /* Bits[4:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of read data response
                               opcode errors
                            */
    UINT32 cmplfifooferrdis : 1;

                            /* Bits[5:5], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of completion FIFO
                               overflows
                            */
    UINT32 cmplfifouferrdis : 1;

                            /* Bits[6:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of completion FIFO
                               underflows
                            */
    UINT32 nmfillwrcamerrdis : 1;

                            /* Bits[7:7], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering of NmFillWr CAM errors */
    UINT32 cmicredtotalviraldis : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI total credit
                               count errors
                            */
    UINT32 cmicredoversubviraldis : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI credit
                               oversubscription
                            */
    UINT32 cmirsvdpoolviraldis : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI reserved credit
                               pool errors
                            */
    UINT32 cmimiscmccrdtviraldis : 1;

                            /* Bits[11:11], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI miscellanous
                               mc_crdt errors; these include overflow and
                               underflow for rsp_fabric_crdt and rsp_vc_crdt
                            */
    UINT32 cmimiscmcarbviraldis : 1;

                            /* Bits[12:12], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of CMI miscellanous
                               mc_arb errors;these include internal errors for
                               non_sgx_refund_arb/refund_arb/sgx_refund_arb/ear
                               ly_rsp_bca/late_ddrt_rsp_bca/late_rsp_bca/late_m
                               essage_arbiter and rd_cpl_credit_acc/rsp_credit_
                               acc/wr_credit_acc/rd_credit_acc
                            */
    UINT32 tmecmiviraldis : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering of CMI errors in TME */
    UINT32 tmetemsecurebitviraldis : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of TEM secure bit
                               errors in TME.
                            */
    UINT32 tmekeyparerrviraldis : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of TME key parity
                               errors
                            */
    UINT32 tmeufillparerrviraldis : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of TME ufill parity
                               errors
                            */
    UINT32 wrcmpddrtfifounderflowviraldis : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of DDRT wr cmpl FIFO
                               underflow errors
                            */
    UINT32 wrcmpddrtfifooverflowviraldis : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of DDRT wr cmpl FIFO
                               overflow errors
                            */
    UINT32 draerrviraldis : 1;

                            /* Bits[19:19], Access Type=RW/P, default=0x00000000*/

                            /* Disable viral triggering of DRA errors */
    UINT32 tmeintegrityviraldis : 1;

                            /* Bits[20:20], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering of integrity errors in
                               TME.
                            */
    UINT32 rsvd : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SBVIRALCTL_MC_2LM_STRUCT;

/* CMIDEBUG_MC_2LM_REG supported on:                                            */
/*      SPRA0 (0x2002016c)                                                      */
/*      SPRB0 (0x2002016c)                                                      */
/*      SPRHBM (0x2002016c)                                                     */
/*      SPRC0 (0x2002016c)                                                      */
/*      SPRMCC (0x2002016c)                                                     */
/*      SPRUCC (0x2002016c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Debug hooks for CMI
*/


#define CMIDEBUG_MC_2LM_REG 0x0712016C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmicrdtthrottleen : 2;

                            /* Bits[1:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Enable throttling the return of CMI credits when
                               the DFD response function asserts. 00 - Dont
                               throttle 01 - Use Trigger-0 10 - Use Trigger-1
                               11 - Use Trigger-2
                            */
    UINT32 cmivccrdtthrottlemask : 8;

                            /* Bits[9:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               Mask to choose what VC credits are throttled.
                               Used in conjunction with CmiCrdtThrottleEn. Bit
                               0 - read VC0 Bit 1 - read VC1 Bit 2 - read VC2
                               Bit 3 - read VC3 Bit 4 - write VC0 Bit 5 - write
                               VC1 Bit 6 - write VC2 Bit 7 - write VC3
                            */
    UINT32 rsvd : 22;

                            /* Bits[31:10], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CMIDEBUG_MC_2LM_STRUCT;

/* SBARRSNAPSHOTCTL_MC_2LM_REG supported on:                                    */
/*      SPRA0 (0x20020170)                                                      */
/*      SPRB0 (0x20020170)                                                      */
/*      SPRHBM (0x20020170)                                                     */
/*      SPRC0 (0x20020170)                                                      */
/*      SPRMCC (0x20020170)                                                     */
/*      SPRUCC (0x20020170)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Read out the contents of the 2LM scoreboard.
*/


#define SBARRSNAPSHOTCTL_MC_2LM_REG 0x07120170

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Read out the entry of the scoreboard programmed
                               in SbArrSnapshotCtl.SbIndex. Once the contents
                               of that entry have been loaded into
                               SbArrSnapshotData0 and SbArrSnapshotData1,
                               hardware will clear this enable bit to 0. Locked
                               by mc2lmctl_dfx_lck_cntl.mc_array_dump_lck. When
                               locked, the Enable bit is immediately cleared.
                            */
    UINT32 sbindex : 8;

                            /* Bits[8:1], Access Type=RW, default=0x00000000*/

                            /* Entry of the scoreboard to read. */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SBARRSNAPSHOTCTL_MC_2LM_STRUCT;

/* SBARRSNAPSHOTDATA0_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x20020174)                                                      */
/*      SPRB0 (0x20020174)                                                      */
/*      SPRHBM (0x20020174)                                                     */
/*      SPRC0 (0x20020174)                                                      */
/*      SPRMCC (0x20020174)                                                     */
/*      SPRUCC (0x20020174)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Contents of the 2LM scoreboard.
*/


#define SBARRSNAPSHOTDATA0_MC_2LM_REG 0x07120174

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sbstate : 17;

                            /* Bits[16:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               State of the SB entry specified by
                               SbArrCapture.SbIndex Bits 16 - valid Bits 15 -
                               NM write pending Bits 14 - FM write pending Bits
                               13 - mirror or WT write pending Bits 12 - pmem
                               request Bits 11 - request targets uncacheable
                               DDRT Bits 10 - block region request Bits 9 - Dfx
                               Bits 8 - DDRT UC or 1LM Early Cmp Bits 7: 2 -
                               Opcode Bits 1: 0 - VCID
                            */
    UINT32 sbtag : 14;

                            /* Bits[30:17], Access Type=RO/V, default=0x00000000*/

                            /*
                               Tag of the SB entry specified by
                               SbArrSnapshotCtl.SbIndex
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SBARRSNAPSHOTDATA0_MC_2LM_STRUCT;

/* SBARRSNAPSHOTDATA1_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x20020178)                                                      */
/*      SPRB0 (0x20020178)                                                      */
/*      SPRHBM (0x20020178)                                                     */
/*      SPRC0 (0x20020178)                                                      */
/*      SPRMCC (0x20020178)                                                     */
/*      SPRUCC (0x20020178)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Contents of the 2LM scoreboard.
*/


#define SBARRSNAPSHOTDATA1_MC_2LM_REG 0x07120178

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sbindex : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Index of the SB entry specified by
                               SbArrSnapshotCtl.SbIndex
                            */

  } Bits;
  UINT32 Data;

} SBARRSNAPSHOTDATA1_MC_2LM_STRUCT;

/* MCSTRUCTCMICREDITCFG_N0_MC_2LM_REG supported on:                             */
/*      SPRA0 (0x20020180)                                                      */
/*      SPRB0 (0x20020180)                                                      */
/*      SPRHBM (0x20020180)                                                     */
/*      SPRC0 (0x20020180)                                                      */
/*      SPRMCC (0x20020180)                                                     */
/*      SPRUCC (0x20020180)                                                     */
/* Register default value on SPRA0: 0x6AD24A52                                  */
/* Register default value on SPRB0: 0x6AD24A52                                  */
/* Register default value on SPRHBM: 0x6AD24A52                                 */
/* Register default value on SPRC0: 0x6AD24A52                                  */
/* Register default value on SPRMCC: 0x6AD24A52                                 */
/* Register default value on SPRUCC: 0x6AD24A52                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Specifies the initial number of shared credits per crediting structure in mcchan
*/


#define MCSTRUCTCMICREDITCFG_N0_MC_2LM_REG 0x07120180

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rpq4_0_shared_cnt : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000012*/

                            /*
                               Initial number of rpq4_0 shared structure
                               credits
                            */
    UINT32 rpq4_1_shared_cnt : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000012*/

                            /*
                               Initial number of rpq4_1 shared structure
                               credits
                            */
    UINT32 wpq4_0_shared_cnt : 6;

                            /* Bits[15:10], Access Type=RW, default=0x00000012*/

                            /*
                               Initial number of wpq4_0 shared structure
                               credits
                            */
    UINT32 wpq4_1_shared_cnt : 6;

                            /* Bits[21:16], Access Type=RW, default=0x00000012*/

                            /*
                               Initial number of wpq4_1 shared structure
                               credits
                            */
    UINT32 rpqt_shared_cnt : 7;

                            /* Bits[28:22], Access Type=RW, default=0x0000002B*/

                            /* Initial number of rpqt shared structure credits */
    UINT32 wpqt_shared_cnt : 3;

                            /* Bits[31:29], Access Type=RW, default=0x00000003*/

                            /* Initial number of wpqt shared structure credits */

  } Bits;
  UINT32 Data;

} MCSTRUCTCMICREDITCFG_N0_MC_2LM_STRUCT;

/* MCSTRUCTCMICREDITCFG_N1_MC_2LM_REG supported on:                             */
/*      SPRA0 (0x20020184)                                                      */
/*      SPRB0 (0x20020184)                                                      */
/*      SPRHBM (0x20020184)                                                     */
/*      SPRC0 (0x20020184)                                                      */
/*      SPRMCC (0x20020184)                                                     */
/*      SPRUCC (0x20020184)                                                     */
/* Register default value on SPRA0: 0x04930579                                  */
/* Register default value on SPRB0: 0x04930579                                  */
/* Register default value on SPRHBM: 0x04930579                                 */
/* Register default value on SPRC0: 0x04930579                                  */
/* Register default value on SPRMCC: 0x04930579                                 */
/* Register default value on SPRUCC: 0x04930579                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Specifies the initial number of shared credits per crediting structure in mcchan
*/


#define MCSTRUCTCMICREDITCFG_N1_MC_2LM_REG 0x07120184

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wpqt_shared_cnt : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000001*/

                            /* Initial number of wpqt shared structure credits */
    UINT32 wdb_shared_cnt : 6;

                            /* Bits[8:3], Access Type=RW, default=0x0000002F*/

                            /* Initial number of wdb shared structure credits */
    UINT32 sb_shared_cnt : 8;

                            /* Bits[16:9], Access Type=RW, default=0x00000082*/

                            /* Initial number of sb shared structure credits */
    UINT32 early_rsp_fifo_0_shared_cnt : 3;

                            /* Bits[19:17], Access Type=RW, default=0x00000001*/

                            /* Initial number of shared structure credits */
    UINT32 early_rsp_fifo_1_shared_cnt : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000001*/

                            /* Initial number of shared structure credits */
    UINT32 early_rsp_fifo_2_shared_cnt : 3;

                            /* Bits[25:23], Access Type=RW, default=0x00000001*/

                            /* Initial number of shared structure credits */
    UINT32 early_rsp_fifo_3_shared_cnt : 3;

                            /* Bits[28:26], Access Type=RW, default=0x00000001*/

                            /* Initial number of shared structure credits */
    UINT32 rsvd : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCSTRUCTCMICREDITCFG_N1_MC_2LM_STRUCT;

/* MCCMIREQCPCFG_N0_MC_2LM_REG supported on:                                    */
/*      SPRA0 (0x20020188)                                                      */
/*      SPRB0 (0x20020188)                                                      */
/*      SPRHBM (0x20020188)                                                     */
/*      SPRC0 (0x20020188)                                                      */
/*      SPRMCC (0x20020188)                                                     */
/*      SPRUCC (0x20020188)                                                     */
/* Register default value on SPRA0: 0x44811448                                  */
/* Register default value on SPRB0: 0x44811448                                  */
/* Register default value on SPRHBM: 0x44811448                                 */
/* Register default value on SPRC0: 0x44811448                                  */
/* Register default value on SPRMCC: 0x44811448                                 */
/* Register default value on SPRUCC: 0x44811448                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* CMI credit configuration register.
*/


#define MCCMIREQCPCFG_N0_MC_2LM_REG 0x07120188

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rd_vc0_floor : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000008*/

                            /*
                               Initial number of floor credits for VC0 read
                               credit pool
                            */
    UINT32 rd_vc1_floor : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000002*/

                            /*
                               Initial number of floor credits for VC1 read
                               credit pool
                            */
    UINT32 rd_vc2_floor : 5;

                            /* Bits[14:10], Access Type=RW, default=0x00000005*/

                            /*
                               Initial number of floor credits for VC2 read
                               credit pool
                            */
    UINT32 rd_vc3_floor : 5;

                            /* Bits[19:15], Access Type=RW, default=0x00000002*/

                            /*
                               Initial number of floor credits for VC3 read
                               credit pool
                            */
    UINT32 wr_vc0_floor : 5;

                            /* Bits[24:20], Access Type=RW, default=0x00000008*/

                            /*
                               Initial number of floor credits for VC0 write
                               credit pool
                            */
    UINT32 wr_vc1_floor : 5;

                            /* Bits[29:25], Access Type=RW, default=0x00000002*/

                            /*
                               Initial number of floor credits for VC1 write
                               credit pool
                            */
    UINT32 wr_vc2_floor : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000001*/

                            /*
                               Initial number of floor credits for VC2 write
                               credit pool
                            */

  } Bits;
  UINT32 Data;

} MCCMIREQCPCFG_N0_MC_2LM_STRUCT;

/* MCCMIREQCPCFG_N1_MC_2LM_REG supported on:                                    */
/*      SPRA0 (0x2002018c)                                                      */
/*      SPRB0 (0x2002018c)                                                      */
/*      SPRHBM (0x2002018c)                                                     */
/*      SPRC0 (0x2002018c)                                                      */
/*      SPRMCC (0x2002018c)                                                     */
/*      SPRUCC (0x2002018c)                                                     */
/* Register default value on SPRA0: 0x00000411                                  */
/* Register default value on SPRB0: 0x00000411                                  */
/* Register default value on SPRHBM: 0x00000411                                 */
/* Register default value on SPRC0: 0x00000411                                  */
/* Register default value on SPRMCC: 0x00000411                                 */
/* Register default value on SPRUCC: 0x00000411                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* CMI credit configuration register.
*/


#define MCCMIREQCPCFG_N1_MC_2LM_REG 0x0712018C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wr_vc2_floor : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000001*/

                            /*
                               Initial number of floor credits for VC2 write
                               credit pool
                            */
    UINT32 wr_vc3_floor : 5;

                            /* Bits[7:3], Access Type=RW, default=0x00000002*/

                            /*
                               Initial number of floor credits for VC3 write
                               credit pool
                            */
    UINT32 req_fab_credits : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000004*/

                            /* Number of request fabric credits to advertise */
    UINT32 req_credit_cfg_done : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Valid bit to hardware that bios has programmed
                               the desired credit count values
                            */
    UINT32 req_credits_initialized : 1;

                            /* Bits[14:14], Access Type=RW/V, default=0x00000000*/

                            /*
                               Hardware writable bit that indicates when
                               hardware has completed request credit exchange
                               over CMI link
                            */
    UINT32 cpgc_req_credits_initialized : 1;

                            /* Bits[15:15], Access Type=RW/V, default=0x00000000*/

                            /*
                               Hardware writable bit that indicates when cpgc
                               hardware has completed request credit exchange
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCCMIREQCPCFG_N1_MC_2LM_STRUCT;

/* MC_2LMCNTL_ECC_RETRY2_CFG_MC_2LM_REG supported on:                           */
/*      SPRA0 (0x20020190)                                                      */
/*      SPRB0 (0x20020190)                                                      */
/*      SPRHBM (0x20020190)                                                     */
/*      SPRC0 (0x20020190)                                                      */
/*      SPRMCC (0x20020190)                                                     */
/*      SPRUCC (0x20020190)                                                     */
/* Register default value on SPRA0: 0x00000108                                  */
/* Register default value on SPRB0: 0x00000108                                  */
/* Register default value on SPRHBM: 0x00000108                                 */
/* Register default value on SPRC0: 0x00000108                                  */
/* Register default value on SPRMCC: 0x00000108                                 */
/* Register default value on SPRUCC: 0x00000108                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 2lm control ecc retry configuration register.
*/


#define MC_2LMCNTL_ECC_RETRY2_CFG_MC_2LM_REG 0x07120190

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mc_ecc_retry_pre_link_fail_wait : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000008*/

                            /* Wait time before entering link fail */
    UINT32 mc_ecc_retry_wait_in_pending_after_link_fail : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Wait in retry PENDING state for 1 more cycle
                               after link fail
                            */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MC_2LMCNTL_ECC_RETRY2_CFG_MC_2LM_STRUCT;

/* MC_TME_CFG_MC_2LM_REG supported on:                                          */
/*      SPRA0 (0x20020194)                                                      */
/*      SPRB0 (0x20020194)                                                      */
/*      SPRHBM (0x20020194)                                                     */
/*      SPRC0 (0x20020194)                                                      */
/*      SPRMCC (0x20020194)                                                     */
/*      SPRUCC (0x20020194)                                                     */
/* Register default value on SPRA0: 0x00000021                                  */
/* Register default value on SPRB0: 0x00000021                                  */
/* Register default value on SPRHBM: 0x00000021                                 */
/* Register default value on SPRC0: 0x00000021                                  */
/* Register default value on SPRMCC: 0x00000021                                 */
/* Register default value on SPRUCC: 0x00000021                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Specifies the initial number of shared TME credits per crediting structure in mcchan
*/


#define MC_TME_CFG_MC_2LM_REG 0x07120194

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ptl_wpq_shared_cnt : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000001*/

                            /*
                               Initial number of ptl wpq shared structure
                               credits
                            */
    UINT32 twk_buffer_shared_cnt : 8;

                            /* Bits[12:5], Access Type=RW, default=0x00000001*/

                            /*
                               Initial number of TME tweak buffer shared
                               structure credits
                            */
    UINT32 rsvd : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MC_TME_CFG_MC_2LM_STRUCT;

/* MC_TME_PRMRR_CFG_MC_2LM_REG supported on:                                    */
/*      SPRA0 (0x20020198)                                                      */
/*      SPRB0 (0x20020198)                                                      */
/*      SPRHBM (0x20020198)                                                     */
/*      SPRC0 (0x20020198)                                                      */
/*      SPRMCC (0x20020198)                                                     */
/*      SPRUCC (0x20020198)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Configures prmrr region when TME is active
*/


#define MC_TME_PRMRR_CFG_MC_2LM_REG 0x07120198

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 prmrr_secured : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* PRMRR secured bit */
    UINT32 rsvd : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MC_TME_PRMRR_CFG_MC_2LM_STRUCT;

/* SBMCACTL_MC_2LM_REG supported on:                                            */
/*      SPRA0 (0x200201a0)                                                      */
/*      SPRB0 (0x200201a0)                                                      */
/*      SPRHBM (0x200201a0)                                                     */
/*      SPRC0 (0x200201a0)                                                      */
/*      SPRMCC (0x200201a0)                                                     */
/*      SPRUCC (0x200201a0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Enables for the SB and CMI error logging
*/


#define SBMCACTL_MC_2LM_REG 0x071201A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reqerrdis : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of bad request
                               errors
                            */
    UINT32 readrspmisserrdis : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of read data
                               response miss errors
                            */
    UINT32 ddr4cmperrdis : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of DDR4 completion
                               errors
                            */
    UINT32 ddrtcmperrdis : 1;

                            /* Bits[3:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of DDRt completion
                               errors
                            */
    UINT32 readrspopcodeerrdis : 1;

                            /* Bits[4:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of read data
                               response opcode errors
                            */
    UINT32 cmplfifooferrdis : 1;

                            /* Bits[5:5], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of completion FIFO
                               overflows
                            */
    UINT32 cmplfifouferrdis : 1;

                            /* Bits[6:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of completion FIFO
                               underflows
                            */
    UINT32 nmfillwrcamerrdis : 1;

                            /* Bits[7:7], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of NmFillWr CAM
                               errors
                            */
    UINT32 cmicredtotalerrdis : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of CMI total
                               credit count errors
                            */
    UINT32 cmicredoversuberrdis : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of CMI credit
                               oversubscription
                            */
    UINT32 cmichnlrsvdpoolerrdis : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of CMI reserved
                               credit pool errors
                            */
    UINT32 cmichnlreqfifooverflowerrdis : 1;

                            /* Bits[11:11], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of CMI request
                               fifo overflow errors
                            */
    UINT32 cmichnlreqfifounderflowerrdis : 1;

                            /* Bits[12:12], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of CMI request
                               fifo underflow errors
                            */
    UINT32 cmichnlrspfifooverflowerrdis : 1;

                            /* Bits[13:13], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of CMI response
                               fifo overflow errors
                            */
    UINT32 cmichnlrspfifounderflowerrdis : 1;

                            /* Bits[14:14], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of CMI response
                               fifo underflow errors
                            */
    UINT32 rdrtnfifoerrdis : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of read return
                               FIFO overflows and underflows
                            */
    UINT32 ddr4wrcmpfifoerrdis : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of DDR4 write
                               completion FIFO overflows and underflows
                            */
    UINT32 rdrtnsrcidfifoerrdis : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of read return
                               SrcId FIFO overflows and underflows
                            */
    UINT32 earlycmplfifoerrdis : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of early
                               completion return FIFO overflows and underflows
                            */
    UINT32 earlydrtnfifoerrdis : 1;

                            /* Bits[19:19], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of early read
                               return FIFO overflows and underflows
                            */
    UINT32 ddrtwrcmpfifoerrdis : 1;

                            /* Bits[20:20], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of DDRT write
                               completion FIFO overflows and underflows
                            */
    UINT32 cmimiscmccrdterrdis : 1;

                            /* Bits[21:21], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable miscellanous CMI mc_crdt errors; these
                               include overflow and underflow for
                               rsp_fabric_crdt and rsp_vc_crdt. IF set to 1,
                               all error in this category will be ignored; so
                               set it to 1 if this module fires false error
                               conditions due to a bug
                            */
    UINT32 cmimiscmcarberrdis : 1;

                            /* Bits[22:22], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable miscellanous CMI mc_arb errors;these
                               include internal errors for non_sgx_refund_arb/r
                               efund_arb/sgx_refund_arb/early_rsp_bca/late_ddrt
                               _rsp_bca/late_rsp_bca/late_message_arbiter and r
                               d_cpl_credit_acc/rsp_credit_acc/wr_credit_acc/rd
                               _credit_acc. IF set to 1, all error in this
                               category will be ignored; so set it to 1 if this
                               module fires false error conditions due to a bug
                            */
    UINT32 wrcmpddrtfifounderflowerrdis : 1;

                            /* Bits[23:23], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of DDRT write
                               completion fifo underflow errors
                            */
    UINT32 wrcmpddrtfifooverflowerrdis : 1;

                            /* Bits[24:24], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable logging and reporting of DDRT write
                               completion fifo overflow errors
                            */
    UINT32 draerrdis : 1;

                            /* Bits[25:25], Access Type=RW/P, default=0x00000000*/

                            /* Disable logging and reporting of DRA errors */
    UINT32 rsvd : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SBMCACTL_MC_2LM_STRUCT;

/* PCIE_ERROR_MSG_MC_2LM_REG supported on:                                      */
/*      SPRA0 (0x200201a4)                                                      */
/*      SPRB0 (0x200201a4)                                                      */
/*      SPRHBM (0x200201a4)                                                     */
/*      SPRC0 (0x200201a4)                                                      */
/*      SPRMCC (0x200201a4)                                                     */
/*      SPRUCC (0x200201a4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* PCIe_ERR IOSF Sideband messages contain BDF, BitMap, and Severity Code. Only HW will generate the Severity Code. BIOS can set the BDF and BitMap through this register.
*/


#define PCIE_ERROR_MSG_MC_2LM_REG 0x071201A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 function : 3;

                            /* Bits[2:0], Access Type=RW/P, default=0x00000000*/

                            /* Function */
    UINT32 device : 5;

                            /* Bits[7:3], Access Type=RW/P, default=0x00000000*/

                            /* Device */
    UINT32 busnumber : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000000*/

                            /* Bus Number */
    UINT32 bitmap : 5;

                            /* Bits[20:16], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Bitmap; When BitmapOverride is set, use Bitmap
                               from this field instead of from fuse/straps.
                            */
    UINT32 bitmapoverride : 1;

                            /* Bits[21:21], Access Type=RW/P, default=0x00000000*/

                            /*
                               When BitmapOverride is set, use Bitmap from
                               Bitmap field instead of from fuse/straps. The
                               override field should be set to 1 before
                               changing the value of the CSR field to allow it
                               to be effective.
                            */
    UINT32 rsvd : 10;

                            /* Bits[31:22], Access Type=RO, default=0x00000000*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PCIE_ERROR_MSG_MC_2LM_STRUCT;








/* MCCMISTRUCTRDCREDITCFG_N0_MC_2LM_REG supported on:                           */
/*      SPRA0 (0x200201d8)                                                      */
/*      SPRB0 (0x200201d8)                                                      */
/*      SPRHBM (0x200201d8)                                                     */
/*      SPRC0 (0x200201d8)                                                      */
/*      SPRMCC (0x200201d8)                                                     */
/*      SPRUCC (0x200201d8)                                                     */
/* Register default value on SPRA0: 0x40A86343                                  */
/* Register default value on SPRB0: 0x40A86343                                  */
/* Register default value on SPRHBM: 0x40A86343                                 */
/* Register default value on SPRC0: 0x40A86343                                  */
/* Register default value on SPRMCC: 0x40A86343                                 */
/* Register default value on SPRUCC: 0x40A86343                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register holds the mapping which shows which structures participate in the construction for each read request VC credit.  The SPR structure vector starting from MSB is {early_rsp[3:0], tme tweak buffer, tme wpq, scoreboard, wpqt, rpt, wpq[1:0], rpq[1:0]}.  For ATS it is {scoreboard, wpq, rpq}.
*/


#define MCCMISTRUCTRDCREDITCFG_N0_MC_2LM_REG 0x071201D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vc0_struct_credit_map : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000343*/

                            /* VC structure credit map */
    UINT32 vc1_struct_credit_map : 13;

                            /* Bits[25:13], Access Type=RW, default=0x00000543*/

                            /* VC structure credit map */
    UINT32 vc2_struct_credit_map : 6;

                            /* Bits[31:26], Access Type=RW, default=0x00000010*/

                            /* VC structure credit map */

  } Bits;
  UINT32 Data;

} MCCMISTRUCTRDCREDITCFG_N0_MC_2LM_STRUCT;

/* MCCMISTRUCTRDCREDITCFG_N1_MC_2LM_REG supported on:                           */
/*      SPRA0 (0x200201dc)                                                      */
/*      SPRB0 (0x200201dc)                                                      */
/*      SPRHBM (0x200201dc)                                                     */
/*      SPRC0 (0x200201dc)                                                      */
/*      SPRMCC (0x200201dc)                                                     */
/*      SPRUCC (0x200201dc)                                                     */
/* Register default value on SPRA0: 0x0008A1A5                                  */
/* Register default value on SPRB0: 0x0008A1A5                                  */
/* Register default value on SPRHBM: 0x0008A1A5                                 */
/* Register default value on SPRC0: 0x0008A1A5                                  */
/* Register default value on SPRMCC: 0x0008A1A5                                 */
/* Register default value on SPRUCC: 0x0008A1A5                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register holds the mapping which shows which structures participate in the construction for each read request VC credit.  The SPR structure vector starting from MSB is {early_rsp[3:0], tme tweak buffer, tme wpq, scoreboard, wpqt, rpt, wpq[1:0], rpq[1:0]}.  For ATS it is {scoreboard, wpq, rpq}.
*/


#define MCCMISTRUCTRDCREDITCFG_N1_MC_2LM_REG 0x071201DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vc2_struct_credit_map : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000025*/

                            /* VC structure credit map */
    UINT32 vc3_struct_credit_map : 13;

                            /* Bits[19:7], Access Type=RW, default=0x00001143*/

                            /* VC structure credit map */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCCMISTRUCTRDCREDITCFG_N1_MC_2LM_STRUCT;

/* MCCMISTRUCTWRCREDITCFG_N0_MC_2LM_REG supported on:                           */
/*      SPRA0 (0x200201e0)                                                      */
/*      SPRB0 (0x200201e0)                                                      */
/*      SPRHBM (0x200201e0)                                                     */
/*      SPRC0 (0x200201e0)                                                      */
/*      SPRMCC (0x200201e0)                                                     */
/*      SPRUCC (0x200201e0)                                                     */
/* Register default value on SPRA0: 0x809182CC                                  */
/* Register default value on SPRB0: 0x809182CC                                  */
/* Register default value on SPRHBM: 0x809182CC                                 */
/* Register default value on SPRC0: 0x809182CC                                  */
/* Register default value on SPRMCC: 0x809182CC                                 */
/* Register default value on SPRUCC: 0x809182CC                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register holds the mapping which shows which structures participate in the construction for each write request VC credit.  Structure vector starting from MSB is {early_rsp[3:0], tme tweak buffer, tme wpq, scoreboard, wpqt, rpt, wpq[1:0], rpq[1:0]}.  For ATS it is {scoreboard, wpq, rpq}.
*/


#define MCCMISTRUCTWRCREDITCFG_N0_MC_2LM_REG 0x071201E0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vc0_struct_credit_map : 13;

                            /* Bits[12:0], Access Type=RW, default=0x000002CC*/

                            /* VC structure credit map */
    UINT32 vc1_struct_credit_map : 13;

                            /* Bits[25:13], Access Type=RW, default=0x0000048C*/

                            /* VC structure credit map */
    UINT32 vc2_struct_credit_map : 6;

                            /* Bits[31:26], Access Type=RW, default=0x00000020*/

                            /* VC structure credit map */

  } Bits;
  UINT32 Data;

} MCCMISTRUCTWRCREDITCFG_N0_MC_2LM_STRUCT;

/* MCCMISTRUCTWRCREDITCFG_N1_MC_2LM_REG supported on:                           */
/*      SPRA0 (0x200201e4)                                                      */
/*      SPRB0 (0x200201e4)                                                      */
/*      SPRHBM (0x200201e4)                                                     */
/*      SPRC0 (0x200201e4)                                                      */
/*      SPRMCC (0x200201e4)                                                     */
/*      SPRUCC (0x200201e4)                                                     */
/* Register default value on SPRA0: 0x00084623                                  */
/* Register default value on SPRB0: 0x00084623                                  */
/* Register default value on SPRHBM: 0x00084623                                 */
/* Register default value on SPRC0: 0x00084623                                  */
/* Register default value on SPRMCC: 0x00084623                                 */
/* Register default value on SPRUCC: 0x00084623                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmcntl_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register holds the mapping which shows which structures participate in the construction for each write request VC credit.  Structure vector starting from MSB is {early_rsp[3:0], tme tweak buffer, tme wpq, scoreboard, wpqt, rpt, wpq[1:0], rpq[1:0]}.  For ATS it is {scoreboard, wpq, rpq}.
*/


#define MCCMISTRUCTWRCREDITCFG_N1_MC_2LM_REG 0x071201E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 vc2_struct_credit_map : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000023*/

                            /* VC structure credit map */
    UINT32 vc3_struct_credit_map : 13;

                            /* Bits[19:7], Access Type=RW, default=0x0000108C*/

                            /* VC structure credit map */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCCMISTRUCTWRCREDITCFG_N1_MC_2LM_STRUCT;

/* RSP_FUNC_ADDR_MATCH_LO_DDRT_MC_2LM_REG supported on:                         */
/*      SPRA0 (0x20021400)                                                      */
/*      SPRB0 (0x20021400)                                                      */
/*      SPRHBM (0x20021400)                                                     */
/*      SPRC0 (0x20021400)                                                      */
/*      SPRMCC (0x20021400)                                                     */
/*      SPRUCC (0x20021400)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Complete address match (Addr[45:3]) and mask is supported for all M2M writes. The error injection logic uses the address match mask logic output to determine which memory writes need to get error injection. Users can program up to two x4 device masks (8-bits per chunk - 64 bits per cacheline). In Lockstep mode, only one device can be programmed in each lockstep channel.
*/


#define RSP_FUNC_ADDR_MATCH_LO_DDRT_MC_2LM_REG 0x07121400

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_match_lower : 32;

                            /* Bits[31:0], Access Type=RW/P, default=0x00000000*/

                            /* Addr Match Lower: 32-bits (Match Addr[34:3]) */

  } Bits;
  UINT32 Data;

} RSP_FUNC_ADDR_MATCH_LO_DDRT_MC_2LM_STRUCT;

/* RSP_FUNC_ADDR_MATCH_HI_DDRT_MC_2LM_REG supported on:                         */
/*      SPRA0 (0x20021408)                                                      */
/*      SPRB0 (0x20021408)                                                      */
/*      SPRHBM (0x20021408)                                                     */
/*      SPRC0 (0x20021408)                                                      */
/*      SPRMCC (0x20021408)                                                     */
/*      SPRUCC (0x20021408)                                                     */
/* Register default value on SPRA0: 0x00080000                                  */
/* Register default value on SPRB0: 0x00080000                                  */
/* Register default value on SPRHBM: 0x00080000                                 */
/* Register default value on SPRC0: 0x00080000                                  */
/* Register default value on SPRMCC: 0x00080000                                 */
/* Register default value on SPRUCC: 0x00080000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Complete address match (Addr[45:3]) and mask is supported for all M2M writes. The error injection logic uses the address match mask logic output to determine which memory writes need to get error injection. Users can program up to two x4 device masks (8-bits per chunk - 64 bits per cacheline). In Lockstep mode, only one device can be programmed in each lockstep channel.
*/


#define RSP_FUNC_ADDR_MATCH_HI_DDRT_MC_2LM_REG 0x07121408

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_match_higher : 17;

                            /* Bits[16:0], Access Type=RW/P, default=0x00000000*/

                            /* Addr Match Higher : 17-Bits (Match Addr[51:35]) */
    UINT32 rsp_func_addr_match_en : 1;

                            /* Bits[17:17], Access Type=RW/V/P/L, default=0x00000000*/

                            /*
                               Enabling the Address Match Response Function
                               when set.
                            */
    UINT32 rsp_func_addr_match_always : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /*
                               The enable bit RSP_FUNC_ADDR_MATCH_EN will not
                               be self cleared after match if this field is
                               set. Continuous address matching.
                            */
    UINT32 clear_addmatch_on_retry : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               Clear the AddMatch bit in DDRT WPQ on DDRT Retry
                               flow.
                            */
    UINT32 rsvd : 5;

                            /* Bits[24:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mirror_match : 3;

                            /* Bits[27:25], Access Type=RW/P, default=0x00000000*/

                            /*
                               Additional match configuration: Bit 0 matches
                               with Mirror field; Bit 1 matches with mirr_pri
                               (primary channel); Bit 2 matches with demand
                               scrub request
                            */
    UINT32 rsvd_28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RSP_FUNC_ADDR_MATCH_HI_DDRT_MC_2LM_STRUCT;

/* RSP_FUNC_ADDR_MASK_LO_DDRT_MC_2LM_REG supported on:                          */
/*      SPRA0 (0x2002140c)                                                      */
/*      SPRB0 (0x2002140c)                                                      */
/*      SPRHBM (0x2002140c)                                                     */
/*      SPRC0 (0x2002140c)                                                      */
/*      SPRMCC (0x2002140c)                                                     */
/*      SPRUCC (0x2002140c)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Complete address match (Addr[45:3]) and mask is supported for all M2M writes. Error injection does not use the response logic triggers and uses the match mask logic output to determine which writes need to get error injection. Users can program up to two x4 device masks (8-bits per chunk - 64 bits per cacheline). In Lockstep mode, only one device can be programmed in each lockstep channel.
*/


#define RSP_FUNC_ADDR_MASK_LO_DDRT_MC_2LM_REG 0x0712140C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_mask_lower : 32;

                            /* Bits[31:0], Access Type=RW/P, default=0xFFFFFFFF*/

                            /*
                               Address Mask to deselect (when set) the
                               corresponding Addr[34:3] for the address match.
                            */

  } Bits;
  UINT32 Data;

} RSP_FUNC_ADDR_MASK_LO_DDRT_MC_2LM_STRUCT;

/* RSP_FUNC_ADDR_MASK_HI_DDRT_MC_2LM_REG supported on:                          */
/*      SPRA0 (0x20021410)                                                      */
/*      SPRB0 (0x20021410)                                                      */
/*      SPRHBM (0x20021410)                                                     */
/*      SPRC0 (0x20021410)                                                      */
/*      SPRMCC (0x20021410)                                                     */
/*      SPRUCC (0x20021410)                                                     */
/* Register default value on SPRA0: 0x0E01FFFF                                  */
/* Register default value on SPRB0: 0x0E01FFFF                                  */
/* Register default value on SPRHBM: 0x0E01FFFF                                 */
/* Register default value on SPRC0: 0x0E01FFFF                                  */
/* Register default value on SPRMCC: 0x0E01FFFF                                 */
/* Register default value on SPRUCC: 0x0E01FFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Complete address match (Addr[45:3]) and mask is supported for all M2M writes. Error injection does not use the response logic triggers and uses the match mask logic output to determine which writes need to get error injection. Users can program up to two x4 device masks (8-bits per chunk - 64 bits per cacheline). In Lockstep mode, only one device can be programmed in each lockstep channel.
*/


#define RSP_FUNC_ADDR_MASK_HI_DDRT_MC_2LM_REG 0x07121410

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_mask_higher : 17;

                            /* Bits[16:0], Access Type=RW/P, default=0x0001FFFF*/

                            /*
                               Address Mask to deselect (when set) the
                               corresponding Addr[51:35] for the address match.
                            */
    UINT32 rsvd : 8;

                            /* Bits[24:17], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mirror_mask : 3;

                            /* Bits[27:25], Access Type=RW/P, default=0x00000007*/

                            /*
                               Additional mask to deselect (when set) the
                               corresponding bits in mirror_mask field. Bit 0
                               is mask for Mirror field; Bit 1 is mask for
                               mirr_pri (primary channel); Bit 2 is mask for
                               demand scrub request
                            */
    UINT32 rsvd_28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RSP_FUNC_ADDR_MASK_HI_DDRT_MC_2LM_STRUCT;

/* DDRT_MAJOR_MODE_THRESHOLD1_MC_2LM_REG supported on:                          */
/*      SPRA0 (0x20021420)                                                      */
/*      SPRB0 (0x20021420)                                                      */
/*      SPRHBM (0x20021420)                                                     */
/*      SPRC0 (0x20021420)                                                      */
/*      SPRMCC (0x20021420)                                                     */
/*      SPRUCC (0x20021420)                                                     */
/* Register default value on SPRA0: 0x321E060C                                  */
/* Register default value on SPRB0: 0x321E060C                                  */
/* Register default value on SPRHBM: 0x321E060C                                 */
/* Register default value on SPRC0: 0x321E060C                                  */
/* Register default value on SPRMCC: 0x321E060C                                 */
/* Register default value on SPRUCC: 0x321E060C                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* configures the DDRT Write Major Mode behavior - Thresholds and starvation counters.
*/


#define DDRT_MAJOR_MODE_THRESHOLD1_MC_2LM_REG 0x07121420

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wmm_enter : 8;

                            /* Bits[7:0], Access Type=RW, default=0x0000000C*/

                            /*
                               When channel is in DDRT RMM and the number of
                               WDB entries gets to this level, channel goes
                               into DDRT WMM. The value must be at least 2.
                            */
    UINT32 wmm_exit : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000006*/

                            /*
                               When channel is in DDRT WMM and the number of
                               WDB entries gets to this level, channel goes
                               back to DDRT RMM. The value must be between 1
                               and (WMM_Enter - 1).
                            */
    UINT32 min_rmm_cycles : 8;

                            /* Bits[23:16], Access Type=RW, default=0x0000001E*/

                            /*
                               This count is used for the starvation switch.
                               Channel will stay in DDRT RMM for at least
                               MIN_RMM_CYCLES number of cycles. Exception: DDRT
                               ADR will force channel into DDRT WMM.
                            */
    UINT32 min_wmm_cycles : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000032*/

                            /*
                               This count is used for the starvation switch.
                               Channel will stay in DDRT WMM for at most
                               MAX_WMM_CYCLES number of cycles. Exception: DDRT
                               ADR will force channel into DDRT WMM.
                            */

  } Bits;
  UINT32 Data;

} DDRT_MAJOR_MODE_THRESHOLD1_MC_2LM_STRUCT;

/* DDRT_MAJOR_MODE_THRESHOLD2_MC_2LM_REG supported on:                          */
/*      SPRA0 (0x20021424)                                                      */
/*      SPRB0 (0x20021424)                                                      */
/*      SPRHBM (0x20021424)                                                     */
/*      SPRC0 (0x20021424)                                                      */
/*      SPRMCC (0x20021424)                                                     */
/*      SPRUCC (0x20021424)                                                     */
/* Register default value on SPRA0: 0x05100540                                  */
/* Register default value on SPRB0: 0x05100540                                  */
/* Register default value on SPRHBM: 0x05100540                                 */
/* Register default value on SPRC0: 0x05100540                                  */
/* Register default value on SPRMCC: 0x05100540                                 */
/* Register default value on SPRUCC: 0x05100540                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* DDRT RW Major Mode Thresholds
*/


#define DDRT_MAJOR_MODE_THRESHOLD2_MC_2LM_REG 0x07121424

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pwmm_starv_cntr_prescaler : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000040*/

                            /*
                               DDR-T Partial Write Starvation Counter Pre-
                               Scaler When the counter increment to the
                               STARV_CNTR_PRESCALER value, the
                               STARV_CNTR_PRESCALER counter will be roll over
                               back to zero and start counting. There is a 3b
                               partial write starvation counter for each
                               partial write in the write queue. At the roll
                               over, all 3b partial write starvation counters
                               will be incremented by 1. The 3b pwr starvation
                               counter will saturated at its max value to
                               indicate the partial write starvation condition.
                               The 3b counter will be cleared when the partial
                               write is served.
                            */
    UINT32 gnt_exit : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000005*/

                            /* Reserved - unused. */
    UINT32 pwr_enter : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000010*/

                            /* Reserved - unused. */
    UINT32 pwr_exit : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000005*/

                            /* Reserved - unused. */

  } Bits;
  UINT32 Data;

} DDRT_MAJOR_MODE_THRESHOLD2_MC_2LM_STRUCT;

/* DDRT_ECC_MODE_MC_2LM_REG supported on:                                       */
/*      SPRA0 (0x20021428)                                                      */
/*      SPRB0 (0x20021428)                                                      */
/*      SPRHBM (0x20021428)                                                     */
/*      SPRC0 (0x20021428)                                                      */
/*      SPRMCC (0x20021428)                                                     */
/*      SPRUCC (0x20021428)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* ECC mode encoding for DDRT write commands
*/


#define DDRT_ECC_MODE_MC_2LM_REG 0x07121428

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 em : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               ECC mode bits to issue to FNV as part of the
                               write command. It is the responsibility of
                               software to program these bits correctly. Note
                               that an encoding of 11111 is the default Flow A
                               ECC mode.
                            */
    UINT32 rsvd : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_ECC_MODE_MC_2LM_STRUCT;

/* DDRT_INJ_ERID_ERR_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x20021430)                                                      */
/*      SPRB0 (0x20021430)                                                      */
/*      SPRHBM (0x20021430)                                                     */
/*      SPRC0 (0x20021430)                                                      */
/*      SPRMCC (0x20021430)                                                     */
/*      SPRUCC (0x20021430)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: ERR_INJ                                          */
/* SPRB0 Security PolicyGroup: ERR_INJ                                          */
/* SPRHBM Security PolicyGroup: ERR_INJ                                         */
/* SPRC0 Security PolicyGroup: ERR_INJ                                          */
/* SPRMCC Security PolicyGroup: ERR_INJ                                         */
/* SPRUCC Security PolicyGroup: ERR_INJ                                         */
/* CSR to program ERID error injection
*/


#define DDRT_INJ_ERID_ERR_MC_2LM_REG 0x07121430

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 inj_error : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Enable ERID Error injection Enables Continuous
                               injection. If continuous bit is not set then the
                               trigger will be set up for a single injection on
                               a 0 to 1 transition in the inj_error field. To
                               allow continuous injection, both inj_error and
                               continuous bits should be set.
                            */
    UINT32 injcontinuous : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Enables Continuous injection. If continuous bit
                               is not set then the trigger will be set up for a
                               single injection on a 0 to 1 transition in the
                               inj_error field. To allow continuous injection,
                               both inj_error and continuous bits should be
                               set.
                            */
    UINT32 done : 1;

                            /* Bits[2:2], Access Type=RW/V, default=0x00000000*/

                            /* This bit is set when the error is injected. */
    UINT32 mask : 10;

                            /* Bits[12:3], Access Type=RW, default=0x00000000*/

                            /* 8 bit mask to inject error on the ERID. */
    UINT32 match : 7;

                            /* Bits[19:13], Access Type=RW, default=0x00000000*/

                            /* 7 bit match to inject error on the ERID. */
    UINT32 enable_match : 7;

                            /* Bits[26:20], Access Type=RW, default=0x00000000*/

                            /*
                               7 bit vector to enable comparison on each the
                               bits in the match field.
                            */
    UINT32 inj_ddrt_addr_parity_err : 1;

                            /* Bits[27:27], Access Type=RW/V, default=0x00000000*/

                            /*
                               Set this bit to a 1 to inject a parity error.
                               The bit is cleared when the error is injected.
                               The error will be injected on the first
                               transaction either to the WPQ or RPQ. There is
                               no control to inject specifically to DDRT RPQ or
                               WPQ.
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_INJ_ERID_ERR_MC_2LM_STRUCT;


/* DDRT_SCRATCHPAD_MC_2LM_REG supported on:                                     */
/*      SPRA0 (0x20021444)                                                      */
/*      SPRB0 (0x20021444)                                                      */
/*      SPRHBM (0x20021444)                                                     */
/*      SPRC0 (0x20021444)                                                      */
/*      SPRMCC (0x20021444)                                                     */
/*      SPRUCC (0x20021444)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* dummy register
*/


#define DDRT_SCRATCHPAD_MC_2LM_REG 0x07121444

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 scratchpad : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /* scratchpad */

  } Bits;
  UINT32 Data;

} DDRT_SCRATCHPAD_MC_2LM_STRUCT;

/* DDRT_RETRY_FSM_STATE_MC_2LM_REG supported on:                                */
/*      SPRA0 (0x20021448)                                                      */
/*      SPRB0 (0x200214b0)                                                      */
/*      SPRHBM (0x200214b0)                                                     */
/*      SPRC0 (0x200214b0)                                                      */
/*      SPRMCC (0x200214b0)                                                     */
/*      SPRUCC (0x200214b0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/*  This register contains current and previous state of DDRT retry FSM.  
*/


#define DDRT_RETRY_FSM_STATE_MC_2LM_REG 0x071A0000

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 current_state : 5;

                            /* Bits[4:0], Access Type=RO/V, default=0x00000000*/

                            /* Current encoded state of DDRT retry FSM */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 previous_state : 5;

                            /* Bits[12:8], Access Type=RO/V, default=0x00000000*/

                            /* Previous encoded state of DDRT retry FSM */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_RETRY_FSM_STATE_MC_2LM_STRUCT;

/* FMRIRWAYNESSLIMIT_0_MC_2LM_REG supported on:                                 */
/*      SPRA0 (0x2002144c)                                                      */
/*      SPRB0 (0x2002144c)                                                      */
/*      SPRHBM (0x2002144c)                                                     */
/*      SPRC0 (0x2002144c)                                                      */
/*      SPRMCC (0x2002144c)                                                     */
/*      SPRUCC (0x2002144c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 4 Rank Interleave Ranges (RIR) for DDR-T 
*/


#define FMRIRWAYNESSLIMIT_0_MC_2LM_REG 0x0712144C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 1;

                            /* Bits[0:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_limit : 13;

                            /* Bits[13:1], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[4:0].LIMIT[41:29] == highest address of the
                               range in channel address space. Needs to address
                               up to 4TB at a 512MB granularity.
                            */
    UINT32 rsvd_14 : 14;

                            /* Bits[27:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_way : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               rank interleave wayness00 = 1 way, 01 = 2 way,
                               10 = 4 way, 11 = 8 way.
                            */
    UINT32 rsvd_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_val : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Range Valid when set; otherwise, invalid */

  } Bits;
  UINT32 Data;

} FMRIRWAYNESSLIMIT_0_MC_2LM_STRUCT;

/* FMRIRWAYNESSLIMIT_1_MC_2LM_REG supported on:                                 */
/*      SPRA0 (0x20021450)                                                      */
/*      SPRB0 (0x20021450)                                                      */
/*      SPRHBM (0x20021450)                                                     */
/*      SPRC0 (0x20021450)                                                      */
/*      SPRMCC (0x20021450)                                                     */
/*      SPRUCC (0x20021450)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 4 Rank Interleave Ranges (RIR) for DDR-T 
*/


#define FMRIRWAYNESSLIMIT_1_MC_2LM_REG 0x07121450

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 1;

                            /* Bits[0:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_limit : 13;

                            /* Bits[13:1], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[4:0].LIMIT[41:29] == highest address of the
                               range in channel address space. Needs to address
                               up to 4TB at a 512MB granularity.
                            */
    UINT32 rsvd_14 : 14;

                            /* Bits[27:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_way : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               rank interleave wayness00 = 1 way, 01 = 2 way,
                               10 = 4 way, 11 = 8 way.
                            */
    UINT32 rsvd_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_val : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Range Valid when set; otherwise, invalid */

  } Bits;
  UINT32 Data;

} FMRIRWAYNESSLIMIT_1_MC_2LM_STRUCT;

/* FMRIRWAYNESSLIMIT_2_MC_2LM_REG supported on:                                 */
/*      SPRA0 (0x20021454)                                                      */
/*      SPRB0 (0x20021454)                                                      */
/*      SPRHBM (0x20021454)                                                     */
/*      SPRC0 (0x20021454)                                                      */
/*      SPRMCC (0x20021454)                                                     */
/*      SPRUCC (0x20021454)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 4 Rank Interleave Ranges (RIR) for DDR-T 
*/


#define FMRIRWAYNESSLIMIT_2_MC_2LM_REG 0x07121454

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 1;

                            /* Bits[0:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_limit : 13;

                            /* Bits[13:1], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[4:0].LIMIT[41:29] == highest address of the
                               range in channel address space. Needs to address
                               up to 4TB at a 512MB granularity.
                            */
    UINT32 rsvd_14 : 14;

                            /* Bits[27:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_way : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               rank interleave wayness00 = 1 way, 01 = 2 way,
                               10 = 4 way, 11 = 8 way.
                            */
    UINT32 rsvd_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_val : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Range Valid when set; otherwise, invalid */

  } Bits;
  UINT32 Data;

} FMRIRWAYNESSLIMIT_2_MC_2LM_STRUCT;

/* FMRIRWAYNESSLIMIT_3_MC_2LM_REG supported on:                                 */
/*      SPRA0 (0x20021458)                                                      */
/*      SPRB0 (0x20021458)                                                      */
/*      SPRHBM (0x20021458)                                                     */
/*      SPRC0 (0x20021458)                                                      */
/*      SPRMCC (0x20021458)                                                     */
/*      SPRUCC (0x20021458)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 4 Rank Interleave Ranges (RIR) for DDR-T 
*/


#define FMRIRWAYNESSLIMIT_3_MC_2LM_REG 0x07121458

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 1;

                            /* Bits[0:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_limit : 13;

                            /* Bits[13:1], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[4:0].LIMIT[41:29] == highest address of the
                               range in channel address space. Needs to address
                               up to 4TB at a 512MB granularity.
                            */
    UINT32 rsvd_14 : 14;

                            /* Bits[27:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_way : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               rank interleave wayness00 = 1 way, 01 = 2 way,
                               10 = 4 way, 11 = 8 way.
                            */
    UINT32 rsvd_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_val : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Range Valid when set; otherwise, invalid */

  } Bits;
  UINT32 Data;

} FMRIRWAYNESSLIMIT_3_MC_2LM_STRUCT;

/* FMRIRILV0OFFSET_0_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x2002145c)                                                      */
/*      SPRB0 (0x2002145c)                                                      */
/*      SPRHBM (0x2002145c)                                                     */
/*      SPRC0 (0x2002145c)                                                      */
/*      SPRMCC (0x2002145c)                                                     */
/*      SPRUCC (0x2002145c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  DDR-T Rank Interleave ranges 
*/


#define FMRIRILV0OFFSET_0_MC_2LM_REG 0x0712145C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset0 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[].RANKOFFSET0[41:26] == rank interleave 0
                               offset
                            */
    UINT32 rir_rnk_tgt0 : 4;

                            /* Bits[21:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 0 (used for
                               1/2-way RIR interleaving).
                            */
    UINT32 rsvd_22 : 10;

                            /* Bits[31:22], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FMRIRILV0OFFSET_0_MC_2LM_STRUCT;

/* FMRIRILV1OFFSET_0_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x20021460)                                                      */
/*      SPRB0 (0x20021460)                                                      */
/*      SPRHBM (0x20021460)                                                     */
/*      SPRC0 (0x20021460)                                                      */
/*      SPRMCC (0x20021460)                                                     */
/*      SPRUCC (0x20021460)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  DDR-T Rank Interleave ranges 
*/


#define FMRIRILV1OFFSET_0_MC_2LM_REG 0x07121460

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset1 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[].RANKOFFSET1[41:26] == rank interleave 1
                               offset, 64MB granularity
                            */
    UINT32 rir_rnk_tgt1 : 4;

                            /* Bits[21:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 1 (used for
                               1/2-way RIR interleaving).
                            */
    UINT32 rsvd_22 : 10;

                            /* Bits[31:22], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FMRIRILV1OFFSET_0_MC_2LM_STRUCT;

/* FMRIRILV0OFFSET_1_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x20021464)                                                      */
/*      SPRB0 (0x20021464)                                                      */
/*      SPRHBM (0x20021464)                                                     */
/*      SPRC0 (0x20021464)                                                      */
/*      SPRMCC (0x20021464)                                                     */
/*      SPRUCC (0x20021464)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  DDR-T Rank Interleave ranges 
*/


#define FMRIRILV0OFFSET_1_MC_2LM_REG 0x07121464

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset0 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[].RANKOFFSET0[41:26] == rank interleave 0
                               offset, 64MB granularity
                            */
    UINT32 rir_rnk_tgt0 : 4;

                            /* Bits[21:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 0 (used for
                               1/2-way RIR interleaving).
                            */
    UINT32 rsvd_22 : 10;

                            /* Bits[31:22], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FMRIRILV0OFFSET_1_MC_2LM_STRUCT;

/* FMRIRILV1OFFSET_1_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x20021468)                                                      */
/*      SPRB0 (0x20021468)                                                      */
/*      SPRHBM (0x20021468)                                                     */
/*      SPRC0 (0x20021468)                                                      */
/*      SPRMCC (0x20021468)                                                     */
/*      SPRUCC (0x20021468)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  DDR-T Rank Interleave ranges 
*/


#define FMRIRILV1OFFSET_1_MC_2LM_REG 0x07121468

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset1 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[].RANKOFFSET1[41:26] == rank interleave 1
                               offset, 64MB granularity
                            */
    UINT32 rir_rnk_tgt1 : 4;

                            /* Bits[21:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 1 (used for
                               1/2-way RIR interleaving).
                            */
    UINT32 rsvd_22 : 10;

                            /* Bits[31:22], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FMRIRILV1OFFSET_1_MC_2LM_STRUCT;

/* FMRIRILV0OFFSET_2_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x2002146c)                                                      */
/*      SPRB0 (0x2002146c)                                                      */
/*      SPRHBM (0x2002146c)                                                     */
/*      SPRC0 (0x2002146c)                                                      */
/*      SPRMCC (0x2002146c)                                                     */
/*      SPRUCC (0x2002146c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  DDR-T Rank Interleave ranges 
*/


#define FMRIRILV0OFFSET_2_MC_2LM_REG 0x0712146C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset0 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[].RANKOFFSET0[41:26] == rank interleave 0
                               offset, 64MB granularity
                            */
    UINT32 rir_rnk_tgt0 : 4;

                            /* Bits[21:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 0 (used for
                               1/2-way RIR interleaving).
                            */
    UINT32 rsvd_22 : 10;

                            /* Bits[31:22], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FMRIRILV0OFFSET_2_MC_2LM_STRUCT;

/* FMRIRILV1OFFSET_2_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x20021470)                                                      */
/*      SPRB0 (0x20021470)                                                      */
/*      SPRHBM (0x20021470)                                                     */
/*      SPRC0 (0x20021470)                                                      */
/*      SPRMCC (0x20021470)                                                     */
/*      SPRUCC (0x20021470)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  DDR-T Rank Interleave ranges 
*/


#define FMRIRILV1OFFSET_2_MC_2LM_REG 0x07121470

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset1 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[].RANKOFFSET1[41:26] == rank interleave 1
                               offset, 64MB granularity
                            */
    UINT32 rir_rnk_tgt1 : 4;

                            /* Bits[21:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 1 (used for
                               1/2-way RIR interleaving).
                            */
    UINT32 rsvd_22 : 10;

                            /* Bits[31:22], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FMRIRILV1OFFSET_2_MC_2LM_STRUCT;

/* FMRIRILV0OFFSET_3_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x20021474)                                                      */
/*      SPRB0 (0x20021474)                                                      */
/*      SPRHBM (0x20021474)                                                     */
/*      SPRC0 (0x20021474)                                                      */
/*      SPRMCC (0x20021474)                                                     */
/*      SPRUCC (0x20021474)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  DDR-T Rank Interleave ranges 
*/


#define FMRIRILV0OFFSET_3_MC_2LM_REG 0x07121474

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset0 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[].RANKOFFSET0[41:26] == rank interleave 0
                               offset, 64MB granularity
                            */
    UINT32 rir_rnk_tgt0 : 4;

                            /* Bits[21:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 0 (used for
                               1/2-way RIR interleaving).
                            */
    UINT32 rsvd_22 : 10;

                            /* Bits[31:22], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FMRIRILV0OFFSET_3_MC_2LM_STRUCT;

/* FMRIRILV1OFFSET_3_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x20021478)                                                      */
/*      SPRB0 (0x20021478)                                                      */
/*      SPRHBM (0x20021478)                                                     */
/*      SPRC0 (0x20021478)                                                      */
/*      SPRMCC (0x20021478)                                                     */
/*      SPRUCC (0x20021478)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  DDR-T Rank Interleave ranges 
*/


#define FMRIRILV1OFFSET_3_MC_2LM_REG 0x07121478

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset1 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[].RANKOFFSET1[41:26] == rank interleave 1
                               offset, 64MB granularity
                            */
    UINT32 rir_rnk_tgt1 : 4;

                            /* Bits[21:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 1 (used for
                               1/2-way RIR interleaving).
                            */
    UINT32 rsvd_22 : 10;

                            /* Bits[31:22], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FMRIRILV1OFFSET_3_MC_2LM_STRUCT;

/* T_DDRT_RD_CNSTRNT_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x2002147c)                                                      */
/*      SPRB0 (0x2002147c)                                                      */
/*      SPRHBM (0x2002147c)                                                     */
/*      SPRC0 (0x2002147c)                                                      */
/*      SPRMCC (0x2002147c)                                                     */
/*      SPRUCC (0x2002147c)                                                     */
/* Register default value on SPRA0: 0x06000600                                  */
/* Register default value on SPRB0: 0x06000600                                  */
/* Register default value on SPRHBM: 0x06000600                                 */
/* Register default value on SPRC0: 0x06000600                                  */
/* Register default value on SPRMCC: 0x06000600                                 */
/* Register default value on SPRUCC: 0x06000600                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT Read Constraint Timing Register.
*/


#define T_DDRT_RD_CNSTRNT_MC_2LM_REG 0x0712147C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_ddrt_rdrd_s : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               Minimum READ to READ command DCLK separation
                               from same DIMM separation parameter (measured
                               between the clock assertion edges of the two
                               corresponding asserted command CS#). The min:max
                               program range is 2-31. Any value outside of the
                               range is RFU.
                            */
    UINT32 t_ddrt_rdrd_dd : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000006*/

                            /*
                               Minimum delay between GRANT on 1 subchannel to
                               READ on other subchannel. Only to be used as a
                               debug hook. Value should be set to 0 in
                               production system. Value should be programmed in
                               dclks. (measured between the clock assertion
                               edges of the two corresponding asserted command
                               CS#). The min:max program range is 0-63. Any
                               value outside of the range is RFU.
                            */
    UINT32 t_ddrt_wrrd_s : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /*
                               Minimum WRITE to READ command DCLK separation
                               from same DIMM separation parameter (measured
                               between the clock assertion edges of the two
                               corresponding asserted command CS#). The min:max
                               program range is 2-31. Any value outside of the
                               range is RFU.
                            */
    UINT32 t_ddrt_wrrd_dd : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000006*/

                            /*
                               Minimum WRITE to READ command DCLK separation
                               from different DIMM separation parameter
                               (measured between the clock assertion edges of
                               the two corresponding asserted command CS#). The
                               min:max program range is 5-31. Any value outside
                               of the range is RFU. This should be programmed
                               to the same value as t_ddrt_wrrd_s if the number
                               of 1 DDRT DIMMs on the channel is 1.
                            */

  } Bits;
  UINT32 Data;

} T_DDRT_RD_CNSTRNT_MC_2LM_STRUCT;

/* T_DDRT_WR_CNSTRNT_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x20021480)                                                      */
/*      SPRB0 (0x200214b4)                                                      */
/*      SPRHBM (0x200214b4)                                                     */
/*      SPRC0 (0x200214b4)                                                      */
/*      SPRMCC (0x200214b4)                                                     */
/*      SPRUCC (0x200214b4)                                                     */
/* Register default value on SPRA0: 0x06040606                                  */
/* Register default value on SPRB0: 0x06040606                                  */
/* Register default value on SPRHBM: 0x06040606                                 */
/* Register default value on SPRC0: 0x06040606                                  */
/* Register default value on SPRMCC: 0x06040606                                 */
/* Register default value on SPRUCC: 0x06040606                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* DDRT Write Constraint Timing Register.
*/


#define T_DDRT_WR_CNSTRNT_MC_2LM_REG 0x071A0001

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_ddrt_rdwr_s : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000006*/

                            /*
                               Minimum READ to WRITE command DCLK separation
                               from same DIMM separation parameter (measured
                               between the clock assertion edges of the two
                               corresponding asserted command CS#). The min:max
                               program range is 2-31. Any value outside of the
                               range is RFU.
                            */
    UINT32 t_ddrt_rdwr_dd : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000006*/

                            /*
                               Minimum delay between GRANT on 1 subchannel to
                               WRITE on other subchannel. Only to be used as a
                               post-silicon debug hook. Value should be set to
                               0 in production system. Value should be
                               programmed in dclks. (measured between the clock
                               assertion edges of the two corresponding
                               asserted command CS#). The min:max program range
                               is 0-63. Any value outside of the range is RFU.
                            */
    UINT32 t_ddrt_wrwr_s : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000004*/

                            /*
                               Minimum WRITE to WRITE command DCLK separation
                               from same DIMM separation parameter (measured
                               between the clock assertion edges of the two
                               corresponding asserted command CS#). The min:max
                               program range is 4-31. Any value outside of the
                               range is RFU.
                            */
    UINT32 t_ddrt_wrwr_dd : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000006*/

                            /*
                               Minimum WRITE to WRITE command DCLK separation
                               from different DIMM separation parameter
                               (measured between the clock assertion edges of
                               the two corresponding asserted command CS#). The
                               min:max program range is 5-31. Any value outside
                               of the range is RFU.
                            */

  } Bits;
  UINT32 Data;

} T_DDRT_WR_CNSTRNT_MC_2LM_STRUCT;

/* T_DDRT_GNT2RW_CNSTRNT_MC_2LM_REG supported on:                               */
/*      SPRA0 (0x20021484)                                                      */
/*      SPRB0 (0x20021484)                                                      */
/*      SPRHBM (0x20021484)                                                     */
/*      SPRC0 (0x20021484)                                                      */
/*      SPRMCC (0x20021484)                                                     */
/*      SPRUCC (0x20021484)                                                     */
/* Register default value on SPRA0: 0x06060600                                  */
/* Register default value on SPRB0: 0x06060600                                  */
/* Register default value on SPRHBM: 0x06060600                                 */
/* Register default value on SPRC0: 0x06060600                                  */
/* Register default value on SPRMCC: 0x06060600                                 */
/* Register default value on SPRUCC: 0x06060600                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT Grant to RW Timing Constraints
*/


#define T_DDRT_GNT2RW_CNSTRNT_MC_2LM_REG 0x07121484

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_ddrt_gntrd_s : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               Minimum GRANT to READ command DCLK separation
                               from same DIMM separation parameter (measured
                               between the clock assertion edges of the two
                               corresponding asserted command CS#). The min:max
                               program range for DDRT/DDRT2 is 0-31. Any value
                               outside of the range is RFU.
                            */
    UINT32 t_ddrt_gntrd_dd : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000006*/

                            /*
                               Minimum GRANT to READ command DCLK separation
                               from different DIMM separation parameter
                               (measured between the clock assertion edges of
                               the two corresponding asserted command CS#). The
                               min:max program range for DDRT/DDRT2 is 2-31.
                               This should be programmed to the same value as
                               t_ddrt_gntrd_s if the number of 1 DDRT DIMMs on
                               the channel is 1.
                            */
    UINT32 t_ddrt_gntwr_s : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000006*/

                            /*
                               Minimum GRANT to WRITE command DCLK separation
                               from same DIMM separation parameter (measured
                               between the clock assertion edges of the two
                               corresponding asserted command CS#). The min:max
                               program range for DDRT is 5-31. The min:max
                               program range for DDRT is 9-31. Any value
                               outside of the range is RFU.
                            */
    UINT32 t_ddrt_gntwr_dd : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000006*/

                            /*
                               Minimum GRANT to WRITE command DCLK separation
                               from different DIMM separation parameter
                               (measured between the clock assertion edges of
                               the two corresponding asserted command CS#). The
                               min:max program range for DDRT/DDRT2 is 5-31.
                               Any value outside of the range is RFU.
                            */

  } Bits;
  UINT32 Data;

} T_DDRT_GNT2RW_CNSTRNT_MC_2LM_STRUCT;

/* T_DDRT_RW2GNT_CNSTRNT_MC_2LM_REG supported on:                               */
/*      SPRA0 (0x20021488)                                                      */
/*      SPRB0 (0x20021488)                                                      */
/*      SPRHBM (0x20021488)                                                     */
/*      SPRC0 (0x20021488)                                                      */
/*      SPRMCC (0x20021488)                                                     */
/*      SPRUCC (0x20021488)                                                     */
/* Register default value on SPRA0: 0x00060600                                  */
/* Register default value on SPRB0: 0x00060600                                  */
/* Register default value on SPRHBM: 0x00060600                                 */
/* Register default value on SPRC0: 0x00060600                                  */
/* Register default value on SPRMCC: 0x00060600                                 */
/* Register default value on SPRUCC: 0x00060600                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT RW to Grant Timing Constraints
*/


#define T_DDRT_RW2GNT_CNSTRNT_MC_2LM_REG 0x07121488

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_ddrt_rdgnt_s : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               Minimum READ to GRANT command DCLK separation
                               from same DIMM separation parameter (measured
                               between the clock assertion edges of the two
                               corresponding asserted command CS#). The min:max
                               program range for DDRT/DDRT2 is 0-31. Any value
                               outside of the range is RFU.
                            */
    UINT32 t_ddrt_wrgnt_s : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000006*/

                            /*
                               Minimum WRITE to GRANT command DCLK separation
                               from same DIMM separation parameter (measured
                               between the clock assertion edges of the two
                               corresponding asserted command CS#). The min:max
                               program range for DDRT is 5-31. The min:max
                               program range for DDRT2 is 9-31. Any value
                               outside of the range is RFU.
                            */
    UINT32 t_ddrt_wrgnt_dd : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000006*/

                            /*
                               Minimum WRITE to GRANT command DCLK separation
                               from different DIMM separation parameter
                               (measured between the clock assertion edges of
                               the two corresponding asserted command CS#). The
                               min:max program range for DDRT/DDRT2 is 5-31.
                               Any value outside of the range is RFU.
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} T_DDRT_RW2GNT_CNSTRNT_MC_2LM_STRUCT;

/* T_DDRT_GNT2GNT_CNSTRNT_MC_2LM_REG supported on:                              */
/*      SPRA0 (0x2002148c)                                                      */
/*      SPRB0 (0x2002148c)                                                      */
/*      SPRHBM (0x2002148c)                                                     */
/*      SPRC0 (0x2002148c)                                                      */
/*      SPRMCC (0x2002148c)                                                     */
/*      SPRUCC (0x2002148c)                                                     */
/* Register default value on SPRA0: 0x84060602                                  */
/* Register default value on SPRB0: 0x84060602                                  */
/* Register default value on SPRHBM: 0x84060602                                 */
/* Register default value on SPRC0: 0x84060602                                  */
/* Register default value on SPRMCC: 0x84060602                                 */
/* Register default value on SPRUCC: 0x84060602                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT Grant to Grant Timing Constraint
*/


#define T_DDRT_GNT2GNT_CNSTRNT_MC_2LM_REG 0x0712148C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_ddrt_gntgnt_s : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000002*/

                            /*
                               Minimum GRANT to GRANT command DCLK separation
                               from same DIMM separation parameter (measured
                               between the clock assertion edges of the two
                               corresponding asserted command CS#). The min:max
                               program range for DDRT is 0-31. The min:max
                               program range for DDRT2 is 4-31. Any value
                               outside of the range is RFU.
                            */
    UINT32 t_ddrt_gntgnt_dd : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000006*/

                            /*
                               Minimum GRANT to GRANT command DCLK separation
                               from different DIMM separation parameter
                               (measured between the clock assertion edges of
                               the two corresponding asserted command CS#). The
                               min:max program range for DDRT/DDRT2 is 5-31.
                               Any value outside of the range is RFU.
                            */
    UINT32 t_ddrt_gntgnt_other_subchn : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000006*/

                            /*
                               Minimum GRANT 2 GRANT timing parameter to block
                               grants on other subchannel. Set
                               DDRT_MISC_CTL.ddrt2_block_other_subchn_gnt to 1
                               to block grant going out in the next clock.
                               Total Dclk block is this CSR value + 2. Default
                               to 0. The min:max program range for DDRT2 is
                               0-31. Thsi value must be 0 for DDRT. Any value
                               outside of the range is RFU.
                            */
    UINT32 t_ddrt_low_vc_same_subchn : 4;

                            /* Bits[27:24], Access Type=RW, default=0x00000004*/

                            /*
                               Additional DCLK delay between 2 grant commands
                               on the same subchannel when RDB credits are low
                               for DDRT. This CSR value is added to
                               t_ddrt_gntgnt_s value when we are in low RDB
                               credit conditions. The min:max program range for
                               DDRT/DDRT2 is 4-15. Any value outside of the
                               range is RFU. Combined gnt2gnt same subchannel
                               block (t_ddrt_gntgnt_s +
                               t_ddrt_low_vc_same_subchn) should be at least 8
                               Dclks to take care of Low_VC2 conditions.
                            */
    UINT32 t_ddrt_low_vc_other_subchn : 4;

                            /* Bits[31:28], Access Type=RW, default=0x00000008*/

                            /*
                               Additional DCLK delay between 2 grant commands
                               on the 2 different subchannels when RDB credits
                               are low for DDRT. This CSR value is added to
                               t_ddrt_gntgnt_other_subchannel value when we are
                               in low RDB credit conditions. The min:max
                               program range for DDRT/DDRT2 is 8-15. Any value
                               outside of the range is RFU. Combined gnt2gnt
                               block for other subchannel
                               (t_ddrt_gntgnt_other_subchannel +
                               t_ddrt_low_vc_other_subchn) should be atleast 8
                               Dclks to take care of low_vc2 conditions.
                            */

  } Bits;
  UINT32 Data;

} T_DDRT_GNT2GNT_CNSTRNT_MC_2LM_STRUCT;

/* T_DDRT_PD_MC_2LM_REG supported on:                                           */
/*      SPRA0 (0x20021490)                                                      */
/*      SPRB0 (0x20021490)                                                      */
/*      SPRHBM (0x20021490)                                                     */
/*      SPRC0 (0x20021490)                                                      */
/*      SPRMCC (0x20021490)                                                     */
/*      SPRUCC (0x20021490)                                                     */
/* Register default value on SPRA0: 0x00060F0F                                  */
/* Register default value on SPRB0: 0x00060F0F                                  */
/* Register default value on SPRHBM: 0x00060F0F                                 */
/* Register default value on SPRC0: 0x00060F0F                                  */
/* Register default value on SPRMCC: 0x00060F0F                                 */
/* Register default value on SPRUCC: 0x00060F0F                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT RW to Power Down Timing Constraints
*/


#define T_DDRT_PD_MC_2LM_REG 0x07121490

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_ddrt_rdpden : 8;

                            /* Bits[7:0], Access Type=RW, default=0x0000000F*/

                            /*
                               Minimum READ to PD command separation (in DCLK,
                               measured between the clock assertion edges of
                               the two corresponding asserted command CS#). The
                               min:max program range is 2-31. Any value outside
                               of the range is RFU.
                            */
    UINT32 t_ddrt_wrpden : 8;

                            /* Bits[15:8], Access Type=RW, default=0x0000000F*/

                            /*
                               Minimum WRITE to PD command separation (in DCLK
                               measured between the clock assertion edges of
                               the two corresponding asserted command CS#). The
                               min:max program range is 2-31. Any value outside
                               of the range is RFU.
                            */
    UINT32 t_ddrt_gntpden : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000006*/

                            /*
                               Minimum GRANT to PD command separation (in DCLK
                               measured between the clock assertion edges of
                               the two corresponding asserted command CS#). The
                               min:max program range is 2-31. Any value outside
                               of the range is RFU.
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} T_DDRT_PD_MC_2LM_STRUCT;

/* T_DDRT_MNT_CNSTRNT_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x20021494)                                                      */
/*      SPRB0 (0x20021494)                                                      */
/*      SPRHBM (0x20021494)                                                     */
/*      SPRC0 (0x20021494)                                                      */
/*      SPRMCC (0x20021494)                                                     */
/*      SPRUCC (0x20021494)                                                     */
/* Register default value on SPRA0: 0x00400000                                  */
/* Register default value on SPRB0: 0x00401000                                  */
/* Register default value on SPRHBM: 0x00401000                                 */
/* Register default value on SPRC0: 0x00801000                                  */
/* Register default value on SPRMCC: 0x00801000                                 */
/* Register default value on SPRUCC: 0x00801000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT MNT to any-command constraints
*/


#define T_DDRT_MNT_CNSTRNT_MC_2LM_REG 0x07121494

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_ddrt_mnt_anycmd : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               Minimum any-MNT to any-CMD delay (in DCLK
                               measured between the clock assertion edges of
                               the two corresponding asserted command CS#). The
                               min:max program range is 8-31. Any value outside
                               of the range is RFU.
                            */
    UINT32 t_ddrt_zqs_anycmd : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Minimum delay from ZQStart to any-CMD (in DCLK
                               measured between the clock assertion edges of
                               the two corresponding asserted command CS#). The
                               min:max program range is 8-31. Any value outside
                               of the range is RFU.
                            */
    UINT32 t_ddrt_zql_anycmd : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000040*/

                            /*
                               Minimum delay from ZQLatch to any-CMD (in DCLK
                               measured between the clock assertion edges of
                               the two corresponding asserted command CS#). The
                               min:max program range is 64-128. Any value
                               outside of the range is RFU.
                            */
    UINT32 t_ddrt_sre_anycmd : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               Minimum delay deom SRE cmd to any-CMD (in DCLK
                               measured between the clock assertion edges of
                               the two corresponding asserted command CS#). The
                               min:max program range is 8-64. Any value outside
                               of the range is RFU.
                            */

  } Bits;
  UINT32 Data;

} T_DDRT_MNT_CNSTRNT_MC_2LM_STRUCT;

/* T_DDRT_PWRUP_MC_2LM_REG supported on:                                        */
/*      SPRA0 (0x20021498)                                                      */
/*      SPRB0 (0x20021498)                                                      */
/*      SPRHBM (0x20021498)                                                     */
/*      SPRC0 (0x20021498)                                                      */
/*      SPRMCC (0x20021498)                                                     */
/*      SPRUCC (0x20021498)                                                     */
/* Register default value on SPRA0: 0x00080308                                  */
/* Register default value on SPRB0: 0x00080308                                  */
/* Register default value on SPRHBM: 0x00080308                                 */
/* Register default value on SPRC0: 0x00080308                                  */
/* Register default value on SPRMCC: 0x00080308                                 */
/* Register default value on SPRUCC: 0x00080308                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT Power Down Exit Timing Constraints
*/


#define T_DDRT_PWRUP_MC_2LM_REG 0x07121498

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_ddrt_xp : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000008*/

                            /*
                               Minimum Power Down Exit to first command DCLK
                               separation. The min:max program range is
                               platform specific. Any value outside of the
                               range is RFU.
                            */
    UINT32 t_ddrt_cke : 7;

                            /* Bits[14:8], Access Type=RW, default=0x00000003*/

                            /*
                               CKE minimum pulse width. Should be programmed
                               consistent with CR_TCRAP.t_cke
                            */
    UINT32 t_ddrt_sre_to_reqoff : 8;

                            /* Bits[22:15], Access Type=RW, default=0x00000010*/

                            /*
                               INST-only timing parameter for SRE2REQoff. REQs
                               are not valid after SRE2REQoff time from SRE
                               command. Value 16-63.
                            */
    UINT32 rsvd : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} T_DDRT_PWRUP_MC_2LM_STRUCT;

/* T_DDRT_DIMM0_BASIC_TIMING_MC_2LM_REG supported on:                           */
/*      SPRA0 (0x2002149c)                                                      */
/*      SPRB0 (0x2002149c)                                                      */
/*      SPRHBM (0x2002149c)                                                     */
/*      SPRC0 (0x2002149c)                                                      */
/*      SPRMCC (0x2002149c)                                                     */
/*      SPRUCC (0x2002149c)                                                     */
/* Register default value on SPRA0: 0x000A0606                                  */
/* Register default value on SPRB0: 0x000A0606                                  */
/* Register default value on SPRHBM: 0x000A0606                                 */
/* Register default value on SPRC0: 0x000A0606                                  */
/* Register default value on SPRMCC: 0x000A0606                                 */
/* Register default value on SPRUCC: 0x000A0606                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT DIMM0 Basic Timing Register
*/


#define T_DDRT_DIMM0_BASIC_TIMING_MC_2LM_REG 0x0712149C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_ddrt_gnt2erid : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000006*/

                            /*
                               Delay from GRANT to ERID. The min:max program
                               range is platform dependent. Any value outside
                               of the range is RFU. The value of this field
                               should be programmed during training as part of
                               roundtrip training.
                            */
    UINT32 t_ddrt_tcl : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000006*/

                            /* Grant to 1st Data Delay. Not used by hardware. */
    UINT32 t_ddrt_twl : 8;

                            /* Bits[23:16], Access Type=RW, default=0x0000000A*/

                            /*
                               Delay between write command (CS# assertion edge)
                               and 1st burst of write data. Offset from
                               programmed value of 9 DCLKs based on pipeline
                               delays.
                            */
    UINT32 t_ddrt_twl_adj : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /*
                               This register defines additional WR data delay
                               per channel in order to overcome the WR-flyby
                               issue. This change is applied only to DDRT DIMMs
                               on the channel. The total CAS write latency that
                               the DDR sees is the sum of t_ddrt_twl and the
                               t_ddrt_twl_adj minus t_ddrt_twl_adj_neg. 000 -
                               no added latency (default) 001 to 111 - 1 to 7
                               Dclk of added latency
                            */
    UINT32 rsvd : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_ddrt_twl_adj_neg : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               This register defines reduction of WR data delay
                               per channel in order to overcome the WR-flyby
                               issue. The total CAS write latency that the DDR
                               sees is the sum of t_ddrt_twl and the
                               t_ddrt_twl_adj minus t_ddrt_twl_adj_neg. This
                               change is applied only to DDRT DIMMs on the
                               channel. 00 - no latency reduction (default) 01
                               - reduce latency by 1 Dclk 10 - reduce latency
                               by 2 Dclk 11 - reduce latency by 3 Dclk The
                               total t_cwl (t_ddrt_twl + t_ddrt_tWL_adj -
                               t_ddrt_twl_adj_neg) should not be less than 8
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} T_DDRT_DIMM0_BASIC_TIMING_MC_2LM_STRUCT;

/* T_DDRT_DIMM1_BASIC_TIMING_MC_2LM_REG supported on:                           */
/*      SPRA0 (0x200214a0)                                                      */
/*      SPRB0 (0x200214a0)                                                      */
/*      SPRHBM (0x200214a0)                                                     */
/*      SPRC0 (0x200214a0)                                                      */
/*      SPRMCC (0x200214a0)                                                     */
/*      SPRUCC (0x200214a0)                                                     */
/* Register default value on SPRA0: 0x000A0606                                  */
/* Register default value on SPRB0: 0x000A0606                                  */
/* Register default value on SPRHBM: 0x000A0606                                 */
/* Register default value on SPRC0: 0x000A0606                                  */
/* Register default value on SPRMCC: 0x000A0606                                 */
/* Register default value on SPRUCC: 0x000A0606                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT DIMM1 Basic Timing Register
*/


#define T_DDRT_DIMM1_BASIC_TIMING_MC_2LM_REG 0x071214A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_ddrt_gnt2erid : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000006*/

                            /*
                               Delay from GRANT to ERID. The min:max program
                               range is platform dependent. Any value outside
                               of the range is RFU. The value of this field
                               should be programmed during training as part of
                               roundtrip training.
                            */
    UINT32 t_ddrt_tcl : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000006*/

                            /* Grant to 1st Data Delay. Not used by hardware. */
    UINT32 t_ddrt_twl : 8;

                            /* Bits[23:16], Access Type=RW, default=0x0000000A*/

                            /* Not used. DIMM0 and DIMM1 must use the same tWL. */
    UINT32 tck2_block_rd : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to enable 2tCK interamble
                               clock for reads. Note that this bit must be
                               programmed to the same value as CSR field
                               memory_timings_adj_type.read_preamble
                            */
    UINT32 tck2_block_wr : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to enable 2tCK interamble
                               block for writes. Note that this bit must be
                               programmed to the same value as CSR field
                               memory_timings_adj_type.write_preamble
                            */
    UINT32 tck4_block_rd : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to enable 4tCK interamble
                               block for reads. Note that this bit must be
                               programmed to the same value as CSR field
                               memory_timings_adj_type.read_preamble
                            */
    UINT32 tck4_block_wr : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to enable 4tCK interamble
                               block for writes. Note that this bit must be
                               programmed to the same value as CSR field
                               memory_timings_adj_type.write_preamble
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} T_DDRT_DIMM1_BASIC_TIMING_MC_2LM_STRUCT;

/* T_PERSIST_TIMING_MC_2LM_REG supported on:                                    */
/*      SPRA0 (0x200214a4)                                                      */
/*      SPRB0 (0x200214a4)                                                      */
/*      SPRHBM (0x200214a4)                                                     */
/*      SPRC0 (0x200214a4)                                                      */
/*      SPRMCC (0x200214a4)                                                     */
/*      SPRUCC (0x200214a4)                                                     */
/* Register default value on SPRA0: 0x00000020                                  */
/* Register default value on SPRB0: 0x00000020                                  */
/* Register default value on SPRHBM: 0x00000020                                 */
/* Register default value on SPRC0: 0x00000020                                  */
/* Register default value on SPRMCC: 0x00000020                                 */
/* Register default value on SPRUCC: 0x00000020                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT Persistent Write Delay
*/


#define T_PERSIST_TIMING_MC_2LM_REG 0x071214A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_persist_delay : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000020*/

                            /*
                               This is the delay that the TWPQ must wait after
                               issuing write data before considering the
                               written data has reached persistent domain in
                               FNV. The scheduler must monitor the ERR# pin in
                               this duration and mark the transaction as
                               visible only if ERR# is not asserted for Error
                               latency duration after write data is issued.
                               Note: Need to document the additional delay for
                               the write data thru DDRIO and the delay of
                               sensing ERR# assertion in DDRIO. The maximum
                               program range is 128 Dclks.
                            */
    UINT32 t_gnt_dq : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /*
                               This is the delay that the data bus must be
                               blocked after a GNT is scheduled. The min:max
                               program range is platform specific. Any value
                               outside of the range is RFU.
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} T_PERSIST_TIMING_MC_2LM_STRUCT;

/* DDRT_MAJOR_MODE_THRESHOLD3_MC_2LM_REG supported on:                          */
/*      SPRA0 (0x200214b8)                                                      */
/*      SPRB0 (0x200214b8)                                                      */
/*      SPRHBM (0x200214b8)                                                     */
/*      SPRC0 (0x200214b8)                                                      */
/*      SPRMCC (0x200214b8)                                                     */
/*      SPRUCC (0x200214b8)                                                     */
/* Register default value on SPRA0: 0x00000108                                  */
/* Register default value on SPRB0: 0x00000108                                  */
/* Register default value on SPRHBM: 0x00000108                                 */
/* Register default value on SPRC0: 0x00000108                                  */
/* Register default value on SPRMCC: 0x00000108                                 */
/* Register default value on SPRUCC: 0x00000108                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Configures the DDRT Major Mode behavior - Thresholds and starvation counters.
*/


#define DDRT_MAJOR_MODE_THRESHOLD3_MC_2LM_REG 0x071214B8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddrt_critical_starve : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000008*/

                            /*
                               Force the scheduler to switch from DDR4 to DDRT
                               major mode even if a single DDRT command is
                               present in the DDRT queues. This transition is
                               triggered after the scheduler has remained in
                               DDR4 major mode for a critical starvation number
                               of cycles and no DDRT transaction was scheduled.
                               The critical starvation threshold is calculated
                               as MODE_STARVE_CYCLE_THRESHOLD.DDRT X
                               ddrt_critical_starve. A value of 0 in this field
                               disables the transition.
                            */
    UINT32 ddr4_critical_starve : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000008*/

                            /*
                               Force the scheduler to switch from DDRT to DDR4
                               major mode even if a single DDR4 command is
                               present in the DDR4 queues. This transition is
                               triggered after the scheduler has remained in
                               DDRT major mode for a critical starvation number
                               of cycles and no DDRT transaction was scheduled.
                               The critical starvation threshold is calculated
                               as MODE_STARVE_CYCLE_THRESHOLD.DDR4 X
                               ddr4_critical_starve. A value of 0 in this field
                               disables the transition.
                            */
    UINT32 rsvd : 22;

                            /* Bits[31:10], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_MAJOR_MODE_THRESHOLD3_MC_2LM_STRUCT;

/* DDRT_RPQ0_MSK_MC_2LM_REG supported on:                                       */
/*      SPRA0 (0x200214bc)                                                      */
/*      SPRB0 (0x200214bc)                                                      */
/*      SPRHBM (0x200214bc)                                                     */
/*      SPRC0 (0x200214bc)                                                      */
/*      SPRMCC (0x200214bc)                                                     */
/*      SPRUCC (0x200214bc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* TRPQ[31:0] entry mask. Masking off the entry when set to one.
*/


#define DDRT_RPQ0_MSK_MC_2LM_REG 0x071214BC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddrt_rpq0_msk : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               TRPQ[31:0] entry mask. Masking off the entry
                               when set to one.
                            */

  } Bits;
  UINT32 Data;

} DDRT_RPQ0_MSK_MC_2LM_STRUCT;

/* DDRT_RPQ1_MSK_MC_2LM_REG supported on:                                       */
/*      SPRA0 (0x200214c0)                                                      */
/*      SPRB0 (0x200214c0)                                                      */
/*      SPRHBM (0x200214c0)                                                     */
/*      SPRC0 (0x200214c0)                                                      */
/*      SPRMCC (0x200214c0)                                                     */
/*      SPRUCC (0x200214c0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* TRPQ[63:32] entry mask. Masking off the entry when set to one.
*/


#define DDRT_RPQ1_MSK_MC_2LM_REG 0x071214C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddrt_rpq1_msk : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               TRPQ[63:32] entry mask. Masking off the entry
                               when set to one.
                            */

  } Bits;
  UINT32 Data;

} DDRT_RPQ1_MSK_MC_2LM_STRUCT;

/* DDRT_WPQ_RPQH_MSK_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x200214c4)                                                      */
/*      SPRB0 (0x200214c4)                                                      */
/*      SPRHBM (0x200214c4)                                                     */
/*      SPRC0 (0x200214c4)                                                      */
/*      SPRMCC (0x200214c4)                                                     */
/*      SPRUCC (0x200214c4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* TWPQ entry mask. TRPQ[79:64] entry mask. Masking off the entry when set to one.
*/


#define DDRT_WPQ_RPQH_MSK_MC_2LM_REG 0x071214C4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddrt_wpq_msk : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /*
                               TWPQ entry mask. TRPQ[79:64] entry mask. Masking
                               off the entry when set to one.
                            */
    UINT32 ddrt_rpq2_msk : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000000*/

                            /*
                               TRPQ[79:64] entry mask. Masking off the entry
                               when set to one.
                            */

  } Bits;
  UINT32 Data;

} DDRT_WPQ_RPQH_MSK_MC_2LM_STRUCT;

/* DDRT_RETRY_TIMER2_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x200214c8)                                                      */
/*      SPRB0 (0x200214c8)                                                      */
/*      SPRHBM (0x200214c8)                                                     */
/*      SPRC0 (0x200214c8)                                                      */
/*      SPRMCC (0x200214c8)                                                     */
/*      SPRUCC (0x200214c8)                                                     */
/* Register default value on SPRA0: 0x0007FFFF                                  */
/* Register default value on SPRB0: 0x0607FFFF                                  */
/* Register default value on SPRHBM: 0x0607FFFF                                 */
/* Register default value on SPRC0: 0x0607FFFF                                  */
/* Register default value on SPRMCC: 0x0607FFFF                                 */
/* Register default value on SPRUCC: 0x0607FFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT Retry Thresholds
*/


#define DDRT_RETRY_TIMER2_MC_2LM_REG 0x071214C8

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 train_reset_time : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000FF*/

                            /*
                               Train reset duration in Dclks. Program to the
                               same value as link retry_timer2.train_reset_time
                            */
    UINT32 retry_cmpl_time : 7;

                            /* Bits[14:8], Access Type=RW, default=0x0000007F*/

                            /*
                               Wait time in completion state (SUCCESS or
                               FAILURE). Program to the same value as link
                               retry_timer2.retry_cmpl_time. Counts down on
                               Hclk.
                            */
    UINT32 train_deassert_to_err_ack_time : 6;

                            /* Bits[20:15], Access Type=RW, default=0x0000000F*/

                            /*
                               Time delay between train reset de-assertion to
                               issuing error_ack. DDRIO requires at least 15
                               Hclks. Program this value in Hclks. Min 15- Max
                               63 Restriction : Train_reset_to_err_ack +
                               DDRT_RETRY_TIMER.min_rt_delay should not exceed
                               8'hff (Hclks)
                            */
    UINT32 rsvd : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_RETRY_TIMER2_MC_2LM_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 train_reset_time : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000FF*/

                            /*
                               Train reset duration in Dclks. Program to the
                               same value as link retry_timer2.train_reset_time
                            */
    UINT32 retry_cmpl_time : 7;

                            /* Bits[14:8], Access Type=RW, default=0x0000007F*/

                            /*
                               Wait time in completion state (SUCCESS or
                               FAILURE). Program to the same value as link
                               retry_timer2.retry_cmpl_time. Counts down on
                               Hclk.
                            */
    UINT32 train_deassert_to_err_ack_time : 6;

                            /* Bits[20:15], Access Type=RW, default=0x0000000F*/

                            /*
                               Time delay between train reset de-assertion to
                               issuing error_ack. DDRIO requires at least 15
                               Hclks. Program this value in Hclks. Min 15- Max
                               63 Restriction : Train_reset_to_err_ack +
                               DDRT_RETRY_TIMER.min_rt_delay should not exceed
                               8'hff (Hclks)
                            */
    UINT32 wrcrdt_cnt_starve : 8;

                            /* Bits[28:21], Access Type=RW, default=0x00000030*/

                            /*
                               write credit count caparison value for credit
                               leak starvation case.
                            */
    UINT32 rsvd : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_RETRY_TIMER2_MC_2LM_SPRB0_SPRHBM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 train_reset_time : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000FF*/

                            /*
                               Train reset duration in Dclks. Program to the
                               same value as link retry_timer2.train_reset_time
                            */
    UINT32 retry_cmpl_time : 7;

                            /* Bits[14:8], Access Type=RW, default=0x0000007F*/

                            /*
                               Wait time in completion state (SUCCESS or
                               FAILURE). Program to the same value as link
                               retry_timer2.retry_cmpl_time. Counts down on
                               Hclk.
                            */
    UINT32 train_deassert_to_err_ack_time : 6;

                            /* Bits[20:15], Access Type=RW, default=0x0000000F*/

                            /*
                               Time delay between train reset de-assertion to
                               issuing error_ack. DDRIO requires at least 15
                               Hclks. Program this value in Hclks. Min 15- Max
                               63 Restriction : Train_reset_to_err_ack +
                               DDRT_RETRY_TIMER.min_rt_delay should not exceed
                               8'hff (Hclks)
                            */
    UINT32 rsvd : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_RETRY_TIMER2_MC_2LM_STRUCT;

/* DDRT_DEFEATURE_MC_2LM_REG supported on:                                      */
/*      SPRA0 (0x200214cc)                                                      */
/*      SPRB0 (0x200214f0)                                                      */
/*      SPRHBM (0x200214f0)                                                     */
/*      SPRC0 (0x200214f0)                                                      */
/*      SPRMCC (0x200214f0)                                                     */
/*      SPRUCC (0x200214f0)                                                     */
/* Register default value on SPRA0: 0xC3008220                                  */
/* Register default value on SPRB0: 0xC3008220                                  */
/* Register default value on SPRHBM: 0xC3008220                                 */
/* Register default value on SPRC0: 0xC3008220                                  */
/* Register default value on SPRMCC: 0xC3008220                                 */
/* Register default value on SPRUCC: 0xC3008220                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Defeature bits for DDRT controller
*/


#define DDRT_DEFEATURE_MC_2LM_REG 0x071A0002

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mm_use_rt_empty : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Use RT empty before switching major mode */
    UINT32 ignore_erid_parity_error : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to block the ERID parity error
                               detection. Default is to leave the error
                               condition enabled.
                            */
    UINT32 ignore_erid_fatal_error : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to force MC to ignore the ERID Fatal
                               error. This error fires when MC detects a RPQ or
                               underfill Read data packet where RID did not
                               match the ERID. Default behavior is to treat the
                               error as a fatal condition. If this bit is set,
                               MC will block the fatal error and instead
                               trigger the Error Flow FSM.
                            */
    UINT32 rsvd : 2;

                            /* Bits[4:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_thermal_event : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*
                               disable DDRT Thermal event. BIOS must set this
                               to be 0 after DDRT memory is trained and before
                               normal traffic starts Follow below sequence to
                               avoid False Temperature Hot and Temperature Trip
                               Reported @ CPL3(cold boot) and @ 2nd ddrt io
                               init command(warm boot) In EarlyDdrtConfig: Set
                               dis_thermal_event = 1 In SwitchToNormalMode: Set
                               dis_thermal_event to 0->1->0, is needed so that
                               it can clear what the MC detected
                            */
    UINT32 rsvd_6 : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd_8 : 2;

                            /* Bits[9:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pkgc_wait_ddrt_wr_credit : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Queue empty indication to PkGC flows will wait
                               for all DDRT write credits to be returned by FNV
                            */
    UINT32 ignore_ddrt_req : 2;

                            /* Bits[12:11], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit in this field to 1 to force MC to
                               ignore incoming REQ pin. Bit 11 is for Slot 0
                               and Bit 12 is for Slot 1 (For both DDRT and
                               DDRT2)
                            */
    UINT32 ignore_erid : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit in this field to 1 to force MC to
                               ignore incoming DDRT ERID pin. Bit 11 is for
                               Slot 0 and Bit 12 is for Slot 1
                            */
    UINT32 ignore_viral : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to force the DDRT Retry FSM to
                               ignore Viral condiion. When set, VIRAL command
                               is not issued to FNV and DDRT FSM will not go to
                               Link Fail.
                            */
    UINT32 ignore_retry_cmd : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to force the DDRT to ignore
                               the Retry bit from M2M. DDRT transactions will
                               not go through the ECC correction path if this
                               bit is set.
                            */
    UINT32 ignore_erid_notrd_err : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Unused - previously Set this bit to 1 to force
                               the DDRT to ignore the check when ERID does not
                               match a read packet but RID does.
                            */
    UINT32 ignore_retry_for_ndp : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to prevent No data packet
                               transactions from using the correction path.
                            */
    UINT32 ignore_pending_retry_delay : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to ignore pending retry command
                               check used to add the delay programmed in
                               t_GNT_DQ_RETRY.
                            */
    UINT32 block_gnt2cmd_1cyc : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to prevent a DDRT command from
                               being scheduling in the Dclk after a GNT.
                               Blocking subsequent to this cycle will be
                               handled by the safe logic blocking.
                            */
    UINT32 ddrt_defeature : 11;

                            /* Bits[31:21], Access Type=RW, default=0x00000618*/

                            /*
                               Bit 21: If this bit is set to 1 then Idle
                               indication to various Power management flows
                               will not be asserted unless there are no pending
                               REQs in the DDRT scheduler. A value of 0 will
                               allow the Idle condition to assert even with
                               non-zero REQs as long as other conditions for
                               Idle are meant. This will cause the MC to enter
                               PM flows and respond to the REQs only on an exit
                               from a low power state Bit 22: If this bit is
                               set to 1 then it disables the fix for SKX HSD
                               b303440 (chicken bit). Bit 23: If this bit is
                               set to 1 then DDRT Retry flow will not prevent
                               CKE APD or PPD Bit 24: If this bit is set to 1
                               then it disables the write credit portion of the
                               b303858 fix. Bit 25: If this bit is set to 1
                               then it disables the read credit portion of the
                               b303858 fix. Bit 26: If this bit is set to 1
                               then it disables Intr PKT_ACK cmds triggering
                               PWR_UP (ICX-1406675219) Bit 27: If this bit is
                               set to 1 then it disabled fix for b304239 Bits
                               28 is unused. Bits 29: If this bit is set then
                               DDRT reads are blocked during a write credit
                               starvation condition. This bit should always be
                               set Bits 30: If Bit 30 is set then DDRT Retry
                               FSM is kicked whenever the Error pin is seen
                               asserted (instead of only on a trasition from
                               inactive to active). This bit should always be
                               set. Bits 31 is unused.
                            */

  } Bits;
  UINT32 Data;

} DDRT_DEFEATURE_MC_2LM_STRUCT;

/* T_DDRT_MISC_DELAY_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x200214d0)                                                      */
/*      SPRB0 (0x200214d0)                                                      */
/*      SPRHBM (0x200214d0)                                                     */
/*      SPRC0 (0x200214d0)                                                      */
/*      SPRMCC (0x200214d0)                                                     */
/*      SPRUCC (0x200214d0)                                                     */
/* Register default value on SPRA0: 0x00200884                                  */
/* Register default value on SPRB0: 0x00200884                                  */
/* Register default value on SPRHBM: 0x00200884                                 */
/* Register default value on SPRC0: 0x00200884                                  */
/* Register default value on SPRMCC: 0x00200884                                 */
/* Register default value on SPRUCC: 0x00200884                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT RW Major Mode Thresholds
*/


#define T_DDRT_MISC_DELAY_MC_2LM_REG 0x071214D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rpq_rid_to_credit_ret : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000004*/

                            /*
                               Controls the delay to return RPQ credit to M2M
                               after ERID is received
                            */
    UINT32 wpq_rid_to_fwr : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000004*/

                            /*
                               Controls the delay to move WPQ Partial to Full
                               Write credit after ERID is received
                            */
    UINT32 wpq_dealloc_to_credit_ret : 4;

                            /* Bits[13:10], Access Type=RW, default=0x00000002*/

                            /*
                               CSR controls the delay to retrun the WPQ credit
                               back to M2M after the Write data is read Write
                               data buffer for the memory write. The maximum
                               value that this can be programmed to is 12.
                            */
    UINT32 force_ddrt_mode : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /* Force DDRT mode. */
    UINT32 force_ddr4_mode : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* Force DDR4 mode. */
    UINT32 rsvd : 4;

                            /* Bits[19:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 wpq_rid_to_rt_ufill : 5;

                            /* Bits[24:20], Access Type=RW, default=0x00000002*/

                            /*
                               Controls the delay from wpq ERID to underfill
                               indication on read return path. The formula to
                               program this is
                               (cmpl_to_data_delay.cmpl_program_delay - 4)
                            */
    UINT32 rsvd_25 : 6;

                            /* Bits[30:25], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 enable_ddrt_2n_timing : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Set this field to 1 to enable DDRT 2N Timing. */

  } Bits;
  UINT32 Data;

} T_DDRT_MISC_DELAY_MC_2LM_STRUCT;

/* DDRT_FNV0_EVENT0_MC_2LM_REG supported on:                                    */
/*      SPRA0 (0x200214d4)                                                      */
/*      SPRB0 (0x200214f4)                                                      */
/*      SPRHBM (0x200214f4)                                                     */
/*      SPRC0 (0x200214f4)                                                      */
/*      SPRMCC (0x200214f4)                                                     */
/*      SPRUCC (0x200214f4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* DDRT DIMM0 FNV low priority event log.

When DDRT DIMM sends interrupt data, hardware writes into this register with the information about the interrupt and fire a SMI. 

BIOS then reads the register and clears it. 

The requirement on hardware is to read the current contents of the register, OR it with the new interrupt data and then write back the register. 

In case a BIOS write to overwrite the register occurs at the same time as a hardware update, and if hardware takes priority, HW will overwrite the CR with new interrupt information. The new interrupt will fire another SMI and BIOS will read the register again and subsequently clear it (In this case, Interrupt data will be OR of previous data and new data).
*/


#define DDRT_FNV0_EVENT0_MC_2LM_REG 0x071A0003

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 log : 24;

                            /* Bits[23:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               FNV event log The requirement on hardware is to
                               read the current contents of the register, OR it
                               with the new interrupt data and then write back
                               the register.
                            */
    UINT32 id : 3;

                            /* Bits[26:24], Access Type=RW/V/P, default=0x00000000*/

                            /* Packet ID of interrupt packet */
    UINT32 rsvd : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 err_select : 1;

                            /* Bits[28:28], Access Type=RW/P, default=0x00000000*/

                            /*
                               FNV event ERR0 assertion select. Upon logging a
                               FNV low priority event, iMC to generate a msgchn
                               posted write to IIO to assert ERR0 pin if this
                               select mask is configured to one by BIOS during
                               boot. Bit 29:28 can have all four combinations.
                               When both are set, both LINK and ERR# are armed.
                            */
    UINT32 smi_select : 1;

                            /* Bits[29:29], Access Type=RW/P, default=0x00000000*/

                            /*
                               FNV event SMM interrupt select. Upon logging a
                               FNV low priority event, iMC to generate a msgchn
                               posted write to UBox to generate LINK if this
                               select mask is configured to one by BIOS during
                               boot. Bit 29:28 can have all four combinations.
                               When both are set, both LINK and ERR# are armed.
                            */
    UINT32 overflow : 1;

                            /* Bits[30:30], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               FNV event overflow. 2nd event is detected before
                               the EVNET_VALID is cleared by interrupt handler.
                            */
    UINT32 valid : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* FNV event valid. Event log is valid. */

  } Bits;
  UINT32 Data;

} DDRT_FNV0_EVENT0_MC_2LM_STRUCT;

/* DDRT_FNV0_EVENT1_MC_2LM_REG supported on:                                    */
/*      SPRA0 (0x200214d8)                                                      */
/*      SPRB0 (0x200214d8)                                                      */
/*      SPRHBM (0x200214d8)                                                     */
/*      SPRC0 (0x200214d8)                                                      */
/*      SPRMCC (0x200214d8)                                                     */
/*      SPRUCC (0x200214d8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* DDRT DIMM0 FNV high priority event log.
When DDRT DIMM sends interrupt data, hardware writes into this register with the information about the interrupt and fire a SMI. 

BIOS then reads the register and clears it. 

The requirement on hardware is to read the current contents of the register, OR it with the new interrupt data and then write back the register. 

In case a BIOS write to overwrite the register occurs at the same time as a hardware update, and if hardware takes priority, HW will overwrite the CR with new interrupt information. The new interrupt will fire another SMI and BIOS will read the register again and subsequently clear it (In this case, Interrupt data will be OR of previous data and new data).
*/


#define DDRT_FNV0_EVENT1_MC_2LM_REG 0x071214D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 log : 24;

                            /* Bits[23:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               FNV event log The requirement on hardware is to
                               read the current contents of the register, OR it
                               with the new interrupt data and then write back
                               the register.
                            */
    UINT32 id : 3;

                            /* Bits[26:24], Access Type=RW/V/P, default=0x00000000*/

                            /* Packet ID of interrupt packet */
    UINT32 rsvd : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 err_select : 1;

                            /* Bits[28:28], Access Type=RW/P, default=0x00000000*/

                            /*
                               FNV event ERR0 assertion select. Upon logging a
                               FNV low priority event, iMC to generate a msgchn
                               posted write to IIO to assert ERR0 pin if this
                               select mask is configured to one by BIOS during
                               boot. Bit 29:28 can have all four combinations.
                               When both are set, both LINK and ERR# are armed.
                            */
    UINT32 smi_select : 1;

                            /* Bits[29:29], Access Type=RW/P, default=0x00000000*/

                            /*
                               FNV event SMM interrupt select. Upon logging a
                               FNV low priority event, iMC to generate a msgchn
                               posted write to UBox to generate LINK if this
                               select mask is configured to one by BIOS during
                               boot. Bit 29:28 can have all four combinations.
                               When both are set, both LINK and ERR# are armed.
                            */
    UINT32 overflow : 1;

                            /* Bits[30:30], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               FNV event overflow. 2nd event is detected before
                               the EVNET_VALID is cleared by interrupt handler.
                            */
    UINT32 valid : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* FNV event valid. Event log is valid. */

  } Bits;
  UINT32 Data;

} DDRT_FNV0_EVENT1_MC_2LM_STRUCT;

/* DDRT_FNV1_EVENT0_MC_2LM_REG supported on:                                    */
/*      SPRA0 (0x200214dc)                                                      */
/*      SPRB0 (0x200214dc)                                                      */
/*      SPRHBM (0x200214dc)                                                     */
/*      SPRC0 (0x200214dc)                                                      */
/*      SPRMCC (0x200214dc)                                                     */
/*      SPRUCC (0x200214dc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* DDRT DIMM1 FNV low priority event log.
When DDRT DIMM sends interrupt data, hardware writes into this register with the information about the interrupt and fire a SMI. 

BIOS then reads the register and clears it. 

The requirement on hardware is to read the current contents of the register, OR it with the new interrupt data and then write back the register. 

In case a BIOS write to overwrite the register occurs at the same time as a hardware update, and if hardware takes priority, HW will overwrite the CR with new interrupt information. The new interrupt will fire another SMI and BIOS will read the register again and subsequently clear it (In this case, Interrupt data will be OR of previous data and new data).
*/


#define DDRT_FNV1_EVENT0_MC_2LM_REG 0x071214DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 log : 24;

                            /* Bits[23:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               FNV event log The requirement on hardware is to
                               read the current contents of the register, OR it
                               with the new interrupt data and then write back
                               the register.
                            */
    UINT32 id : 3;

                            /* Bits[26:24], Access Type=RW/V/P, default=0x00000000*/

                            /* Packet ID of interrupt packet */
    UINT32 rsvd : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 err_select : 1;

                            /* Bits[28:28], Access Type=RW/P, default=0x00000000*/

                            /*
                               FNV event ERR0 assertion select. Upon logging a
                               FNV low priority event, iMC to generate a msgchn
                               posted write to IIO to assert ERR0 pin if this
                               select mask is configured to one by BIOS during
                               boot. Bit 29:28 can have all four combinations.
                               When both are set, both LINK and ERR# are armed.
                            */
    UINT32 smi_select : 1;

                            /* Bits[29:29], Access Type=RW/P, default=0x00000000*/

                            /*
                               FNV event SMM interrupt select. Upon logging a
                               FNV low priority event, iMC to generate a msgchn
                               posted write to UBox to generate LINK if this
                               select mask is configured to one by BIOS during
                               boot. Bit 29:28 can have all four combinations.
                               When both are set, both LINK and ERR# are armed.
                            */
    UINT32 overflow : 1;

                            /* Bits[30:30], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               FNV event overflow. 2nd event is detected before
                               the EVNET_VALID is cleared by interrupt handler.
                            */
    UINT32 valid : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* FNV event valid. Event log is valid. */

  } Bits;
  UINT32 Data;

} DDRT_FNV1_EVENT0_MC_2LM_STRUCT;

/* DDRT_FNV1_EVENT1_MC_2LM_REG supported on:                                    */
/*      SPRA0 (0x200214e0)                                                      */
/*      SPRB0 (0x20021418)                                                      */
/*      SPRHBM (0x20021418)                                                     */
/*      SPRC0 (0x20021418)                                                      */
/*      SPRMCC (0x20021418)                                                     */
/*      SPRUCC (0x20021418)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* DDRT DIMM1 FNV high priority event log.
When DDRT DIMM sends interrupt data, hardware writes into this register with the information about the interrupt and fire a SMI. 

BIOS then reads the register and clears it. 

The requirement on hardware is to read the current contents of the register, OR it with the new interrupt data and then write back the register. 

In case a BIOS write to overwrite the register occurs at the same time as a hardware update, and if hardware takes priority, HW will overwrite the CR with new interrupt information. The new interrupt will fire another SMI and BIOS will read the register again and subsequently clear it (In this case, Interrupt data will be OR of previous data and new data).
*/


#define DDRT_FNV1_EVENT1_MC_2LM_REG 0x071A0004

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 log : 24;

                            /* Bits[23:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               FNV event log The requirement on hardware is to
                               read the current contents of the register, OR it
                               with the new interrupt data and then write back
                               the register.
                            */
    UINT32 id : 3;

                            /* Bits[26:24], Access Type=RW/V/P, default=0x00000000*/

                            /* Packet ID of interrupt packet */
    UINT32 rsvd : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 err_select : 1;

                            /* Bits[28:28], Access Type=RW/P, default=0x00000000*/

                            /*
                               FNV event ERR0 assertion select. Upon logging a
                               FNV low priority event, iMC to generate a msgchn
                               posted write to IIO to assert ERR0 pin if this
                               select mask is configured to one by BIOS during
                               boot. Bit 29:28 can have all four combinations.
                               When both are set, both LINK and ERR# are armed.
                            */
    UINT32 smi_select : 1;

                            /* Bits[29:29], Access Type=RW/P, default=0x00000000*/

                            /*
                               FNV event SMM interrupt select. Upon logging a
                               FNV low priority event, iMC to generate a msgchn
                               posted write to UBox to generate LINK if this
                               select mask is configured to one by BIOS during
                               boot. Bit 29:28 can have all four combinations.
                               When both are set, both LINK and ERR# are armed.
                            */
    UINT32 overflow : 1;

                            /* Bits[30:30], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               FNV event overflow. 2nd event is detected before
                               the EVNET_VALID is cleared by interrupt handler.
                            */
    UINT32 valid : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /* FNV event valid. Event log is valid. */

  } Bits;
  UINT32 Data;

} DDRT_FNV1_EVENT1_MC_2LM_STRUCT;

/* MODE_STARVE_CYCLE_THRESHOLD_MC_2LM_REG supported on:                         */
/*      SPRA0 (0x200214e4)                                                      */
/*      SPRB0 (0x200214e4)                                                      */
/*      SPRHBM (0x200214e4)                                                     */
/*      SPRC0 (0x200214e4)                                                      */
/*      SPRMCC (0x200214e4)                                                     */
/*      SPRUCC (0x200214e4)                                                     */
/* Register default value on SPRA0: 0x00180018                                  */
/* Register default value on SPRB0: 0x00180018                                  */
/* Register default value on SPRHBM: 0x00180018                                 */
/* Register default value on SPRC0: 0x00180018                                  */
/* Register default value on SPRMCC: 0x00180018                                 */
/* Register default value on SPRUCC: 0x00180018                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT idle cycle threshold before releasing current major mode
*/


#define MODE_STARVE_CYCLE_THRESHOLD_MC_2LM_REG 0x071214E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddrt : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000018*/

                            /*
                               This field controls the minimum duration that
                               the major mode FSM remains in DDRT mode. This
                               field additionally is used to calculate the
                               number of cycles since exit from DDRT major mode
                               before DDRT mode is considered starved. See
                               DDRT_MAJOR_MODE_THRESHOLD3.critical_starve
                            */
    UINT32 ddr4 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000018*/

                            /*
                               This field controls the minimum duration that
                               the major mode FSM remains in DDR4 mode. This
                               field additionally is used to calculate the
                               number of cycles since exit from DDR4 major mode
                               before DDR4 mode is considered starved. See
                               DDRT_MAJOR_MODE_THRESHOLD3.critical_starve
                            */

  } Bits;
  UINT32 Data;

} MODE_STARVE_CYCLE_THRESHOLD_MC_2LM_STRUCT;

/* MODE_DELAYS_MC_2LM_REG supported on:                                         */
/*      SPRA0 (0x200214e8)                                                      */
/*      SPRB0 (0x200214e8)                                                      */
/*      SPRHBM (0x200214e8)                                                     */
/*      SPRC0 (0x200214e8)                                                      */
/*      SPRMCC (0x200214e8)                                                     */
/*      SPRUCC (0x200214e8)                                                     */
/* Register default value on SPRA0: 0x10201010                                  */
/* Register default value on SPRB0: 0x10201010                                  */
/* Register default value on SPRHBM: 0x10201010                                 */
/* Register default value on SPRC0: 0x10101010                                  */
/* Register default value on SPRMCC: 0x10101010                                 */
/* Register default value on SPRUCC: 0x10101010                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT idle cycle threshold before releasing current major mode
*/


#define MODE_DELAYS_MC_2LM_REG 0x071214E8

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddrt_to_ddr4_delay : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000010*/

                            /*
                               Delay while switching from DDRT to DDR4 major
                               mode. During this period, the MC will continue
                               to remain in DDRT mode but no new DDRT
                               transactions are scheduled
                            */
    UINT32 ddr4_to_ddrt_delay : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000010*/

                            /*
                               Delay while switching from DDR4 to DDRT major
                               mode. During this period, the MC will continue
                               to remain in DDR4 mode but no new DDR4
                               transactions are scheduled
                            */
    UINT32 rsvd : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 reset_timer : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               A 0 to 1 transition on this register will reset
                               the various timers used in the DDR4 - DDRT major
                               mode FSM
                            */
    UINT32 wmm_gnt2gnt_delay : 5;

                            /* Bits[22:18], Access Type=RW, default=0x00000008*/

                            /*
                               Additional delay to add in GNT to GNT scheduling
                               in WMM.
                            */
    UINT32 spare : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /* spare */
    UINT32 reqs : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000010*/

                            /*
                               Threshold of outstanding REQ in DDRT scheduler
                               to switch from DDR4 to DDRT mode
                            */

  } Bits;
  UINT32 Data;

} MODE_DELAYS_MC_2LM_SPRA0_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddrt_to_ddr4_delay : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000010*/

                            /*
                               Delay while switching from DDRT to DDR4 major
                               mode. During this period, the MC will continue
                               to remain in DDRT mode but no new DDRT
                               transactions are scheduled
                            */
    UINT32 ddr4_to_ddrt_delay : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000010*/

                            /*
                               Delay while switching from DDR4 to DDRT major
                               mode. During this period, the MC will continue
                               to remain in DDR4 mode but no new DDR4
                               transactions are scheduled
                            */
    UINT32 rsvd : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 reset_timer : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               A 0 to 1 transition on this register will reset
                               the various timers used in the DDR4 - DDRT major
                               mode FSM
                            */
    UINT32 wmm_gnt2gnt_delay : 6;

                            /* Bits[23:18], Access Type=RW, default=0x00000004*/

                            /*
                               Additional delay to add in GNT to GNT scheduling
                               in WMM. This delay should be programmed in
                               number of hclks (dclks/2)
                            */
    UINT32 reqs : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000010*/

                            /*
                               Threshold of outstanding REQ in DDRT scheduler
                               to switch from DDR4 to DDRT mode
                            */

  } Bits;
  UINT32 Data;

} MODE_DELAYS_MC_2LM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddrt_to_ddr4_delay : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000010*/

                            /*
                               Delay while switching from DDRT to DDR4 major
                               mode. During this period, the MC will continue
                               to remain in DDRT mode but no new DDRT
                               transactions are scheduled
                            */
    UINT32 ddr4_to_ddrt_delay : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000010*/

                            /*
                               Delay while switching from DDR4 to DDRT major
                               mode. During this period, the MC will continue
                               to remain in DDR4 mode but no new DDR4
                               transactions are scheduled
                            */
    UINT32 rsvd : 1;

                            /* Bits[16:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 reset_timer : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               A 0 to 1 transition on this register will reset
                               the various timers used in the DDR4 - DDRT major
                               mode FSM
                            */
    UINT32 rsvd_18 : 6;

                            /* Bits[23:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 reqs : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000010*/

                            /*
                               Threshold of outstanding REQ in DDRT scheduler
                               to switch from DDR4 to DDRT mode
                            */

  } Bits;
  UINT32 Data;

} MODE_DELAYS_MC_2LM_STRUCT;

/* MODE_DDRT_CMD_STARVE_THRESHOLD_MC_2LM_REG supported on:                      */
/*      SPRA0 (0x200214ec)                                                      */
/*      SPRB0 (0x200214ec)                                                      */
/*      SPRHBM (0x200214ec)                                                     */
/*      SPRC0 (0x200214ec)                                                      */
/*      SPRMCC (0x200214ec)                                                     */
/*      SPRUCC (0x200214ec)                                                     */
/* Register default value on SPRA0: 0x00080810                                  */
/* Register default value on SPRB0: 0x00080810                                  */
/* Register default value on SPRHBM: 0x00080810                                 */
/* Register default value on SPRC0: 0x00080810                                  */
/* Register default value on SPRMCC: 0x00080810                                 */
/* Register default value on SPRUCC: 0x00080810                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT idle cycle threshold before releasing current major mode
*/


#define MODE_DDRT_CMD_STARVE_THRESHOLD_MC_2LM_REG 0x071214EC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reads : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000010*/

                            /*
                               Threshold of outstanding reads in DDRT RPQ to
                               hit DDRT starvation condition
                            */
    UINT32 writes : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000008*/

                            /*
                               Threshold of outstanding writes in DDRT WPQ to
                               hit DDRT starvation condition
                            */
    UINT32 partials : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000008*/

                            /*
                               Threshold of outstanding partials writes in DDRT
                               WPQ to hit DDRT starvation condition
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MODE_DDRT_CMD_STARVE_THRESHOLD_MC_2LM_STRUCT;

/* DDRT_RETRY_TIMER_MC_2LM_REG supported on:                                    */
/*      SPRA0 (0x200214f8)                                                      */
/*      SPRB0 (0x200214f8)                                                      */
/*      SPRHBM (0x200214f8)                                                     */
/*      SPRC0 (0x200214f8)                                                      */
/*      SPRMCC (0x200214f8)                                                     */
/*      SPRUCC (0x200214f8)                                                     */
/* Register default value on SPRA0: 0x20004110                                  */
/* Register default value on SPRB0: 0x20004110                                  */
/* Register default value on SPRHBM: 0x20004110                                 */
/* Register default value on SPRC0: 0x20004110                                  */
/* Register default value on SPRMCC: 0x20004110                                 */
/* Register default value on SPRUCC: 0x20004110                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT Retry Thresholds
*/


#define DDRT_RETRY_TIMER_MC_2LM_REG 0x071214F8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 retry_on_timer_limit : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000010*/

                            /*
                               Sets the limit as (2 ^ retry_on_timer_limit)
                               HCLKs for duration when Retry FSM can be active
                               before an error is triggered.
                            */
    UINT32 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 disable_retry_timer : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Set to 0 to enable watch dog timer for DDRT
                               Retry FSM timer. The timer limit is programmed
                               as (2retry_on_timer_limit) DCLKs for duration
                               when Retry FSM can be active before an error is
                               triggered.
                            */
    UINT32 err_ack_timer_limit : 8;

                            /* Bits[16:9], Access Type=RW, default=0x00000020*/

                            /*
                               Sets the limit in HCLKs for number of cycles
                               issue err ack state should stay before checking
                               error pin.
                            */
    UINT32 rsvd_17 : 7;

                            /* Bits[23:17], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 min_rt_delay : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000020*/

                            /*
                               Sets the limit in HCLKs for for certain Retry
                               that check events that depend on the round trip
                               channel delay.
                            */

  } Bits;
  UINT32 Data;

} DDRT_RETRY_TIMER_MC_2LM_STRUCT;

/* DDRT_RETRY_LINK_FAIL_MC_2LM_REG supported on:                                */
/*      SPRA0 (0x200214fc)                                                      */
/*      SPRB0 (0x200214fc)                                                      */
/*      SPRHBM (0x200214fc)                                                     */
/*      SPRC0 (0x200214fc)                                                      */
/*      SPRMCC (0x200214fc)                                                     */
/*      SPRUCC (0x200214fc)                                                     */
/* Register default value on SPRA0: 0x00200000                                  */
/* Register default value on SPRB0: 0x00200000                                  */
/* Register default value on SPRHBM: 0x00200000                                 */
/* Register default value on SPRC0: 0x00200000                                  */
/* Register default value on SPRMCC: 0x00200000                                 */
/* Register default value on SPRUCC: 0x00200000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT RW Major Mode Thresholds
*/


#define DDRT_RETRY_LINK_FAIL_MC_2LM_REG 0x071214FC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 res_threshold : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /*
                               If the number of Error FSM interations within a
                               DCLK interval defined by
                               DDRT_RETRY_LINK_FAIL.window exceeds the value
                               programmed in DDRT_RETRY_LINK_FAIL.threshold,
                               then a Link Fail condition is triggered. If the
                               threshold is programed to 0 then the Link Fail
                               condition is disabled.
                            */
    UINT32 window : 6;

                            /* Bits[21:16], Access Type=RW, default=0x00000020*/

                            /*
                               If the number of Error FSM interations within a
                               DCLK interval defined by
                               (2DDRT_RETRY_LINK_FAIL.window) exceeds the value
                               programmed in DDRT_RETRY_LINK_FAIL.threshold,
                               then a Link Fail condition is triggered. If the
                               threshold is programed to 0 then the Link Fail
                               condition is disabled.
                            */
    UINT32 rsvd : 10;

                            /* Bits[31:22], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_RETRY_LINK_FAIL_MC_2LM_STRUCT;

/* DDRT_RETRY_STATUS_N0_MC_2LM_REG supported on:                                */
/*      SPRA0 (0x20021500)                                                      */
/*      SPRB0 (0x20021500)                                                      */
/*      SPRHBM (0x20021500)                                                     */
/*      SPRC0 (0x20021500)                                                      */
/*      SPRMCC (0x20021500)                                                     */
/*      SPRUCC (0x20021500)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT RW Major Mode Thresholds
*/


#define DDRT_RETRY_STATUS_N0_MC_2LM_REG 0x07121500

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 current_iterations_cnt : 16;

                            /* Bits[15:0], Access Type=RO/V, default=0x00000000*/

                            /* Number of DCLKs Retry FSM has been active. */
    UINT32 current_retry_state : 4;

                            /* Bits[19:16], Access Type=RO/V, default=0x00000000*/

                            /* Current state of the Retry FSM */
    UINT32 rsvd : 2;

                            /* Bits[21:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 previous_retry_state : 4;

                            /* Bits[25:22], Access Type=RO/V, default=0x00000000*/

                            /* Previous state of the Retry FSM */
    UINT32 watchdog_timer_expired : 1;

                            /* Bits[26:26], Access Type=RO/V, default=0x00000000*/

                            /* WatchDog timer expired */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 inj_cmd_cnt : 4;

                            /* Bits[31:28], Access Type=RO/V, default=0x00000000*/

                            /*
                               Count of the number of times Force Error command
                               is issued unsuccessfully in each DDRT Retry flow
                               iteration.
                            */

  } Bits;
  UINT32 Data;

} DDRT_RETRY_STATUS_N0_MC_2LM_STRUCT;

/* DDRT_RETRY_STATUS_N1_MC_2LM_REG supported on:                                */
/*      SPRA0 (0x20021504)                                                      */
/*      SPRB0 (0x20021504)                                                      */
/*      SPRHBM (0x20021504)                                                     */
/*      SPRC0 (0x20021504)                                                      */
/*      SPRMCC (0x20021504)                                                     */
/*      SPRUCC (0x20021504)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT RW Major Mode Thresholds
*/


#define DDRT_RETRY_STATUS_N1_MC_2LM_REG 0x07121504

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 err_ack_cmd_cnt : 16;

                            /* Bits[15:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Count of the number of times Error Ack command
                               is issued unsuccessfully in each DDRT Retry flow
                               iteration.
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_RETRY_STATUS_N1_MC_2LM_STRUCT;

/* DDRT_CMD_SUBCHAN1_CNT_MC_2LM_REG supported on:                               */
/*      SPRA0 (0x20021508)                                                      */
/*      SPRB0 (0x20021508)                                                      */
/*      SPRHBM (0x20021508)                                                     */
/*      SPRC0 (0x20021508)                                                      */
/*      SPRMCC (0x20021508)                                                     */
/*      SPRUCC (0x20021508)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/*  
     This register contains debug information on the
     number of outstanding commands seen by DDRT MM FSM. CSR bit en_ddrt_dfd_clk must be
     enabled to use this register   
    
*/


#define DDRT_CMD_SUBCHAN1_CNT_MC_2LM_REG 0x07121508

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 num_gnt : 7;

                            /* Bits[6:0], Access Type=RO/V, default=0x00000000*/

                            /* GNTs ready to issue */
    UINT32 num_wr : 5;

                            /* Bits[11:7], Access Type=RO/V, default=0x00000000*/

                            /* Writes */
    UINT32 num_rd : 7;

                            /* Bits[18:12], Access Type=RO/V, default=0x00000000*/

                            /* Reads */
    UINT32 num_pwr : 5;

                            /* Bits[23:19], Access Type=RO/V, default=0x00000000*/

                            /* PWRs */
    UINT32 reqcnt : 7;

                            /* Bits[30:24], Access Type=RO/V, default=0x00000000*/

                            /* Number of outstanding Reqs */
    UINT32 reqcntiszero : 1;

                            /* Bits[31:31], Access Type=RO/V, default=0x00000000*/

                            /* Set if there are no outstanding Reqs */

  } Bits;
  UINT32 Data;

} DDRT_CMD_SUBCHAN1_CNT_MC_2LM_STRUCT;

/* DDRT_CLK_GATING_MC_2LM_REG supported on:                                     */
/*      SPRA0 (0x20021514)                                                      */
/*      SPRB0 (0x20021514)                                                      */
/*      SPRHBM (0x20021514)                                                     */
/*      SPRC0 (0x20021514)                                                      */
/*      SPRMCC (0x20021514)                                                     */
/*      SPRUCC (0x20021514)                                                     */
/* Register default value on SPRA0: 0x00080040                                  */
/* Register default value on SPRB0: 0x00080040                                  */
/* Register default value on SPRHBM: 0x00080040                                 */
/* Register default value on SPRC0: 0x00080040                                  */
/* Register default value on SPRMCC: 0x00080040                                 */
/* Register default value on SPRUCC: 0x00080040                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* CSR to program clock gating for DDRT scheduler
*/


#define DDRT_CLK_GATING_MC_2LM_REG 0x07121514

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 reqcnt_timer : 10;

                            /* Bits[9:0], Access Type=RW, default=0x00000040*/

                            /*
                               Timer to keep clocks running afer MC issues a
                               GNT for last outstanding REQ. This should more
                               than the DDRT round trip delay. Program to all
                               1s to keep the timer always running.
                            */
    UINT32 rsvd : 9;

                            /* Bits[18:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 en_ddrt_global_rsp_logic_clk : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               This bit must be set to 1 to enable response
                               master/response-function / trigger logic.
                               Deafault value is set to 1 for wave-3 as there
                               are known workarounds on customer system which
                               need trigger response logic to propogate.
                            */
    UINT32 en_ddrt_dfd_clk : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               This bit must be set to 1 to enable various
                               debug features in the DDRT scheduler logic. This
                               bit need not be set to 1 for normal functional
                               operation.
                            */
    UINT32 dis_major_mode_clkgating : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Disable clock gating for the DDRT major mode
                               logic
                            */
    UINT32 dis_safe_clkgating : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /* Disable clock gating for the DDRT safe logic */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_retry_clkgating : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /* Disable clock gating for the DDRT Retry FSM */
    UINT32 rsvd_25 : 1;

                            /* Bits[25:25], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_wpq_clkgating : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /* Disable clock gating for the DDRT WPQ */
    UINT32 dis_wpq_fsm_clkgating : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Disable clock gating for the DDRT WPQ FSM logic */
    UINT32 dis_revaddr_log_clkgating : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Disable clock gating used to store addresses for
                               reverse address decode
                            */
    UINT32 dis_rpq_clkgating : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* Disable clock gating for in the DDRT RPQ block */
    UINT32 dis_cpgc_clkgating : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Disable clock gating for CPGC logic in the DDRT
                               block
                            */
    UINT32 dis_ddrts_clkgating : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Disable clock gating in DDRTS block. */

  } Bits;
  UINT32 Data;

} DDRT_CLK_GATING_MC_2LM_STRUCT;

/* DDRT_MISC_CTL_MC_2LM_REG supported on:                                       */
/*      SPRA0 (0x20021518)                                                      */
/*      SPRB0 (0x20021518)                                                      */
/*      SPRHBM (0x20021518)                                                     */
/*      SPRC0 (0x20021518)                                                      */
/*      SPRMCC (0x20021518)                                                     */
/*      SPRUCC (0x20021518)                                                     */
/* Register default value on SPRA0: 0x0478C880                                  */
/* Register default value on SPRB0: 0x0478C880                                  */
/* Register default value on SPRHBM: 0x0478C880                                 */
/* Register default value on SPRC0: 0x0478C880                                  */
/* Register default value on SPRMCC: 0x0478C880                                 */
/* Register default value on SPRUCC: 0x0478C880                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Misc defeatures for DDRt
*/


#define DDRT_MISC_CTL_MC_2LM_REG 0x07121518

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 en_dir_only_upd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               0: Reads and writes will always be full
                               cacheline 1: MemInvXto* reads will be directory-
                               only reads, and DirUpd will be directory-only
                               writes.
                            */
    UINT32 dis_ddrt_opp_rd : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               1: DDRT RPQ Reads will not be scheduled in DDR4
                               mode 0: DDRT RPQ Reads will be scheduled in DDR4
                               mode. GNTs continue to be blocked in DDR4 mode
                               This bit should be set for DDRT 2N mode.
                            */
    UINT32 dis_ddrt_opp_ufill_rd : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               1: DDRT Underfill Reads will not be scheduled in
                               DDR4 mode 0: DDRT Underfill Reads will be
                               scheduled in DDR4 mode. GNTs continue to be
                               blocked in DDR4 mode This bit should be set for
                               DDRT 2N mode.
                            */
    UINT32 dis_ddrt_mode_reads : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               1: DDRT Reads (both RPQ reads and underfill
                               reads) will not be scheduled in DDRT mode -
                               Should be used only when opportunistic reads are
                               allowed in DDR4 mode. This is a post-silicon
                               switch to create opportunistic reads stress
                               conditions. This bit should not be set on
                               production systems. 0: DDRT Reads can be
                               scheduled in DDRT mode. Opportunistic reads can
                               still go out based on dis_ddrt_opp_rd and
                               dis_ddrt_opp_ufill_rd values. This should be the
                               default behavior.
                            */
    UINT32 viral_dummy_write : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Viral condition will block DDRT writes. */
    UINT32 link_fail_on_viral : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Viral condition will force DDRT FSM into link
                               fail condition.
                            */
    UINT32 dis_wpq_gnts_in_wmm : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Set to prevent WPQ from issuing GNTs if reqCnt
                               is non-zero in DDRT WMM while there are no FNV
                               write credits.
                            */
    UINT32 en_adr_gnts_in_wmm : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000001*/

                            /*
                               WPQ can GNTs if reqCnt is non-zero in DDRT WMM
                               and DDRT ADR is active.
                            */
    UINT32 cpgc_en_wpq_early_dealloc : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Enables returning WR crdt to CPGC engine as soon
                               as WR is scheduled, instead of waiting for WR +
                               WR_latency delay. The bit needs to be set for
                               DDRT CPGC algorithms that require back to back
                               writes on the DQ bus
                            */
    UINT32 ddrt2_block_other_subchn_gnt : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               This CSR can be used along with
                               gnt2gnt_other_subchannel CSR to separate grants
                               on 2 different subchannels only in DDRT2 mode.
                               If set, this will block 2 grants going out one
                               after other on 2 subchannels by 1 clock. This is
                               a debug knob to make GRANT scheduling between
                               subchannels more pessimistic in DDRT2. Should
                               not be set on production systems. Defaults to 0.
                               This value must be 0 for DDRT.
                            */
    UINT32 ddrt2_subchn_priority_cntr_val : 6;

                            /* Bits[15:10], Access Type=RW, default=0x00000032*/

                            /*
                               DCLK Counter value to switch subchannel
                               preference in DDRT2. Design doesn't allow 2
                               GRANTS or 2 WRITES in one cycle. Counter resets
                               when we transition from DDR4 mode to DDRT mode.
                               When the CSR value is met, subchannel select bit
                               will be inverted. Min:Max is 4:63, but use
                               default for optinal performance. N/A for DDRT.
                            */
    UINT32 ddrt2_gnt2rd_blk_active : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Only applicable to DDRT2 - Set this switch to
                               activate t_ddrt_sxp_gntrd_s - Grant 2 RD timing
                               for same subchannel. This should be used only
                               for post silicon debug purposes. Set this to 0
                               for production. Default to 0. CSR is N/A for
                               DDRT.
                            */
    UINT32 ddrt_gnt2rd_perf_opt_dis : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Only applicable to DDRT - Chicken bit to disable
                               DDRT performance optimization when reads are
                               getting blocked by continuous stream of grants.
                               Default to 0. CSR is N/A for DDRT2.
                            */
    UINT32 ddrt2_gnt_cmd_dbg_info_en : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Only applicable to DDRT2 - Chicken bit to enable
                               debug information on DDRT2 grant command.
                               Default to 0. CSR is N/A for DDRT.
                            */
    UINT32 ddrt2_illegal_conditions_en : 5;

                            /* Bits[23:19], Access Type=RW, default=0x0000000F*/

                            /*
                               Only applicable to DDRT2 - Chicken bit to enable
                               DDRT2 illegal conditions. Can trigger retry or
                               MCA logging or assertions in simulation 0 -
                               Interrupt packet came on secondary subchannel 1
                               - Info packet came on secondary subchannel 2 -
                               read data came on different subchannel than
                               expected 3 - Invalid REQ pulse width detected 4
                               - Invalid RID value detected
                            */
    UINT32 dis_wr_crdt_underflow_err : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Checken bit to disable logging/MCA write credit
                               underflow errors.
                            */
    UINT32 dis_cke_block_mm_switch : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Chicken bit to disable ddrt cke command to block
                               major mode from switching immediatly to ddrt
                               mode
                            */
    UINT32 ddrt2_debug_mode : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000001*/

                            /*
                               When this bit is set, we would duplicate UI bits
                               to FNV for the 4 UI commands as follows: 2nd UI
                               CA[13] to 1st UI CA12 3rd UI CA[13] to 2nd UI
                               CA[10] 4th UI CA[13] to 2nd UI CA[11]
                            */
    UINT32 dis_ddr4_mnt_block_mm_switch : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Chicken bit to disable ddr4/5 mnt command to
                               block major mode from switching immediatly to
                               ddrt mode
                            */
    UINT32 dis_wmm_no_rdb_crdt_switch : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Chicken bit to disable major mode to switch to
                               wmm when there is no rdb credit for gnt to be
                               issued for ddrt2
                            */
    UINT32 rsvd : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_MISC_CTL_MC_2LM_STRUCT;

/* DDRT_VIRAL_CTL_MC_2LM_REG supported on:                                      */
/*      SPRA0 (0x2002151c)                                                      */
/*      SPRB0 (0x2002151c)                                                      */
/*      SPRHBM (0x2002151c)                                                     */
/*      SPRC0 (0x2002151c)                                                      */
/*      SPRMCC (0x2002151c)                                                     */
/*      SPRUCC (0x2002151c)                                                     */
/* Register default value on SPRA0: 0x00000185                                  */
/* Register default value on SPRB0: 0x00000185                                  */
/* Register default value on SPRHBM: 0x00000185                                 */
/* Register default value on SPRC0: 0x00000185                                  */
/* Register default value on SPRMCC: 0x00000185                                 */
/* Register default value on SPRUCC: 0x00000185                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Bits to control viral signalling for DDRT Errors
*/


#define DDRT_VIRAL_CTL_MC_2LM_REG 0x0712151C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_erid_par : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000001*/

                            /*
                               Unused in wave-3. This is a correctable error
                               which doesn't trigger viral on wave-3. Wave-1
                               description - Disable viral triggering for ERID
                               correctable Parity error. Viral signalling is
                               Error signalling is disabled by default
                            */
    UINT32 dis_erid_uc : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for ERID fatal parity
                               error
                            */
    UINT32 dis_pending_intr_error : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000001*/

                            /* Spare unused bit */
    UINT32 dis_erid_fifo_error : 1;

                            /* Bits[3:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering for ERID FIFO over flow
                               or underflow error
                            */
    UINT32 dis_wr_fnv_credit_error : 1;

                            /* Bits[4:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering when number of write
                               credit returned exceeds number of outstanding
                               writes
                            */
    UINT32 dis_rd_fnv_credit_error : 1;

                            /* Bits[5:5], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering when number of read
                               credit returned exceeds number of outstanding
                               reads
                            */
    UINT32 dis_ddrt_scheduler_mismatch : 1;

                            /* Bits[6:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering when there is a
                               mismatch is command scheduled at DDRT and global
                               scheduler
                            */
    UINT32 dis_fnv_error : 1;

                            /* Bits[7:7], Access Type=RW/P, default=0x00000001*/

                            /*
                               Unused in wave-3. This is a correctable error
                               which doesn't trigger viral on wave-3. Wave-1
                               description - Disable viral triggering when FNV
                               Error pin is asserted
                            */
    UINT32 dis_fnv_thermal_error : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000001*/

                            /*
                               Disable viral triggering when FNV Error error is
                               detected
                            */
    UINT32 dis_unexp_pkt_cmi_idle : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering when unexpect DDRT
                               packet (not NDP) is received during CMI idle
                            */
    UINT32 dis_rpq_req_parity : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering when DDRT RPQ Request
                               Parity error is seen
                            */
    UINT32 dis_wpq_req_parity : 1;

                            /* Bits[11:11], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable viral triggering when DDRT WPQ Request
                               Parity error is seen
                            */
    UINT32 rsvd : 20;

                            /* Bits[31:12], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_VIRAL_CTL_MC_2LM_STRUCT;

/* DDRT_MCA_CTL_MC_2LM_REG supported on:                                        */
/*      SPRA0 (0x20021520)                                                      */
/*      SPRB0 (0x20021520)                                                      */
/*      SPRHBM (0x20021520)                                                     */
/*      SPRC0 (0x20021520)                                                      */
/*      SPRMCC (0x20021520)                                                     */
/*      SPRUCC (0x20021520)                                                     */
/* Register default value on SPRA0: 0x00000001                                  */
/* Register default value on SPRB0: 0x00000001                                  */
/* Register default value on SPRHBM: 0x00000001                                 */
/* Register default value on SPRC0: 0x00000001                                  */
/* Register default value on SPRMCC: 0x00000001                                 */
/* Register default value on SPRUCC: 0x00000001                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Bits to control MCA signalling for DDRT Errors
*/


#define DDRT_MCA_CTL_MC_2LM_REG 0x07121520

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_erid_par : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000001*/

                            /*
                               Disable MCA Bank logging for ERID correctable
                               Parity error. Viral signalling is Error
                               signalling is disabled by default Set CSR value
                               same as ddrt_error.ignore_erid_parity_error to
                               get the correct MCA log.
                            */
    UINT32 dis_erid_uc : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable MCA Bank logging for ERID fatal parity
                               error
                            */
    UINT32 dis_pending_intr_error : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /* Disable MCA Bank logging for DDRT Interrupt */
    UINT32 dis_erid_fifo_error : 1;

                            /* Bits[3:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable MCA Bank logging for ERID FIFO over flow
                               or underflow error
                            */
    UINT32 dis_wr_fnv_credit_error : 1;

                            /* Bits[4:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable MCA Bank logging when number of write
                               credit returned exceeds number of outstanding
                               writes
                            */
    UINT32 dis_rd_fnv_credit_error : 1;

                            /* Bits[5:5], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable MCA Bank logging when number of read
                               credit returned exceeds number of outstanding
                               reads
                            */
    UINT32 dis_ddrt_scheduler_mismatch : 1;

                            /* Bits[6:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable MCA Bank logging when there is a
                               mismatch is command scheduled at DDRT and global
                               scheduler
                            */
    UINT32 dis_fnv_error : 1;

                            /* Bits[7:7], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable MCA Bank logging when FNV pin error is
                               asserted
                            */
    UINT32 dis_fnv_thermal_error : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable MCA Bank logging when FNV thermal error
                               is asserted
                            */
    UINT32 dis_unexp_pkt_cmi_idle : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable MCA Bank logging when unexpected packet
                               received during CMI idle
                            */
    UINT32 dis_rpq_req_parity : 1;

                            /* Bits[10:10], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable MCA signalling for DDRT RPQ Request
                               Parity error
                            */
    UINT32 dis_wpq_req_parity : 1;

                            /* Bits[11:11], Access Type=RW/P, default=0x00000000*/

                            /*
                               Disable MCA signalling for DDRT WPQ Request
                               Parity error
                            */
    UINT32 rsvd : 12;

                            /* Bits[23:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 en_smi_fnv_err : 1;

                            /* Bits[24:24], Access Type=RW/P, default=0x00000000*/

                            /* Enable SMI for correctable ERID parity error */
    UINT32 en_smi_erid_par : 1;

                            /* Bits[25:25], Access Type=RW/P, default=0x00000000*/

                            /* Enable LINK for correctable ERID parity error */
    UINT32 rsvd_26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_MCA_CTL_MC_2LM_STRUCT;

/* DDRT_CLK_GATING2_MC_2LM_REG supported on:                                    */
/*      SPRA0 (0x20021524)                                                      */
/*      SPRB0 (0x20021524)                                                      */
/*      SPRHBM (0x20021524)                                                     */
/*      SPRC0 (0x20021524)                                                      */
/*      SPRMCC (0x20021524)                                                     */
/*      SPRUCC (0x20021524)                                                     */
/* Register default value on SPRA0: 0x00000040                                  */
/* Register default value on SPRB0: 0x00000040                                  */
/* Register default value on SPRHBM: 0x00000040                                 */
/* Register default value on SPRC0: 0x00000040                                  */
/* Register default value on SPRMCC: 0x00000040                                 */
/* Register default value on SPRUCC: 0x00000040                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Misc defeatures for DDRt
*/


#define DDRT_CLK_GATING2_MC_2LM_REG 0x07121524

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddrtq_busy_timer : 12;

                            /* Bits[11:0], Access Type=RW, default=0x00000040*/

                            /*
                               Timer to keep clocks running for DDRT ReadQ or
                               DDRT WriteQ after the queues drain all
                               transactions.
                            */
    UINT32 rsvd : 20;

                            /* Bits[31:12], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_CLK_GATING2_MC_2LM_STRUCT;

/* CPGC_DDRT_ERR_CTL_STS_MC_2LM_REG supported on:                               */
/*      SPRA0 (0x20021528)                                                      */
/*      SPRB0 (0x20021528)                                                      */
/*      SPRHBM (0x20021528)                                                     */
/*      SPRC0 (0x20021528)                                                      */
/*      SPRMCC (0x20021528)                                                     */
/*      SPRUCC (0x20021528)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* Register to control and observe errors during CPGC RMT and other training
*/


#define CPGC_DDRT_ERR_CTL_STS_MC_2LM_REG 0x07121528

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 crdt_limit : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               The DDRT scheduler will return credits to the
                               CPGC engine as long as the number of
                               transactions in the RPQ is below the threshold
                               programmed in CPGC_DDRT_ERR_CTL_STS.crdt_limit
                               If the DDRT scheduler hits this threshold, then
                               the condition is logged in
                               CPGC_DDRT_ERR_CTL_STS.crdt_limit_hit
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 timeout_threshold : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000000*/

                            /*
                               The DDRT scheduler will log an error if it sees
                               no progress in reads during training. This can
                               happen if either REQs or Read commands are not
                               decoded correctly while sweeping command
                               timings. An error is logged in
                               CPGC_DDRT_ERR_CTL_STS.timeout_error if no
                               progress is seen in
                               (2^CPGC_DDRT_ERR_CTL_STS.timeout_base_clk *
                               CPGC_DDRT_ERR_CTL_STS.timeout_threshold) Dclks
                            */
    UINT32 timeout_base_clk : 6;

                            /* Bits[17:12], Access Type=RW, default=0x00000000*/

                            /*
                               The DDRT scheduler will log an error if it sees
                               no progress in reads during training. This can
                               happen if either REQs or Read commands are not
                               decoded correctly while sweeping command
                               timings. An error is logged in
                               CPGC_DDRT_ERR_CTL_STS.timeout_error if no
                               progress is seen in
                               (2^CPGC_DDRT_ERR_CTL_STS.timeout_base_clk *
                               CPGC_DDRT_ERR_CTL_STS.timeout_threshold) Dclks
                            */
    UINT32 rsvd_18 : 12;

                            /* Bits[29:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 crdt_limit_hit : 1;

                            /* Bits[30:30], Access Type=RW/V, default=0x00000000*/

                            /*
                               The DDRT scheduler will return credits to the
                               CPGC engine as long as the number of
                               transactions in the RPQ is below the threshold
                               programmed in CPGC_DDRT_ERR_CTL_STS.crdt_limit
                               If the DDRT scheduler hits this threshold, then
                               the condition is logged in
                               CPGC_DDRT_ERR_CTL_STS.crdt_limit_hit A value of
                               0 in CPGC_DDRT_ERR_CTL_STS.crdt_limit_hit will
                               disable the mechanism. A value of 0 in
                               CPGC_DDRT_ERR_CTL_STS.crdt_limit_hit will
                               disable the mechanism.
                            */
    UINT32 timeout_error : 1;

                            /* Bits[31:31], Access Type=RW/V, default=0x00000000*/

                            /*
                               The DDRT scheduler will log an error if it sees
                               no progress in reads during training. This can
                               happen if either REQs or Read commands are not
                               decoded correctly while sweeping command
                               timings. An error is logged in
                               CPGC_DDRT_ERR_CTL_STS.timeout_error if no
                               progress is seen in
                               (2^CPGC_DDRT_ERR_CTL_STS.timeout_base_clk *
                               CPGC_DDRT_ERR_CTL_STS.timeout_threshold) Dclks
                               Software should write a 0 to this register to
                               clear the error.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DDRT_ERR_CTL_STS_MC_2LM_STRUCT;

/* CPGC_DDRT_MISC_CTL_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x2002154c)                                                      */
/*      SPRB0 (0x2002154c)                                                      */
/*      SPRHBM (0x2002154c)                                                     */
/*      SPRC0 (0x2002154c)                                                      */
/*      SPRMCC (0x2002154c)                                                     */
/*      SPRUCC (0x2002154c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* DDRT RW Major Mode Thresholds
*/


#define CPGC_DDRT_MISC_CTL_MC_2LM_REG 0x0712154C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 multi_credit_on : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set this to 1 only when the DDRT schedulers need
                               to handle multple outstanding transactions
                            */
    UINT32 disable_max_credit_check : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               If this bit is set during multi-credit mode,
                               then the scheduler ignores the value programmed
                               cpgc_max_credit field. No restriction to block
                               grants until a certain threshold of reads are
                               scheduled is done. Reads and Grants are
                               scheduled as they become available.
                            */
    UINT32 enable_erid_return : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If this bit is set during multi-credit mode,
                               then the scheduler ignores ERID returned from
                               DDRIO and use internally generated ERID value to
                               deallocate from RPQ. Should be set to 1 when
                               ERID is expected to incorrect during CPGC
                               training.
                            */
    UINT32 ddrt2_ignore_rid : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 in DDRT2 CPGC training to
                               ignore DDRT2 RID information in the data packet.
                               RID information is generated in the CPGC FIFO
                               and completions are sent out based on that. Set
                               this bit to 0 in functional mode.
                            */
    UINT32 rsvd : 6;

                            /* Bits[9:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cpgc_max_credit : 8;

                            /* Bits[17:10], Access Type=RW, default=0x00000000*/

                            /*
                               Maximum number of read credits allowed to CPGC
                               sequencer. This limit is used to block reads if
                               the scheduler accumulates reads with pending
                               GNTs
                            */
    UINT32 cpgc_rpq_force_drain : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               CR bit to clear valids of all RPQ entries. Meant
                               to be used by BIOS during training in CPGC mode.
                               Set this CR bit to unconditionally clear all
                               valids. Transactions will be dropped by clearing
                               the valids without actually draining them. Level
                               sensitive control, i.e., valids are cleared as
                               long as this CR bit stays high so BIOS must
                               clear the bit before pending queues can be
                               reused
                            */
    UINT32 cpgc_wpq_force_drain : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               CR bit to clear valids of all WPQ entries. Meant
                               to be used by BIOS during training in CPGC mode.
                               Set this CR bit to unconditionally clear all
                               valids. Transactions will be dropped by clearing
                               the valids without actually draining them. Level
                               sensitive control, i.e., valids are cleared as
                               long as this CR bit stays high so BIOS must
                               clear the bit before pending queues can be
                               reused
                            */
    UINT32 cpgc_dis_rpq_fifo_ptr_rst : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               CR defeature bit, to disable
                               cr_cpgc_rpq_force_drain_DnnnH from resetting
                               RPQs fifo ptrs.
                            */
    UINT32 cpgc_wait_for_rpq_empty : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               If this bit is set, the cpgc sequencer waits for
                               the DDRT RPQ to be empty before finishing a
                               subsequence.
                            */
    UINT32 use_wr_fifo : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               If this bit is set, the DDRT scheduler uses a
                               write tracker to keep CPGC writes in-order.
                            */
    UINT32 rsvd_23 : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_DDRT_MISC_CTL_MC_2LM_STRUCT;

/* DDRT_ERROR_MC_2LM_REG supported on:                                          */
/*      SPRA0 (0x20021550)                                                      */
/*      SPRB0 (0x20021550)                                                      */
/*      SPRHBM (0x20021550)                                                     */
/*      SPRC0 (0x20021550)                                                      */
/*      SPRMCC (0x20021550)                                                     */
/*      SPRUCC (0x20021550)                                                     */
/* Register default value on SPRA0: 0x00000F44                                  */
/* Register default value on SPRB0: 0x00000F44                                  */
/* Register default value on SPRHBM: 0x00000F44                                 */
/* Register default value on SPRC0: 0x00020F44                                  */
/* Register default value on SPRMCC: 0x00020F44                                 */
/* Register default value on SPRUCC: 0x00020F44                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* DDRT ERID training Error status
*/


#define DDRT_ERROR_MC_2LM_REG 0x07121550

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 current_ddrt_err0 : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit reflects the current status of DDR-T
                               Error from Slot 0 as seen in the memory
                               controller. If the error pin is asserted, this
                               field shows value 1. The logging in this field
                               is not affected by ignore_ddrt_err0 bit. If the
                               error condition is still in effect, then
                               hardware will re-assert the bit after software
                               clears it.
                            */
    UINT32 observed_ddrt_err0_assert : 1;

                            /* Bits[1:1], Access Type=RW/V, default=0x00000000*/

                            /*
                               Hardware will set this bit to a 1 when it
                               observes that DDR-T Error from Slot 0 has been
                               active. The logging in this field is not
                               affected by ignore_ddrt_err0 bit. Once set,
                               hardware will keep the bit set even if DDR-T
                               Error from Slot 0 is not active until the bit is
                               cleared by software. It is the responsibility of
                               software to clear this bit. If the error
                               condition is still in effect, then hardware will
                               re-assert the bit after software clears it.
                            */
    UINT32 ignore_ddrt_err0 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to mask the DDR-T Error from
                               Slot 0 in the iMC. DDRT_ERROR.current_ddrt_err0
                               will still report the current state of error
                               signal, but the DDR-T retry flow will not be
                               initiated even if the error indication asserts.
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 current_ddrt_err1 : 1;

                            /* Bits[4:4], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit reflects the current status of DDR-T
                               Error from Slot 1 as seen in the memory
                               controller. If the error pin is asserted, this
                               field shows value 1. The logging in this field
                               is not affected by ignore_ddrt_err1 bit. If the
                               error condition is still in effect, then
                               hardware will re-assert the bit after software
                               clears it.
                            */
    UINT32 observed_ddrt_err1_assert : 1;

                            /* Bits[5:5], Access Type=RW/V, default=0x00000000*/

                            /*
                               Hardware will set this bit to a 1 when it
                               observes that DDR-T Error from Slot 1 has been
                               active. The logging in this field is not
                               affected by ignore_ddrt_err1 bit. Once set,
                               hardware will keep the bit set even if DDR-T
                               Error from Slot 1 is not active until the bit is
                               cleared by software. It is the responsibility of
                               software to clear this bit. If the error
                               condition is still in effect, then hardware will
                               re-assert the bit after software clears it.
                            */
    UINT32 ignore_ddrt_err1 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to mask the DDR-T Error from
                               Slot 1 in the iMC. DDRT_ERROR.current_ddrt_err1
                               will still report the current state of error
                               signal, but the DDR-T retry flow will not be
                               initiated even if the error indication asserts.
                            */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ignore_ddrt_ecc_error : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to force the DDRT Retry FSM to
                               ignore ECC errors. The correct behavior is to
                               start retry FSM on DDRT read data ECC errors.
                               This bit should be set during CPGC mode where
                               Read data uses training patterns that do not
                               have good ECC.
                            */
    UINT32 ignore_erid_parity_error : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to force the DDRT Retry FSM to
                               ignore ERID parity errors. The correct behavior
                               is to start retry FSM on ERID parity errors.
                               This bit should be set during CPGC mode where
                               ERID parity error is not reliable. CSR value
                               should be same as ddrt_mca_ctl.dis_erid_par to
                               get correct MCA logs.
                            */
    UINT32 ignore_ddr4_error : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to force the DDRT Retry FSM to
                               ignore the DDR4 command parity errors. The
                               correct behavior is to set this bit to 1 only
                               when there is no DDRT populated in the channel.
                               If the channel has a DDRT DIMM then the bit
                               should be programmed to 0.
                            */
    UINT32 ignore_info_pkt_error : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to force the DDRT2 Retry FSM
                               to ignore trigger bit coming from information
                               packet.
                            */
    UINT32 spare : 5;

                            /* Bits[16:12], Access Type=RW, default=0x00000000*/

                            /* Spare */
    UINT32 rsvd_17 : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_ERROR_MC_2LM_SPRA0_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 current_ddrt_err0 : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit reflects the current status of DDR-T
                               Error from Slot 0 as seen in the memory
                               controller. If the error pin is asserted, this
                               field shows value 1. The logging in this field
                               is not affected by ignore_ddrt_err0 bit. If the
                               error condition is still in effect, then
                               hardware will re-assert the bit after software
                               clears it.
                            */
    UINT32 observed_ddrt_err0_assert : 1;

                            /* Bits[1:1], Access Type=RW/V, default=0x00000000*/

                            /*
                               Hardware will set this bit to a 1 when it
                               observes that DDR-T Error from Slot 0 has been
                               active. The logging in this field is not
                               affected by ignore_ddrt_err0 bit. Once set,
                               hardware will keep the bit set even if DDR-T
                               Error from Slot 0 is not active until the bit is
                               cleared by software. It is the responsibility of
                               software to clear this bit. If the error
                               condition is still in effect, then hardware will
                               re-assert the bit after software clears it.
                            */
    UINT32 ignore_ddrt_err0 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to mask the DDR-T Error from
                               Slot 0 in the iMC. DDRT_ERROR.current_ddrt_err0
                               will still report the current state of error
                               signal, but the DDR-T retry flow will not be
                               initiated even if the error indication asserts.
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 current_ddrt_err1 : 1;

                            /* Bits[4:4], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit reflects the current status of DDR-T
                               Error from Slot 1 as seen in the memory
                               controller. If the error pin is asserted, this
                               field shows value 1. The logging in this field
                               is not affected by ignore_ddrt_err1 bit. If the
                               error condition is still in effect, then
                               hardware will re-assert the bit after software
                               clears it.
                            */
    UINT32 observed_ddrt_err1_assert : 1;

                            /* Bits[5:5], Access Type=RW/V, default=0x00000000*/

                            /*
                               Hardware will set this bit to a 1 when it
                               observes that DDR-T Error from Slot 1 has been
                               active. The logging in this field is not
                               affected by ignore_ddrt_err1 bit. Once set,
                               hardware will keep the bit set even if DDR-T
                               Error from Slot 1 is not active until the bit is
                               cleared by software. It is the responsibility of
                               software to clear this bit. If the error
                               condition is still in effect, then hardware will
                               re-assert the bit after software clears it.
                            */
    UINT32 ignore_ddrt_err1 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to mask the DDR-T Error from
                               Slot 1 in the iMC. DDRT_ERROR.current_ddrt_err1
                               will still report the current state of error
                               signal, but the DDR-T retry flow will not be
                               initiated even if the error indication asserts.
                            */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ignore_ddrt_ecc_error : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to force the DDRT Retry FSM to
                               ignore ECC errors. The correct behavior is to
                               start retry FSM on DDRT read data ECC errors.
                               This bit should be set during CPGC mode where
                               Read data uses training patterns that do not
                               have good ECC.
                            */
    UINT32 ignore_erid_parity_error : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to force the DDRT Retry FSM to
                               ignore ERID parity errors. The correct behavior
                               is to start retry FSM on ERID parity errors.
                               This bit should be set during CPGC mode where
                               ERID parity error is not reliable. CSR value
                               should be same as ddrt_mca_ctl.dis_erid_par to
                               get correct MCA logs.
                            */
    UINT32 ignore_ddr4_error : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to force the DDRT Retry FSM to
                               ignore the DDR4 command parity errors. The
                               correct behavior is to set this bit to 1 only
                               when there is no DDRT populated in the channel.
                               If the channel has a DDRT DIMM then the bit
                               should be programmed to 0.
                            */
    UINT32 ignore_info_pkt_error : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to force the DDRT2 Retry FSM
                               to ignore trigger bit coming from information
                               packet.
                            */
    UINT32 spare : 5;

                            /* Bits[16:12], Access Type=RW, default=0x00000000*/

                            /* Spare */
    UINT32 ignore_special_cond_level : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to force the DDRT2 Retry FSM
                               to ignore speicial condition level signal.
                            */
    UINT32 rsvd_18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_ERROR_MC_2LM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 current_ddrt_err0 : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit reflects the current status of DDR-T
                               Error from Slot 0 as seen in the memory
                               controller. If the error pin is asserted, this
                               field shows value 1. The logging in this field
                               is not affected by ignore_ddrt_err0 bit. If the
                               error condition is still in effect, then
                               hardware will re-assert the bit after software
                               clears it.
                            */
    UINT32 observed_ddrt_err0_assert : 1;

                            /* Bits[1:1], Access Type=RW/V, default=0x00000000*/

                            /*
                               Hardware will set this bit to a 1 when it
                               observes that DDR-T Error from Slot 0 has been
                               active. The logging in this field is not
                               affected by ignore_ddrt_err0 bit. Once set,
                               hardware will keep the bit set even if DDR-T
                               Error from Slot 0 is not active until the bit is
                               cleared by software. It is the responsibility of
                               software to clear this bit. If the error
                               condition is still in effect, then hardware will
                               re-assert the bit after software clears it.
                            */
    UINT32 ignore_ddrt_err0 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to mask the DDR-T Error from
                               Slot 0 in the iMC. DDRT_ERROR.current_ddrt_err0
                               will still report the current state of error
                               signal, but the DDR-T retry flow will not be
                               initiated even if the error indication asserts.
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 current_ddrt_err1 : 1;

                            /* Bits[4:4], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit reflects the current status of DDR-T
                               Error from Slot 1 as seen in the memory
                               controller. If the error pin is asserted, this
                               field shows value 1. The logging in this field
                               is not affected by ignore_ddrt_err1 bit. If the
                               error condition is still in effect, then
                               hardware will re-assert the bit after software
                               clears it.
                            */
    UINT32 observed_ddrt_err1_assert : 1;

                            /* Bits[5:5], Access Type=RW/V, default=0x00000000*/

                            /*
                               Hardware will set this bit to a 1 when it
                               observes that DDR-T Error from Slot 1 has been
                               active. The logging in this field is not
                               affected by ignore_ddrt_err1 bit. Once set,
                               hardware will keep the bit set even if DDR-T
                               Error from Slot 1 is not active until the bit is
                               cleared by software. It is the responsibility of
                               software to clear this bit. If the error
                               condition is still in effect, then hardware will
                               re-assert the bit after software clears it.
                            */
    UINT32 ignore_ddrt_err1 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to mask the DDR-T Error from
                               Slot 1 in the iMC. DDRT_ERROR.current_ddrt_err1
                               will still report the current state of error
                               signal, but the DDR-T retry flow will not be
                               initiated even if the error indication asserts.
                            */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ignore_ddrt_ecc_error : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to force the DDRT Retry FSM to
                               ignore ECC errors. The correct behavior is to
                               start retry FSM on DDRT read data ECC errors.
                               This bit should be set during CPGC mode where
                               Read data uses training patterns that do not
                               have good ECC.
                            */
    UINT32 ignore_erid_parity_error : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to force the DDRT Retry FSM to
                               ignore ERID parity errors. The correct behavior
                               is to start retry FSM on ERID parity errors.
                               This bit should be set during CPGC mode where
                               ERID parity error is not reliable. CSR value
                               should be same as ddrt_mca_ctl.dis_erid_par to
                               get correct MCA logs.
                            */
    UINT32 ignore_ddr4_error : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to force the DDRT Retry FSM to
                               ignore the DDR4 command parity errors. The
                               correct behavior is to set this bit to 1 only
                               when there is no DDRT populated in the channel.
                               If the channel has a DDRT DIMM then the bit
                               should be programmed to 0.
                            */
    UINT32 ignore_info_pkt_error : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to force the DDRT2 Retry FSM
                               to ignore trigger bit coming from information
                               packet.
                            */
    UINT32 spare : 5;

                            /* Bits[16:12], Access Type=RW, default=0x00000000*/

                            /* Spare */
    UINT32 rsvd_17 : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_ERROR_MC_2LM_STRUCT;

/* DDRT_MM_FSM_STATE_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x20021558)                                                      */
/*      SPRB0 (0x20021558)                                                      */
/*      SPRHBM (0x20021558)                                                     */
/*      SPRC0 (0x20021558)                                                      */
/*      SPRMCC (0x20021558)                                                     */
/*      SPRUCC (0x20021558)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/*  
     This register contains current state and debug
     information about major mode FSM. CSR bit en_ddrt_dfd_clk must be
     enabled to use this register  
    
*/


#define DDRT_MM_FSM_STATE_MC_2LM_REG 0x07121558

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 current_state : 3;

                            /* Bits[2:0], Access Type=RO/V, default=0x00000000*/

                            /* Current state of DDRT Major mode FSM */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddrt_exit_events : 7;

                            /* Bits[10:4], Access Type=RO/V, default=0x00000000*/

                            /* Events that triggered exits from DDRT mode */
    UINT32 rsvd_11 : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddr4_exit_events : 7;

                            /* Bits[18:12], Access Type=RO/V, default=0x00000000*/

                            /* Events that triggered exits from DDR4 mode */
    UINT32 rsvd_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 wmm_state : 2;

                            /* Bits[21:20], Access Type=RO/V, default=0x00000000*/

                            /* Curent state of DDRT WMM FSM */
    UINT32 partial_is_starved : 1;

                            /* Bits[22:22], Access Type=RO/V, default=0x00000000*/

                            /* Partial is starved */
    UINT32 write_is_starved : 1;

                            /* Bits[23:23], Access Type=RO/V, default=0x00000000*/

                            /* Write is starved */
    UINT32 wrcrdt_is_starved : 1;

                            /* Bits[24:24], Access Type=RO/V, default=0x00000000*/

                            /* Write credit is starved */
    UINT32 tgr_is_starved : 1;

                            /* Bits[25:25], Access Type=RO/V, default=0x00000000*/

                            /* TGR underfill read is starved */
    UINT32 rsvd_26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_MM_FSM_STATE_MC_2LM_STRUCT;

/* DDRT_RPQ_DUMP_REG_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x2002155c)                                                      */
/*      SPRB0 (0x2002155c)                                                      */
/*      SPRHBM (0x2002155c)                                                     */
/*      SPRC0 (0x2002155c)                                                      */
/*      SPRMCC (0x2002155c)                                                     */
/*      SPRUCC (0x2002155c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* generated by critter 20_0_0x320
*/


#define DDRT_RPQ_DUMP_REG_MC_2LM_REG 0x0712155C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 arraycontent : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Arraycontents[31:0]. This register is GATED by
                               the DDRT_RPQ_DUMP_CFG2.VALID. When the VALID bit
                               is 0, this register is forced to zero.
                            */

  } Bits;
  UINT32 Data;

} DDRT_RPQ_DUMP_REG_MC_2LM_STRUCT;

/* DDRT_RPQ_DUMP_CFG0_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x20021560)                                                      */
/*      SPRB0 (0x20021560)                                                      */
/*      SPRHBM (0x20021560)                                                     */
/*      SPRC0 (0x20021560)                                                      */
/*      SPRMCC (0x20021560)                                                     */
/*      SPRUCC (0x20021560)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* generated by critter 20_0_0x324
*/


#define DDRT_RPQ_DUMP_CFG0_MC_2LM_REG 0x07121560

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 chanid : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /* channel id match value */
    UINT32 ag2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* ag2 match value */
    UINT32 trigmask : 16;

                            /* Bits[18:3], Access Type=RW, default=0x00000000*/

                            /*
                               setting a bit to 1 makes the trigger component a
                               dont care
                            */
    UINT32 rsvd : 2;

                            /* Bits[20:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ridoverride : 7;

                            /* Bits[27:21], Access Type=RW, default=0x00000000*/

                            /* entry select override */
    UINT32 subentryselect : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               selects 32 bit portion of entry to dump to RPQ
                               dump reg
                            */
    UINT32 cont : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* continuous dump to RPQ dump reg after trigger */
    UINT32 clear : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* clear trigger count */

  } Bits;
  UINT32 Data;

} DDRT_RPQ_DUMP_CFG0_MC_2LM_STRUCT;

/* DDRT_RPQ_DUMP_CFG1_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x20021564)                                                      */
/*      SPRB0 (0x20021564)                                                      */
/*      SPRHBM (0x20021564)                                                     */
/*      SPRC0 (0x20021564)                                                      */
/*      SPRMCC (0x20021564)                                                     */
/*      SPRUCC (0x20021564)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* generated by critter 20_0_0x328
*/


#define DDRT_RPQ_DUMP_CFG1_MC_2LM_REG 0x07121564

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sbindx : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* score board index match value */
    UINT32 htid : 9;

                            /* Bits[16:8], Access Type=RW, default=0x00000000*/

                            /* htid match value */
    UINT32 type0 : 6;

                            /* Bits[22:17], Access Type=RW, default=0x00000000*/

                            /* type match value 0 */
    UINT32 type1 : 6;

                            /* Bits[28:23], Access Type=RW, default=0x00000000*/

                            /* type match value 1 */
    UINT32 rank : 3;

                            /* Bits[31:29], Access Type=RW, default=0x00000000*/

                            /* rank 2:0 match value */

  } Bits;
  UINT32 Data;

} DDRT_RPQ_DUMP_CFG1_MC_2LM_STRUCT;

/* DDRT_RPQ_DUMP_CFG3_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x2002156c)                                                      */
/*      SPRB0 (0x2002156c)                                                      */
/*      SPRHBM (0x2002156c)                                                     */
/*      SPRC0 (0x2002156c)                                                      */
/*      SPRMCC (0x2002156c)                                                     */
/*      SPRUCC (0x2002156c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* generated by critter 20_0_0x328
*/


#define DDRT_RPQ_DUMP_CFG3_MC_2LM_REG 0x0712156C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_lo : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* address match value lower */

  } Bits;
  UINT32 Data;

} DDRT_RPQ_DUMP_CFG3_MC_2LM_STRUCT;

/* DDRT_RPQ_DUMP_CFG4_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x20021570)                                                      */
/*      SPRB0 (0x20021570)                                                      */
/*      SPRHBM (0x20021570)                                                     */
/*      SPRC0 (0x20021570)                                                      */
/*      SPRMCC (0x20021570)                                                     */
/*      SPRUCC (0x20021570)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* generated by critter 20_0_0x328
*/


#define DDRT_RPQ_DUMP_CFG4_MC_2LM_REG 0x07121570

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_mask_lo : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* address match mask lower */

  } Bits;
  UINT32 Data;

} DDRT_RPQ_DUMP_CFG4_MC_2LM_STRUCT;

/* DDRT_RPQ_DUMP_CFG5_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x20021574)                                                      */
/*      SPRB0 (0x20021574)                                                      */
/*      SPRHBM (0x20021574)                                                     */
/*      SPRC0 (0x20021574)                                                      */
/*      SPRMCC (0x20021574)                                                     */
/*      SPRUCC (0x20021574)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* generated by critter 20_0_0x328
*/


#define DDRT_RPQ_DUMP_CFG5_MC_2LM_REG 0x07121574

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_hi : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /* address match value upper */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 addr_mask_hi : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000000*/

                            /* address match mask upper */
    UINT32 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 type2 : 6;

                            /* Bits[21:16], Access Type=RW, default=0x00000000*/

                            /* type match value 2 */
    UINT32 type3 : 6;

                            /* Bits[27:22], Access Type=RW, default=0x00000000*/

                            /* type match value 3 */
    UINT32 rsvd_28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_RPQ_DUMP_CFG5_MC_2LM_STRUCT;

/* DDRT_WPQ_DUMP_REG_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x20021578)                                                      */
/*      SPRB0 (0x20021578)                                                      */
/*      SPRHBM (0x20021578)                                                     */
/*      SPRC0 (0x20021578)                                                      */
/*      SPRMCC (0x20021578)                                                     */
/*      SPRUCC (0x20021578)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* generated by critter 20_0_0x320
*/


#define DDRT_WPQ_DUMP_REG_MC_2LM_REG 0x07121578

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 arraycontent : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Arraycontents[31:0]. This register is GATED by
                               the DDRT_WPQ_DUMP_CFG2.VALID. When the VALID bit
                               is 0, this register is forced to zero.
                            */

  } Bits;
  UINT32 Data;

} DDRT_WPQ_DUMP_REG_MC_2LM_STRUCT;

/* DDRT_WPQ_DUMP_CFG0_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x2002157c)                                                      */
/*      SPRB0 (0x2002157c)                                                      */
/*      SPRHBM (0x2002157c)                                                     */
/*      SPRC0 (0x2002157c)                                                      */
/*      SPRMCC (0x2002157c)                                                     */
/*      SPRUCC (0x2002157c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* generated by critter 20_0_0x324
*/


#define DDRT_WPQ_DUMP_CFG0_MC_2LM_REG 0x0712157C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 chanid : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /* channel id match value */
    UINT32 ag2 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* ag2 match value */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 trigmask : 16;

                            /* Bits[19:4], Access Type=RW, default=0x00000000*/

                            /*
                               setting a bit to 1 makes the trigger component a
                               dont care
                            */
    UINT32 rsvd_20 : 2;

                            /* Bits[21:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 widoverride : 5;

                            /* Bits[26:22], Access Type=RW, default=0x00000000*/

                            /* entry select override */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 subentryselect : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               selects 32 bit portion of entry to dump to WPQ
                               dump reg
                            */
    UINT32 cont : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* continuous dump to RPQ dump reg after trigger */
    UINT32 clear : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* clear trigger count */

  } Bits;
  UINT32 Data;

} DDRT_WPQ_DUMP_CFG0_MC_2LM_STRUCT;

/* DDRT_WPQ_DUMP_CFG1_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x20021580)                                                      */
/*      SPRB0 (0x20021580)                                                      */
/*      SPRHBM (0x20021580)                                                     */
/*      SPRC0 (0x20021580)                                                      */
/*      SPRMCC (0x20021580)                                                     */
/*      SPRUCC (0x20021580)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* generated by critter 20_0_0x328
*/


#define DDRT_WPQ_DUMP_CFG1_MC_2LM_REG 0x07121580

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sbindx : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* score board index match value */
    UINT32 htid : 9;

                            /* Bits[16:8], Access Type=RW, default=0x00000000*/

                            /* htid match value */
    UINT32 type0 : 6;

                            /* Bits[22:17], Access Type=RW, default=0x00000000*/

                            /* type match value 0 */
    UINT32 type1 : 6;

                            /* Bits[28:23], Access Type=RW, default=0x00000000*/

                            /* type match value 1 */
    UINT32 rank : 3;

                            /* Bits[31:29], Access Type=RW, default=0x00000000*/

                            /* rank 2:0 match value */

  } Bits;
  UINT32 Data;

} DDRT_WPQ_DUMP_CFG1_MC_2LM_STRUCT;

/* DDRT_WPQ_DUMP_CFG3_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x20021588)                                                      */
/*      SPRB0 (0x20021588)                                                      */
/*      SPRHBM (0x20021588)                                                     */
/*      SPRC0 (0x20021588)                                                      */
/*      SPRMCC (0x20021588)                                                     */
/*      SPRUCC (0x20021588)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* generated by critter 20_0_0x328
*/


#define DDRT_WPQ_DUMP_CFG3_MC_2LM_REG 0x07121588

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_lo : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* address match value lower */

  } Bits;
  UINT32 Data;

} DDRT_WPQ_DUMP_CFG3_MC_2LM_STRUCT;

/* DDRT_WPQ_DUMP_CFG4_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x2002158c)                                                      */
/*      SPRB0 (0x2002158c)                                                      */
/*      SPRHBM (0x2002158c)                                                     */
/*      SPRC0 (0x2002158c)                                                      */
/*      SPRMCC (0x2002158c)                                                     */
/*      SPRUCC (0x2002158c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* generated by critter 20_0_0x328
*/


#define DDRT_WPQ_DUMP_CFG4_MC_2LM_REG 0x0712158C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_mask_lo : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* address match mask lower */

  } Bits;
  UINT32 Data;

} DDRT_WPQ_DUMP_CFG4_MC_2LM_STRUCT;

/* DDRT_WPQ_DUMP_CFG5_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x20021590)                                                      */
/*      SPRB0 (0x20021590)                                                      */
/*      SPRHBM (0x20021590)                                                     */
/*      SPRC0 (0x20021590)                                                      */
/*      SPRMCC (0x20021590)                                                     */
/*      SPRUCC (0x20021590)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* generated by critter 20_0_0x328
*/


#define DDRT_WPQ_DUMP_CFG5_MC_2LM_REG 0x07121590

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_hi : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /* address match value upper */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 addr_mask_hi : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000000*/

                            /* address match mask upper */
    UINT32 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 type2 : 6;

                            /* Bits[21:16], Access Type=RW, default=0x00000000*/

                            /* type match value 2 */
    UINT32 type3 : 6;

                            /* Bits[27:22], Access Type=RW, default=0x00000000*/

                            /* type match value 3 */
    UINT32 rsvd_28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_WPQ_DUMP_CFG5_MC_2LM_STRUCT;

/* DDRT_CMD_CNT_MC_2LM_REG supported on:                                        */
/*      SPRA0 (0x20021594)                                                      */
/*      SPRB0 (0x20021594)                                                      */
/*      SPRHBM (0x20021594)                                                     */
/*      SPRC0 (0x20021594)                                                      */
/*      SPRMCC (0x20021594)                                                     */
/*      SPRUCC (0x20021594)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/*  
     This register contains debug information on the
     number of outstanding commands seen by DDRT MM FSM. CSR bit en_ddrt_dfd_clk must be
     enabled to use this register   
    
*/


#define DDRT_CMD_CNT_MC_2LM_REG 0x07121594

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 num_gnt : 7;

                            /* Bits[6:0], Access Type=RO/V, default=0x00000000*/

                            /* GNTs ready to issue */
    UINT32 num_wr : 5;

                            /* Bits[11:7], Access Type=RO/V, default=0x00000000*/

                            /* Writes */
    UINT32 num_rd : 7;

                            /* Bits[18:12], Access Type=RO/V, default=0x00000000*/

                            /* Reads */
    UINT32 num_pwr : 5;

                            /* Bits[23:19], Access Type=RO/V, default=0x00000000*/

                            /* PWRs */
    UINT32 reqcnt : 7;

                            /* Bits[30:24], Access Type=RO/V, default=0x00000000*/

                            /* Number of outstanding Reqs */
    UINT32 reqcntiszero : 1;

                            /* Bits[31:31], Access Type=RO/V, default=0x00000000*/

                            /* Set if there are no outstanding Reqs */

  } Bits;
  UINT32 Data;

} DDRT_CMD_CNT_MC_2LM_STRUCT;

/* DDRT_CMD_SUBCHAN0_CNT_MC_2LM_REG supported on:                               */
/*      SPRA0 (0x20021598)                                                      */
/*      SPRB0 (0x20021598)                                                      */
/*      SPRHBM (0x20021598)                                                     */
/*      SPRC0 (0x20021598)                                                      */
/*      SPRMCC (0x20021598)                                                     */
/*      SPRUCC (0x20021598)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/*  
     This register contains debug information on the
     number of outstanding commands seen by DDRT MM FSM. CSR bit en_ddrt_dfd_clk must be
     enabled to use this register   
    
*/


#define DDRT_CMD_SUBCHAN0_CNT_MC_2LM_REG 0x07121598

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 num_gnt : 7;

                            /* Bits[6:0], Access Type=RO/V, default=0x00000000*/

                            /* GNTs ready to issue */
    UINT32 num_wr : 5;

                            /* Bits[11:7], Access Type=RO/V, default=0x00000000*/

                            /* Writes */
    UINT32 num_rd : 7;

                            /* Bits[18:12], Access Type=RO/V, default=0x00000000*/

                            /* Reads */
    UINT32 num_pwr : 5;

                            /* Bits[23:19], Access Type=RO/V, default=0x00000000*/

                            /* PWRs */
    UINT32 reqcnt : 7;

                            /* Bits[30:24], Access Type=RO/V, default=0x00000000*/

                            /* Number of outstanding Reqs */
    UINT32 reqcntiszero : 1;

                            /* Bits[31:31], Access Type=RO/V, default=0x00000000*/

                            /* Set if there are no outstanding Reqs */

  } Bits;
  UINT32 Data;

} DDRT_CMD_SUBCHAN0_CNT_MC_2LM_STRUCT;

/* DDRT_RETRY_TIMER_STATUS_HI_MC_2LM_REG supported on:                          */
/*      SPRA0 (0x2002159c)                                                      */
/*      SPRB0 (0x2002159c)                                                      */
/*      SPRHBM (0x2002159c)                                                     */
/*      SPRC0 (0x2002159c)                                                      */
/*      SPRMCC (0x2002159c)                                                     */
/*      SPRUCC (0x2002159c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/*  
     This register shows the upper 32b of the DDRT Retry Timer. 
    
*/


#define DDRT_RETRY_TIMER_STATUS_HI_MC_2LM_REG 0x0712159C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cnt : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /* Upper 32b of Retry FSM watchdog timer. */

  } Bits;
  UINT32 Data;

} DDRT_RETRY_TIMER_STATUS_HI_MC_2LM_STRUCT;

/* DDRT_ERR_LOG_CTL_MC_2LM_REG supported on:                                    */
/*      SPRA0 (0x200215a0)                                                      */
/*      SPRB0 (0x200215a0)                                                      */
/*      SPRHBM (0x200215a0)                                                     */
/*      SPRC0 (0x200215a0)                                                      */
/*      SPRMCC (0x200215a0)                                                     */
/*      SPRUCC (0x200215a0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
     This register accumulates all the errors logged in the DDRT logic
     after the 1st error. 
     CSR bit en_ddrt_dfd_clk must be enabled to use this register  
    
*/


#define DDRT_ERR_LOG_CTL_MC_2LM_REG 0x071215A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mask : 17;

                            /* Bits[16:0], Access Type=RW, default=0x00000000*/

                            /*
                               Mask Errors from being logged into the DDDRT
                               Error log registers Bit positions to disable
                               DDRT Error conditions 0 DDRT Erid parity error 1
                               DDRT Erid and RID mismatch UC error 2 ERID FIFO
                               overflow 3 Error on Read credit between IMC and
                               DDRT Controller for Subchannel 0 4 Error on Read
                               credit between IMC and DDRT Controller for
                               Subchannel 1 5 Error on Write credit between IMC
                               and DDRT Controller for Subchannel 0 6 Error on
                               Write credit between IMC and DDRT Controller for
                               Subchannel 1 7 Dropped DDRT command at global
                               scheduler for Subchannel 0 8 Dropped DDRT
                               command at global scheduler for Subchannel 1 9
                               DDRT Error 10 Thermal Event 11 RPQ address
                               parity 12 WPQ address parity 13 RPQ idle
                               threshold 14 WPQ idle threshold 15 Illegal DDRT2
                               condition detected 16 Undetectable erid parity
                               mapped to issued command completion
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_ERR_LOG_CTL_MC_2LM_STRUCT;

/* DDRT_ERR_LOG_NEXT_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x200215a4)                                                      */
/*      SPRB0 (0x200215a4)                                                      */
/*      SPRHBM (0x200215a4)                                                     */
/*      SPRC0 (0x200215a4)                                                      */
/*      SPRMCC (0x200215a4)                                                     */
/*      SPRUCC (0x200215a4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
     This register accumulates all the errors logged in the DDRT logic
     after the 1st error. 
     CSR bit en_ddrt_dfd_clk must be enabled to use this register  
    
*/


#define DDRT_ERR_LOG_NEXT_MC_2LM_REG 0x071215A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 error : 17;

                            /* Bits[16:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               See ddrt_err_log_1st register for description.
                               Last error will overwrite this field
                            */
    UINT32 rsvd : 14;

                            /* Bits[30:17], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 valid : 1;

                            /* Bits[31:31], Access Type=RW/V, default=0x00000000*/

                            /*
                               See ddrt_err_log_1st register for description.
                               Last error will overwrite this field
                            */

  } Bits;
  UINT32 Data;

} DDRT_ERR_LOG_NEXT_MC_2LM_STRUCT;

/* DDRT_ERR_LOG_1ST_N0_MC_2LM_REG supported on:                                 */
/*      SPRA0 (0x200215a8)                                                      */
/*      SPRB0 (0x200215a8)                                                      */
/*      SPRHBM (0x200215a8)                                                     */
/*      SPRC0 (0x200215a8)                                                      */
/*      SPRMCC (0x200215a8)                                                     */
/*      SPRUCC (0x200215a8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
     This register shows the 1st error loggged by the DDRT logic.
     CSR bit en_ddrt_dfd_clk must be enabled to use this register  
    
*/


#define DDRT_ERR_LOG_1ST_N0_MC_2LM_REG 0x071215A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 error : 17;

                            /* Bits[16:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Mask Errors from being logged into the DDDRT
                               Error log registers. Bit positions to disable
                               DDRT Error conditions - 0 DDRT Erid parity error
                               1 DDRT Erid and RID mismatch UC error 2 ERID
                               FIFO overflow 3 Error on Read credit between IMC
                               and DDRT Controller for Subchannel 0 4 Error on
                               Read credit between IMC and DDRT Controller for
                               Subchannel 1 5 Error on Write credit between IMC
                               and DDRT Controller for Subchannel 0 6 Error on
                               Write credit between IMC and DDRT Controller for
                               Subchannel 1 7 Dropped DDRT command at global
                               scheduler for Subchannel 0 8 Dropped DDRT
                               command at global scheduler for Subchannel 1 9
                               DDRT FNV Error 10 Thermal Event 11 RPQ address
                               parity 12 WPQ address parity 13 RPQ idle
                               threshold 14 WPQ idle threshold 15 Illegal DDRT2
                               condition detected 16 Undetectable erid parity
                               error mapped to issed command completion
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_ERR_LOG_1ST_N0_MC_2LM_STRUCT;

/* DDRT_ERR_LOG_1ST_N1_MC_2LM_REG supported on:                                 */
/*      SPRA0 (0x200215ac)                                                      */
/*      SPRB0 (0x200215ac)                                                      */
/*      SPRHBM (0x200215ac)                                                     */
/*      SPRC0 (0x200215ac)                                                      */
/*      SPRMCC (0x200215ac)                                                     */
/*      SPRUCC (0x200215ac)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
     This register shows the 1st error loggged by the DDRT logic.
     CSR bit en_ddrt_dfd_clk must be enabled to use this register  
    
*/


#define DDRT_ERR_LOG_1ST_N1_MC_2LM_REG 0x071215AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 info : 31;

                            /* Bits[30:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Additional information about condition logged in
                               error field 0 DDRT Erid parity error : {11'b0,
                               Previous ERID_parity[2:0], Previous ERID[6:0],
                               ERID_parity of error ERID[2:0], Error ERID[6:0]}
                               1 DDRT Erid and RID mismatch UC error : {15'b0,
                               RSP[1:0], RID[6:0], Last ERID[6:0]} 2 ERID FIFO
                               overflow : {29'b0, FIFO Overflow, FIFO
                               Underflow} 3 Error on Read credit between IMC
                               and DDRT Controller : {30'b0, Read credit error
                               on Subchannel 0} 4 Error on Read credit between
                               IMC and DDRT Controller : {30'b0, Read credit
                               error on Subchannel 1} 5 Error on Write credit
                               between IMC and DDRT Controller : {30'b0, Write
                               credit error on Subchannel 0} 6 Error on Write
                               credit between IMC and DDRT Controller : {30'b0,
                               Write credit error on subchannel 1} 7 Dropped
                               Subchannel 0 DDRT command at global scheduler :
                               {24'b0, RdWon[0], GntWon[0], WrWon[0],
                               MiscWon[0], WpqRdWon[0], WpqGntWon[0],
                               DDRTWon[0]} 8 Dropped Subchannel 1 DDRT command
                               at global scheduler : {24'b0, RdWon[1],
                               GntWon[1], WrWon[1], MiscWon[1], WpqRdWon[1],
                               WpqGntWon[1], DDRTWon[1]} 9 DDRT FNV Error :
                               {24'b0, NewFNVErr, RetryTrigger, RdECC, GlbRsp,
                               DDR4_Alert, ERID_Parity_Err,
                               NewFNVErr_MCAQualified} 10 Thermal Event :
                               {29'b0, Slot1 Thermal Event, Slot0 Thermal
                               Event} 11 RPQ address parity : {23'b0, RPQ entry
                               number of read[6:0], Parity Stored in
                               RPQArray[0:0]} 12 WPQ address parity : {26'b0,
                               WPQ Entry number of write[3:0], Parity stored in
                               WPQArray[0:0]} 13 RPQ idle timer threshold :
                               {17'b0, Subchannel 1 RPQ valid count[6:0],
                               Subchannel 0 RPQ valid count[6:0]} 14 WPQ idle
                               timer threshold : {21'b0, Subchannel 1 WPQ valid
                               count[4:0], Subchannel 0 WPQ valid count[4:0]}
                               15 Illegal DDRT2 condition detected : {14'b0,
                               Type of Illegal DDRT2 conditions [4:0], ReqPulse
                               Width type [4:0], RID captured on Data packet
                               [6:0] } 16 Undetectable erid parity error mapped
                               to issed command completion : {24'b0, ERID for
                               rd [6:0], ERID parity Err[0:0] }
                            */
    UINT32 valid : 1;

                            /* Bits[31:31], Access Type=RW/V, default=0x00000000*/

                            /* Register contains valid information */

  } Bits;
  UINT32 Data;

} DDRT_ERR_LOG_1ST_N1_MC_2LM_STRUCT;

/* DDRT_WR_STARVE_CTL_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x200215b4)                                                      */
/*      SPRB0 (0x200215b4)                                                      */
/*      SPRHBM (0x200215b4)                                                     */
/*      SPRC0 (0x200215b4)                                                      */
/*      SPRMCC (0x200215b4)                                                     */
/*      SPRUCC (0x200215b4)                                                     */
/* Register default value on SPRA0: 0x04000612                                  */
/* Register default value on SPRB0: 0x04000612                                  */
/* Register default value on SPRHBM: 0x04000612                                 */
/* Register default value on SPRC0: 0x04000612                                  */
/* Register default value on SPRMCC: 0x04000612                                 */
/* Register default value on SPRUCC: 0x04000612                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
      This register controls a mechanism in the DDRT scheduler to
      issue full writes when the number of writes is below the
      threshold to enter WMM, and causes the scheduler to not issue
      writes for a long interval. When this mechanism triggers entry
      into WMM, then the scheduler will enter WMM and issue a
      programmable number of writes before exiing WMM. 
      
*/


#define DDRT_WR_STARVE_CTL_MC_2LM_REG 0x071215B4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tmr : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000012*/

                            /*
                               Timer to control write starvation window. The
                               threshold field is incremented every (2timer)
                               DCLK ticks
                            */
    UINT32 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 res_threshold : 16;

                            /* Bits[23:8], Access Type=RW, default=0x00000006*/

                            /*
                               If not write is issued in a (threshold x 2timer)
                               window then DDRT WMM is forced. The scheduler
                               will remain in DDRT WMM until num_writes number
                               of writes are issued.
                            */
    UINT32 num_writes : 4;

                            /* Bits[27:24], Access Type=RW, default=0x00000004*/

                            /*
                               Number of writes to issue in WWM before exiting
                               when WMM is entered as a result of this
                               mechanism.
                            */
    UINT32 rsvd_28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_WR_STARVE_CTL_MC_2LM_STRUCT;

/* DDRT_TRIG_CTL_N0_MC_2LM_REG supported on:                                    */
/*      SPRA0 (0x200215b8)                                                      */
/*      SPRB0 (0x200215b8)                                                      */
/*      SPRHBM (0x200215b8)                                                     */
/*      SPRC0 (0x200215b8)                                                      */
/*      SPRMCC (0x200215b8)                                                     */
/*      SPRUCC (0x200215b8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/*  
     This register contains triggers for DDRT logic. CSR bit en_ddrt_dfd_clk must be
     enabled to use this register   
    
*/


#define DDRT_TRIG_CTL_N0_MC_2LM_REG 0x071215B8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 retry_state1 : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger when Retry FSM enters this state. This
                               does not trigger for entry into IDLE state.
                            */
    UINT32 retry_state2 : 4;

                            /* Bits[7:4], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger when Retry FSM enters this state. This
                               does not trigger for entry into IDLE state.
                            */
    UINT32 erid_par_err : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger when ERID correctable parity error is
                               detected.
                            */
    UINT32 erid_uc_err : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger when ERID uncorrectable error condition
                               occurs.
                            */
    UINT32 expected_nodata : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger when ERID uncorrectable error condition
                               occurs.
                            */
    UINT32 unexpected_nodata : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger when ERID uncorrectable error condition
                               occurs.
                            */
    UINT32 thermal_event : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger when ERID uncorrectable error condition
                               occurs.
                            */
    UINT32 retry_watchdog_tmr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger when DDRT Retry FSM watchdog timer
                               fires.
                            */
    UINT32 fnv_err_assert : 2;

                            /* Bits[15:14], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger when FNV Error is asserted. The LSB of
                               the field is for Slot 0 and MSB of the field is
                               for Slot 1
                            */
    UINT32 fnv_err_deassert : 2;

                            /* Bits[17:16], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger when FNV Error is de-asserted. The LSB
                               of the field is for Slot 0 and MSB of the field
                               is for Slot 1
                            */
    UINT32 ddr4_exit_events : 7;

                            /* Bits[24:18], Access Type=RW, default=0x00000000*/

                            /*
                               7 bit mask for events that cause Major Mode FSM
                               to exit DDR4 mode. The mask corresponds to the
                               following conditions that caused exit from DDR4
                               mode. Bit 6 : Retry commnads need to issue Bit 5
                               : ACK command Bit 4 : Pending DDRT commands
                               while DDR4 queue is empty Bit 3 : Major mode
                               duration threshold hit Bit 2 : DDRT command
                               starved Bit 1 : DDRT ADR Event Bit 0 : DDRT
                               maintenence command
                            */
    UINT32 ddrt_exit_events : 5;

                            /* Bits[29:25], Access Type=RW, default=0x00000000*/

                            /*
                               5 bit mask for events that cause Major Mode FSM
                               to exit DDR4 mode. The mask corresponds to the
                               following conditions that caused exit from DDRT
                               mode. Bit 4 : DDR4 ADR command Bit 3 : DDR4
                               maintenence command Bit 2 : Pending DDR4
                               commands while DDRT queue is empty Bit 1 : DDRT
                               queue is empty after waiting for min. number of
                               cycles in DDRT mode Bit 1 : Pending DDR4
                               commands after waiting for min. number of cycles
                               in DDRT mode
                            */
    UINT32 ddrt2_info_event : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger when corresponding trigger bit coming
                               from ddrt2 information packet asserts
                            */

  } Bits;
  UINT32 Data;

} DDRT_TRIG_CTL_N0_MC_2LM_STRUCT;

/* DDRT_TRIG_CTL_N1_MC_2LM_REG supported on:                                    */
/*      SPRA0 (0x200215bc)                                                      */
/*      SPRB0 (0x200215bc)                                                      */
/*      SPRHBM (0x200215bc)                                                     */
/*      SPRC0 (0x200215bc)                                                      */
/*      SPRMCC (0x200215bc)                                                     */
/*      SPRUCC (0x200215bc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/*  
     This register contains triggers for DDRT logic. CSR bit en_ddrt_dfd_clk must be
     enabled to use this register   
    
*/


#define DDRT_TRIG_CTL_N1_MC_2LM_REG 0x071215BC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddrt2_info_event : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger when corresponding trigger bit coming
                               from ddrt2 information packet asserts
                            */
    UINT32 pending_queues_idle : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger when corresponding trigger bit coming
                               from DDRT RPQ/WPQ idle indication asserts
                            */
    UINT32 wrcrdt_starvation : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger DDRT link retry when write credit
                               starvation condition is hit.
                            */
    UINT32 tgr_starvation : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger DDRT link retry when trangress
                               starvation condition (pending partial writes but
                               no VC2 DDRT write credits available) is hit.
                            */
    UINT32 illegal_ddrt2_conditions : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger DDRT link retry when we detect any
                               illegal DDRT2 condition for example - invalid
                               req pulse width detected, Info/interrupt packet
                               received on secondary subchannel, Data packet
                               came back on wrong subchannel etc.
                            */
    UINT32 wrcrdt_overflow : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Trigger DDRT link retry when we detect DDRT2
                               write credit overflow condition. Can also be
                               triggered for wrcredit_underflow cases (write
                               issued when write credits are 0)
                            */
    UINT32 rsvd : 22;

                            /* Bits[31:10], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_TRIG_CTL_N1_MC_2LM_STRUCT;

/* DDRT_DEFEATURE2_MC_2LM_REG supported on:                                     */
/*      SPRA0 (0x200215c0)                                                      */
/*      SPRB0 (0x200215c0)                                                      */
/*      SPRHBM (0x200215c0)                                                     */
/*      SPRC0 (0x200215c0)                                                      */
/*      SPRMCC (0x200215c0)                                                     */
/*      SPRUCC (0x200215c0)                                                     */
/* Register default value on SPRA0: 0x00000001                                  */
/* Register default value on SPRB0: 0x00000001                                  */
/* Register default value on SPRHBM: 0x00000001                                 */
/* Register default value on SPRC0: 0x00000001                                  */
/* Register default value on SPRMCC: 0x00000001                                 */
/* Register default value on SPRUCC: 0x00000001                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Defeature bits for DDRT controller
*/


#define DDRT_DEFEATURE2_MC_2LM_REG 0x071215C0

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_gnt_blk_cmi_idle : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /* Disable gnt blocking when CMI is idle */
    UINT32 dis_ddrt_uc_to_linkfail : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Disable going to link fail when DDRT UC error is
                               detected
                            */
    UINT32 rsvd_2 : 2;

                            /* Bits[3:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 en_any_cmd_to_ckelo : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Set this chicken bit to Cmd to CKE Lo delay for
                               Misc (Retry) and Maintenence (ZQ, Scmd, Power
                               fail) commands. Default behavior is to add the
                               delay for read and write commands. If chicken
                               bit is set, then cr_t_ddrt_pd_sxp_rdpden should
                               be programmed to tPERR2ERR When this chicken bit
                               is set then t_DDRT_PD.t_ddrt_rdpden should be
                               programmed to tPERR2ERR.
                            */
    UINT32 dis_ddrt2_parity : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /*
                               DDRT2 read data carries 3b of parity check on
                               the ERID field in the read data packet. This 3
                               bit field can be set to disable each of the 3
                               parity checks. Bit 0: Disable RIDP0 Bit 1:
                               Disable RIDP1 Bit 2: Disable RIDP2
                            */
    UINT32 dis_sre_cap_block : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to disable SR FSM in scheduler
                               from blocking Force Error command during SRE CAP
                               flows
                            */
    UINT32 dis_err_ack_rst : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               By default, MC will block re-issuing ERR_ACK if
                               the ERR# pin has gone high because of the
                               previous ERR_ACK cmd. If this bit is set to 1,
                               MC will re-issue the ERR_ACK without looking at
                               the ERR# pin.
                            */
    UINT32 dis_frc_err_rst : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               By default, MC will block re-issuing FRC_ERR if
                               the ERR# pin has gone low because of previous
                               FRC_ERR cmd. If this bit is set to 1, MC will
                               re-issue the FRC_ERR without looking at the ERR#
                               pin.
                            */
    UINT32 ddrt_defeature : 21;

                            /* Bits[31:11], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_DEFEATURE2_MC_2LM_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_gnt_blk_cmi_idle : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /* Disable gnt blocking when CMI is idle */
    UINT32 dis_ddrt_uc_to_linkfail : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Disable going to link fail when DDRT UC error is
                               detected
                            */
    UINT32 rsvd_2 : 2;

                            /* Bits[3:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 en_any_cmd_to_ckelo : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Set this chicken bit to Cmd to CKE Lo delay for
                               Misc (Retry) and Maintenence (ZQ, Scmd, Power
                               fail) commands. Default behavior is to add the
                               delay for read and write commands. If chicken
                               bit is set, then cr_t_ddrt_pd_sxp_rdpden should
                               be programmed to tPERR2ERR When this chicken bit
                               is set then t_DDRT_PD.t_ddrt_rdpden should be
                               programmed to tPERR2ERR.
                            */
    UINT32 dis_ddrt2_parity : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /*
                               DDRT2 read data carries 3b of parity check on
                               the ERID field in the read data packet. This 3
                               bit field can be set to disable each of the 3
                               parity checks. Bit 0: Disable RIDP0 Bit 1:
                               Disable RIDP1 Bit 2: Disable RIDP2
                            */
    UINT32 dis_sre_cap_block : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to disable SR FSM in scheduler
                               from blocking Force Error command during SRE CAP
                               flows
                            */
    UINT32 dis_err_ack_rst : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               By default, MC will block re-issuing ERR_ACK if
                               the ERR# pin has gone high because of the
                               previous ERR_ACK cmd. If this bit is set to 1,
                               MC will re-issue the ERR_ACK without looking at
                               the ERR# pin.
                            */
    UINT32 dis_frc_err_rst : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               By default, MC will block re-issuing FRC_ERR if
                               the ERR# pin has gone low because of previous
                               FRC_ERR cmd. If this bit is set to 1, MC will
                               re-issue the FRC_ERR without looking at the ERR#
                               pin.
                            */
    UINT32 dis_spid_bus_quiet_retry_block : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to disable this fix. Default
                               behavior will be - block triggering DDRT link
                               retry when SPID bus quiet commands are issued
                               (DQS retraining and RCOMP). Bus is expected to
                               be quiet at this point so the only async
                               triggers - CSR based and global-response logic
                               can trigger DDRT link retry.
                            */
    UINT32 dis_mnt_cmd_sec_sch_block : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Default behavior is to block all traffic on
                               DDRT2 decondary subchannel when maintenance
                               command is winning on primary subchannel. Set
                               this bit to 1 to disable the fix - 14010103403
                            */
    UINT32 dis_modea_last_retry_blk : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to disable bug fix -
                               2208211689 Mode A force correction path should
                               assert once we come out of last retry so that
                               transactions in flight are correctly dropped.
                            */
    UINT32 dis_cas_aggr_safe_blk : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to disable bug fix -
                               14010041372 Default behavior is to trigger
                               safe_timer logic on both subchannels when a
                               rd_cas / wr_cas is detected on either
                               subchannel.
                            */
    UINT32 dis_dqs_retry_block_all : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Disable DQS blocking all DDRT link retry. If set
                               to 0, DQS will block all triggers to DDRT link
                               retry.
                            */
    UINT32 dis_wrcrdt_only_starve_tmr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Disable write credit only starvation timer used
                               for credit leak detection
                            */
    UINT32 ddrt_defeature : 15;

                            /* Bits[31:17], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_DEFEATURE2_MC_2LM_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_gnt_blk_cmi_idle : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /* Disable gnt blocking when CMI is idle */
    UINT32 dis_ddrt_uc_to_linkfail : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Disable going to link fail when DDRT UC error is
                               detected
                            */
    UINT32 rsvd_2 : 2;

                            /* Bits[3:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 en_any_cmd_to_ckelo : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Set this chicken bit to Cmd to CKE Lo delay for
                               Misc (Retry) and Maintenence (ZQ, Scmd, Power
                               fail) commands. Default behavior is to add the
                               delay for read and write commands. If chicken
                               bit is set, then cr_t_ddrt_pd_sxp_rdpden should
                               be programmed to tPERR2ERR When this chicken bit
                               is set then t_DDRT_PD.t_ddrt_rdpden should be
                               programmed to tPERR2ERR.
                            */
    UINT32 dis_ddrt2_parity : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /*
                               DDRT2 read data carries 3b of parity check on
                               the ERID field in the read data packet. This 3
                               bit field can be set to disable each of the 3
                               parity checks. Bit 0: Disable RIDP0 Bit 1:
                               Disable RIDP1 Bit 2: Disable RIDP2
                            */
    UINT32 dis_sre_cap_block : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to disable SR FSM in scheduler
                               from blocking Force Error command during SRE CAP
                               flows
                            */
    UINT32 dis_err_ack_rst : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               By default, MC will block re-issuing ERR_ACK if
                               the ERR# pin has gone high because of the
                               previous ERR_ACK cmd. If this bit is set to 1,
                               MC will re-issue the ERR_ACK without looking at
                               the ERR# pin.
                            */
    UINT32 dis_frc_err_rst : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               By default, MC will block re-issuing FRC_ERR if
                               the ERR# pin has gone low because of previous
                               FRC_ERR cmd. If this bit is set to 1, MC will
                               re-issue the FRC_ERR without looking at the ERR#
                               pin.
                            */
    UINT32 dis_spid_bus_quiet_retry_block : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to disable this fix. Default
                               behavior will be - block triggering DDRT link
                               retry when SPID bus quiet commands are issued
                               (DQS retraining and RCOMP). Bus is expected to
                               be quiet at this point so the only async
                               triggers - CSR based and global-response logic
                               can trigger DDRT link retry.
                            */
    UINT32 dis_mnt_cmd_sec_sch_block : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Default behavior is to block all traffic on
                               DDRT2 decondary subchannel when maintenance
                               command is winning on primary subchannel. Set
                               this bit to 1 to disable the fix - 14010103403
                            */
    UINT32 dis_modea_last_retry_blk : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to disable bug fix -
                               2208211689 Mode A force correction path should
                               assert once we come out of last retry so that
                               transactions in flight are correctly dropped.
                            */
    UINT32 dis_cas_aggr_safe_blk : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to disable bug fix -
                               14010041372 Default behavior is to trigger
                               safe_timer logic on both subchannels when a
                               rd_cas / wr_cas is detected on either
                               subchannel.
                            */
    UINT32 en_dqs_retry_block_all : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Disable DQS blocking all DDRT link retry. If set
                               to 0, DQS will block all triggers to DDRT link
                               retry.
                            */
    UINT32 dis_wrcrdt_only_starve_tmr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Disable write credit only starvation timer used
                               for credit leak detection
                            */
    UINT32 ddrt_defeature : 15;

                            /* Bits[31:17], Access Type=RW, default=0x00000000*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_DEFEATURE2_MC_2LM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_gnt_blk_cmi_idle : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /* Disable gnt blocking when CMI is idle */
    UINT32 dis_ddrt_uc_to_linkfail : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Disable going to link fail when DDRT UC error is
                               detected
                            */
    UINT32 rsvd_2 : 2;

                            /* Bits[3:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 en_any_cmd_to_ckelo : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Set this chicken bit to Cmd to CKE Lo delay for
                               Misc (Retry) and Maintenence (ZQ, Scmd, Power
                               fail) commands. Default behavior is to add the
                               delay for read and write commands. If chicken
                               bit is set, then cr_t_ddrt_pd_sxp_rdpden should
                               be programmed to tPERR2ERR When this chicken bit
                               is set then t_DDRT_PD.t_ddrt_rdpden should be
                               programmed to tPERR2ERR.
                            */
    UINT32 dis_ddrt2_parity : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /*
                               DDRT2 read data carries 3b of parity check on
                               the ERID field in the read data packet. This 3
                               bit field can be set to disable each of the 3
                               parity checks. Bit 0: Disable RIDP0 Bit 1:
                               Disable RIDP1 Bit 2: Disable RIDP2
                            */
    UINT32 dis_sre_cap_block : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to disable SR FSM in scheduler
                               from blocking Force Error command during SRE CAP
                               flows
                            */
    UINT32 dis_err_ack_rst : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               By default, MC will block re-issuing ERR_ACK if
                               the ERR# pin has gone high because of the
                               previous ERR_ACK cmd. If this bit is set to 1,
                               MC will re-issue the ERR_ACK without looking at
                               the ERR# pin.
                            */
    UINT32 dis_frc_err_rst : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               By default, MC will block re-issuing FRC_ERR if
                               the ERR# pin has gone low because of previous
                               FRC_ERR cmd. If this bit is set to 1, MC will
                               re-issue the FRC_ERR without looking at the ERR#
                               pin.
                            */
    UINT32 rsvd : 21;

                            /* Bits[31:11], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_DEFEATURE2_MC_2LM_STRUCT;

/* DDRT_WPQ_FLUSH_CTL_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x200215c4)                                                      */
/*      SPRB0 (0x200215c4)                                                      */
/*      SPRHBM (0x200215c4)                                                     */
/*      SPRC0 (0x200215c4)                                                      */
/*      SPRMCC (0x200215c4)                                                     */
/*      SPRUCC (0x200215c4)                                                     */
/* Register default value on SPRA0: 0x20008A28                                  */
/* Register default value on SPRB0: 0x20008A28                                  */
/* Register default value on SPRHBM: 0x20008A28                                 */
/* Register default value on SPRC0: 0x20008A28                                  */
/* Register default value on SPRMCC: 0x20008A28                                 */
/* Register default value on SPRUCC: 0x20008A28                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Configures the WPQ Flush handling in DDRT scheduler.
*/


#define DDRT_WPQ_FLUSH_CTL_MC_2LM_REG 0x071215C4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddrt_mode_wpqflush_threshold : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000028*/

                            /*
                               Force scheduler to switch from DDR4 to DDRT when
                               min DDR4 mode cycle time residency is met and
                               WPQ Flush is pending in WPQ with number of
                               wpqflush writes greater than this CR value
                               (ddrt_mode_wpqflush_thr). - default 'd40
                            */
    UINT32 enter_wmm_mode_wpqflush_threshold : 6;

                            /* Bits[11:6], Access Type=RW, default=0x00000028*/

                            /*
                               Force DDRT WMM state machine to switch to WMM
                               when min residency in RMM is met and when WPQ
                               Flush is pending with number of writes greater
                               than the value programmed in this field.
                            */
    UINT32 exit_wmm_mode_wpqflush_threshold : 6;

                            /* Bits[17:12], Access Type=RW, default=0x00000008*/

                            /*
                               Force DDRT WMM state machine to switch to WMM
                               when min residency in RMM is met and when WPQ
                               Flush is pending with number of writes greater
                               thant the value in this field. Note taht the
                               default of 8 is the same as
                            */
    UINT32 rsvd : 10;

                            /* Bits[27:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 force_wpqflush_ack : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to force DDRT scheduler to issue an Ack
                               for an allocated WPQ flush without waiting for
                               other writes to drain. This is only applied on
                               the rising edge of this CSR; when changing the
                               CSR from a 0 to a 1, it immediately acks any
                               pending WPQ flush. It will not cause later WPQ
                               flushes to immediately ack. To auto-ack all WPQ
                               flushes, without having to change the CSR from a
                               0 to 1 each time, simply set wpqflush_enable = 0
                               instead.
                            */
    UINT32 wpqflush_ack_for_linkfail : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               If this bit is clear, WPQ flush acks are blocked
                               once a channel hits link fail condition. If this
                               bit is set (default), MC will send an ACK for
                               WPQ flush even in link fail condition. This bit
                               is used for WPQ flush directed to DDRT.
                            */
    UINT32 wpqflush_snapshot_all_wrs : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Default behavior of WPQ flush is to snapshot all
                               outstanding writes to persistent or block region
                               when a WPQ flush instruction is seen. If this
                               bit is set then debug defeature is set then
                               snapshot ALL wrs in DDRT WPQ.
                            */
    UINT32 wpqflush_enable : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Enable WPQ Flush operation. */

  } Bits;
  UINT32 Data;

} DDRT_WPQ_FLUSH_CTL_MC_2LM_STRUCT;


/* DDRT_STARVE_CTL2_MC_2LM_REG supported on:                                    */
/*      SPRA0 (0x200215cc)                                                      */
/*      SPRB0 (0x200215cc)                                                      */
/*      SPRHBM (0x200215cc)                                                     */
/*      SPRC0 (0x200215cc)                                                      */
/*      SPRMCC (0x200215cc)                                                     */
/*      SPRUCC (0x200215cc)                                                     */
/* Register default value on SPRA0: 0xC3FC3FF7                                  */
/* Register default value on SPRB0: 0xC3FC3FF7                                  */
/* Register default value on SPRHBM: 0xC3FC3FF7                                 */
/* Register default value on SPRC0: 0xC3FC3FF7                                  */
/* Register default value on SPRMCC: 0xC3FC3FF7                                 */
/* Register default value on SPRUCC: 0xC3FC3FF7                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register chicken bits and bits to control anti-starvation schemes
*/


#define DDRT_STARVE_CTL2_MC_2LM_REG 0x071215CC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rid_underfill_entry : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000017*/

                            /*
                               Reserved underfill read number in RDB. This
                               field must be programmed to the same value as
                               reg_ddrt_datapath_delay.rid_underfill_entry
                            */
    UINT32 enable_rid_underfill : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*
                               Enable bit for reserved underfill read entry in
                               RDB. This field must be programmed to the same
                               value as
                               reg_ddrt_datapath_delay.enable_rid_underfill
                            */
    UINT32 rpq_idle_threshold : 12;

                            /* Bits[17:6], Access Type=RW, default=0x000000FF*/

                            /*
                               Trigger error flow if DDRT RPQ entries have not
                               changed for a long time. Counter counts till
                               rpq_idle_threshold time and then triggers error
                               flow. Please set to 0 to disable the counter.
                            */
    UINT32 wpq_idle_threshold : 12;

                            /* Bits[29:18], Access Type=RW, default=0x000000FF*/

                            /*
                               Trigger error flow if DDRT WPQ entries have not
                               changed for a long time. Counter counts till
                               wpq_idle_threshold time and then triggerserror
                               flow. please set to 0 to disable the counter.
                            */
    UINT32 wrcrdt_starve_ddrt_flow : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000001*/

                            /*
                               Trigger DDRT srcrdt_starvation flow (ICX/CLX)
                               when this bit is set. DDRT flow will issue
                               Grants and look for write credits in the read
                               data packets. On SPR (DDRT2), set this bit to 0.
                            */
    UINT32 tgr_starve_ddrt_flow : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               Trigger DDRT trangress starvation flow (ICX/CLX)
                               when this bit is set. DDRT flow will issue
                               Grants for partial writes even if we don't have
                               any VC2 credits available.
                            */

  } Bits;
  UINT32 Data;

} DDRT_STARVE_CTL2_MC_2LM_STRUCT;

/* DDRT_CREDIT_LIMIT_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x200215d0)                                                      */
/*      SPRB0 (0x200215d0)                                                      */
/*      SPRHBM (0x200215d0)                                                     */
/*      SPRC0 (0x200215d0)                                                      */
/*      SPRMCC (0x200215d0)                                                     */
/*      SPRUCC (0x200215d0)                                                     */
/* Register default value on SPRA0: 0x07F00028                                  */
/* Register default value on SPRB0: 0x07F00028                                  */
/* Register default value on SPRHBM: 0x07F00028                                 */
/* Register default value on SPRC0: 0x07F00028                                  */
/* Register default value on SPRMCC: 0x07F00028                                 */
/* Register default value on SPRUCC: 0x07F00028                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR-T Read and Write credits per DIMM
*/


#define DDRT_CREDIT_LIMIT_MC_2LM_REG 0x071215D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddrt_rd_credit : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000028*/

                            /*
                               Max 64B Pending Read Credit to FM (FNV RPQ
                               Depth)
                            */
    UINT32 ddrt_wr_credit : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Max 64B Pending Write Credit to FM (FNV WPQ
                               depth)
                            */
    UINT32 min_rd_credit_partials : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000000*/

                            /*
                               DDRT Reads from the Read Pending Queue are
                               scheduled only if the number of available SXP
                               Read credits is greater than the value
                               programmed in this field. This reserves a
                               minimum number of DDRT read credits for the
                               background underfill read for partial writes
                            */
    UINT32 max_req_cnt : 7;

                            /* Bits[26:20], Access Type=RW, default=0x0000007F*/

                            /*
                               Maximum number of Read REQs per channel from
                               3DXPoint controller. If the number of reqs
                               reaches this threshold then the scheduler
                               ignores new reqs. Programming this value to 0
                               disables this check and the counter to track
                               reqs will increment for new Read Reqs and
                               possibly roll over
                            */
    UINT32 reserved : 5;

                            /* Bits[31:27], Access Type=RW, default=0x00000000*/

                            /* Reserved for future use. */

  } Bits;
  UINT32 Data;

} DDRT_CREDIT_LIMIT_MC_2LM_STRUCT;

/* MODE_MIN_RESIDENCY_THRESHOLD_MC_2LM_REG supported on:                        */
/*      SPRA0 (0x200215d4)                                                      */
/*      SPRB0 (0x200215d4)                                                      */
/*      SPRHBM (0x200215d4)                                                     */
/*      SPRC0 (0x200215d4)                                                      */
/*      SPRMCC (0x200215d4)                                                     */
/*      SPRUCC (0x200215d4)                                                     */
/* Register default value on SPRA0: 0x00200020                                  */
/* Register default value on SPRB0: 0x00200020                                  */
/* Register default value on SPRHBM: 0x00200020                                 */
/* Register default value on SPRC0: 0x00200020                                  */
/* Register default value on SPRMCC: 0x00200020                                 */
/* Register default value on SPRUCC: 0x00200020                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDRT idle cycle threshold before releasing current major mode
*/


#define MODE_MIN_RESIDENCY_THRESHOLD_MC_2LM_REG 0x071215D4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddrt : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000020*/

                            /*
                               This field is not used. Refer to
                               MODE_STARVE_CYCLE_THRESHOLD.DDRT
                            */
    UINT32 ddr4 : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000020*/

                            /*
                               This field is not used. Refer to
                               MODE_STARVE_CYCLE_THRESHOLD.DDR4
                            */

  } Bits;
  UINT32 Data;

} MODE_MIN_RESIDENCY_THRESHOLD_MC_2LM_STRUCT;

/* DDRT_CONFIG_CTL_MC_2LM_REG supported on:                                     */
/*      SPRA0 (0x200215d8)                                                      */
/*      SPRB0 (0x200215d8)                                                      */
/*      SPRHBM (0x200215d8)                                                     */
/*      SPRC0 (0x200215d8)                                                      */
/*      SPRMCC (0x200215d8)                                                     */
/*      SPRUCC (0x200215d8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Configure DDRT mode and other key parameters for DDRT
*/


#define DDRT_CONFIG_CTL_MC_2LM_REG 0x071215D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddrt2_mode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* 0 - DDRT Mode 1 - DDRT2 Mode */
    UINT32 single_subchn_mode : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               DDRT2 modes - 0 - Two Subchannels Mode 1 -
                               Single Subchannel Mode Should not be used for
                               DDRT mode!
                            */
    UINT32 primary_subchn : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Some DDRT2 commands can be issued only to a
                               specific sub-channel even when both sub-channels
                               are present on the system. This register is
                               programmed to reflect the sub-channel that
                               should be issued to use the special commands
                               when the MC is in two-subchannels mode. In
                               single sub channel mode, this field represents
                               the active sub-channel. 0 - Single subchannel
                               mode - subchannel 0 is active 1 - Single
                               subchannel mode - subchannel 1 is active Should
                               not be used for DDRT mode!
                            */
    UINT32 subchn_sel_mode : 2;

                            /* Bits[4:3], Access Type=RW, default=0x00000000*/

                            /*
                               Different modes for subchannel differentiation
                               logic based on Address bits - DDRT2 - 00 -
                               Addr[7] 01 - Addr[8] 10 - Addr[12] 11 - Invalid
                               DDRT (theoretical for design purpose) - 00 -
                               Addr[7] 01 - Addr[8] 10 - Addr[12] 11 - Based on
                               odd/even pending queue entry. Address is not
                               used to assign subchannel bit to a new request.
                            */
    UINT32 rsvd : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_CONFIG_CTL_MC_2LM_STRUCT;

/* DDRT_STARVE_CTL_MC_2LM_REG supported on:                                     */
/*      SPRA0 (0x200215e4)                                                      */
/*      SPRB0 (0x200215e4)                                                      */
/*      SPRHBM (0x200215e4)                                                     */
/*      SPRC0 (0x200215e4)                                                      */
/*      SPRMCC (0x200215e4)                                                     */
/*      SPRUCC (0x200215e4)                                                     */
/* Register default value on SPRA0: 0x0020020A                                  */
/* Register default value on SPRB0: 0x0020020A                                  */
/* Register default value on SPRHBM: 0x0020020A                                 */
/* Register default value on SPRC0: 0x0020020A                                  */
/* Register default value on SPRMCC: 0x0020020A                                 */
/* Register default value on SPRUCC: 0x0020020A                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
      This register controls a mechanism in the DDRT scheduler to
      issue GNT when there is no BL egress credit to get write credit
      back from FNV, or to issue GNT for transgress underfill read 
      when there is no general purpose BL egress credit. This register
      controls the period after above condition occurs that such a GNT 
      can be issued.
      
*/


#define DDRT_STARVE_CTL_MC_2LM_REG 0x071215E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tmr : 6;

                            /* Bits[5:0], Access Type=RW, default=0x0000000A*/

                            /*
                               Timer to control write starvation window. The
                               threshold field is incremented every (2timer)
                               DCLK ticks
                            */
    UINT32 stop_rd : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, stops issuing new DDRT read when
                               TGR starvation is detected. Ensures TGR data
                               will be received.
                            */
    UINT32 wr_cmpl_fifo_crdt_dis : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, do not check for DDRT wr cmpl
                               fifo credits
                            */
    UINT32 wrcrdt_threshold : 12;

                            /* Bits[19:8], Access Type=RW, default=0x00000002*/

                            /*
                               If the condition of no BL egress credit and no
                               write credit lasts for (threshold x 2timer)
                               period, then a GNT is allowed to be issued. The
                               read data coming back will be dropped.
                            */
    UINT32 tgr_threshold : 12;

                            /* Bits[31:20], Access Type=RW, default=0x00000002*/

                            /*
                               If the condition of no general purpose BL egress
                               credit and transgress underfill read available
                               lasts for (threshold x 2timer) period, then a
                               GNT is allowed to be issued. The read data
                               coming back will be dropped if it is not for any
                               transgress underfill read.
                            */

  } Bits;
  UINT32 Data;

} DDRT_STARVE_CTL_MC_2LM_STRUCT;

/* DDRT_TIMING_MC_2LM_REG supported on:                                         */
/*      SPRA0 (0x200215e8)                                                      */
/*      SPRB0 (0x200214ac)                                                      */
/*      SPRHBM (0x200214ac)                                                     */
/*      SPRC0 (0x200214ac)                                                      */
/*      SPRMCC (0x200214ac)                                                     */
/*      SPRUCC (0x200214ac)                                                     */
/* Register default value on SPRA0: 0x00000600                                  */
/* Register default value on SPRB0: 0x00000600                                  */
/* Register default value on SPRHBM: 0x00000600                                 */
/* Register default value on SPRC0: 0x00000600                                  */
/* Register default value on SPRMCC: 0x00000600                                 */
/* Register default value on SPRUCC: 0x00000600                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DDR-T Timing register.
*/


#define DDRT_TIMING_MC_2LM_REG 0x071A0005

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 8;

                            /* Bits[7:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rid2dealloc : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000006*/

                            /*
                               This field controls the delay from when the MC
                               sees RID to the deallocation of the entry in the
                               T-RPQ.
                            */
    UINT32 rsvd_16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_TIMING_MC_2LM_STRUCT;

/* DDRT_ECC_MODE_A_INFO_MC_2LM_REG supported on:                                */
/*      SPRA0 (0x200215ec)                                                      */
/*      SPRB0 (0x200215ec)                                                      */
/*      SPRHBM (0x200215ec)                                                     */
/*      SPRC0 (0x200215ec)                                                      */
/*      SPRMCC (0x200215ec)                                                     */
/*      SPRUCC (0x200215ec)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This csr is used in DDRT ECC mode A. It holds the threshold for the number of link retries caused due to ecc errors.
             Also has a bit to reset the counter
*/


#define DDRT_ECC_MODE_A_INFO_MC_2LM_REG 0x071215EC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cnt_threshold : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /*
                               Threshold for the number of times the link retry
                               fsm is invoked due to ecc error before forcing
                               furture ddrt ecc errors through the correction
                               path
                            */
    UINT32 reset_count : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* Reset the counter */
    UINT32 reset_modea : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Reset the counter */
    UINT32 rsvd : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_ECC_MODE_A_INFO_MC_2LM_STRUCT;

/* DDRT_M2M_CREDIT_COUNT_MC_2LM_REG supported on:                               */
/*      SPRA0 (0x200215f0)                                                      */
/*      SPRB0 (0x200215f0)                                                      */
/*      SPRHBM (0x200215f0)                                                     */
/*      SPRC0 (0x200215f0)                                                      */
/*      SPRMCC (0x200215f0)                                                     */
/*      SPRUCC (0x200215f0)                                                     */
/* Register default value on SPRA0: 0x30300000                                  */
/* Register default value on SPRB0: 0x30300000                                  */
/* Register default value on SPRHBM: 0x30300000                                 */
/* Register default value on SPRC0: 0x30300000                                  */
/* Register default value on SPRMCC: 0x30300000                                 */
/* Register default value on SPRUCC: 0x30300000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* DDRT current credit count/state.  For debug. 
*/


#define DDRT_M2M_CREDIT_COUNT_MC_2LM_REG 0x071215F0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 16;

                            /* Bits[15:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 m2m_rd_cr_cnt : 8;

                            /* Bits[23:16], Access Type=RO/V, default=0x00000030*/

                            /* Current 64B Pending Read Credit Count to M2M */
    UINT32 m2m_wr_cr_cnt : 8;

                            /* Bits[31:24], Access Type=RO/V, default=0x00000030*/

                            /* Current 64B Pending Write Credit Count to M2M */

  } Bits;
  UINT32 Data;

} DDRT_M2M_CREDIT_COUNT_MC_2LM_STRUCT;

/* DDRT_CREDIT_COUNT_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x200215f8)                                                      */
/*      SPRB0 (0x200215f8)                                                      */
/*      SPRHBM (0x200215f8)                                                     */
/*      SPRC0 (0x200215f8)                                                      */
/*      SPRMCC (0x200215f8)                                                     */
/*      SPRUCC (0x200215f8)                                                     */
/* Register default value on SPRA0: 0x38283828                                  */
/* Register default value on SPRB0: 0x38283828                                  */
/* Register default value on SPRHBM: 0x38283828                                 */
/* Register default value on SPRC0: 0x38283828                                  */
/* Register default value on SPRMCC: 0x38283828                                 */
/* Register default value on SPRUCC: 0x38283828                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* DDRT current credit count/state
*/


#define DDRT_CREDIT_COUNT_MC_2LM_REG 0x071215F8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddrt_rd_cr_cnt_ddrt0 : 8;

                            /* Bits[7:0], Access Type=RO/V, default=0x00000028*/

                            /*
                               Current count of Read credits to FM consumed on
                               rank 0
                            */
    UINT32 ddrt_wr_cr_cnt_ddrt0 : 8;

                            /* Bits[15:8], Access Type=RO/V, default=0x00000038*/

                            /*
                               Current count of Write credits to FM consumed on
                               rank 0
                            */
    UINT32 ddrt_rd_cr_cnt_ddrt1 : 8;

                            /* Bits[23:16], Access Type=RO/V, default=0x00000028*/

                            /*
                               Current count of Read credits to FM consumed on
                               rank 1
                            */
    UINT32 ddrt_wr_cr_cnt_ddrt1 : 8;

                            /* Bits[31:24], Access Type=RO/V, default=0x00000038*/

                            /*
                               Current count of Write credits to FM consumed on
                               rank 1
                            */

  } Bits;
  UINT32 Data;

} DDRT_CREDIT_COUNT_MC_2LM_STRUCT;

/* DDRT_RETRY_TIMER_STATUS_LO_MC_2LM_REG supported on:                          */
/*      SPRA0 (0x200215fc)                                                      */
/*      SPRB0 (0x200215fc)                                                      */
/*      SPRHBM (0x200215fc)                                                     */
/*      SPRC0 (0x200215fc)                                                      */
/*      SPRMCC (0x200215fc)                                                     */
/*      SPRUCC (0x200215fc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/*  
     This register shows the lower 32b of the DDRT Retry Timer. 
    
*/


#define DDRT_RETRY_TIMER_STATUS_LO_MC_2LM_REG 0x071215FC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cnt : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /* Lower 32b of Retry FSM watchdog timer. */

  } Bits;
  UINT32 Data;

} DDRT_RETRY_TIMER_STATUS_LO_MC_2LM_STRUCT;

/* DDRT_GLBRSP_CTL_MC_2LM_REG supported on:                                     */
/*      SPRA0 (0x20021600)                                                      */
/*      SPRB0 (0x20021600)                                                      */
/*      SPRHBM (0x20021600)                                                     */
/*      SPRC0 (0x20021600)                                                      */
/*      SPRMCC (0x20021600)                                                     */
/*      SPRUCC (0x20021600)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/*  
     This register contains control DDRT logic to handle Global
     Response logic. Each 2b field control the response to the trigger
     using the following encoding
     00 - Dont inject
     01 - Use Trigger 0
     10 - Use Trigger 1
     11 - Use Trigger 2
    
*/


#define DDRT_GLBRSP_CTL_MC_2LM_REG 0x07121600

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 trigger_retry_fsm : 2;

                            /* Bits[1:0], Access Type=RW/L, default=0x00000000*/

                            /* Kick off the Retry FSM */
    UINT32 enter_ddr4_mm : 2;

                            /* Bits[3:2], Access Type=RW/L, default=0x00000000*/

                            /*
                               Switch from DDRT to DDR4 major mode as soon as
                               the minimum duration in DDRT mode is met.
                            */
    UINT32 enter_ddrt_mm : 2;

                            /* Bits[5:4], Access Type=RW/L, default=0x00000000*/

                            /*
                               Switch from DDR4 to DDRT major mode as soon as
                               the minimum duration in DDR4 mode is met.
                            */
    UINT32 start_cmd_block : 2;

                            /* Bits[7:6], Access Type=RW/L, default=0x00000000*/

                            /*
                               Start blocking commands from DDRT scheduler
                               using the command mask programmed in cmd_mask
                               field. If end_cmd_block = 0, then command will
                               be blocked as long as the global response output
                               selected here is asserted. If end_cmd_block > 0,
                               then command will be blocked until the global
                               response output selected by end_cmd_block is
                               asserted.
                            */
    UINT32 end_cmd_block : 2;

                            /* Bits[9:8], Access Type=RW/L, default=0x00000000*/

                            /*
                               Clear blocking commands from DDRT scheduler
                               using the command mask programmed in cmd_mask
                               field.
                            */
    UINT32 cmd_mask : 9;

                            /* Bits[18:10], Access Type=RW/L, default=0x00000000*/

                            /*
                               Mask to control which DDRT commands should be
                               blocked using start_cmd_block and end_cmd_block
                               knobs. Bit 8 : Misc Cmd (Retry and Intr_Ack
                               related Cmds) Misc command block is expected to
                               de-assert as soon as DDRT Link Retry is hit.
                               (Back2back commands - viral and err_ack - can
                               behave incorrectly if this block goes down
                               abruptly when DDRT Link retry is ON) (Misc cmd
                               block for force_err commands should de-assert
                               before linkfail threshold is hit) Bit 7 : CKE
                               High Cmd for DDRT2 only Bit 6 : CKE Low Cmd for
                               DDRT2 only Bit 5 : Maintenence Cmd (Back2back
                               command - powerfail - can behave incorrectly if
                               this block goes down abruptly after ADR command)
                               Bit 4 : RPQ GNT Bit 3 : RPQ Read Bit 2 : WPQ GNT
                               Bit 1 : WPQ Read Bit 0 : WPQ Write
                            */
    UINT32 block_m2m_crdt : 2;

                            /* Bits[20:19], Access Type=RW/L, default=0x00000000*/

                            /*
                               Block credit returns to M2M as long as the
                               global response trigger is asserted
                            */
    UINT32 spare : 8;

                            /* Bits[28:21], Access Type=RW/L, default=0x00000000*/

                            /* Spare */
    UINT32 rsvd : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_GLBRSP_CTL_MC_2LM_STRUCT;

/* DDRT_RPQ_DUMP_CFG2_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x20021604)                                                      */
/*      SPRB0 (0x20021604)                                                      */
/*      SPRHBM (0x20021604)                                                     */
/*      SPRC0 (0x20021604)                                                      */
/*      SPRMCC (0x20021604)                                                     */
/*      SPRUCC (0x20021604)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* generated by critter 20_0_0x32c
*/


#define DDRT_RPQ_DUMP_CFG2_MC_2LM_REG 0x07121604

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 trigcount : 30;

                            /* Bits[29:0], Access Type=RW, default=0x00000000*/

                            /*
                               number of triggers to count before dump to RPQ
                               dump reg
                            */
    UINT32 valid : 1;

                            /* Bits[30:30], Access Type=RW/V/L, default=0x00000000*/

                            /*
                               trigger count hit and RPQ dump reg contents are
                               valid Locked by MC_ARRAY_DUMP_LCK bit in
                               EPMCDDRT_DFX_LCK_CNTL uCR register. When locked,
                               the VALID bit is cleared and the RPQ dump is
                               disabled.
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_RPQ_DUMP_CFG2_MC_2LM_STRUCT;

/* DDRT_WPQ_DUMP_CFG2_MC_2LM_REG supported on:                                  */
/*      SPRA0 (0x20021608)                                                      */
/*      SPRB0 (0x20021608)                                                      */
/*      SPRHBM (0x20021608)                                                     */
/*      SPRC0 (0x20021608)                                                      */
/*      SPRMCC (0x20021608)                                                     */
/*      SPRUCC (0x20021608)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* generated by critter 20_0_0x32c
*/


#define DDRT_WPQ_DUMP_CFG2_MC_2LM_REG 0x07121608

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 trigcount : 30;

                            /* Bits[29:0], Access Type=RW, default=0x00000000*/

                            /*
                               number of triggers to count before dump to RPQ
                               dump reg
                            */
    UINT32 valid : 1;

                            /* Bits[30:30], Access Type=RW/V/L, default=0x00000000*/

                            /*
                               trigger count hit and RPQ dump reg contents are
                               valid Locked by MC_ARRAY_DUMP_LCK bit in
                               EPMCDDRT_DFX_LCK_CNTL uCR register. When locked,
                               the VALID bit is cleared and the RPQ dump is
                               disabled.
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_WPQ_DUMP_CFG2_MC_2LM_STRUCT;

/* DDRT_RETRY_CTL_N0_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x20021610)                                                      */
/*      SPRB0 (0x20021610)                                                      */
/*      SPRHBM (0x20021610)                                                     */
/*      SPRC0 (0x20021610)                                                      */
/*      SPRMCC (0x20021610)                                                     */
/*      SPRUCC (0x20021610)                                                     */
/* Register default value on SPRA0: 0x821D0162                                  */
/* Register default value on SPRB0: 0x821D0162                                  */
/* Register default value on SPRHBM: 0x821D0162                                 */
/* Register default value on SPRC0: 0x821D0162                                  */
/* Register default value on SPRMCC: 0x821D0162                                 */
/* Register default value on SPRUCC: 0x821D0162                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* DDRT RW Major Mode Thresholds
*/


#define DDRT_RETRY_CTL_N0_MC_2LM_REG 0x07121610

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 trigger_retry : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               A 0 to 1 transition in this fields force the
                               Retry FSM out of Idle.
                            */
    UINT32 reissue_err_ack : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to force the Retry FSM to keep
                               injecting the Error Ack Command until the Error
                               signal is de-asserted. If this bit is not set,
                               then the FSM will inject Err Ack once and go to
                               Link Fail is the DDR-T Error pin from any
                               populated DDR-T slot is not de-asserted.
                            */
    UINT32 reset_err_cnt : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to reset all error counts and
                               timers related to DDRT Retry FSM. The count will
                               remain at 0 as long as this bit is a 1
                            */
    UINT32 pending_queue_idle : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to trigger DDRT Retry FSM when DDRT
                               RPQ/WPQ are idle. Counter will count till
                               DDRT_STARVE_CTL2.pending_queue_idle_threshold
                               before issuing a retry if this bit is set.
                            */
    UINT32 inj_cnt_limit : 4;

                            /* Bits[7:4], Access Type=RW, default=0x00000006*/

                            /*
                               Number of times Force Error command is issued
                               unsuccessfully in each DDRT Retry flow iteration
                               to trigger Link Fail condition. A value of 0 in
                               this field disables the check.
                            */
    UINT32 queue_empty_chk : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               When set to 1, DDRT retry timer should always
                               count when DDRT queues are empty When set to 0,
                               DDRT retry timer will count when the MC is in
                               DDRT mode irrespective of whether the DDRT
                               queues are empty or not. This is a debug option
                            */
    UINT32 force_write_drain : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Default behavior is to unblock DDRT reads as
                               soon as FNV_ERR is de-asserted and to not wait
                               for writes to drain. If the CSR bit is set then
                               Retry FSM will wait for writes to drain before
                               going back to Idle.
                            */
    UINT32 force_timer_non_ddrt_mode : 7;

                            /* Bits[16:10], Access Type=RW, default=0x00000040*/

                            /*
                               For wait timer in each state, force timer to
                               count when not in DDRT mode. Bit 10 -
                               FORCE_ERROR state Bit 11 - RD_FLUSH state Bit 12
                               - RD_DRAIN state Bit 13 - POST_RD_DRAIN state
                               Bit 14 - ISSUE_ERR_ACK state Bit 15 - FAILURE
                               state Bit 16 - SUCCESS state
                            */
    UINT32 link_fail_max_rd : 4;

                            /* Bits[20:17], Access Type=RW, default=0x0000000E*/

                            /*
                               Maximum number of DDRT reads allowed after link
                               goes to link fail mode.
                            */
    UINT32 link_fail_block_width : 5;

                            /* Bits[25:21], Access Type=RW, default=0x00000010*/

                            /*
                               Number of cycles to assert block to M2M for
                               after a DDRT read in DDRT Link Fail state.
                            */
    UINT32 link_fail_block_disable : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit so that DDRT Retry FSM does not
                               assert Block to M2M for DDRT Reads in Retry Link
                               Fail State.
                            */
    UINT32 retry_on_wrcrdt_starve : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Set this CSR to trigger DDRT link retry flow
                               when write credit starvation condition is hit.
                            */
    UINT32 retry_on_tgr_starve : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Set this CSR to trigger DDRT link retry flow
                               when transgress starvation condition is hit.
                            */
    UINT32 retry_on_illegal_ddrt2_conditions : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Set this CSR to trigger DDRT link retry flow
                               when illegal conditions happen for DDRT2
                               (example - Invalid req pulse width detected,
                               Info/interrupt packet received on secondary
                               subchannel, Data packet came back on wrong
                               subchannel etc)
                            */
    UINT32 retry_on_wrcrdt_overflow : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Set this CSR to trigger DDRT link retry flow
                               when DDRT2 write credit overflow happens. Can be
                               also applied to wr_crdt underflow (issued write
                               when write credits are 0) based on another CSR.
                            */
    UINT32 retry_on_dup_cmd_cpl : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               Trigger retry when a duplicate cmd (early)
                               completion is going to CMI. These cmd
                               completions will be dropped. Set this bit to 1
                               to enable this feature.
                            */

  } Bits;
  UINT32 Data;

} DDRT_RETRY_CTL_N0_MC_2LM_STRUCT;

/* DDRT_RETRY_CTL_N1_MC_2LM_REG supported on:                                   */
/*      SPRA0 (0x20021614)                                                      */
/*      SPRB0 (0x20021614)                                                      */
/*      SPRHBM (0x20021614)                                                     */
/*      SPRC0 (0x20021614)                                                      */
/*      SPRMCC (0x20021614)                                                     */
/*      SPRUCC (0x20021614)                                                     */
/* Register default value on SPRA0: 0x00000006                                  */
/* Register default value on SPRB0: 0x00000006                                  */
/* Register default value on SPRHBM: 0x00000006                                 */
/* Register default value on SPRC0: 0x00000006                                  */
/* Register default value on SPRMCC: 0x00000006                                 */
/* Register default value on SPRUCC: 0x00000006                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR  */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_2lmddrt_crnode/MEM_MC2LM_CSR */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* DDRT RW Major Mode Thresholds
*/


#define DDRT_RETRY_CTL_N1_MC_2LM_REG 0x07121614

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 err_ack_cnt_limit : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000006*/

                            /*
                               Number of times Error Ack command is issued
                               unsuccessfully in each DDRT Retry flow iteration
                               to trigger Link Fail condition. A value of 0 in
                               this field disables the check.
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_RETRY_CTL_N1_MC_2LM_STRUCT;
#endif /* _MC_2LM_h */
