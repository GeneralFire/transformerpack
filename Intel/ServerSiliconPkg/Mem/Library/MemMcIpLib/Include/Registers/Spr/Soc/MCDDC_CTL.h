
/** @file
  MCDDC_CTL.h

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2007 - 2020 Intel Corporation. <BR>
  
  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.
  
  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.
  
  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
  
  This file contains Silicon register definitions.
  
  This is a generated file; please do not modify it directly.
  
**/

/* The following security policy groups are used by registers in this file:     */

/* SPRA0 Security Policy Groups:                                                */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRB0 Security Policy Groups:                                                */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRHBM Security Policy Groups:                                               */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRC0 Security Policy Groups:                                                */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRMCC Security Policy Groups:                                               */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRUCC Security Policy Groups:                                               */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* ERR_INJ                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */


#ifndef _MCDDC_CTL_h
#define _MCDDC_CTL_h
#include <Base.h>

/* CPGC_MISCCKECTL_MCDDC_CTL_REG supported on:                                  */
/*      SPRA0 (0x20021800)                                                      */
/*      SPRB0 (0x20021800)                                                      */
/*      SPRHBM (0x20021800)                                                     */
/*      SPRC0 (0x20021800)                                                      */
/*      SPRMCC (0x20021800)                                                     */
/*      SPRUCC (0x20021800)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* CPGC CKE Control -
This register is used to control CKE powerdown and ODT operation in REUT mode.
CKE powerdown will be issued by the normal CKE functional logic and must be induced by programming the appropriate delays between sub-sequences to initiate.
*/


#define CPGC_MISCCKECTL_MCDDC_CTL_REG 0x0B021800

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cke_override : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               CKE_Override is a 8-bit field, one bit per
                               logical rank. The LSB relates to Rank0 and the
                               MSB relates to the highest Rank. When
                               CKE_Override is set to 1 for a rank, the CKE
                               functional logic will be bypassed and the CKE_On
                               value for that rank will be used. When
                               CKE_Override is set to 0 for a rank, the CKE
                               functional logic will drive the CKE value for
                               that rank.
                            */
    UINT32 refresh_enable : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Per Channel Refresh enable If cold reset, this
                               bit should be set by bios after 1) Initializing
                               the refresh timing parameters 2) Running DDR
                               through reset and init sequence If warm reset or
                               S3 exit, this bit should be set immediately
                               after SR exit
                            */
    UINT32 rsvd : 6;

                            /* Bits[14:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cke_on : 8;

                            /* Bits[22:15], Access Type=RW, default=0x00000000*/

                            /*
                               CKE_on is a 8-bit field, one bit per rank. The
                               LSB relates to Rank0 and the MSB relates to the
                               highest Rank. In REUT mode when the per rank bit
                               is set CKE will be always on for that rank.
                            */
    UINT32 rsvd_23 : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_MISCCKECTL_MCDDC_CTL_STRUCT;

/* CPGC_MISCODTCTL_MCDDC_CTL_REG supported on:                                  */
/*      SPRA0 (0x20021804)                                                      */
/*      SPRB0 (0x20021804)                                                      */
/*      SPRHBM (0x20021804)                                                     */
/*      SPRC0 (0x20021804)                                                      */
/*      SPRMCC (0x20021804)                                                     */
/*      SPRUCC (0x20021804)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* CPGC ODT Control -
This register is used to control CKE powerdown and ODT operation in REUT mode.
CKE powerdown will be issued by the normal CKE functional logic and must be induced by programming the appropriate delays between subsequences to initiate.
*/


#define CPGC_MISCODTCTL_MCDDC_CTL_REG 0x0B021804

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 odt_override : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               ODT_Override is a 6-bit field, one bit per rank.
                               The LSB relates to Rank0 and the MSB relates to
                               the highest Rank. When ODT_Override is set to 1
                               for a rank, the ODT functional logic will be
                               bypassed and the ODT_On value for that rank will
                               be used. When ODT_Override is set to 0 for a
                               rank, the ODT functional logic will drive the
                               ODT value for that rank.
                            */
    UINT32 rsvd : 11;

                            /* Bits[14:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 odt_on : 4;

                            /* Bits[18:15], Access Type=RW, default=0x00000000*/

                            /*
                               ODT_on is a 6-bit field, one bit per rank. The
                               LSB relates to Rank0 and the MSB relates to the
                               highest Rank. When ODT_Override is set to 1 for
                               a rank the value in ODT_On will be used as the
                               ODT value for that rank.
                            */
    UINT32 rsvd_19 : 11;

                            /* Bits[29:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddr5_convert_rd_to_mrr : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               When set, DDR5 RD/RDA commands are converted to
                               MRR commands. This should only be set for
                               training and only affects DDR5 operation.
                            */
    UINT32 mpr_train_ddr_on : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is to be set during DDR training. The
                               MPR pattern (Hardcoded 0101 pattern) from the
                               DRAM will be used to initially train the read
                               timing. This MPR pattern is accessed via the MR3
                               DRAM register and, per the JEDEC spec, the mode
                               comes with two key limitations: 1. Before
                               entering this mode, all pages must be
                               precharges. 2. Once in this mode, the MC can
                               only issue RD or RDA commands. When this CR bit
                               is set, the RAS# and WE# will always drive high.
                               This will morph any command from the scheduler
                               into either READ or DESELECT. The flow is as
                               follows: 1. MRS Mode to write MR3 2. Set
                               MPR_Train_DDR_On 3. Set REUT Mode 4. Wait for
                               all pages to close (page table idle counter to
                               expire) 5. Run REUT Test 6. Stop Test, clear
                               MPR_Train_DDR_On bit, clear MR3 register 7.
                               Continue with other REUT tests Note that ZQ, CKE
                               and Refresh should be disabled using the
                               appropriate CR settings during MPR_Train_DDR_On
                            */

  } Bits;
  UINT32 Data;

} CPGC_MISCODTCTL_MCDDC_CTL_STRUCT;

/* CPGC_MISCREFCTL_MCDDC_CTL_REG supported on:                                  */
/*      SPRA0 (0x20021808)                                                      */
/*      SPRB0 (0x20021808)                                                      */
/*      SPRHBM (0x20021808)                                                     */
/*      SPRC0 (0x20021808)                                                      */
/*      SPRMCC (0x20021808)                                                     */
/*      SPRUCC (0x20021808)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* CPGC Refresh Control -
This register is used to control refresh operation in REUT mode.
Refreshes will be issued by the REUT block in a sequential circular rank order - Rank0, Rank1, Rank2, Rank3, Rank0, Rank1, etc.
*/


#define CPGC_MISCREFCTL_MCDDC_CTL_REG 0x0B021808

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ref_rankmask : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               Refresh_Rank_Mask is a 8-bit field, one bit per
                               Rank. The LSB relates to Rank0 and the MSB
                               relates to the highest Rank. If the per Rank bit
                               of the Refresh_Rank_Mask is set to 1, then the
                               REUT engine will disable executing any refresh
                               to that rank while in REUT mode. If the per rank
                               bit of the Refresh_Rank_Mask is set to 0 and
                               then the REUT engine will enable executing a
                               refresh (assuming the MC has refreshes enabled)
                               to that Rank while in REUT mode based on the
                               Panic_Refresh_Only value.
                            */
    UINT32 rsvd : 23;

                            /* Bits[30:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 panic_ref_only : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               If Panic_Refresh_Only is set to 1 then
                               opportunistic and high priority auto refreshes
                               will be disabled for all ranks and refreshes
                               will only occur when the panic refresh watermark
                               has been exceeded. If Panic_Refresh_Only is set
                               to 0 then refreshes will occur using the
                               existing MC functional refresh logic.
                            */

  } Bits;
  UINT32 Data;

} CPGC_MISCREFCTL_MCDDC_CTL_STRUCT;

/* CPGC_MISCZQCTL_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x2002180c)                                                      */
/*      SPRB0 (0x2002180c)                                                      */
/*      SPRHBM (0x2002180c)                                                     */
/*      SPRC0 (0x2002180c)                                                      */
/*      SPRMCC (0x2002180c)                                                     */
/*      SPRUCC (0x2002180c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* CPGC ZQ Control -
This register is used to control rZQ operation in REUT mode. ZQ will be issued in REUT mode using the existing MC functional per-rank refresh FSM.
*/


#define CPGC_MISCZQCTL_MCDDC_CTL_REG 0x0B02180C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 zq_rankmask : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               ZQ Mask is a per rank field. The LSB relates to
                               Rank0 and the MSB relates to the highest Rank.
                               If the per rank bit of the ZQ Mask is set to 1,
                               then the REUT engine will disable executing ZQ
                               operations to that Rank. Note: that if the
                               Refresh_Rank_Mask for the same rank is set to 1
                               then the ZQ Mask will have no effect and ZQ will
                               disabled to that rank. If the per rank bit of
                               the ZQ mask is set to 0 and refreshes are being
                               issued to the corresponding Rank, ZQ will be
                               issued at a rate equal to 128*ZQCS_period
                               programmed inside the channel TC_ZQCAL CR,
                               always occurring after refreshes occur.
                            */
    UINT32 rsvd : 23;

                            /* Bits[30:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 always_do_zq : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               If Always_Do_ZQ is set to 1 a ZQ operation will
                               always take place after a refresh occurs as long
                               as the ZQ_Rank_Mask for that rank is set to 0.
                               If Always_Do_ZQ is set to 0 a ZQ operation will
                               take place at the normal programmed
                               128*ZQCS_period after a refresh occurs as long
                               as the ZQ_Rank_Mask for that rank is set to 0.
                            */

  } Bits;
  UINT32 Data;

} CPGC_MISCZQCTL_MCDDC_CTL_STRUCT;

/* MC_CADB_CTL_MCDDC_CTL_REG supported on:                                      */
/*      SPRA0 (0x20021810)                                                      */
/*      SPRB0 (0x20021810)                                                      */
/*      SPRHBM (0x20021810)                                                     */
/*      SPRC0 (0x20021810)                                                      */
/*      SPRMCC (0x20021810)                                                     */
/*      SPRUCC (0x20021810)                                                     */
/* Register default value on SPRA0: 0x00000004                                  */
/* Register default value on SPRB0: 0x00000004                                  */
/* Register default value on SPRHBM: 0x00000004                                 */
/* Register default value on SPRC0: 0x00000004                                  */
/* Register default value on SPRMCC: 0x00000004                                 */
/* Register default value on SPRUCC: 0x00000004                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* MC Controls for the CADB SubIP

*/


#define MC_CADB_CTL_MCDDC_CTL_REG 0x0B021810

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cadb_mode_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               0x0 = CADB Disabled and Bypassed. 0x1 = CADB
                               Enabled. CA Spid is routed through CADB.
                            */
    UINT32 cadb_reset : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Set and Clear to manually perform a warm reset
                               on CADB IP
                            */
    UINT32 cadb_disable_sb_wakeup : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               0x0 = CRNode Request Addr bit 0 wakes up CADB
                               0x1 = CRNode Request Addr bit 0 doesn't wake up
                               CADB
                            */
    UINT32 cadb_ddr4_3ds_slot : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Slot number to pick for CADB to selectively
                               override in ddr4 3ds operation
                            */
    UINT32 rsvd : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MC_CADB_CTL_MCDDC_CTL_STRUCT;

/* ERF_DDR4_CMD_REG8_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20021820)                                                      */
/*      SPRB0 (0x20021820)                                                      */
/*      SPRHBM (0x20021820)                                                     */
/*      SPRC0 (0x20021820)                                                      */
/*      SPRMCC (0x20021820)                                                     */
/*      SPRUCC (0x20021820)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Error Flow DDR4/5 command register 8 (DDR5: for subCh1)
*/


#define ERF_DDR4_CMD_REG8_MCDDC_CTL_REG 0x0B021820

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ad : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through address(A) pins of DDR4 interface .
                            */
    UINT32 ba : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BA pins of DDR4 interface .
                            */
    UINT32 bg : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BG pins of DDR4 interface .
                            */
    UINT32 rcw : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the RAS#,CAS#,WE# fields of
                               DDR4 interface
                            */
    UINT32 rsvd : 6;

                            /* Bits[26:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrrtype : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Used by mcdp via GS_DpCommand to know if a
                               particular ERF MRR was associated with a WrCRC
                               or DIMM CAP Isolation error recovery command.
                               Set to 1'b1 to denote WrCRC. Set to 1'b0 to
                               denote DIMM CAP Iso.
                            */
    UINT32 cw : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Control Word field as part of the Command
                               Address sent to the DIMM during ERF.
                            */
    UINT32 allow_invert : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the command sent is
                               also sent a 2nd time inverted. Required for MRS
                               0 to 6 writes. Must not be set for MR7 (register
                               buffer) writes
                            */
    UINT32 rdimm : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the content of this
                               register should be given to register part of the
                               dimm OR only one rank of the dimm. Other wise
                               the command should be given to all the ranks of
                               the channel.
                            */
    UINT32 en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables this register. The Error flow
                               FSM uses the contents of this register only if
                               en bit is set.
                            */

  } Bits;
  UINT32 Data;

} ERF_DDR4_CMD_REG8_MCDDC_CTL_STRUCT;

/* ERF_DDR4_CMD_REG9_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20021824)                                                      */
/*      SPRB0 (0x20021824)                                                      */
/*      SPRHBM (0x20021824)                                                     */
/*      SPRC0 (0x20021824)                                                      */
/*      SPRMCC (0x20021824)                                                     */
/*      SPRUCC (0x20021824)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Error Flow DDR4/5 command register 9 (DDR5: for subCh1)
*/


#define ERF_DDR4_CMD_REG9_MCDDC_CTL_REG 0x0B021824

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ad : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through address(A) pins of DDR4 interface .
                            */
    UINT32 ba : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BA pins of DDR4 interface .
                            */
    UINT32 bg : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BG pins of DDR4 interface .
                            */
    UINT32 rcw : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the RAS#,CAS#,WE# fields of
                               DDR4 interface
                            */
    UINT32 rsvd : 6;

                            /* Bits[26:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrrtype : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Used by mcdp via GS_DpCommand to know if a
                               particular ERF MRR was associated with a WrCRC
                               or DIMM CAP Isolation error recovery command.
                               Set to 1'b1 to denote WrCRC. Set to 1'b0 to
                               denote DIMM CAP Iso.
                            */
    UINT32 cw : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Control Word field as part of the Command
                               Address sent to the DIMM during ERF.
                            */
    UINT32 allow_invert : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the command sent is
                               also sent a 2nd time inverted. Required for MRS
                               0 to 6 writes. Must not be set for MR7 (register
                               buffer) writes
                            */
    UINT32 rdimm : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the content of this
                               register should be given to register part of the
                               dimm OR only one rank of the dimm. Other wise
                               the command should be given to all the ranks of
                               the channel.
                            */
    UINT32 en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables this register. The Error flow
                               FSM uses the contents of this register only if
                               en bit is set.
                            */

  } Bits;
  UINT32 Data;

} ERF_DDR4_CMD_REG9_MCDDC_CTL_STRUCT;

/* ERF_DDR4_CMD_REG10_MCDDC_CTL_REG supported on:                               */
/*      SPRA0 (0x20021828)                                                      */
/*      SPRB0 (0x20021828)                                                      */
/*      SPRHBM (0x20021828)                                                     */
/*      SPRC0 (0x20021828)                                                      */
/*      SPRMCC (0x20021828)                                                     */
/*      SPRUCC (0x20021828)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Error Flow DDR4/5 command register 10 (DDR5: for subCh1)
*/


#define ERF_DDR4_CMD_REG10_MCDDC_CTL_REG 0x0B021828

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ad : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through address(A) pins of DDR4 interface .
                            */
    UINT32 ba : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BA pins of DDR4 interface .
                            */
    UINT32 bg : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BG pins of DDR4 interface .
                            */
    UINT32 rcw : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the RAS#,CAS#,WE# fields of
                               DDR4 interface
                            */
    UINT32 rsvd : 6;

                            /* Bits[26:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrrtype : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Used by mcdp via GS_DpCommand to know if a
                               particular ERF MRR was associated with a WrCRC
                               or DIMM CAP Isolation error recovery command.
                               Set to 1'b1 to denote WrCRC. Set to 1'b0 to
                               denote DIMM CAP Iso.
                            */
    UINT32 cw : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Control Word field as part of the Command
                               Address sent to the DIMM during ERF.
                            */
    UINT32 allow_invert : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the command sent is
                               also sent a 2nd time inverted. Required for MRS
                               0 to 6 writes. Must not be set for MR7 (register
                               buffer) writes
                            */
    UINT32 rdimm : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the content of this
                               register should be given to register part of the
                               dimm OR only one rank of the dimm. Other wise
                               the command should be given to all the ranks of
                               the channel.
                            */
    UINT32 en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables this register. The Error flow
                               FSM uses the contents of this register only if
                               en bit is set.
                            */

  } Bits;
  UINT32 Data;

} ERF_DDR4_CMD_REG10_MCDDC_CTL_STRUCT;

/* ERF_DDR4_CMD_REG11_MCDDC_CTL_REG supported on:                               */
/*      SPRA0 (0x2002182c)                                                      */
/*      SPRB0 (0x2002182c)                                                      */
/*      SPRHBM (0x2002182c)                                                     */
/*      SPRC0 (0x2002182c)                                                      */
/*      SPRMCC (0x2002182c)                                                     */
/*      SPRUCC (0x2002182c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Error Flow DDR4/5 command register 11 (DDR5: for subCh1)
*/


#define ERF_DDR4_CMD_REG11_MCDDC_CTL_REG 0x0B02182C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ad : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through address(A) pins of DDR4 interface .
                            */
    UINT32 ba : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BA pins of DDR4 interface .
                            */
    UINT32 bg : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BG pins of DDR4 interface .
                            */
    UINT32 rcw : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the RAS#,CAS#,WE# fields of
                               DDR4 interface
                            */
    UINT32 rsvd : 6;

                            /* Bits[26:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrrtype : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Used by mcdp via GS_DpCommand to know if a
                               particular ERF MRR was associated with a WrCRC
                               or DIMM CAP Isolation error recovery command.
                               Set to 1'b1 to denote WrCRC. Set to 1'b0 to
                               denote DIMM CAP Iso.
                            */
    UINT32 cw : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Control Word field as part of the Command
                               Address sent to the DIMM during ERF.
                            */
    UINT32 allow_invert : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the command sent is
                               also sent a 2nd time inverted. Required for MRS
                               0 to 6 writes. Must not be set for MR7 (register
                               buffer) writes
                            */
    UINT32 rdimm : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the content of this
                               register should be given to register part of the
                               dimm OR only one rank of the dimm. Other wise
                               the command should be given to all the ranks of
                               the channel.
                            */
    UINT32 en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables this register. The Error flow
                               FSM uses the contents of this register only if
                               en bit is set.
                            */

  } Bits;
  UINT32 Data;

} ERF_DDR4_CMD_REG11_MCDDC_CTL_STRUCT;

/* ERF_DDR4_CMD_REG12_MCDDC_CTL_REG supported on:                               */
/*      SPRA0 (0x20021830)                                                      */
/*      SPRB0 (0x20021830)                                                      */
/*      SPRHBM (0x20021830)                                                     */
/*      SPRC0 (0x20021830)                                                      */
/*      SPRMCC (0x20021830)                                                     */
/*      SPRUCC (0x20021830)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Error Flow DDR4/5 command register 12 (DDR5: for subCh1)
*/


#define ERF_DDR4_CMD_REG12_MCDDC_CTL_REG 0x0B021830

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ad : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through address(A) pins of DDR4 interface .
                            */
    UINT32 ba : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BA pins of DDR4 interface .
                            */
    UINT32 bg : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BG pins of DDR4 interface .
                            */
    UINT32 rcw : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the RAS#,CAS#,WE# fields of
                               DDR4 interface
                            */
    UINT32 rsvd : 6;

                            /* Bits[26:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrrtype : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Used by mcdp via GS_DpCommand to know if a
                               particular ERF MRR was associated with a WrCRC
                               or DIMM CAP Isolation error recovery command.
                               Set to 1'b1 to denote WrCRC. Set to 1'b0 to
                               denote DIMM CAP Iso.
                            */
    UINT32 cw : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Control Word field as part of the Command
                               Address sent to the DIMM during ERF.
                            */
    UINT32 allow_invert : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the command sent is
                               also sent a 2nd time inverted. Required for MRS
                               0 to 6 writes. Must not be set for MR7 (register
                               buffer) writes
                            */
    UINT32 rdimm : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the content of this
                               register should be given to register part of the
                               dimm OR only one rank of the dimm. Other wise
                               the command should be given to all the ranks of
                               the channel.
                            */
    UINT32 en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables this register. The Error flow
                               FSM uses the contents of this register only if
                               en bit is set.
                            */

  } Bits;
  UINT32 Data;

} ERF_DDR4_CMD_REG12_MCDDC_CTL_STRUCT;

/* ERF_DDR4_CMD_REG13_MCDDC_CTL_REG supported on:                               */
/*      SPRA0 (0x20021834)                                                      */
/*      SPRB0 (0x20021834)                                                      */
/*      SPRHBM (0x20021834)                                                     */
/*      SPRC0 (0x20021834)                                                      */
/*      SPRMCC (0x20021834)                                                     */
/*      SPRUCC (0x20021834)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Error Flow DDR4/5 command register 13 (DDR5: for subCh0 - global register access)
*/


#define ERF_DDR4_CMD_REG13_MCDDC_CTL_REG 0x0B021834

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ad : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through address(A) pins of DDR4 interface .
                            */
    UINT32 ba : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BA pins of DDR4 interface .
                            */
    UINT32 bg : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BG pins of DDR4 interface .
                            */
    UINT32 rcw : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the RAS#,CAS#,WE# fields of
                               DDR4 interface
                            */
    UINT32 rsvd : 6;

                            /* Bits[26:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrrtype : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Used by mcdp via GS_DpCommand to know if a
                               particular ERF MRR was associated with a WrCRC
                               or DIMM CAP Isolation error recovery command.
                               Set to 1'b1 to denote WrCRC. Set to 1'b0 to
                               denote DIMM CAP Iso.
                            */
    UINT32 cw : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Control Word field as part of the Command
                               Address sent to the DIMM during ERF.
                            */
    UINT32 allow_invert : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the command sent is
                               also sent a 2nd time inverted. Required for MRS
                               0 to 6 writes. Must not be set for MR7 (register
                               buffer) writes
                            */
    UINT32 rdimm : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the content of this
                               register should be given to register part of the
                               dimm OR only one rank of the dimm. Other wise
                               the command should be given to all the ranks of
                               the channel.
                            */
    UINT32 en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables this register. The Error flow
                               FSM uses the contents of this register only if
                               en bit is set.
                            */

  } Bits;
  UINT32 Data;

} ERF_DDR4_CMD_REG13_MCDDC_CTL_STRUCT;

/* ERF_DDR4_CMD_REG14_MCDDC_CTL_REG supported on:                               */
/*      SPRA0 (0x20021838)                                                      */
/*      SPRB0 (0x20021838)                                                      */
/*      SPRHBM (0x20021838)                                                     */
/*      SPRC0 (0x20021838)                                                      */
/*      SPRMCC (0x20021838)                                                     */
/*      SPRUCC (0x20021838)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Error Flow DDR4/5 command register 14 (DDR5: for subCh0 - global register access)
*/


#define ERF_DDR4_CMD_REG14_MCDDC_CTL_REG 0x0B021838

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ad : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through address(A) pins of DDR4 interface .
                            */
    UINT32 ba : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BA pins of DDR4 interface .
                            */
    UINT32 bg : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BG pins of DDR4 interface .
                            */
    UINT32 rcw : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the RAS#,CAS#,WE# fields of
                               DDR4 interface
                            */
    UINT32 rsvd : 6;

                            /* Bits[26:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrrtype : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Used by mcdp via GS_DpCommand to know if a
                               particular ERF MRR was associated with a WrCRC
                               or DIMM CAP Isolation error recovery command.
                               Set to 1'b1 to denote WrCRC. Set to 1'b0 to
                               denote DIMM CAP Iso.
                            */
    UINT32 cw : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Control Word field as part of the Command
                               Address sent to the DIMM during ERF.
                            */
    UINT32 allow_invert : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the command sent is
                               also sent a 2nd time inverted. Required for MRS
                               0 to 6 writes. Must not be set for MR7 (register
                               buffer) writes
                            */
    UINT32 rdimm : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the content of this
                               register should be given to register part of the
                               dimm OR only one rank of the dimm. Other wise
                               the command should be given to all the ranks of
                               the channel.
                            */
    UINT32 en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables this register. The Error flow
                               FSM uses the contents of this register only if
                               en bit is set.
                            */

  } Bits;
  UINT32 Data;

} ERF_DDR4_CMD_REG14_MCDDC_CTL_STRUCT;

/* ERF_DDR4_CMD_REG15_MCDDC_CTL_REG supported on:                               */
/*      SPRA0 (0x2002183c)                                                      */
/*      SPRB0 (0x2002183c)                                                      */
/*      SPRHBM (0x2002183c)                                                     */
/*      SPRC0 (0x2002183c)                                                      */
/*      SPRMCC (0x2002183c)                                                     */
/*      SPRUCC (0x2002183c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Error Flow DDR4/5 command register 15 (DDR5: for subCh0 - global register access)
*/


#define ERF_DDR4_CMD_REG15_MCDDC_CTL_REG 0x0B02183C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ad : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through address(A) pins of DDR4 interface .
                            */
    UINT32 ba : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BA pins of DDR4 interface .
                            */
    UINT32 bg : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BG pins of DDR4 interface .
                            */
    UINT32 rcw : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the RAS#,CAS#,WE# fields of
                               DDR4 interface
                            */
    UINT32 rsvd : 6;

                            /* Bits[26:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrrtype : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Used by mcdp via GS_DpCommand to know if a
                               particular ERF MRR was associated with a WrCRC
                               or DIMM CAP Isolation error recovery command.
                               Set to 1'b1 to denote WrCRC. Set to 1'b0 to
                               denote DIMM CAP Iso.
                            */
    UINT32 cw : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Control Word field as part of the Command
                               Address sent to the DIMM during ERF.
                            */
    UINT32 allow_invert : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the command sent is
                               also sent a 2nd time inverted. Required for MRS
                               0 to 6 writes. Must not be set for MR7 (register
                               buffer) writes
                            */
    UINT32 rdimm : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the content of this
                               register should be given to register part of the
                               dimm OR only one rank of the dimm. Other wise
                               the command should be given to all the ranks of
                               the channel.
                            */
    UINT32 en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables this register. The Error flow
                               FSM uses the contents of this register only if
                               en bit is set.
                            */

  } Bits;
  UINT32 Data;

} ERF_DDR4_CMD_REG15_MCDDC_CTL_STRUCT;


/* CRDEFEATURE1_BS_MCDDC_CTL_REG supported on:                                  */
/*      SPRA0 (0x10021848)                                                      */
/*      SPRB0 (0x10021848)                                                      */
/*      SPRHBM (0x10021848)                                                     */
/*      SPRC0 (0x10021848)                                                      */
/*      SPRMCC (0x10021848)                                                     */
/*      SPRUCC (0x10021848)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* spare
*/


#define CRDEFEATURE1_BS_MCDDC_CTL_REG 0x0B011848

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 spare : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* spare */

  } Bits;
  UINT16 Data;

} CRDEFEATURE1_BS_MCDDC_CTL_STRUCT;

/* CRDEFEATURE2_BS_MCDDC_CTL_REG supported on:                                  */
/*      SPRA0 (0x10021850)                                                      */
/*      SPRB0 (0x10021850)                                                      */
/*      SPRHBM (0x10021850)                                                     */
/*      SPRC0 (0x10021850)                                                      */
/*      SPRMCC (0x10021850)                                                     */
/*      SPRUCC (0x10021850)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* spare
*/


#define CRDEFEATURE2_BS_MCDDC_CTL_REG 0x0B011850

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 spare : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* spare */

  } Bits;
  UINT16 Data;

} CRDEFEATURE2_BS_MCDDC_CTL_STRUCT;

/* CRDEFEATURE3_BS_MCDDC_CTL_REG supported on:                                  */
/*      SPRA0 (0x10021858)                                                      */
/*      SPRB0 (0x10021858)                                                      */
/*      SPRHBM (0x10021858)                                                     */
/*      SPRC0 (0x10021858)                                                      */
/*      SPRMCC (0x10021858)                                                     */
/*      SPRUCC (0x10021858)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* spare
*/


#define CRDEFEATURE3_BS_MCDDC_CTL_REG 0x0B011858

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 spare : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* spare */

  } Bits;
  UINT16 Data;

} CRDEFEATURE3_BS_MCDDC_CTL_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 integrity_enabled : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Integrity enable configuration; should only be
                               set for DDR5 mode
                            */
    UINT16 spare : 15;

                            /* Bits[15:1], Access Type=RW, default=0x00000000*/

                            /* spare */

  } Bits;
  UINT16 Data;

} CRDEFEATURE3_BS_MCDDC_CTL_SPRB0_SPRHBM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */



















/* SCRATCHPAD_MCDDC_CTL_REG supported on:                                       */
/*      SPRA0 (0x200218f8)                                                      */
/*      SPRB0 (0x200218f8)                                                      */
/*      SPRHBM (0x200218f8)                                                     */
/*      SPRC0 (0x200218f8)                                                      */
/*      SPRMCC (0x200218f8)                                                     */
/*      SPRUCC (0x200218f8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* SCRATCHPAD
*/


#define SCRATCHPAD_MCDDC_CTL_REG 0x0B0218F8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 scratchpad : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* SCRATCHPAD */

  } Bits;
  UINT32 Data;

} SCRATCHPAD_MCDDC_CTL_STRUCT;

/* FILTER0_MASKA_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20021900)                                                      */
/*      SPRB0 (0x20021900)                                                      */
/*      SPRHBM (0x20021900)                                                     */
/*      SPRC0 (0x20021900)                                                      */
/*      SPRMCC (0x20021900)                                                     */
/*      SPRUCC (0x20021900)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Set bits to 1 to enable matching
*/


#define FILTER0_MASKA_MCDDC_CTL_REG 0x0B021900

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cke_enable : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that CKE line in the
                               match
                            */
    UINT32 act_enable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Set bit to 1 to enable ACT in the match */
    UINT32 cid_enable : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that CID bit in the
                               match
                            */
    UINT32 rank_enable : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that rank ID in the
                               match
                            */
    UINT32 bg_enable : 3;

                            /* Bits[18:16], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that bank group bit
                               in the match
                            */
    UINT32 ba_enable : 2;

                            /* Bits[20:19], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that bank address
                               bit in the match
                            */
    UINT32 ma_first_enable : 10;

                            /* Bits[30:21], Access Type=RW, default=0x00000000*/

                            /*
                               Match enable bits for first DDRT cycle
                               {CID[1:0],spid_ca[20:14]}. When in HBM2 mode,
                               the low 3 bits of this field are the column
                               command enable and the next 3 bits are the row
                               command enable as follows: ma_first_enable[5]
                               enables match of ACT commands ma_first_enable[4]
                               enables match of REF/REFSB commands
                               ma_first_enable[3] enables match of PRE/PREALL
                               commands ma_first_enable[2] enables match of
                               RD/RDA commands ma_first_enable[1] enables match
                               of WR/WRA commands ma_first_enable[0] enables
                               match of MRS commands
                            */
    UINT32 filter_enable : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Set to 1 to enable this filter */

  } Bits;
  UINT32 Data;

} FILTER0_MASKA_MCDDC_CTL_STRUCT;

/* FILTER0_MASKB_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20021904)                                                      */
/*      SPRB0 (0x20021904)                                                      */
/*      SPRHBM (0x20021904)                                                     */
/*      SPRC0 (0x20021904)                                                      */
/*      SPRMCC (0x20021904)                                                     */
/*      SPRUCC (0x20021904)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Set bits to 1 to enable matching
*/


#define FILTER0_MASKB_MCDDC_CTL_REG 0x0B021904

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ma_enable : 18;

                            /* Bits[17:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that address bit in
                               the match (DDR4 commands
                               RASn=ma[16],CASn=ma[15],WEn=ma[14] when Act==0)
                            */
    UINT32 ma_first_enable : 14;

                            /* Bits[31:18], Access Type=RW, default=0x00000000*/

                            /*
                               Match enable bits for first DDRT cycle
                               spid_ca[13:0]
                            */

  } Bits;
  UINT32 Data;

} FILTER0_MASKB_MCDDC_CTL_STRUCT;

/* FILTER0_MATCHA_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x20021908)                                                      */
/*      SPRB0 (0x20021908)                                                      */
/*      SPRHBM (0x20021908)                                                     */
/*      SPRC0 (0x20021908)                                                      */
/*      SPRMCC (0x20021908)                                                     */
/*      SPRUCC (0x20021908)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* holds filter matching info for SPID tracing
*/


#define FILTER0_MATCHA_MCDDC_CTL_REG 0x0B021908

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cke_match_value : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /* CKE value to match */
    UINT32 act_match_value : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Match value for positive true ACT */
    UINT32 cid_match_value : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /* CID value to match */
    UINT32 ddrt_commands : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to match only DDRT commands (does not
                               match grants). Set to 0 to match only DDR
                               commands
                            */
    UINT32 ddrt_grants : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to match DDRT grants (does not match
                               DDRT commands). Set to 0 to ignore DDRT grants
                            */
    UINT32 rsvd : 6;

                            /* Bits[15:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 bg_match_value : 3;

                            /* Bits[18:16], Access Type=RW, default=0x00000000*/

                            /* bank group match value */
    UINT32 ba_match_value : 2;

                            /* Bits[20:19], Access Type=RW, default=0x00000000*/

                            /* bank address match value */
    UINT32 ma_first_match_value : 10;

                            /* Bits[30:21], Access Type=RW, default=0x00000000*/

                            /*
                               Match value bits for first DDRT cycle
                               {CID[1:0],spid_ca[20:14]}. If the cycle was not
                               a DDRT command the match will fail if enabled.
                               When in HBM2 mode, this filed has no effect
                            */
    UINT32 filter_invert : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Set to 1 to invert filter result */

  } Bits;
  UINT32 Data;

} FILTER0_MATCHA_MCDDC_CTL_STRUCT;

/* FILTER0_MATCHB_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x2002190c)                                                      */
/*      SPRB0 (0x2002190c)                                                      */
/*      SPRHBM (0x2002190c)                                                     */
/*      SPRC0 (0x2002190c)                                                      */
/*      SPRMCC (0x2002190c)                                                     */
/*      SPRUCC (0x2002190c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* holds extended filter matching info for SPID tracing
*/


#define FILTER0_MATCHB_MCDDC_CTL_REG 0x0B02190C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ma_match_value : 18;

                            /* Bits[17:0], Access Type=RW, default=0x00000000*/

                            /*
                               Match value bits for address (DDR4 commands
                               RASn=ma[16],CASn=ma[15],WEn=ma[14] when Act==0)
                            */
    UINT32 ma_first_match_value : 14;

                            /* Bits[31:18], Access Type=RW, default=0x00000000*/

                            /*
                               Match value bits for first DDRT cycle
                               spid_ca[13:0]
                            */

  } Bits;
  UINT32 Data;

} FILTER0_MATCHB_MCDDC_CTL_STRUCT;

/* FILTER1_MASKA_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20021910)                                                      */
/*      SPRB0 (0x20021910)                                                      */
/*      SPRHBM (0x20021910)                                                     */
/*      SPRC0 (0x20021910)                                                      */
/*      SPRMCC (0x20021910)                                                     */
/*      SPRUCC (0x20021910)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Set bits to 1 to enable matching
*/


#define FILTER1_MASKA_MCDDC_CTL_REG 0x0B021910

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cke_enable : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that CKE line in the
                               match
                            */
    UINT32 act_enable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Set bit to 1 to enable ACT in the match */
    UINT32 cid_enable : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that CID bit in the
                               match
                            */
    UINT32 rank_enable : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that rank ID in the
                               match
                            */
    UINT32 bg_enable : 3;

                            /* Bits[18:16], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that bank group bit
                               in the match
                            */
    UINT32 ba_enable : 2;

                            /* Bits[20:19], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that bank address
                               bit in the match
                            */
    UINT32 ma_first_enable : 10;

                            /* Bits[30:21], Access Type=RW, default=0x00000000*/

                            /*
                               Match enable bits for first DDRT cycle
                               {CID[1:0],spid_ca[20:14]}. When in HBM2 mode,
                               the low 3 bits of this field are the column
                               command enable and the next 3 bits are the row
                               command enable as follows: ma_first_enable[5]
                               enables match of ACT commands ma_first_enable[4]
                               enables match of REF/REFSB commands
                               ma_first_enable[3] enables match of PRE/PREALL
                               commands ma_first_enable[2] enables match of
                               RD/RDA commands ma_first_enable[1] enables match
                               of WR/WRA commands ma_first_enable[0] enables
                               match of MRS commands
                            */
    UINT32 filter_enable : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Set to 1 to enable this filter */

  } Bits;
  UINT32 Data;

} FILTER1_MASKA_MCDDC_CTL_STRUCT;

/* FILTER1_MASKB_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20021914)                                                      */
/*      SPRB0 (0x20021914)                                                      */
/*      SPRHBM (0x20021914)                                                     */
/*      SPRC0 (0x20021914)                                                      */
/*      SPRMCC (0x20021914)                                                     */
/*      SPRUCC (0x20021914)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Set bits to 1 to enable matching
*/


#define FILTER1_MASKB_MCDDC_CTL_REG 0x0B021914

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ma_enable : 18;

                            /* Bits[17:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that address bit in
                               the match (DDR4 commands
                               RASn=ma[16],CASn=ma[15],WEn=ma[14] when Act==0)
                            */
    UINT32 ma_first_enable : 14;

                            /* Bits[31:18], Access Type=RW, default=0x00000000*/

                            /*
                               Match enable bits for first DDRT cycle
                               spid_ca[13:0]
                            */

  } Bits;
  UINT32 Data;

} FILTER1_MASKB_MCDDC_CTL_STRUCT;

/* FILTER1_MATCHA_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x20021918)                                                      */
/*      SPRB0 (0x20021918)                                                      */
/*      SPRHBM (0x20021918)                                                     */
/*      SPRC0 (0x20021918)                                                      */
/*      SPRMCC (0x20021918)                                                     */
/*      SPRUCC (0x20021918)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* holds filter matching info for SPID tracing
*/


#define FILTER1_MATCHA_MCDDC_CTL_REG 0x0B021918

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cke_match_value : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /* CKE value to match */
    UINT32 act_match_value : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Match value for positive true ACT */
    UINT32 cid_match_value : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /* CID value to match */
    UINT32 ddrt_commands : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to match only DDRT commands (does not
                               match grants). Set to 0 to match only DDR
                               commands
                            */
    UINT32 ddrt_grants : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to match DDRT grants (does not match
                               DDRT commands). Set to 0 to ignore DDRT grants
                            */
    UINT32 rsvd : 6;

                            /* Bits[15:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 bg_match_value : 3;

                            /* Bits[18:16], Access Type=RW, default=0x00000000*/

                            /* bank group match value */
    UINT32 ba_match_value : 2;

                            /* Bits[20:19], Access Type=RW, default=0x00000000*/

                            /* bank address match value */
    UINT32 ma_first_match_value : 10;

                            /* Bits[30:21], Access Type=RW, default=0x00000000*/

                            /*
                               Match value bits for first DDRT cycle
                               {CID[1:0],spid_ca[20:14]}. If the cycle was not
                               a DDRT command the match will fail if enabled.
                               When in HBM2 mode, this filed has no effect
                            */
    UINT32 filter_invert : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Set to 1 to invert filter result */

  } Bits;
  UINT32 Data;

} FILTER1_MATCHA_MCDDC_CTL_STRUCT;

/* FILTER1_MATCHB_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x2002191c)                                                      */
/*      SPRB0 (0x2002191c)                                                      */
/*      SPRHBM (0x2002191c)                                                     */
/*      SPRC0 (0x2002191c)                                                      */
/*      SPRMCC (0x2002191c)                                                     */
/*      SPRUCC (0x2002191c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* holds extended filter matching info for SPID tracing
*/


#define FILTER1_MATCHB_MCDDC_CTL_REG 0x0B02191C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ma_match_value : 18;

                            /* Bits[17:0], Access Type=RW, default=0x00000000*/

                            /*
                               Match value bits for address (DDR4 commands
                               RASn=ma[16],CASn=ma[15],WEn=ma[14] when Act==0)
                            */
    UINT32 ma_first_match_value : 14;

                            /* Bits[31:18], Access Type=RW, default=0x00000000*/

                            /*
                               Match value bits for first DDRT cycle
                               spid_ca[13:0]
                            */

  } Bits;
  UINT32 Data;

} FILTER1_MATCHB_MCDDC_CTL_STRUCT;

/* FILTER2_MASKA_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20021920)                                                      */
/*      SPRB0 (0x20021920)                                                      */
/*      SPRHBM (0x20021920)                                                     */
/*      SPRC0 (0x20021920)                                                      */
/*      SPRMCC (0x20021920)                                                     */
/*      SPRUCC (0x20021920)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Set bits to 1 to enable matching
*/


#define FILTER2_MASKA_MCDDC_CTL_REG 0x0B021920

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cke_enable : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that CKE line in the
                               match
                            */
    UINT32 act_enable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Set bit to 1 to enable ACT in the match */
    UINT32 cid_enable : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that CID bit in the
                               match
                            */
    UINT32 rank_enable : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that rank ID in the
                               match
                            */
    UINT32 bg_enable : 3;

                            /* Bits[18:16], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that bank group bit
                               in the match
                            */
    UINT32 ba_enable : 2;

                            /* Bits[20:19], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that bank address
                               bit in the match
                            */
    UINT32 ma_first_enable : 10;

                            /* Bits[30:21], Access Type=RW, default=0x00000000*/

                            /*
                               Match enable bits for first DDRT cycle
                               {CID[1:0],spid_ca[20:14]}. When in HBM2 mode,
                               the low 3 bits of this field are the column
                               command enable and the next 3 bits are the row
                               command enable as follows: ma_first_enable[5]
                               enables match of ACT commands ma_first_enable[4]
                               enables match of REF/REFSB commands
                               ma_first_enable[3] enables match of PRE/PREALL
                               commands ma_first_enable[2] enables match of
                               RD/RDA commands ma_first_enable[1] enables match
                               of WR/WRA commands ma_first_enable[0] enables
                               match of MRS commands
                            */
    UINT32 filter_enable : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Set to 1 to enable this filter */

  } Bits;
  UINT32 Data;

} FILTER2_MASKA_MCDDC_CTL_STRUCT;

/* FILTER2_MASKB_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20021924)                                                      */
/*      SPRB0 (0x20021924)                                                      */
/*      SPRHBM (0x20021924)                                                     */
/*      SPRC0 (0x20021924)                                                      */
/*      SPRMCC (0x20021924)                                                     */
/*      SPRUCC (0x20021924)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Set bits to 1 to enable matching
*/


#define FILTER2_MASKB_MCDDC_CTL_REG 0x0B021924

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ma_enable : 18;

                            /* Bits[17:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that address bit in
                               the match (DDR4 commands
                               RASn=ma[16],CASn=ma[15],WEn=ma[14] when Act==0)
                            */
    UINT32 ma_first_enable : 14;

                            /* Bits[31:18], Access Type=RW, default=0x00000000*/

                            /*
                               Match enable bits for first DDRT cycle
                               spid_ca[13:0]
                            */

  } Bits;
  UINT32 Data;

} FILTER2_MASKB_MCDDC_CTL_STRUCT;

/* FILTER2_MATCHA_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x20021928)                                                      */
/*      SPRB0 (0x20021928)                                                      */
/*      SPRHBM (0x20021928)                                                     */
/*      SPRC0 (0x20021928)                                                      */
/*      SPRMCC (0x20021928)                                                     */
/*      SPRUCC (0x20021928)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* holds filter matching info for SPID tracing
*/


#define FILTER2_MATCHA_MCDDC_CTL_REG 0x0B021928

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cke_match_value : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /* CKE value to match */
    UINT32 act_match_value : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Match value for positive true ACT */
    UINT32 cid_match_value : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /* CID value to match */
    UINT32 ddrt_commands : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to match only DDRT commands (does not
                               match grants). Set to 0 to match only DDR
                               commands
                            */
    UINT32 ddrt_grants : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to match DDRT grants (does not match
                               DDRT commands). Set to 0 to ignore DDRT grants
                            */
    UINT32 rsvd : 6;

                            /* Bits[15:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 bg_match_value : 3;

                            /* Bits[18:16], Access Type=RW, default=0x00000000*/

                            /* bank group match value */
    UINT32 ba_match_value : 2;

                            /* Bits[20:19], Access Type=RW, default=0x00000000*/

                            /* bank address match value */
    UINT32 ma_first_match_value : 10;

                            /* Bits[30:21], Access Type=RW, default=0x00000000*/

                            /*
                               Match value bits for first DDRT cycle
                               {CID[1:0],spid_ca[20:14]}. If the cycle was not
                               a DDRT command the match will fail if enabled.
                               When in HBM2 mode, this filed has no effect
                            */
    UINT32 filter_invert : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Set to 1 to invert filter result */

  } Bits;
  UINT32 Data;

} FILTER2_MATCHA_MCDDC_CTL_STRUCT;

/* FILTER2_MATCHB_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x2002192c)                                                      */
/*      SPRB0 (0x2002192c)                                                      */
/*      SPRHBM (0x2002192c)                                                     */
/*      SPRC0 (0x2002192c)                                                      */
/*      SPRMCC (0x2002192c)                                                     */
/*      SPRUCC (0x2002192c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* holds extended filter matching info for SPID tracing
*/


#define FILTER2_MATCHB_MCDDC_CTL_REG 0x0B02192C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ma_match_value : 18;

                            /* Bits[17:0], Access Type=RW, default=0x00000000*/

                            /*
                               Match value bits for address (DDR4 commands
                               RASn=ma[16],CASn=ma[15],WEn=ma[14] when Act==0)
                            */
    UINT32 ma_first_match_value : 14;

                            /* Bits[31:18], Access Type=RW, default=0x00000000*/

                            /*
                               Match value bits for first DDRT cycle
                               spid_ca[13:0]
                            */

  } Bits;
  UINT32 Data;

} FILTER2_MATCHB_MCDDC_CTL_STRUCT;

/* FILTER3_MASKA_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20021930)                                                      */
/*      SPRB0 (0x20021930)                                                      */
/*      SPRHBM (0x20021930)                                                     */
/*      SPRC0 (0x20021930)                                                      */
/*      SPRMCC (0x20021930)                                                     */
/*      SPRUCC (0x20021930)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Set bits to 1 to enable matching
*/


#define FILTER3_MASKA_MCDDC_CTL_REG 0x0B021930

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cke_enable : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that CKE line in the
                               match
                            */
    UINT32 act_enable : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Set bit to 1 to enable ACT in the match */
    UINT32 cid_enable : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that CID bit in the
                               match
                            */
    UINT32 rank_enable : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that rank ID in the
                               match
                            */
    UINT32 bg_enable : 3;

                            /* Bits[18:16], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that bank group bit
                               in the match
                            */
    UINT32 ba_enable : 2;

                            /* Bits[20:19], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that bank address
                               bit in the match
                            */
    UINT32 ma_first_enable : 10;

                            /* Bits[30:21], Access Type=RW, default=0x00000000*/

                            /*
                               Match enable bits for first DDRT cycle
                               {CID[1:0],spid_ca[20:14]}. When in HBM2 mode,
                               the low 3 bits of this field are the column
                               command enable and the next 3 bits are the row
                               command enable as follows: ma_first_enable[5]
                               enables match of ACT commands ma_first_enable[4]
                               enables match of REF/REFSB commands
                               ma_first_enable[3] enables match of PRE/PREALL
                               commands ma_first_enable[2] enables match of
                               RD/RDA commands ma_first_enable[1] enables match
                               of WR/WRA commands ma_first_enable[0] enables
                               match of MRS commands
                            */
    UINT32 filter_enable : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Set to 1 to enable this filter */

  } Bits;
  UINT32 Data;

} FILTER3_MASKA_MCDDC_CTL_STRUCT;

/* FILTER3_MASKB_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20021934)                                                      */
/*      SPRB0 (0x20021934)                                                      */
/*      SPRHBM (0x20021934)                                                     */
/*      SPRC0 (0x20021934)                                                      */
/*      SPRMCC (0x20021934)                                                     */
/*      SPRUCC (0x20021934)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Set bits to 1 to enable matching
*/


#define FILTER3_MASKB_MCDDC_CTL_REG 0x0B021934

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ma_enable : 18;

                            /* Bits[17:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set each bit to 1 to enable that address bit in
                               the match (DDR4 commands
                               RASn=ma[16],CASn=ma[15],WEn=ma[14] when Act==0)
                            */
    UINT32 ma_first_enable : 14;

                            /* Bits[31:18], Access Type=RW, default=0x00000000*/

                            /*
                               Match enable bits for first DDRT cycle
                               spid_ca[13:0]
                            */

  } Bits;
  UINT32 Data;

} FILTER3_MASKB_MCDDC_CTL_STRUCT;

/* FILTER3_MATCHA_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x20021938)                                                      */
/*      SPRB0 (0x20021938)                                                      */
/*      SPRHBM (0x20021938)                                                     */
/*      SPRC0 (0x20021938)                                                      */
/*      SPRMCC (0x20021938)                                                     */
/*      SPRUCC (0x20021938)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* holds filter matching info for SPID tracing
*/


#define FILTER3_MATCHA_MCDDC_CTL_REG 0x0B021938

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cke_match_value : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /* CKE value to match */
    UINT32 act_match_value : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Match value for positive true ACT */
    UINT32 cid_match_value : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /* CID value to match */
    UINT32 ddrt_commands : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to match only DDRT commands (does not
                               match grants). Set to 0 to match only DDR
                               commands
                            */
    UINT32 ddrt_grants : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to match DDRT grants (does not match
                               DDRT commands). Set to 0 to ignore DDRT grants
                            */
    UINT32 rsvd : 6;

                            /* Bits[15:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 bg_match_value : 3;

                            /* Bits[18:16], Access Type=RW, default=0x00000000*/

                            /* bank group match value */
    UINT32 ba_match_value : 2;

                            /* Bits[20:19], Access Type=RW, default=0x00000000*/

                            /* bank address match value */
    UINT32 ma_first_match_value : 10;

                            /* Bits[30:21], Access Type=RW, default=0x00000000*/

                            /*
                               Match value bits for first DDRT cycle
                               {CID[1:0],spid_ca[20:14]}. If the cycle was not
                               a DDRT command the match will fail if enabled.
                               When in HBM2 mode, this filed has no effect
                            */
    UINT32 filter_invert : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Set to 1 to invert filter result */

  } Bits;
  UINT32 Data;

} FILTER3_MATCHA_MCDDC_CTL_STRUCT;

/* FILTER3_MATCHB_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x2002193c)                                                      */
/*      SPRB0 (0x2002193c)                                                      */
/*      SPRHBM (0x2002193c)                                                     */
/*      SPRC0 (0x2002193c)                                                      */
/*      SPRMCC (0x2002193c)                                                     */
/*      SPRUCC (0x2002193c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* holds extended filter matching info for SPID tracing
*/


#define FILTER3_MATCHB_MCDDC_CTL_REG 0x0B02193C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ma_match_value : 18;

                            /* Bits[17:0], Access Type=RW, default=0x00000000*/

                            /*
                               Match value bits for address (DDR4 commands
                               RASn=ma[16],CASn=ma[15],WEn=ma[14] when Act==0)
                            */
    UINT32 ma_first_match_value : 14;

                            /* Bits[31:18], Access Type=RW, default=0x00000000*/

                            /*
                               Match value bits for first DDRT cycle
                               spid_ca[13:0]
                            */

  } Bits;
  UINT32 Data;

} FILTER3_MATCHB_MCDDC_CTL_STRUCT;

/* MCSCHED_CHKN_BIT2_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20021944)                                                      */
/*      SPRB0 (0x20021944)                                                      */
/*      SPRHBM (0x20021944)                                                     */
/*      SPRC0 (0x20021944)                                                      */
/*      SPRMCC (0x20021944)                                                     */
/*      SPRUCC (0x20021944)                                                     */
/* Register default value on SPRA0: 0x00000007                                  */
/* Register default value on SPRB0: 0x00000007                                  */
/* Register default value on SPRHBM: 0x00000007                                 */
/* Register default value on SPRC0: 0x00000007                                  */
/* Register default value on SPRMCC: 0x00000007                                 */
/* Register default value on SPRUCC: 0x00000007                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x708
*/


#define MCSCHED_CHKN_BIT2_MCDDC_CTL_REG 0x0B021944

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_cke_pwdn_lpmode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Disable DDRIO power down due to all CKE lines
                               going to zero
                            */
    UINT32 dis_ddrio_pwdn : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Disable ddrio power down due to opportunistic
                               channel in selfrefresh
                            */
    UINT32 dis_cke_thermtrip_shutdown : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /* Spare. This bit has no effect on the logic */
    UINT32 dis_rcomp_squash_pm : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Chkn bit for fix where rcomp squashes PM (lpmode
                               and pm_req) on spid
                            */
    UINT32 unused_bits26_4 : 23;

                            /* Bits[26:4], Access Type=RW, default=0x00000000*/

                            /* unused */
    UINT32 drop_writes_on_viral : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to drop writes when viral condition
                               occurs. This bit needs to be set when NVDIMMs
                               are populated on the system.
                            */
    UINT32 ddrt2_pri_subchn : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to configure DDRT2 subchannel
                               1 as the primary subchannel. This is a debug bit
                               for validation purposes and should not be set to
                               1 on a production system. This bit needs to have
                               the same value as DDRT_CONFIG_CTL.primary_subchn
                            */
    UINT32 clear_adddc_plusone_en : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /* Reserved - unused. */
    UINT32 clear_dev_sub_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* Reserved - unused. */
    UINT32 unused_bit31 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* unused */

  } Bits;
  UINT32 Data;

} MCSCHED_CHKN_BIT2_MCDDC_CTL_STRUCT;

/* MCSCHED_CHKN_BIT3_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20021948)                                                      */
/*      SPRB0 (0x20021948)                                                      */
/*      SPRHBM (0x20021948)                                                     */
/*      SPRC0 (0x20021948)                                                      */
/*      SPRMCC (0x20021948)                                                     */
/*      SPRUCC (0x20021948)                                                     */
/* Register default value on SPRA0: 0x80008000                                  */
/* Register default value on SPRB0: 0x80008000                                  */
/* Register default value on SPRHBM: 0x80008000                                 */
/* Register default value on SPRC0: 0x80008000                                  */
/* Register default value on SPRMCC: 0x80008000                                 */
/* Register default value on SPRUCC: 0x80008000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x708
*/


#define MCSCHED_CHKN_BIT3_MCDDC_CTL_REG 0x0B021948

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 defeature : 32;

                            /* Bits[31:0], Access Type=RW, default=0x80008000*/

                            /*
                               bit 15: disable use no RDB credit for dependent
                               read anti-starvation; bit 16: disable use no VC
                               credit for dependent read anti-starvation; bit
                               17: disable use VC1 no RDB credit for dependent
                               read anti-starvation; bit 18: disable use VC3 no
                               RDB credit for dependent read anti-starvation;
                               bit 30: chkn bit for OSR enable from PS allow -
                               this bit set to 1 disables the fix bit 31: set
                               to 1 to allow 1 CAS every 4 dclk only for all
                               modes; other: reserved
                            */

  } Bits;
  UINT32 Data;

} MCSCHED_CHKN_BIT3_MCDDC_CTL_STRUCT;

/* MCSCHED_CHKN_BIT_MCDDC_CTL_REG supported on:                                 */
/*      SPRA0 (0x2002194c)                                                      */
/*      SPRB0 (0x2002194c)                                                      */
/*      SPRHBM (0x2002194c)                                                     */
/*      SPRC0 (0x2002194c)                                                      */
/*      SPRMCC (0x2002194c)                                                     */
/*      SPRUCC (0x2002194c)                                                     */
/* Register default value on SPRA0: 0x00000006                                  */
/* Register default value on SPRB0: 0x00200004                                  */
/* Register default value on SPRHBM: 0x00200004                                 */
/* Register default value on SPRC0: 0x00200006                                  */
/* Register default value on SPRMCC: 0x00200006                                 */
/* Register default value on SPRUCC: 0x00200006                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x704
*/


#define MCSCHED_CHKN_BIT_MCDDC_CTL_REG 0x0B02194C

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_ddr4_cap_err_latency : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable cap error latency counte on SRE command
                               before sending pm2 message in ddr4
                            */
    UINT32 dis_ref_dqsosc_wait_during_retry : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Disable wait during ST_REF_DQSOSC_STRT_REQ state
                               during retry and instead go back to FREE state;
                               default value should be 1'b1 (i.e. skip DQSOSC
                               and return to REF_FREE during retry).
                            */
    UINT32 en_wr_cas_won_during_viral : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Allow datapath to see write CAS won indication
                               during viral.
                            */
    UINT32 unused_bits12_2 : 10;

                            /* Bits[12:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bits 12:4 are actually unused; bit 3 is used as
                               a workaround for 1409738990 to disable the
                               workaround
                            */
    UINT32 dis_bs_parerr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Disable parity error detection for BS address
                               output.
                            */
    UINT32 dis_aom : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /* Override ODT output to IO */
    UINT32 unused_bits18_15 : 4;

                            /* Bits[18:15], Access Type=RW, default=0x00000000*/

                            /* unused */
    UINT32 dis_ck_gate_sched : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /* Disable Clock Gate in Scheduler */
    UINT32 unused_bits30_20 : 11;

                            /* Bits[30:20], Access Type=RW, default=0x00000000*/

                            /* unused */
    UINT32 def_1 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable write pointer for CADB
                               lmn_fifo.
                            */

  } Bits;
  UINT32 Data;

} MCSCHED_CHKN_BIT_MCDDC_CTL_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_ddr4_cap_err_latency : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable cap error latency counte on SRE command
                               before sending pm2 message in ddr4
                            */
    UINT32 dis_ref_dqsosc_wait_during_retry : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Disable wait during ST_REF_DQSOSC_STRT_REQ state
                               during retry and instead go back to FREE state;
                               default value should be 1'b1 (i.e. skip DQSOSC
                               and return to REF_FREE during retry).
                            */
    UINT32 en_wr_cas_won_during_viral : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Allow datapath to see write CAS won indication
                               during viral.
                            */
    UINT32 unused_bits11_3 : 9;

                            /* Bits[11:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bits 12:4 are actually unused; bit 3 is used as
                               a workaround for 1409738990 to disable the
                               workaround
                            */
    UINT32 rsvd_12 : 1;

                            /* Bits[12:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_bs_parerr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Disable parity error detection for BS address
                               output.
                            */
    UINT32 dis_aom : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /* Override ODT output to IO */
    UINT32 unused_bits18_15 : 4;

                            /* Bits[18:15], Access Type=RW, default=0x00000000*/

                            /* unused */
    UINT32 dis_ck_gate_sched : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /* Disable Clock Gate in Scheduler */
    UINT32 dis_ddrt_gnt_aggr_blk : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Disable bug fix for 14010041372 Default behavior
                               is to trigger safe timers on both subchannels
                               when DDRT grant is detected on either
                               subchannel.
                            */
    UINT32 sel_write_err_latency : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000001*/

                            /*
                               use write_err_latency field from spare wire;
                               should be cleared to 0 before clearing
                               mcsched_pq_chkn_bit.sel_write_err_latency
                            */
    UINT32 sel_cas_blockrule : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               use cas_blockrule field from spare wire; should
                               be set to 1 after clearing
                               mcsched_pq_chkn_bit.sel_write_err_latency
                            */
    UINT32 unused_bits30_23 : 8;

                            /* Bits[30:23], Access Type=RW, default=0x00000000*/

                            /* unused */
    UINT32 def_1 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable write pointer for CADB
                               lmn_fifo.
                            */

  } Bits;
  UINT32 Data;

} MCSCHED_CHKN_BIT_MCDDC_CTL_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_ddr4_cap_err_latency : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable cap error latency counte on SRE command
                               before sending pm2 message in ddr4
                            */
    UINT32 dis_ref_dqsosc_wait_during_retry : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Disable wait during ST_REF_DQSOSC_STRT_REQ state
                               during retry and instead go back to FREE state;
                               default value should be 1'b1 (i.e. skip DQSOSC
                               and return to REF_FREE during retry).
                            */
    UINT32 en_wr_cas_won_during_viral : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Allow datapath to see write CAS won indication
                               during viral.
                            */
    UINT32 unused_bits11_3 : 9;

                            /* Bits[11:3], Access Type=RW, default=0x00000000*/

                            /*
                               Bits 12:4 are actually unused; bit 3 is used as
                               a workaround for 1409738990 to disable the
                               workaround
                            */
    UINT32 rsvd_12 : 1;

                            /* Bits[12:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_bs_parerr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Disable parity error detection for BS address
                               output.
                            */
    UINT32 dis_aom : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /* Override ODT output to IO */
    UINT32 unused_bits18_15 : 4;

                            /* Bits[18:15], Access Type=RW, default=0x00000000*/

                            /* unused */
    UINT32 dis_ck_gate_sched : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /* Disable Clock Gate in Scheduler */
    UINT32 dis_ddrt_gnt_aggr_blk : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Disable bug fix for 14010041372 Default behavior
                               is to trigger safe timers on both subchannels
                               when DDRT grant is detected on either
                               subchannel.
                            */
    UINT32 unused_bit_21 : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000001*/

                            /* unused */
    UINT32 unused_bit_22 : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /* unused */
    UINT32 unused_bits30_23 : 8;

                            /* Bits[30:23], Access Type=RW, default=0x00000000*/

                            /* unused */
    UINT32 def_1 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable write pointer for CADB
                               lmn_fifo.
                            */

  } Bits;
  UINT32 Data;

} MCSCHED_CHKN_BIT_MCDDC_CTL_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_ddr4_cap_err_latency : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable cap error latency counte on SRE command
                               before sending pm2 message in ddr4
                            */
    UINT32 dis_ref_dqsosc_wait_during_retry : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Disable wait during ST_REF_DQSOSC_STRT_REQ state
                               during retry and instead go back to FREE state;
                               default value should be 1'b1 (i.e. skip DQSOSC
                               and return to REF_FREE during retry).
                            */
    UINT32 en_wr_cas_won_during_viral : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Allow datapath to see write CAS won indication
                               during viral.
                            */
    UINT32 rsvd : 10;

                            /* Bits[12:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_bs_parerr : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Disable parity error detection for BS address
                               output.
                            */
    UINT32 dis_aom : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /* Override ODT output to IO */
    UINT32 unused_bits18_15 : 4;

                            /* Bits[18:15], Access Type=RW, default=0x00000000*/

                            /* unused */
    UINT32 dis_ck_gate_sched : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /* Disable Clock Gate in Scheduler */
    UINT32 rsvd_20 : 11;

                            /* Bits[30:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 def_1 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable write pointer for CADB
                               lmn_fifo.
                            */

  } Bits;
  UINT32 Data;

} MCSCHED_CHKN_BIT_MCDDC_CTL_STRUCT;

/* PC6_CLKSTP_FSM_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x20021950)                                                      */
/*      SPRB0 (0x20021950)                                                      */
/*      SPRHBM (0x20021950)                                                     */
/*      SPRC0 (0x20021950)                                                      */
/*      SPRMCC (0x20021950)                                                     */
/*      SPRUCC (0x20021950)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* This is a debug register to capture FSM states for PkgC flow
*/


#define PC6_CLKSTP_FSM_MCDDC_CTL_REG 0x0B021950

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pc6_clkstp_fsm : 7;

                            /* Bits[6:0], Access Type=RO/V, default=0x00000000*/

                            /* Current state of PC6 clock stop fsm in MNT */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pcupwdn_fsm : 2;

                            /* Bits[9:8], Access Type=RO/V, default=0x00000000*/

                            /* Current state of PCUPWDN fsm in MNT */
    UINT32 srck_fsm : 3;

                            /* Bits[12:10], Access Type=RO/V, default=0x00000000*/

                            /* Current state of SRCK fsm in MNT */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PC6_CLKSTP_FSM_MCDDC_CTL_STRUCT;

/* REFRESH_FSM_STATE_0_MCDDC_CTL_REG supported on:                              */
/*      SPRA0 (0x20021954)                                                      */
/*      SPRB0 (0x20021954)                                                      */
/*      SPRHBM (0x20021954)                                                     */
/*      SPRC0 (0x20021954)                                                      */
/*      SPRMCC (0x20021954)                                                     */
/*      SPRUCC (0x20021954)                                                     */
/* Register default value on SPRA0: 0x3F3F3F3F                                  */
/* Register default value on SPRB0: 0x3F3F3F3F                                  */
/* Register default value on SPRHBM: 0x3F3F3F3F                                 */
/* Register default value on SPRC0: 0x3F3F3F3F                                  */
/* Register default value on SPRMCC: 0x3F3F3F3F                                 */
/* Register default value on SPRUCC: 0x3F3F3F3F                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/*  This register contains current and previous state of refresh FSMs for rank 0 and 1.  
*/


#define REFRESH_FSM_STATE_0_MCDDC_CTL_REG 0x0B021954

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rank0_current_state : 6;

                            /* Bits[5:0], Access Type=RO/V, default=0x0000003F*/

                            /* Current encoded state of rank 0 refresh FSM */
    UINT32 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank0_previous_state : 6;

                            /* Bits[13:8], Access Type=RO/V, default=0x0000003F*/

                            /* Previous encoded state of rank 0 refresh FSM */
    UINT32 rsvd_14 : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank1_current_state : 6;

                            /* Bits[21:16], Access Type=RO/V, default=0x0000003F*/

                            /* Current encoded state of rank 1 refresh FSM */
    UINT32 rsvd_22 : 2;

                            /* Bits[23:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank1_previous_state : 6;

                            /* Bits[29:24], Access Type=RO/V, default=0x0000003F*/

                            /* Previous encoded state of rank 1 refresh FSM */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} REFRESH_FSM_STATE_0_MCDDC_CTL_STRUCT;

/* REFRESH_FSM_STATE_1_MCDDC_CTL_REG supported on:                              */
/*      SPRA0 (0x20021958)                                                      */
/*      SPRB0 (0x20021958)                                                      */
/*      SPRHBM (0x20021958)                                                     */
/*      SPRC0 (0x20021958)                                                      */
/*      SPRMCC (0x20021958)                                                     */
/*      SPRUCC (0x20021958)                                                     */
/* Register default value on SPRA0: 0x3F3F3F3F                                  */
/* Register default value on SPRB0: 0x3F3F3F3F                                  */
/* Register default value on SPRHBM: 0x3F3F3F3F                                 */
/* Register default value on SPRC0: 0x3F3F3F3F                                  */
/* Register default value on SPRMCC: 0x3F3F3F3F                                 */
/* Register default value on SPRUCC: 0x3F3F3F3F                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/*  This register contains current and previous state of refresh FSMs for rank 2 and 3.  
*/


#define REFRESH_FSM_STATE_1_MCDDC_CTL_REG 0x0B021958

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rank2_current_state : 6;

                            /* Bits[5:0], Access Type=RO/V, default=0x0000003F*/

                            /* Current encoded state of rank 2 refresh FSM */
    UINT32 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank2_previous_state : 6;

                            /* Bits[13:8], Access Type=RO/V, default=0x0000003F*/

                            /* Previous encoded state of rank 2 refresh FSM */
    UINT32 rsvd_14 : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank3_current_state : 6;

                            /* Bits[21:16], Access Type=RO/V, default=0x0000003F*/

                            /* Current encoded state of rank 3 refresh FSM */
    UINT32 rsvd_22 : 2;

                            /* Bits[23:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank3_previous_state : 6;

                            /* Bits[29:24], Access Type=RO/V, default=0x0000003F*/

                            /* Previous encoded state of rank 3 refresh FSM */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} REFRESH_FSM_STATE_1_MCDDC_CTL_STRUCT;

/* SPID_TRACE_CFG_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x2002195c)                                                      */
/*      SPRB0 (0x2002195c)                                                      */
/*      SPRHBM (0x2002195c)                                                     */
/*      SPRC0 (0x2002195c)                                                      */
/*      SPRMCC (0x2002195c)                                                     */
/*      SPRUCC (0x2002195c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* configure local spid tracing in scheduler partition
*/


#define SPID_TRACE_CFG_MCDDC_CTL_REG 0x0B02195C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 7;

                            /* Bits[6:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 adl_throttle_enable : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Enable ADL throttling. When enabled, throttling
                               will be enabled (dividend/divisor)% of the time.
                            */
    UINT32 adl_throttle_divisor : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /* Divisor for ADL throttling */
    UINT32 adl_throttle_dividend : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /* Dividend for ADL throttling */
    UINT32 subchannel_select : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Selects the DDR5/T2 subchannel for ADL PA
                               tracing
                            */
    UINT32 rsvd_25 : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SPID_TRACE_CFG_MCDDC_CTL_STRUCT;

/* FINAL_FILTER_MCDDC_CTL_REG supported on:                                     */
/*      SPRA0 (0x20021960)                                                      */
/*      SPRB0 (0x20021960)                                                      */
/*      SPRHBM (0x20021960)                                                     */
/*      SPRC0 (0x20021960)                                                      */
/*      SPRMCC (0x20021960)                                                     */
/*      SPRUCC (0x20021960)                                                     */
/* Register default value on SPRA0: 0x2E000000                                  */
/* Register default value on SPRB0: 0x2E000000                                  */
/* Register default value on SPRHBM: 0x2E000000                                 */
/* Register default value on SPRC0: 0x2E000000                                  */
/* Register default value on SPRMCC: 0x2E000000                                 */
/* Register default value on SPRUCC: 0x2E000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Set bits to 1 to enable matching and also to enable spid tracing and filtering
*/


#define FINAL_FILTER_MCDDC_CTL_REG 0x0B021960

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 filter_select0 : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               N-hot code to select which of the 4 filter
                               outputs to AND together for filter output 0 (set
                               to zero to make output 1). All 4 filter_selected
                               outputs are then ORed for final spid trace
                               enable
                            */
    UINT32 filter_select1 : 4;

                            /* Bits[7:4], Access Type=RW, default=0x00000000*/

                            /*
                               N-hot code to select which of the 4 filter
                               outputs to AND together for filter output 1 (set
                               to zero to make output 1). All 4 filter_selected
                               outputs are then ORed for final spid trace
                               enable
                            */
    UINT32 filter_select2 : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000000*/

                            /*
                               N-hot code to select which of the 4 filter
                               outputs to AND together for filter output 2 (set
                               to zero to make output 1). All 4 filter_selected
                               outputs are then ORed for final spid trace
                               enable
                            */
    UINT32 filter_select3 : 4;

                            /* Bits[15:12], Access Type=RW, default=0x00000000*/

                            /*
                               N-hot code to select which of the 4 filter
                               outputs to AND together for filter output 3 (set
                               to zero to make output 1). All 4 filter_selected
                               outputs are then ORed for final spid trace
                               enable
                            */
    UINT32 pmon_trigger_counter_inc_select : 5;

                            /* Bits[20:16], Access Type=RW, default=0x00000000*/

                            /*
                               Select which PMON counters to include in trigger
                               when pmon_trigger_mode_inc is set to 1
                            */
    UINT32 pmon_trigger_mode_inc : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Select PMON trigger mode to be increment when
                               set or overflow when clear
                            */
    UINT32 rsvd : 2;

                            /* Bits[23:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 spid_trace_fifo_overflow : 1;

                            /* Bits[24:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit will be set if the SPID trace FIFO is
                               written to when full. If this bit is set, a
                               sample was lost
                            */
    UINT32 trigger_en_ddrt_alert : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to enable debug trigger 0 to
                               fire on ddrt_alert
                            */
    UINT32 trigger_en_alert : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to enable debug trigger 0 to
                               fire on alert
                            */
    UINT32 trigger_en_rd_error : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to enable debug trigger 0 to
                               fire on read ECC error
                            */
    UINT32 trigger_en : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /* Set this bit to 1 to enable debug triggers */
    UINT32 spid_trace_bp_enable : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Set this bit to 1 to enable spid tracing back
                               pressure on the scheduler
                            */
    UINT32 spid_trace_enable : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to enable spid tracing and
                               filtering logic
                            */
    UINT32 select_all : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 to capture all and ignore the
                               filter_selects
                            */

  } Bits;
  UINT32 Data;

} FINAL_FILTER_MCDDC_CTL_STRUCT;

/* DDRT_SEL_BUS_MCDDC_CTL_REG supported on:                                     */
/*      SPRA0 (0x20021964)                                                      */
/*      SPRB0 (0x20021964)                                                      */
/*      SPRHBM (0x20021964)                                                     */
/*      SPRC0 (0x20021964)                                                      */
/*      SPRMCC (0x20021964)                                                     */
/*      SPRUCC (0x20021964)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Use this register to select among 4 types of spid bus for ddrt to be captured and sent by pa block.
*/


#define DDRT_SEL_BUS_MCDDC_CTL_REG 0x0B021964

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddrt_pa_data_bus_select : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               One-hot coded to select which of the 4 types of
                               spid bus for ddrt to be captured and sent by pa
                               block.
                            */
    UINT32 rsvd : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_SEL_BUS_MCDDC_CTL_STRUCT;

/* CMD_PAR_INJ_MASK_MCDDC_CTL_REG supported on:                                 */
/*      SPRA0 (0x20021980)                                                      */
/*      SPRB0 (0x20021980)                                                      */
/*      SPRHBM (0x20021980)                                                     */
/*      SPRC0 (0x20021980)                                                      */
/*      SPRMCC (0x20021980)                                                     */
/*      SPRUCC (0x20021980)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* DDR Command Parity Injection Mask Value 
*/


#define CMD_PAR_INJ_MASK_MCDDC_CTL_REG 0x0B021980

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd : 29;

                            /* Bits[28:0], Access Type=RW, default=0x1FFFFFFF*/

                            /*
                               Mask mapping for DDR4/T: RAS_b, CAS_b, WE_b,
                               ACT_b, C[2:0], BG[1:0], BA[1:0], A[17:0] Mask
                               mapping for HBM: 7: 0 is used for UI0 of column
                               command 15: 8 is used for UI1 of column command
                               21:16 is used for UI0 and UI2 of row command
                               27:22 is used for UI1 and UI3 of row command For
                               DDRT: The RAS_b, CAS_b, WE_b, ACT_b fields
                               should be masked as they are undefined
                            */
    UINT32 rank : 3;

                            /* Bits[31:29], Access Type=RW, default=0x00000007*/

                            /* Mask Value for Rank; not used in HBM */

  } Bits;
  UINT32 Data;

} CMD_PAR_INJ_MASK_MCDDC_CTL_STRUCT;

/* CMD_PAR_INJ_MATCH_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20021984)                                                      */
/*      SPRB0 (0x20021984)                                                      */
/*      SPRHBM (0x20021984)                                                     */
/*      SPRC0 (0x20021984)                                                      */
/*      SPRMCC (0x20021984)                                                     */
/*      SPRUCC (0x20021984)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* DDR Command Parity Injection Match Value. Match will always be done on first UI for DDRT commands. 
*/


#define CMD_PAR_INJ_MATCH_MCDDC_CTL_REG 0x0B021984

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd : 29;

                            /* Bits[28:0], Access Type=RW, default=0x00000000*/

                            /*
                               Mask mapping for DDR4/T: C[2:0], RAS_b, CAS_b,
                               WE_b, ACT_b, BG[1:0], BA[1:0], A[17:0] Mask
                               mapping for HBM: 7: 0 is used for UI0 of column
                               command 15: 8 is used for UI1 of column command
                               21:16 is used for UI0 and UI2 of row command
                               27:22 is used for UI1 and UI3 of row command For
                               DDRT: The RAS_b, CAS_b, WE_b, ACT_b fields
                               should be masked as they are undefined
                            */
    UINT32 rank : 3;

                            /* Bits[31:29], Access Type=RW, default=0x00000000*/

                            /* Match Value for Rank */

  } Bits;
  UINT32 Data;

} CMD_PAR_INJ_MATCH_MCDDC_CTL_STRUCT;

/* RPA_WPA_PAR_ERR_CTL_MCDDC_CTL_REG supported on:                              */
/*      SPRA0 (0x20021988)                                                      */
/*      SPRB0 (0x20021988)                                                      */
/*      SPRHBM (0x20021988)                                                     */
/*      SPRC0 (0x20021988)                                                      */
/*      SPRMCC (0x20021988)                                                     */
/*      SPRUCC (0x20021988)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: ERR_INJ                                          */
/* SPRB0 Security PolicyGroup: ERR_INJ                                          */
/* SPRHBM Security PolicyGroup: ERR_INJ                                         */
/* SPRC0 Security PolicyGroup: ERR_INJ                                          */
/* SPRMCC Security PolicyGroup: ERR_INJ                                         */
/* SPRUCC Security PolicyGroup: ERR_INJ                                         */
/* generated by critter 20_0_0x704
*/


#define RPA_WPA_PAR_ERR_CTL_MCDDC_CTL_REG 0x0B021988

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 errinj_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Parity error will be injected on the next BS
                               read after this bit is set. Enable bit will be
                               unset after injection.
                            */
    UINT32 rsvd : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RPA_WPA_PAR_ERR_CTL_MCDDC_CTL_STRUCT;

/* DIMM_TEMP_EV_OFST_0_MCDDC_CTL_REG supported on:                              */
/*      SPRA0 (0x200219a0)                                                      */
/*      SPRB0 (0x200219a0)                                                      */
/*      SPRHBM (0x200219a0)                                                     */
/*      SPRC0 (0x200219a0)                                                      */
/*      SPRMCC (0x200219a0)                                                     */
/*      SPRUCC (0x200219a0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* generated by critter 20_0_0x140
*/


#define DIMM_TEMP_EV_OFST_0_MCDDC_CTL_REG 0x0B0219A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dimm_temp_offset : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /* Bit 3-0 - Temperature Offset Register */
    UINT32 rsvd : 6;

                            /* Bits[9:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ev_mh_templo_en : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Assert MEMHOT# Event on TEMPLO */
    UINT32 ev_mh_tempmid_en : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /* Assert MEMHOT# Event on TEMPMID */
    UINT32 ev_mh_temphi_en : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /* Assert MEMHOT# Event on TEMPHI */
    UINT32 ev_2x_ref_en : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Enable 2X refresh when memory temperature is
                               above TEMP_TWOXREF
                            */
    UINT32 ev_thrtmid_templo : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /* Initiate THRTMID on TEMPLO */
    UINT32 ev_halfx_ref_en : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Enable 1/2X refresh when memory temperature is
                               below TEMP_HALFXREF
                            */
    UINT32 ev_4x_ref_en : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Enable 4X refresh when memory temperature is
                               above TEMP_FOURXREF
                            */
    UINT32 ev_2x_pb_ref_en : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Allow per-bank refresh if enabled by
                               tcstagger_ref.perbank_mode when memory
                               temperature is above TEMP_TWOXREF and
                               ev_2x_ref_en is 1. Note that this field affects
                               both DIMM 0 and DIMM 1
                            */
    UINT32 ev_4x_pb_ref_en : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Allow per-bank refresh if enabled by
                               tcstagger_ref.perbank_mode when memory
                               temperature is above TEMP_FOURXREF and
                               ev_4x_ref_en is 1. Note that this field affects
                               both DIMM 0 and DIMM 1
                            */
    UINT32 use_dimm1_temp_for_hbm_refresh_rate : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Use DIMM temperature 1 for 1/2x, 2x and 4x
                               refresh rate determination for HBM instead of
                               DIMM temperature 0
                            */
    UINT32 rsvd_20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIMM_TEMP_EV_OFST_0_MCDDC_CTL_STRUCT;

/* DIMM_TEMP_EV_OFST_1_MCDDC_CTL_REG supported on:                              */
/*      SPRA0 (0x200219a4)                                                      */
/*      SPRB0 (0x200219a4)                                                      */
/*      SPRHBM (0x200219a4)                                                     */
/*      SPRC0 (0x200219a4)                                                      */
/*      SPRMCC (0x200219a4)                                                     */
/*      SPRUCC (0x200219a4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* generated by critter 20_0_0x144
*/


#define DIMM_TEMP_EV_OFST_1_MCDDC_CTL_REG 0x0B0219A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dimm_temp_offset : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /* Bit 3-0 - Temperature Offset Register */
    UINT32 rsvd : 6;

                            /* Bits[9:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ev_mh_templo_en : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Assert MEMHOT# Event on TEMPLO */
    UINT32 ev_mh_tempmid_en : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /* Assert MEMHOT# Event on TEMPMID */
    UINT32 ev_mh_temphi_en : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /* Assert MEMHOT# Event on TEMPHI */
    UINT32 ev_2x_ref_en : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Enable 2X refresh when memory temperature is
                               above TEMP_TWOXREF
                            */
    UINT32 ev_thrtmid_templo : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /* Initiate THRTMID on TEMPLO */
    UINT32 ev_halfx_ref_en : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Enable 1/2X refresh when memory temperature is
                               below TEMP_HALFXREF
                            */
    UINT32 ev_4x_ref_en : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Enable 4X refresh when memory temperature is
                               above TEMP_FOURXREF
                            */
    UINT32 rsvd_17 : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIMM_TEMP_EV_OFST_1_MCDDC_CTL_STRUCT;

/* DIMM_TEMP_TH_0_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x200219a8)                                                      */
/*      SPRB0 (0x200219a8)                                                      */
/*      SPRHBM (0x200219a8)                                                     */
/*      SPRC0 (0x200219a8)                                                      */
/*      SPRMCC (0x200219a8)                                                     */
/*      SPRUCC (0x200219a8)                                                     */
/* Register default value on SPRA0: 0x005F5A55                                  */
/* Register default value on SPRB0: 0x005F5A55                                  */
/* Register default value on SPRHBM: 0x005F5A55                                 */
/* Register default value on SPRC0: 0x005F5A55                                  */
/* Register default value on SPRMCC: 0x005F5A55                                 */
/* Register default value on SPRUCC: 0x005F5A55                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* generated by critter 20_0_0x120
*/


#define DIMM_TEMP_TH_0_MCDDC_CTL_REG 0x0B0219A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 temp_lo : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000055*/

                            /*
                               TCase threshold at which to Initiate THRTMID and
                               initiate Interrupt (MEMHOT#). Note: the default
                               value is listed in decimal.valid range: 32 - 127
                               in degree C. FF: Disabled Others: reserved.
                               TEMP_LO should be programmed so it is less than
                               TEMP_MID
                            */
    UINT32 temp_mid : 8;

                            /* Bits[15:8], Access Type=RW, default=0x0000005A*/

                            /*
                               TCase threshold at which to Initiate THRTHI and
                               assert valid range: 32 - 127 in degree C. Note:
                               the default value is listed in decimal. FF:
                               Disabled Others: reserved. TEMP_MID should be
                               programmed so it is less than TEMP_HI
                            */
    UINT32 temp_hi : 8;

                            /* Bits[23:16], Access Type=RW, default=0x0000005F*/

                            /*
                               TCase threshold at which to Initiate THRTCRIT
                               and assert THERMTRIP# valid range: 32 - 127 in
                               degree C. Note: the default value is listed in
                               decimal. FF: Disabled Others: reserved. TEMP_HI
                               should be programmed so it is greater than
                               TEMP_MID
                            */
    UINT32 temp_thrt_hyst : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /*
                               Positive going Threshold Hysteresis Value. Set
                               to 00h if sensor does not support positive-going
                               threshold hysteresis. This value is subtracted
                               from TEMP_THRT_XX to determine the point where
                               the asserted status for that threshold will
                               clear.
                            */
    UINT32 rsvd : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIMM_TEMP_TH_0_MCDDC_CTL_STRUCT;

/* DIMM_TEMP_TH_1_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x200219ac)                                                      */
/*      SPRB0 (0x200219ac)                                                      */
/*      SPRHBM (0x200219ac)                                                     */
/*      SPRC0 (0x200219ac)                                                      */
/*      SPRMCC (0x200219ac)                                                     */
/*      SPRUCC (0x200219ac)                                                     */
/* Register default value on SPRA0: 0x005F5A55                                  */
/* Register default value on SPRB0: 0x005F5A55                                  */
/* Register default value on SPRHBM: 0x005F5A55                                 */
/* Register default value on SPRC0: 0x005F5A55                                  */
/* Register default value on SPRMCC: 0x005F5A55                                 */
/* Register default value on SPRUCC: 0x005F5A55                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* generated by critter 20_0_0x124
*/


#define DIMM_TEMP_TH_1_MCDDC_CTL_REG 0x0B0219AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 temp_lo : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000055*/

                            /*
                               TCase threshold at which to Initiate THRTMID and
                               initiate Interrupt (MEMHOT#). Note: the default
                               value is listed in decimal.valid range: 32 - 127
                               in degree C. FF: Disabled Others: reserved.
                               TEMP_LO should be programmed so it is less than
                               TEMP_MID
                            */
    UINT32 temp_mid : 8;

                            /* Bits[15:8], Access Type=RW, default=0x0000005A*/

                            /*
                               TCase threshold at which to Initiate THRTHI and
                               assert valid range: 32 - 127 in degree C. Note:
                               the default value is listed in decimal. FF:
                               Disabled Others: reserved. TEMP_MID should be
                               programmed so it is less than TEMP_HI
                            */
    UINT32 temp_hi : 8;

                            /* Bits[23:16], Access Type=RW, default=0x0000005F*/

                            /*
                               TCase threshold at which to Initiate THRTCRIT
                               and assert THERMTRIP# valid range: 32 - 127 in
                               degree C. Note: the default value is listed in
                               decimal. FF: Disabled Others: reserved. TEMP_HI
                               should be programmed so it is greater than
                               TEMP_MID
                            */
    UINT32 temp_thrt_hyst : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /*
                               Positive going Threshold Hysteresis Value. Set
                               to 00h if sensor does not support positive-going
                               threshold hysteresis. This value is subtracted
                               from TEMP_THRT_XX to determine the point where
                               the asserted status for that threshold will
                               clear.
                            */
    UINT32 rsvd : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIMM_TEMP_TH_1_MCDDC_CTL_STRUCT;

/* DIMM_TEMP_THRT_LMT_0_MCDDC_CTL_REG supported on:                             */
/*      SPRA0 (0x200219b0)                                                      */
/*      SPRB0 (0x200219b0)                                                      */
/*      SPRHBM (0x200219b0)                                                     */
/*      SPRC0 (0x200219b0)                                                      */
/*      SPRMCC (0x200219b0)                                                     */
/*      SPRUCC (0x200219b0)                                                     */
/* Register default value on SPRA0: 0x00000FFF                                  */
/* Register default value on SPRB0: 0x00000FFF                                  */
/* Register default value on SPRHBM: 0x00000FFF                                 */
/* Register default value on SPRC0: 0x00000FFF                                  */
/* Register default value on SPRMCC: 0x00000FFF                                 */
/* Register default value on SPRUCC: 0x00000FFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* All three THRT_CRIT, THRT_HI and THRT_MID are per DIMM BW limit, i.e. all activities (ACT, READ, WRITE) from all ranks within a DIMM are tracked together in one DIMM activity counter.
These throttle limits for hi and crit are also used during scalable memory buffer thermal throttling.
*/


#define DIMM_TEMP_THRT_LMT_0_MCDDC_CTL_REG 0x0B0219B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 thrt_mid : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000FF*/

                            /*
                               Max number of throttled transactions (ACT, READ,
                               WRITE) to be issued during BWLIMITTF.
                            */
    UINT32 thrt_hi : 8;

                            /* Bits[15:8], Access Type=RW, default=0x0000000F*/

                            /*
                               Max number of throttled transactions (ACT, READ,
                               WRITE) to be issued during BWLIMITTF.
                            */
    UINT32 thrt_crit : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /*
                               Max number of throttled transactions (ACT, READ,
                               WRITE) to be issued during BWLIMITTF.
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIMM_TEMP_THRT_LMT_0_MCDDC_CTL_STRUCT;

/* DIMM_TEMP_THRT_LMT_1_MCDDC_CTL_REG supported on:                             */
/*      SPRA0 (0x200219b4)                                                      */
/*      SPRB0 (0x200219b4)                                                      */
/*      SPRHBM (0x200219b4)                                                     */
/*      SPRC0 (0x200219b4)                                                      */
/*      SPRMCC (0x200219b4)                                                     */
/*      SPRUCC (0x200219b4)                                                     */
/* Register default value on SPRA0: 0x00000FFF                                  */
/* Register default value on SPRB0: 0x00000FFF                                  */
/* Register default value on SPRHBM: 0x00000FFF                                 */
/* Register default value on SPRC0: 0x00000FFF                                  */
/* Register default value on SPRMCC: 0x00000FFF                                 */
/* Register default value on SPRUCC: 0x00000FFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* All three THRT_CRIT, THRT_HI and THRT_MID are per DIMM BW limit, i.e. all activities (ACT, READ, WRITE) from all ranks within a DIMM are tracked together in one DIMM activity counter.
These throttle limits for hi and crit are also used during scalable memory buffer thermal throttling.
*/


#define DIMM_TEMP_THRT_LMT_1_MCDDC_CTL_REG 0x0B0219B4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 thrt_mid : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000FF*/

                            /*
                               Max number of throttled transactions (ACT, READ,
                               WRITE) to be issued during BWLIMITTF.
                            */
    UINT32 thrt_hi : 8;

                            /* Bits[15:8], Access Type=RW, default=0x0000000F*/

                            /*
                               Max number of throttled transactions (ACT, READ,
                               WRITE) to be issued during BWLIMITTF.
                            */
    UINT32 thrt_crit : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /*
                               Max number of throttled transactions (ACT, READ,
                               WRITE) to be issued during BWLIMITTF.
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIMM_TEMP_THRT_LMT_1_MCDDC_CTL_STRUCT;

/* MCMNT_CHKN_BIT_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x200219b8)                                                      */
/*      SPRB0 (0x200219b8)                                                      */
/*      SPRHBM (0x200219b8)                                                     */
/*      SPRC0 (0x200219b8)                                                      */
/*      SPRMCC (0x200219b8)                                                     */
/*      SPRUCC (0x200219b8)                                                     */
/* Register default value on SPRA0: 0x910000E0                                  */
/* Register default value on SPRB0: 0x910000A0                                  */
/* Register default value on SPRHBM: 0x910000A0                                 */
/* Register default value on SPRC0: 0x910000A0                                  */
/* Register default value on SPRMCC: 0x910000A0                                 */
/* Register default value on SPRUCC: 0x910000A0                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x700
*/


#define MCMNT_CHKN_BIT_MCDDC_CTL_REG 0x0B0219B8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_refresh_start_delay : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Disable refresh start delay */
    UINT32 dis_ck_gate_mnts : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Disable Clock Gating at MNTS. */
    UINT32 allow_sref_exit_while_pcu_wants_to_stay : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Allow self-refresh exit due to new traffic even
                               though PCU is trying to keep the DIMMs in self-
                               refresh. Note that LPmode for self-refrsh must
                               be disabled to be able to use this mode.
                            */
    UINT32 dis_opp_ref : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit is set, MC will never issue a
                               refresh unless either HP or Panic refresh is
                               triggered. For example, if we only have panic
                               refresh enabled, if IMC has reached panic
                               refresh watermark and issue one refresh to get
                               out of panic. When the next tREFI expires, the
                               IMC will enter panic refresh again. The pattern
                               will repeat every tREFI and remain at constant
                               panic mode. Therefore, this is not very useful
                               mode for normal usage. Setting this bit is
                               recommended only for bug workaround in
                               opportunistic refresh flows. Setting this bit
                               will not affect AsyncSR or ForceSR since these
                               signals are ORed with opp_ref_enabled in RTL so
                               that we will be able to drain all refreshes and
                               enter the power savings mode. Limitations: If
                               this bit is set, we will never be able to enter
                               self refresh via idle timer since the refreshes
                               are not drained.
                            */
    UINT32 rsvd_4 : 2;

                            /* Bits[5:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 zqlsrl : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000001*/

                            /*
                               Enabling the memory controller to issue two
                               auto-refreshes upon exiting self-refresh. It
                               also serialize the ZQCx between ranks upon self-
                               refresh exit when set.
                            */
    UINT32 srx_rcomp_block : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000001*/

                            /*
                               Enable extra Rcomp block during ZQcals generated
                               from self-refresh exit.
                            */
    UINT32 en_cke_rise_on_fake_ddrt_ref : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Enable CKE rise on DDR-T DIMMs for NOP refresh
                               commands.
                            */
    UINT32 dis_zqcal : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Disable ZQCAL. Note: If DIS_ZQCAL=1 and
                               DIS_SRX_EX_ZQ=1, IMC will not issue any ZQCx.
                            */
    UINT32 long_zq : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               1: IMC issues ZQCL instead of ZQCS in the
                               subsequent ZQ calibration after the initial ZQ
                               0: IMC issues ZQCS instead of ZQCL in the
                               subsequent ZQ calibration after the initial ZQ
                            */
    UINT32 dis_srx_ex_zq : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Disable srx ex zq disable ZQ calibration upon
                               exiting self-refresh if set
                            */
    UINT32 fst_zq : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               enable fast zq tczqcal_zqcsperiod is divided by
                               16 when fst_zq is set.
                            */
    UINT32 en_ddrt_pc6_clkstp_fsm : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               This bit must be set if the MC has any DDRT dimm
                               populated. It is needed for correct operation of
                               DDRT PC6 Clock Stop. This bit must be set to 0
                               in a DDR4 only config.
                            */
    UINT32 pc6_clkstp_fsm_block_pma_ack : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Chicken bit to be set to 1 if DDRT Clock Stop
                               FSM should control Ack to PMA during clock stop.
                            */
    UINT32 pwdn_idle_tmr_increase : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 in increase the power Down
                               Idle Timer that controls delay from Idle to CKE
                               de-assertion by 256 Dclks. This increase will
                               take effect when CKE has to be taken low for
                               Idle as well as throttling conditions.
                            */
    UINT32 pwdn_idle_tmr_increase_thr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit to 1 in increase the power Down
                               Idle Timer that controls delay from Idle to CKE
                               de-assertion by 256 Dclks only when CKE has to
                               be taken low due to thermal throttling
                               conditions. The timer will not increase when
                               when CKE has to be taken low for Idle
                               conditions.
                            */
    UINT32 dis_cke_off_durg_thr : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Disable turnoff CKE during throttle Important
                               Note: Setting DIS_CKE_OFF_DURG_THR=1will cause
                               ACT to be issued during throttling which will
                               cause additional power consumption.
                            */
    UINT32 zqcal_block_pm_dis : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               DDR5/DDRT2: disable feature of blocking
                               powerdown entry between ZQCalStart/Latch pair
                            */
    UINT32 stagger_ref_en : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Stagger Refresh Enable, When set, the
                               T_STAGGER_REF timing parameter becomes effective
                               to stagger the REF command
                            */
    UINT32 dis_wpq_sref_exit : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Disable self-refresh exit due to WPQ going non-
                               empty.
                            */
    UINT32 dissrclkstop : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               DDRT-only. Disable Self Refresh with Clock Stop
                               feature via CSn behavior.
                            */
    UINT32 frc_mdll_off : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Force DDRIO master DLL off, and de-assert
                               MCActive signal to the MC PMA.
                            */
    UINT32 frc_mdll_on : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Force DDRIO master DLL on, and assert MCActive
                               signal to the MC PMA. Takes priority over
                               frc_mdll_off.
                            */
    UINT32 dqsmrr_block_cas_dis : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000001*/

                            /*
                               Disable blocking CAS commands during DQS Tx
                               Retraining MRR sequence
                            */
    UINT32 dqsmrr_block_cas_tmr : 5;

                            /* Bits[29:25], Access Type=RW, default=0x00000008*/

                            /*
                               Number of cycles to block CAS commands before
                               first DQS Tx Retraining MRR and after last DQS
                               MRR
                            */
    UINT32 block_thr_1 : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* Blocks throttle signal for panic refresh */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCMNT_CHKN_BIT_MCDDC_CTL_STRUCT;

/* MCODTVISACFG_MCDDC_CTL_REG supported on:                                     */
/*      SPRA0 (0x200219d0)                                                      */
/*      SPRB0 (0x200219d0)                                                      */
/*      SPRHBM (0x200219d0)                                                     */
/*      SPRC0 (0x200219d0)                                                      */
/*      SPRMCC (0x200219d0)                                                     */
/*      SPRUCC (0x200219d0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is reserved.
*/


#define MCODTVISACFG_MCDDC_CTL_REG 0x0B0219D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lane0sel : 6;

                            /* Bits[5:0], Access Type=RW/P/L, default=0x00000000*/

                            /* lane 0 select */
    UINT32 lane1sel : 6;

                            /* Bits[11:6], Access Type=RW/P/L, default=0x00000000*/

                            /* lane 1 select */
    UINT32 lane2sel : 6;

                            /* Bits[17:12], Access Type=RW/P/L, default=0x00000000*/

                            /* lane 2 select */
    UINT32 lane3sel : 6;

                            /* Bits[23:18], Access Type=RW/P/L, default=0x00000000*/

                            /* lane 3 select */
    UINT32 clken : 1;

                            /* Bits[24:24], Access Type=RW/P/L, default=0x00000000*/

                            /* clock enable for debug mux */
    UINT32 rsvd : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCODTVISACFG_MCDDC_CTL_STRUCT;

/* WDAR_MODE_MCDDC_CTL_REG supported on:                                        */
/*      SPRA0 (0x200219d4)                                                      */
/*      SPRB0 (0x200219d4)                                                      */
/*      SPRHBM (0x200219d4)                                                     */
/*      SPRC0 (0x200219d4)                                                      */
/*      SPRMCC (0x200219d4)                                                     */
/*      SPRUCC (0x200219d4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is not used
*/


#define WDAR_MODE_MCDDC_CTL_REG 0x0B0219D4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wdarmode : 1;

                            /* Bits[0:0], Access Type=RW/L, default=0x00000000*/

                            /* 0 - Not enabled, 1 -Enabled */
    UINT32 rsvd : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} WDAR_MODE_MCDDC_CTL_STRUCT;

/* CMD_PAR_INJ_CTL_N0_MCDDC_CTL_REG supported on:                               */
/*      SPRA0 (0x200219d8)                                                      */
/*      SPRB0 (0x200219d8)                                                      */
/*      SPRHBM (0x200219d8)                                                     */
/*      SPRC0 (0x200219d8)                                                      */
/*      SPRMCC (0x200219d8)                                                     */
/*      SPRUCC (0x200219d8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* DDR Command Parity Injection Control. Use with cmd_par_inj_match and cmd_par_inj_mask.
                   en_ddrt_ui0, en_ddrt_ui1, and en_ddr4 should always be mutex.
*/


#define CMD_PAR_INJ_CTL_N0_MCDDC_CTL_REG 0x0B0219D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 en_ddr4 : 1;

                            /* Bits[0:0], Access Type=RW/V/L, default=0x00000000*/

                            /*
                               Enable injection on DDR4 Command and HBM column
                               command. HW will self clear on final injection.
                            */
    UINT32 en_ddrt_ui0 : 1;

                            /* Bits[1:1], Access Type=RW/V/L, default=0x00000000*/

                            /*
                               Enable injection on DDRT Comnmand UI0 and for
                               HBM row command UI1:0 . HW will self clear on
                               final injection.
                            */
    UINT32 en_ddrt_ui1 : 1;

                            /* Bits[2:2], Access Type=RW/V/L, default=0x00000000*/

                            /*
                               Enable injection on DDRT Command UI1 and for HBM
                               row command UI3:2. HW will self clear on final
                               injection.
                            */
    UINT32 en_ddrt_ui2 : 1;

                            /* Bits[3:3], Access Type=RW/V/L, default=0x00000000*/

                            /*
                               Enable injection on DDRT2 Command UI2. HW will
                               self clear on final injection. Set to 0 for
                               DDRT/HBM/DDR4/DDR5.
                            */
    UINT32 en_ddrt_ui3 : 1;

                            /* Bits[4:4], Access Type=RW/V/L, default=0x00000000*/

                            /*
                               Enable injection on DDRT2 Command UI3. HW will
                               self clear on final injection. Set to 0 for
                               DDRT/HBM/DDR4/DDR5.
                            */
    UINT32 trig_en_ddr4 : 1;

                            /* Bits[5:5], Access Type=RW/L, default=0x00000000*/

                            /*
                               Global response trigger enable injection on DDR4
                               Command and HBM column command. HW will self
                               clear on final injection. The en_ddr4 bit will
                               get set to 1 when this bit is set to 1 and the
                               global response trigger occurs. This bit will
                               self-clear when the trigger occurs.
                            */
    UINT32 trig_en_ddrt_ui0 : 1;

                            /* Bits[6:6], Access Type=RW/L, default=0x00000000*/

                            /*
                               Global response trigger enable injection on DDRT
                               Comnmand UI0 and for HBM row command UI1:0 . HW
                               will self clear on final injection. The
                               en_ddrt_ui0 bit will get set to 1 when this bit
                               is set to 1 and the global response trigger
                               occurs. This bit will self-clear when the
                               trigger occurs.
                            */
    UINT32 trig_en_ddrt_ui1 : 1;

                            /* Bits[7:7], Access Type=RW/L, default=0x00000000*/

                            /*
                               Global response trigger enable injection on DDRT
                               Command UI1 and for HBM row command UI3:2. HW
                               will self clear on final injection. The
                               en_ddrt_ui1 bit will get set to 1 when this bit
                               is set to 1 and the global response trigger
                               occurs. This bit will self-clear when the
                               trigger occurs.
                            */
    UINT32 trig_en_ddrt_ui2 : 1;

                            /* Bits[8:8], Access Type=RW/L, default=0x00000000*/

                            /*
                               Global response trigger enable injection on
                               DDRT2 Command UI2. HW will self clear on final
                               injection. The en_ddrt_ui2 bit will get set to 1
                               when this bit is set to 1 and the global
                               response trigger occurs. This bit will self-
                               clear when the trigger occurs. Set to 0 for
                               DDRT/DDR4/DDR5/HBM.
                            */
    UINT32 trig_en_ddrt_ui3 : 1;

                            /* Bits[9:9], Access Type=RW/L, default=0x00000000*/

                            /*
                               Global response trigger enable injection on
                               DDRT2 Command UI3. HW will self clear on final
                               injection. The en_ddrt_ui3 bit will get set to 1
                               when this bit is set to 1 and the global
                               response trigger occurs. This bit will self-
                               clear when the trigger occurs. Set to 0 for
                               DDRT/HBM/DDR4/DDR5.
                            */
    UINT32 subchannel_safe : 2;

                            /* Bits[11:10], Access Type=RW/L, default=0x00000000*/

                            /*
                               Individual subchannel safe signals to be used by
                               ddr5 and ddrt2. When this bit is set, hardware
                               command parity error will not be injected on
                               that specific subchannel.
                            */
    UINT32 count : 8;

                            /* Bits[19:12], Access Type=RW/V/L, default=0x00000000*/

                            /*
                               Injection count: 0 = infinite error injection,
                               otherwise the value indicates the number of
                               error injections that will occur before the
                               enable bits are cleared.
                            */
    UINT32 trig_count : 8;

                            /* Bits[27:20], Access Type=RW/L, default=0x00000000*/

                            /*
                               Injection count value to use for the global
                               response trigger: 0 = infinite error injection,
                               otherwise the value indicates the number of
                               error injections that will occur before the
                               enable bits are cleared. When the selected
                               global response trigger occurs, this value is
                               loaded into the count field.
                            */
    UINT32 skipcount : 4;

                            /* Bits[31:28], Access Type=RW/L, default=0x00000000*/

                            /* Number of commands to skip between injections */

  } Bits;
  UINT32 Data;

} CMD_PAR_INJ_CTL_N0_MCDDC_CTL_STRUCT;

/* CMD_PAR_INJ_CTL_N1_MCDDC_CTL_REG supported on:                               */
/*      SPRA0 (0x200219dc)                                                      */
/*      SPRB0 (0x200219dc)                                                      */
/*      SPRHBM (0x200219dc)                                                     */
/*      SPRC0 (0x200219dc)                                                      */
/*      SPRMCC (0x200219dc)                                                     */
/*      SPRUCC (0x200219dc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* DDR Command Parity Injection Control. Use with cmd_par_inj_match and cmd_par_inj_mask.
                   en_ddrt_ui0, en_ddrt_ui1, and en_ddr4 should always be mutex.
*/


#define CMD_PAR_INJ_CTL_N1_MCDDC_CTL_REG 0x0B0219DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 skipcount : 2;

                            /* Bits[1:0], Access Type=RW/L, default=0x00000000*/

                            /* Number of commands to skip between injections */
    UINT32 ddr4safe : 1;

                            /* Bits[2:2], Access Type=RW/L, default=0x00000000*/

                            /* Enable safe command injection */
    UINT32 ddrtsafe : 1;

                            /* Bits[3:3], Access Type=RW/L, default=0x00000000*/

                            /* Enable safe command injection */
    UINT32 ignore_skipcount : 1;

                            /* Bits[4:4], Access Type=RW/L, default=0x00000000*/

                            /* Set this chicken bit to 1 to ignore skipcount. */
    UINT32 rsvd : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CMD_PAR_INJ_CTL_N1_MCDDC_CTL_STRUCT;

/* CHN_TEMP_CFG_MCDDC_CTL_REG supported on:                                     */
/*      SPRA0 (0x20021a00)                                                      */
/*      SPRB0 (0x20021a00)                                                      */
/*      SPRHBM (0x20021a00)                                                     */
/*      SPRC0 (0x20021a00)                                                      */
/*      SPRMCC (0x20021a00)                                                     */
/*      SPRUCC (0x20021a00)                                                     */
/* Register default value on SPRA0: 0xDA0003FF                                  */
/* Register default value on SPRB0: 0xDA0003FF                                  */
/* Register default value on SPRHBM: 0xDA0003FF                                 */
/* Register default value on SPRC0: 0xDA0003FF                                  */
/* Register default value on SPRMCC: 0xDA0003FF                                 */
/* Register default value on SPRUCC: 0xDA0003FF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x108
*/


#define CHN_TEMP_CFG_MCDDC_CTL_REG 0x0B021A00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 bw_limit_tf : 11;

                            /* Bits[10:0], Access Type=RW, default=0x000003FF*/

                            /*
                               BW Throttle Window Size in DCLK/8 (a value of 1
                               results in 8 DCLKs)
                            */
    UINT32 rsvd : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cr_commands_count : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Bit to choose between full commands count /
                               reads/writes count - 0 for read/writes
                            */
    UINT32 cr_legacy : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Bit to choose between legacy or new channel BW
                               implementation 1- legacy
                            */
    UINT32 thrt_allow_cke_low_while_apd_ppd_disabled : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit is one, MC will lower CKE during
                               Thermal Throttling unless thrt_allow_isoch is 1
                               even if CKE APD and PPD are disabled. However,
                               setting this bit to 0 means more power is
                               consumed due to CKE being asserted during
                               thermal or power throttling.
                            */
    UINT32 thrt_allow_isoch : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               When this bit is zero, MC will lower CKE during
                               Thermal Throttling, and ISOCH is blocked. When
                               this bit is one, MC will NOT lower CKE during
                               Thermal Throttling, and ISOCH will be allowed
                               based on bandwidth throttling setting. However,
                               setting this bit means more power is consumed
                               due to CKE being asserted during thermal or
                               power throttling.
                            */
    UINT32 thrt_ext : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /*
                               Max number of throttled transactions to be
                               issued during BWLIMITTF due to externally
                               asserted MEMHOT#.
                            */
    UINT32 shift_throttle_level : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000002*/

                            /* Value 2 for DDR and 1 for HBM */
    UINT32 bw_limit_thrt_en : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000001*/

                            /* Bandwith limit throttle enable. */
    UINT32 async_sr_nothrot_enable : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000001*/

                            /*
                               Allow async self-refresh request to disable
                               throttling to drain queues quickly
                            */
    UINT32 pwm_throttle : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Use PWM (time count) instead of the power
                               (command count) throttling when set to one. Set
                               thrt_pwr_dimm_0.thrt_pwr and
                               thrt_pwr_dimm_1.thrt_pwr to the number of clocks
                               to allow traffic before traffic is blocked
                               during the chn_temp_cfg.bw_limit_tf window.
                               Remember that the actual window is
                               chn_temp_cfg.bw_limit_tf*8 clocks.
                            */
    UINT32 cke_odt_contrib_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000001*/

                            /*
                               Enable CKE and ODT contributions during OLTT
                               rank energy accumulation
                            */
    UINT32 oltt_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /* Enable OLTT temperature tracking */

  } Bits;
  UINT32 Data;

} CHN_TEMP_CFG_MCDDC_CTL_STRUCT;

/* CHN_TEMP_STAT_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20021a04)                                                      */
/*      SPRB0 (0x20021a04)                                                      */
/*      SPRHBM (0x20021a04)                                                     */
/*      SPRC0 (0x20021a04)                                                      */
/*      SPRMCC (0x20021a04)                                                     */
/*      SPRUCC (0x20021a04)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x10c
*/


#define CHN_TEMP_STAT_MCDDC_CTL_REG 0x0B021A04

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ev_asrt_dimm0 : 1;

                            /* Bits[0:0], Access Type=RW/1C/V, default=0x00000000*/

                            /* Event Asserted on DIMM ID 0 */
    UINT32 ev_asrt_dimm1 : 1;

                            /* Bits[1:1], Access Type=RW/1C/V, default=0x00000000*/

                            /* Event Asserted on DIMM ID 1 */
    UINT32 rsvd : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CHN_TEMP_STAT_MCDDC_CTL_STRUCT;

/* CKE_LL0_MCDDC_CTL_REG supported on:                                          */
/*      SPRA0 (0x20021a10)                                                      */
/*      SPRB0 (0x20021a10)                                                      */
/*      SPRHBM (0x20021a10)                                                     */
/*      SPRC0 (0x20021a10)                                                      */
/*      SPRMCC (0x20021a10)                                                     */
/*      SPRUCC (0x20021a10)                                                     */
/* Register default value on SPRA0: 0x10000080                                  */
/* Register default value on SPRB0: 0x10000080                                  */
/* Register default value on SPRHBM: 0x10000080                                 */
/* Register default value on SPRC0: 0x10000080                                  */
/* Register default value on SPRMCC: 0x10000080                                 */
/* Register default value on SPRUCC: 0x10000080                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  Control for CKE (DRAM powerdown modes) at Load Line point 0.  Used when PMLink signal PowerModeSelect[1][0]=00 
*/


#define CKE_LL0_MCDDC_CTL_REG 0x0B021A10

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cke_idle_timer : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000080*/

                            /*
                               This defines the rank idle period that causes
                               CKE power-down entrance. The number of idle
                               cycles (in DCLKs) are based from command CS
                               assertion. It is important to program this
                               parameter to be greater than roundtrip latency
                               parameter in order to avoid the CKE de-assertion
                               sooner than data return. This register field can
                               be updated dynamically.
                            */
    UINT32 apd_en : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               CKE Active Power Down Mode for DDR4 DIMMs: When
                               0, APD is disabled When 1, APD is enabled This
                               register field can be updated dynamically.
                            */
    UINT32 ppd_en : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               CKE Precharge Power Down (PPD): When 0, PPD is
                               disabled When 1, PPD is enabled This register
                               field can be updated dynamically.
                            */
    UINT32 rsvd : 14;

                            /* Bits[23:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddrt_cke_en : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               CKE Active Power Down Mode for DDR-T DIMMs: When
                               0, APD is disabled When 1, APD is enabled This
                               register field can be updated dynamically.
                            */
    UINT32 rsvd_25 : 3;

                            /* Bits[27:25], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 reserved : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000001*/

                            /* Reserved for future use. */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CKE_LL0_MCDDC_CTL_STRUCT;

/* CKE_LL1_MCDDC_CTL_REG supported on:                                          */
/*      SPRA0 (0x20021a14)                                                      */
/*      SPRB0 (0x20021a14)                                                      */
/*      SPRHBM (0x20021a14)                                                     */
/*      SPRC0 (0x20021a14)                                                      */
/*      SPRMCC (0x20021a14)                                                     */
/*      SPRUCC (0x20021a14)                                                     */
/* Register default value on SPRA0: 0x10000080                                  */
/* Register default value on SPRB0: 0x10000080                                  */
/* Register default value on SPRHBM: 0x10000080                                 */
/* Register default value on SPRC0: 0x10000080                                  */
/* Register default value on SPRMCC: 0x10000080                                 */
/* Register default value on SPRUCC: 0x10000080                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  Control for CKE (DRAM powerdown modes) at Load Line point 1.  Used when PMLink signal PowerModeSelect[1][0]=01 
*/


#define CKE_LL1_MCDDC_CTL_REG 0x0B021A14

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cke_idle_timer : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000080*/

                            /*
                               This defines the rank idle period that causes
                               CKE power-down entrance. The number of idle
                               cycles (in DCLKs) are based from command CS
                               assertion. It is important to program this
                               parameter to be greater than roundtrip latency
                               parameter in order to avoid the CKE de-assertion
                               sooner than data return. This register field can
                               be updated dynamically.
                            */
    UINT32 apd_en : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               CKE Active Power Down Mode for DDR4 DIMMs: When
                               0, APD is disabled When 1, APD is enabled This
                               register field can be updated dynamically.
                            */
    UINT32 ppd_en : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               CKE Precharge Power Down (PPD): When 0, PPD is
                               disabled When 1, PPD is enabled This register
                               field can be updated dynamically.
                            */
    UINT32 rsvd : 14;

                            /* Bits[23:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddrt_cke_en : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               CKE Active Power Down Mode for DDR-T DIMMs: When
                               0, APD is disabled When 1, APD is enabled This
                               register field can be updated dynamically.
                            */
    UINT32 rsvd_25 : 3;

                            /* Bits[27:25], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 reserved : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000001*/

                            /* Reserved for future use. */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CKE_LL1_MCDDC_CTL_STRUCT;

/* CKE_LL2_MCDDC_CTL_REG supported on:                                          */
/*      SPRA0 (0x20021a18)                                                      */
/*      SPRB0 (0x20021a18)                                                      */
/*      SPRHBM (0x20021a18)                                                     */
/*      SPRC0 (0x20021a18)                                                      */
/*      SPRMCC (0x20021a18)                                                     */
/*      SPRUCC (0x20021a18)                                                     */
/* Register default value on SPRA0: 0x10000080                                  */
/* Register default value on SPRB0: 0x10000080                                  */
/* Register default value on SPRHBM: 0x10000080                                 */
/* Register default value on SPRC0: 0x10000080                                  */
/* Register default value on SPRMCC: 0x10000080                                 */
/* Register default value on SPRUCC: 0x10000080                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  Control for CKE (DRAM powerdown modes) at Load Line point 2.  Used when PMLink signal PowerModeSelect[1][0]=10 
*/


#define CKE_LL2_MCDDC_CTL_REG 0x0B021A18

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cke_idle_timer : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000080*/

                            /*
                               This defines the rank idle period that causes
                               CKE power-down entrance. The number of idle
                               cycles (in DCLKs) are based from command CS
                               assertion. It is important to program this
                               parameter to be greater than roundtrip latency
                               parameter in order to avoid the CKE de-assertion
                               sooner than data return. This register field can
                               be updated dynamically.
                            */
    UINT32 apd_en : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               CKE Active Power Down Mode for DDR4 DIMMs: When
                               0, APD is disabled When 1, APD is enabled This
                               register field can be updated dynamically.
                            */
    UINT32 ppd_en : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               CKE Precharge Power Down (PPD): When 0, PPD is
                               disabled When 1, PPD is enabled This register
                               field can be updated dynamically.
                            */
    UINT32 rsvd : 14;

                            /* Bits[23:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddrt_cke_en : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               CKE Active Power Down Mode for DDR-T DIMMs: When
                               0, APD is disabled When 1, APD is enabled This
                               register field can be updated dynamically.
                            */
    UINT32 rsvd_25 : 3;

                            /* Bits[27:25], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 reserved : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000001*/

                            /* Reserved for future use. */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CKE_LL2_MCDDC_CTL_STRUCT;

/* CKE_LL3_MCDDC_CTL_REG supported on:                                          */
/*      SPRA0 (0x20021a1c)                                                      */
/*      SPRB0 (0x20021a1c)                                                      */
/*      SPRHBM (0x20021a1c)                                                     */
/*      SPRC0 (0x20021a1c)                                                      */
/*      SPRMCC (0x20021a1c)                                                     */
/*      SPRUCC (0x20021a1c)                                                     */
/* Register default value on SPRA0: 0x10000080                                  */
/* Register default value on SPRB0: 0x10000080                                  */
/* Register default value on SPRHBM: 0x10000080                                 */
/* Register default value on SPRC0: 0x10000080                                  */
/* Register default value on SPRMCC: 0x10000080                                 */
/* Register default value on SPRUCC: 0x10000080                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  Control for CKE (DRAM powerdown modes) at Load Line point 3.  Used when PMLink signal PowerModeSelect[1][0]=11 
*/


#define CKE_LL3_MCDDC_CTL_REG 0x0B021A1C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cke_idle_timer : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000080*/

                            /*
                               This defines the rank idle period that causes
                               CKE power-down entrance. The number of idle
                               cycles (in DCLKs) are based from command CS
                               assertion. It is important to program this
                               parameter to be greater than roundtrip latency
                               parameter in order to avoid the CKE de-assertion
                               sooner than data return. This register field can
                               be updated dynamically.
                            */
    UINT32 apd_en : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               CKE Active Power Down Mode for DDR4 DIMMs: When
                               0, APD is disabled When 1, APD is enabled This
                               register field can be updated dynamically.
                            */
    UINT32 ppd_en : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               CKE Precharge Power Down (PPD): When 0, PPD is
                               disabled When 1, PPD is enabled This register
                               field can be updated dynamically.
                            */
    UINT32 rsvd : 14;

                            /* Bits[23:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddrt_cke_en : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               CKE Active Power Down Mode for DDR-T DIMMs: When
                               0, APD is disabled When 1, APD is enabled This
                               register field can be updated dynamically.
                            */
    UINT32 rsvd_25 : 3;

                            /* Bits[27:25], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 reserved : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000001*/

                            /* Reserved for future use. */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CKE_LL3_MCDDC_CTL_STRUCT;

/* DDR4_CBIT_PARITY_MCDDC_CTL_REG supported on:                                 */
/*      SPRA0 (0x20021a20)                                                      */
/*      SPRB0 (0x20021a20)                                                      */
/*      SPRHBM (0x20021a20)                                                     */
/*      SPRC0 (0x20021a20)                                                      */
/*      SPRMCC (0x20021a20)                                                     */
/*      SPRUCC (0x20021a20)                                                     */
/* Register default value on SPRA0: 0x00000007                                  */
/* Register default value on SPRB0: 0x00000007                                  */
/* Register default value on SPRHBM: 0x00000007                                 */
/* Register default value on SPRC0: 0x00000007                                  */
/* Register default value on SPRMCC: 0x00000007                                 */
/* Register default value on SPRUCC: 0x00000007                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x614
*/


#define DDR4_CBIT_PARITY_MCDDC_CTL_REG 0x0B021A20

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 res_enable : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000007*/

                            /*
                               Per bit inclusion control for ddr4 Cbits in
                               command/address parity generation. i.e. if
                               enable[0]=1, C[0] will be included in parity
                               calculation. if enable[1]=1, C[1] will be
                               included; etc.
                            */
    UINT32 rsvd : 29;

                            /* Bits[31:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDR4_CBIT_PARITY_MCDDC_CTL_STRUCT;

/* DIMM_TEMP_REFRESH_0_MCDDC_CTL_REG supported on:                              */
/*      SPRA0 (0x20021a24)                                                      */
/*      SPRB0 (0x20021a24)                                                      */
/*      SPRHBM (0x20021a24)                                                     */
/*      SPRC0 (0x20021a24)                                                      */
/*      SPRMCC (0x20021a24)                                                     */
/*      SPRUCC (0x20021a24)                                                     */
/* Register default value on SPRA0: 0xFF5F5519                                  */
/* Register default value on SPRB0: 0xFF5F5519                                  */
/* Register default value on SPRHBM: 0xFF5F5519                                 */
/* Register default value on SPRC0: 0xFF5F5519                                  */
/* Register default value on SPRMCC: 0xFF5F5519                                 */
/* Register default value on SPRUCC: 0xFF5F5519                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x110
*/


#define DIMM_TEMP_REFRESH_0_MCDDC_CTL_REG 0x0B021A24

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 temp_halfxref : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000019*/

                            /*
                               When memory temperature is below or at this
                               value and dimm_temp_ev_ofst_0.ev_halfx_ref_en is
                               enabled, 1/2x refresh will be performed
                            */
    UINT32 temp_twoxref : 8;

                            /* Bits[15:8], Access Type=RW/V, default=0x00000055*/

                            /*
                               When memory temperature is above or at this
                               value and dimm_temp_ev_ofst_0.ev_twox_ref_en is
                               enabled, 2x refresh will be performed
                            */
    UINT32 temp_fourxref : 8;

                            /* Bits[23:16], Access Type=RW/V, default=0x0000005F*/

                            /*
                               When memory temperature is above or at this
                               value and dimm_temp_ev_ofst_0.ev_fourx_ref_en is
                               enabled, 4x refresh will be performed
                            */
    UINT32 temp_memtrip : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000FF*/

                            /*
                               When memory temperature is above or at this
                               value the machine will take drastic action
                            */

  } Bits;
  UINT32 Data;

} DIMM_TEMP_REFRESH_0_MCDDC_CTL_STRUCT;

/* DIMM_TEMP_REFRESH_1_MCDDC_CTL_REG supported on:                              */
/*      SPRA0 (0x20021a28)                                                      */
/*      SPRB0 (0x20021a28)                                                      */
/*      SPRHBM (0x20021a28)                                                     */
/*      SPRC0 (0x20021a28)                                                      */
/*      SPRMCC (0x20021a28)                                                     */
/*      SPRUCC (0x20021a28)                                                     */
/* Register default value on SPRA0: 0xFF5F5519                                  */
/* Register default value on SPRB0: 0xFF5F5519                                  */
/* Register default value on SPRHBM: 0xFF5F5519                                 */
/* Register default value on SPRC0: 0xFF5F5519                                  */
/* Register default value on SPRMCC: 0xFF5F5519                                 */
/* Register default value on SPRUCC: 0xFF5F5519                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x114
*/


#define DIMM_TEMP_REFRESH_1_MCDDC_CTL_REG 0x0B021A28

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 temp_halfxref : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000019*/

                            /*
                               When memory temperature is below or at this
                               value and dimm_temp_ev_ofst_1.ev_halfx_ref_en is
                               enabled, 1/2x refresh will be performed
                            */
    UINT32 temp_twoxref : 8;

                            /* Bits[15:8], Access Type=RW/V, default=0x00000055*/

                            /*
                               When memory temperature is above or at this
                               value and dimm_temp_ev_ofst_1.ev_twox_ref_en is
                               enabled, 2x refresh will be performed
                            */
    UINT32 temp_fourxref : 8;

                            /* Bits[23:16], Access Type=RW/V, default=0x0000005F*/

                            /*
                               When memory temperature is above or at this
                               value and dimm_temp_ev_ofst_1.ev_fourx_ref_en is
                               enabled, 4x refresh will be performed
                            */
    UINT32 temp_memtrip : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000FF*/

                            /*
                               When memory temperature is above or at this
                               value the machine will take drastic action
                            */

  } Bits;
  UINT32 Data;

} DIMM_TEMP_REFRESH_1_MCDDC_CTL_STRUCT;

/* DIMMTEMPSTAT_0_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x20021a2c)                                                      */
/*      SPRB0 (0x20021a2c)                                                      */
/*      SPRHBM (0x20021a2c)                                                     */
/*      SPRC0 (0x20021a2c)                                                      */
/*      SPRMCC (0x20021a2c)                                                     */
/*      SPRUCC (0x20021a2c)                                                     */
/* Register default value on SPRA0: 0x20000055                                  */
/* Register default value on SPRB0: 0x20000055                                  */
/* Register default value on SPRHBM: 0x20000055                                 */
/* Register default value on SPRC0: 0x20000055                                  */
/* Register default value on SPRMCC: 0x20000055                                 */
/* Register default value on SPRUCC: 0x20000055                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x150
*/


#define DIMMTEMPSTAT_0_MCDDC_CTL_REG 0x0B021A2C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dimm_temp : 8;

                            /* Bits[7:0], Access Type=RW/V, default=0x00000055*/

                            /* Current DIMM Temperature for thermal throttling */
    UINT32 rsvd : 18;

                            /* Bits[25:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ev_asrt_templo : 1;

                            /* Bits[26:26], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Event Asserted on TEMPLO Going High It is
                               assumed that each of the event assertion is
                               going to trigger Configurable interrupt (Either
                               MEMHOT# only or both SMI and MEMHOT#) defined in
                               bit 30 of CHN_TEMP_CFG
                            */
    UINT32 ev_asrt_tempmid : 1;

                            /* Bits[27:27], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Event Asserted on TEMPMID going High It is
                               assumed that each of the event assertion is
                               going to trigger Configurable interrupt (Either
                               MEMHOT# only or both SMI and MEMHOT#) defined in
                               bit 30 of CHN_TEMP_CFG
                            */
    UINT32 ev_asrt_temphi : 1;

                            /* Bits[28:28], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Event Asserted on TEMPHI going HIGH It is
                               assumed that each of the event assertion is
                               going to trigger Configurable interrupt (Either
                               MEMHOT# only or both SMI and MEMHOT#) defined in
                               bit 30 of CHN_TEMP_CFG
                            */
    UINT32 dimm_refresh_rate : 2;

                            /* Bits[30:29], Access Type=RW/V, default=0x00000001*/

                            /* Refresh rate for dimm 0 */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIMMTEMPSTAT_0_MCDDC_CTL_STRUCT;

/* DIMMTEMPSTAT_1_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x20021a30)                                                      */
/*      SPRB0 (0x20021a30)                                                      */
/*      SPRHBM (0x20021a30)                                                     */
/*      SPRC0 (0x20021a30)                                                      */
/*      SPRMCC (0x20021a30)                                                     */
/*      SPRUCC (0x20021a30)                                                     */
/* Register default value on SPRA0: 0x20000055                                  */
/* Register default value on SPRB0: 0x20000055                                  */
/* Register default value on SPRHBM: 0x20000055                                 */
/* Register default value on SPRC0: 0x20000055                                  */
/* Register default value on SPRMCC: 0x20000055                                 */
/* Register default value on SPRUCC: 0x20000055                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x154
*/


#define DIMMTEMPSTAT_1_MCDDC_CTL_REG 0x0B021A30

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dimm_temp : 8;

                            /* Bits[7:0], Access Type=RW/V, default=0x00000055*/

                            /* Current DIMM Temperature for thermal throttling */
    UINT32 rsvd : 18;

                            /* Bits[25:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ev_asrt_templo : 1;

                            /* Bits[26:26], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Event Asserted on TEMPLO Going High It is
                               assumed that each of the event assertion is
                               going to trigger Configurable interrupt (Either
                               MEMHOT# only or both SMI and MEMHOT#) defined in
                               bit 30 of CHN_TEMP_CFG
                            */
    UINT32 ev_asrt_tempmid : 1;

                            /* Bits[27:27], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Event Asserted on TEMPMID going High It is
                               assumed that each of the event assertion is
                               going to trigger Configurable interrupt (Either
                               MEMHOT# only or both SMI and MEMHOT#) defined in
                               bit 30 of CHN_TEMP_CFG
                            */
    UINT32 ev_asrt_temphi : 1;

                            /* Bits[28:28], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               Event Asserted on TEMPHI going HIGH It is
                               assumed that each of the event assertion is
                               going to trigger Configurable interrupt (Either
                               MEMHOT# only or both SMI and MEMHOT#) defined in
                               bit 30 of CHN_TEMP_CFG
                            */
    UINT32 dimm_refresh_rate : 2;

                            /* Bits[30:29], Access Type=RW/V, default=0x00000001*/

                            /* Refresh rate for dimm 1 */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIMMTEMPSTAT_1_MCDDC_CTL_STRUCT;

/* ERF_DDR4_CMD_REG0_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20021a34)                                                      */
/*      SPRB0 (0x20021a34)                                                      */
/*      SPRHBM (0x20021a34)                                                     */
/*      SPRC0 (0x20021a34)                                                      */
/*      SPRMCC (0x20021a34)                                                     */
/*      SPRUCC (0x20021a34)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Error Flow DDR4/5 command register 0 (DDR5: for subCh0)
*/


#define ERF_DDR4_CMD_REG0_MCDDC_CTL_REG 0x0B021A34

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ad : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through address(A) pins of DDR4 interface .
                            */
    UINT32 ba : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BA pins of DDR4 interface .
                            */
    UINT32 bg : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BG pins of DDR4 interface .
                            */
    UINT32 rcw : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the RAS#,CAS#,WE# fields of
                               DDR4 interface
                            */
    UINT32 rsvd : 6;

                            /* Bits[26:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrrtype : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Used by mcdp via GS_DpCommand to know if a
                               particular ERF MRR was associated with a WrCRC
                               or DIMM CAP Isolation error recovery command.
                               Set to 1'b1 to denote WrCRC. Set to 1'b0 to
                               denote DIMM CAP Iso.
                            */
    UINT32 cw : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Control Word field as part of the Command
                               Address sent to the DIMM during ERF.
                            */
    UINT32 allow_invert : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the command sent is
                               also sent a 2nd time inverted. Required for MRS
                               0 to 6 writes. Must not be set for MR7 (register
                               buffer) writes
                            */
    UINT32 rdimm : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the content of this
                               register should be given to register part of the
                               dimm OR only one rank of the dimm. Other wise
                               the command should be given to all the ranks of
                               the channel.
                            */
    UINT32 en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables this register. The Error flow
                               FSM uses the contents of this register only if
                               en bit is set.
                            */

  } Bits;
  UINT32 Data;

} ERF_DDR4_CMD_REG0_MCDDC_CTL_STRUCT;

/* ERF_DDR4_CMD_REG1_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20021a38)                                                      */
/*      SPRB0 (0x20021a38)                                                      */
/*      SPRHBM (0x20021a38)                                                     */
/*      SPRC0 (0x20021a38)                                                      */
/*      SPRMCC (0x20021a38)                                                     */
/*      SPRUCC (0x20021a38)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Error Flow DDR4/5 command register 1 (DDR5: for subCh0)
*/


#define ERF_DDR4_CMD_REG1_MCDDC_CTL_REG 0x0B021A38

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ad : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through address(A) pins of DDR4 interface .
                            */
    UINT32 ba : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BA pins of DDR4 interface .
                            */
    UINT32 bg : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BG pins of DDR4 interface .
                            */
    UINT32 rcw : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the RAS#,CAS#,WE# fields of
                               DDR4 interface
                            */
    UINT32 rsvd : 6;

                            /* Bits[26:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrrtype : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Used by mcdp via GS_DpCommand to know if a
                               particular ERF MRR was associated with a WrCRC
                               or DIMM CAP Isolation error recovery command.
                               Set to 1'b1 to denote WrCRC. Set to 1'b0 to
                               denote DIMM CAP Iso.
                            */
    UINT32 cw : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Control Word field as part of the Command
                               Address sent to the DIMM during ERF.
                            */
    UINT32 allow_invert : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the command sent is
                               also sent a 2nd time inverted. Required for MRS
                               0 to 6 writes. Must not be set for MR7 (register
                               buffer) writes
                            */
    UINT32 rdimm : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the content of this
                               register should be given to register part of the
                               dimm OR only one rank of the dimm. Other wise
                               the command should be given to all the ranks of
                               the channel.
                            */
    UINT32 en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables this register. The Error flow
                               FSM uses the contents of this register only if
                               en bit is set.
                            */

  } Bits;
  UINT32 Data;

} ERF_DDR4_CMD_REG1_MCDDC_CTL_STRUCT;

/* ERF_DDR4_CMD_REG2_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20021a3c)                                                      */
/*      SPRB0 (0x20021a3c)                                                      */
/*      SPRHBM (0x20021a3c)                                                     */
/*      SPRC0 (0x20021a3c)                                                      */
/*      SPRMCC (0x20021a3c)                                                     */
/*      SPRUCC (0x20021a3c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Error Flow DDR4/5 command register 2 (DDR5: for subCh0)
*/


#define ERF_DDR4_CMD_REG2_MCDDC_CTL_REG 0x0B021A3C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ad : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through address(A) pins of DDR4 interface .
                            */
    UINT32 ba : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BA pins of DDR4 interface .
                            */
    UINT32 bg : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BG pins of DDR4 interface .
                            */
    UINT32 rcw : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the RAS#,CAS#,WE# fields of
                               DDR4 interface
                            */
    UINT32 rsvd : 6;

                            /* Bits[26:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrrtype : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Used by mcdp via GS_DpCommand to know if a
                               particular ERF MRR was associated with a WrCRC
                               or DIMM CAP Isolation error recovery command.
                               Set to 1'b1 to denote WrCRC. Set to 1'b0 to
                               denote DIMM CAP Iso.
                            */
    UINT32 cw : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Control Word field as part of the Command
                               Address sent to the DIMM during ERF.
                            */
    UINT32 allow_invert : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the command sent is
                               also sent a 2nd time inverted. Required for MRS
                               0 to 6 writes. Must not be set for MR7 (register
                               buffer) writes
                            */
    UINT32 rdimm : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the content of this
                               register should be given to register part of the
                               dimm OR only one rank of the dimm. Other wise
                               the command should be given to all the ranks of
                               the channel.
                            */
    UINT32 en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables this register. The Error flow
                               FSM uses the contents of this register only if
                               en bit is set.
                            */

  } Bits;
  UINT32 Data;

} ERF_DDR4_CMD_REG2_MCDDC_CTL_STRUCT;

/* ERF_DDR4_CMD_REG3_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20021a40)                                                      */
/*      SPRB0 (0x20021a40)                                                      */
/*      SPRHBM (0x20021a40)                                                     */
/*      SPRC0 (0x20021a40)                                                      */
/*      SPRMCC (0x20021a40)                                                     */
/*      SPRUCC (0x20021a40)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Error Flow DDR4/5 command register 3 (DDR5: for subCh0)
*/


#define ERF_DDR4_CMD_REG3_MCDDC_CTL_REG 0x0B021A40

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ad : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through address(A) pins of DDR4 interface .
                            */
    UINT32 ba : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BA pins of DDR4 interface .
                            */
    UINT32 bg : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BG pins of DDR4 interface .
                            */
    UINT32 rcw : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the RAS#,CAS#,WE# fields of
                               DDR4 interface
                            */
    UINT32 rsvd : 6;

                            /* Bits[26:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrrtype : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Used by mcdp via GS_DpCommand to know if a
                               particular ERF MRR was associated with a WrCRC
                               or DIMM CAP Isolation error recovery command.
                               Set to 1'b1 to denote WrCRC. Set to 1'b0 to
                               denote DIMM CAP Iso.
                            */
    UINT32 cw : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Control Word field as part of the Command
                               Address sent to the DIMM during ERF.
                            */
    UINT32 allow_invert : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the command sent is
                               also sent a 2nd time inverted. Required for MRS
                               0 to 6 writes. Must not be set for MR7 (register
                               buffer) writes
                            */
    UINT32 rdimm : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the content of this
                               register should be given to register part of the
                               dimm OR only one rank of the dimm. Other wise
                               the command should be given to all the ranks of
                               the channel.
                            */
    UINT32 en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables this register. The Error flow
                               FSM uses the contents of this register only if
                               en bit is set.
                            */

  } Bits;
  UINT32 Data;

} ERF_DDR4_CMD_REG3_MCDDC_CTL_STRUCT;

/* ERF_DDR4_CMD_REG4_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20021a44)                                                      */
/*      SPRB0 (0x20021a44)                                                      */
/*      SPRHBM (0x20021a44)                                                     */
/*      SPRC0 (0x20021a44)                                                      */
/*      SPRMCC (0x20021a44)                                                     */
/*      SPRUCC (0x20021a44)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Error Flow DDR4/5 command register 4 (DDR5: for subCh0)
*/


#define ERF_DDR4_CMD_REG4_MCDDC_CTL_REG 0x0B021A44

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ad : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through address(A) pins of DDR4 interface .
                            */
    UINT32 ba : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BA pins of DDR4 interface .
                            */
    UINT32 bg : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BG pins of DDR4 interface .
                            */
    UINT32 rcw : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the RAS#,CAS#,WE# fields of
                               DDR4 interface
                            */
    UINT32 rsvd : 6;

                            /* Bits[26:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrrtype : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Used by mcdp via GS_DpCommand to know if a
                               particular ERF MRR was associated with a WrCRC
                               or DIMM CAP Isolation error recovery command.
                               Set to 1'b1 to denote WrCRC. Set to 1'b0 to
                               denote DIMM CAP Iso.
                            */
    UINT32 cw : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Control Word field as part of the Command
                               Address sent to the DIMM during ERF.
                            */
    UINT32 allow_invert : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the command sent is
                               also sent a 2nd time inverted. Required for MRS
                               0 to 6 writes. Must not be set for MR7 (register
                               buffer) writes
                            */
    UINT32 rdimm : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the content of this
                               register should be given to register part of the
                               dimm OR only one rank of the dimm. Other wise
                               the command should be given to all the ranks of
                               the channel.
                            */
    UINT32 en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables this register. The Error flow
                               FSM uses the contents of this register only if
                               en bit is set.
                            */

  } Bits;
  UINT32 Data;

} ERF_DDR4_CMD_REG4_MCDDC_CTL_STRUCT;

/* ERF_DDR4_CMD_REG5_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20021a48)                                                      */
/*      SPRB0 (0x20021a48)                                                      */
/*      SPRHBM (0x20021a48)                                                     */
/*      SPRC0 (0x20021a48)                                                      */
/*      SPRMCC (0x20021a48)                                                     */
/*      SPRUCC (0x20021a48)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Error Flow DDR4/5 command register 5 (DDr5: for subCh0)
*/


#define ERF_DDR4_CMD_REG5_MCDDC_CTL_REG 0x0B021A48

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ad : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through address(A) pins of DDR4 interface .
                            */
    UINT32 ba : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BA pins of DDR4 interface .
                            */
    UINT32 bg : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BG pins of DDR4 interface .
                            */
    UINT32 rcw : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the RAS#,CAS#,WE# fields of
                               DDR4 interface
                            */
    UINT32 rsvd : 6;

                            /* Bits[26:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrrtype : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Used by mcdp via GS_DpCommand to know if a
                               particular ERF MRR was associated with a WrCRC
                               or DIMM CAP Isolation error recovery command.
                               Set to 1'b1 to denote WrCRC. Set to 1'b0 to
                               denote DIMM CAP Iso.
                            */
    UINT32 cw : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Control Word field as part of the Command
                               Address sent to the DIMM during ERF.
                            */
    UINT32 allow_invert : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the command sent is
                               also sent a 2nd time inverted. Required for MRS
                               0 to 6 writes. Must not be set for MR7 (register
                               buffer) writes
                            */
    UINT32 rdimm : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the content of this
                               register should be given to register part of the
                               dimm OR only one rank of the dimm. Other wise
                               the command should be given to all the ranks of
                               the channel.
                            */
    UINT32 en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables this register. The Error flow
                               FSM uses the contents of this register only if
                               en bit is set.
                            */

  } Bits;
  UINT32 Data;

} ERF_DDR4_CMD_REG5_MCDDC_CTL_STRUCT;

/* ERF_DDR4_CMD_REG6_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20021a4c)                                                      */
/*      SPRB0 (0x20021a4c)                                                      */
/*      SPRHBM (0x20021a4c)                                                     */
/*      SPRC0 (0x20021a4c)                                                      */
/*      SPRMCC (0x20021a4c)                                                     */
/*      SPRUCC (0x20021a4c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Error Flow DDR4/5 command register 6 (DDR5: for subCh1)
*/


#define ERF_DDR4_CMD_REG6_MCDDC_CTL_REG 0x0B021A4C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ad : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through address(A) pins of DDR4 interface .
                            */
    UINT32 ba : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BA pins of DDR4 interface .
                            */
    UINT32 bg : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BG pins of DDR4 interface .
                            */
    UINT32 rcw : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the RAS#,CAS#,WE# fields of
                               DDR4 interface
                            */
    UINT32 rsvd : 6;

                            /* Bits[26:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrrtype : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Used by mcdp via GS_DpCommand to know if a
                               particular ERF MRR was associated with a WrCRC
                               or DIMM CAP Isolation error recovery command.
                               Set to 1'b1 to denote WrCRC. Set to 1'b0 to
                               denote DIMM CAP Iso.
                            */
    UINT32 cw : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Control Word field as part of the Command
                               Address sent to the DIMM during ERF.
                            */
    UINT32 allow_invert : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the command sent is
                               also sent a 2nd time inverted. Required for MRS
                               0 to 6 writes. Must not be set for MR7 (register
                               buffer) writes
                            */
    UINT32 rdimm : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the content of this
                               register should be given to register part of the
                               dimm OR only one rank of the dimm. Other wise
                               the command should be given to all the ranks of
                               the channel.
                            */
    UINT32 en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables this register. The Error flow
                               FSM uses the contents of this register only if
                               en bit is set.
                            */

  } Bits;
  UINT32 Data;

} ERF_DDR4_CMD_REG6_MCDDC_CTL_STRUCT;

/* ERF_DDR4_CMD_REG7_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20021a50)                                                      */
/*      SPRB0 (0x20021a50)                                                      */
/*      SPRHBM (0x20021a50)                                                     */
/*      SPRC0 (0x20021a50)                                                      */
/*      SPRMCC (0x20021a50)                                                     */
/*      SPRUCC (0x20021a50)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Error Flow DDR4/5 command register 7 (DDR5: for subCh1)
*/


#define ERF_DDR4_CMD_REG7_MCDDC_CTL_REG 0x0B021A50

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ad : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through address(A) pins of DDR4 interface .
                            */
    UINT32 ba : 2;

                            /* Bits[14:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BA pins of DDR4 interface .
                            */
    UINT32 bg : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the command field which goes
                               through BG pins of DDR4 interface .
                            */
    UINT32 rcw : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000000*/

                            /*
                               This field holds the RAS#,CAS#,WE# fields of
                               DDR4 interface
                            */
    UINT32 rsvd : 6;

                            /* Bits[26:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrrtype : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Used by mcdp via GS_DpCommand to know if a
                               particular ERF MRR was associated with a WrCRC
                               or DIMM CAP Isolation error recovery command.
                               Set to 1'b1 to denote WrCRC. Set to 1'b0 to
                               denote DIMM CAP Iso.
                            */
    UINT32 cw : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Control Word field as part of the Command
                               Address sent to the DIMM during ERF.
                            */
    UINT32 allow_invert : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the command sent is
                               also sent a 2nd time inverted. Required for MRS
                               0 to 6 writes. Must not be set for MR7 (register
                               buffer) writes
                            */
    UINT32 rdimm : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If this field is set to 1, the content of this
                               register should be given to register part of the
                               dimm OR only one rank of the dimm. Other wise
                               the command should be given to all the ranks of
                               the channel.
                            */
    UINT32 en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               This field enables this register. The Error flow
                               FSM uses the contents of this register only if
                               en bit is set.
                            */

  } Bits;
  UINT32 Data;

} ERF_DDR4_CMD_REG7_MCDDC_CTL_STRUCT;

/* MC_TERM_RNK_MSK_MCDDC_CTL_REG supported on:                                  */
/*      SPRA0 (0x20021a58)                                                      */
/*      SPRB0 (0x20021a58)                                                      */
/*      SPRHBM (0x20021a58)                                                     */
/*      SPRC0 (0x20021a58)                                                      */
/*      SPRMCC (0x20021a58)                                                     */
/*      SPRUCC (0x20021a58)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* legacy spare bit
*/


#define MC_TERM_RNK_MSK_MCDDC_CTL_REG 0x0B021A58

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 spare : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* spare */
    UINT32 rsvd : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MC_TERM_RNK_MSK_MCDDC_CTL_STRUCT;

/* MCMNT_CHKN_BIT2_MCDDC_CTL_REG supported on:                                  */
/*      SPRA0 (0x20021a5c)                                                      */
/*      SPRB0 (0x20021a5c)                                                      */
/*      SPRHBM (0x20021a5c)                                                     */
/*      SPRC0 (0x20021a5c)                                                      */
/*      SPRMCC (0x20021a5c)                                                     */
/*      SPRUCC (0x20021a5c)                                                     */
/* Register default value on SPRA0: 0x01908030                                  */
/* Register default value on SPRB0: 0x29908030                                  */
/* Register default value on SPRHBM: 0x29908030                                 */
/* Register default value on SPRC0: 0x69908030                                  */
/* Register default value on SPRMCC: 0x69908030                                 */
/* Register default value on SPRUCC: 0x69908030                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x700
*/


#define MCMNT_CHKN_BIT2_MCDDC_CTL_REG 0x0B021A5C

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_cke_pri_rcb_gate : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Disable RCB Clock Gate in CKE */
    UINT32 dis_thr_pri_rcb_gate : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Disable RCB Clock Gate in THR */
    UINT32 dis_ref_pri_rcb_gate : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Disable RCB Clock Gate in REF */
    UINT32 dis_skx_b307329 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* Disable SKX b307329 */
    UINT32 dis_hpref_blk : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /* Enable high priority refresh */
    UINT32 dis_panicref_blk : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /* Enable panic refresh */
    UINT32 dis_ddrt_srexit_adr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit for DDRT to remain in SR if ADR
                               occurs
                            */
    UINT32 dqsosc_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /* Enable DQS retraining */
    UINT32 dqsosc_blkchl : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               DQS retraining - chicken bit to block entire
                               channel during Tx Retraining
                            */
    UINT32 dqsosc_runtime : 8;

                            /* Bits[16:9], Access Type=RW, default=0x00000040*/

                            /*
                               DQS interval timer run time. CSR should match
                               what MR45 was set to by BIOS.
                            */
    UINT32 zqcal_block_sre_dis : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               disable blocking SRE entry between
                               ZQCalStart/Latch pair
                            */
    UINT32 dll_off_cntr_extend_msb : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1 the range of the values supported
                               for PHY data DLL wakeup time and the
                               corresponding RD block time in #Hclks will be
                               increased by 32Hclks
                            */
    UINT32 rid_mrr_entry : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000012*/

                            /*
                               Reserved MRR entry number in RDB; only used if
                               the corresponding enable bit is set in
                               mcmnt_chkn_bit2.enable_MRR; default value is 19
                            */
    UINT32 enable_rid_mrr : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000001*/

                            /*
                               Enable bit for served MRR entry in RDB; the
                               corresponding entry number is set in
                               mcmnt_chkn_bit2.rid_MRR_entry
                            */
    UINT32 rsvd : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCMNT_CHKN_BIT2_MCDDC_CTL_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_cke_pri_rcb_gate : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Disable RCB Clock Gate in CKE */
    UINT32 dis_thr_pri_rcb_gate : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Disable RCB Clock Gate in THR */
    UINT32 dis_ref_pri_rcb_gate : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Disable RCB Clock Gate in REF */
    UINT32 dis_skx_b307329 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* Disable SKX b307329 */
    UINT32 dis_hpref_blk : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /* Enable high priority refresh */
    UINT32 dis_panicref_blk : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /* Enable panic refresh */
    UINT32 dis_ddrt_srexit_adr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit for DDRT to remain in SR if ADR
                               occurs
                            */
    UINT32 dqsosc_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /* Enable DQS retraining */
    UINT32 dqsosc_blkchl : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               DQS retraining - chicken bit to block entire
                               channel during Tx Retraining
                            */
    UINT32 dqsosc_runtime : 8;

                            /* Bits[16:9], Access Type=RW, default=0x00000040*/

                            /*
                               DQS interval timer run time. CSR should match
                               what MR45 was set to by BIOS.
                            */
    UINT32 zqcal_block_sre_dis : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               disable blocking SRE entry between
                               ZQCalStart/Latch pair
                            */
    UINT32 dll_off_cntr_extend_msb : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1 the range of the values supported
                               for PHY data DLL wakeup time and the
                               corresponding RD block time in #Hclks will be
                               increased by 32Hclks
                            */
    UINT32 rid_mrr_entry : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000012*/

                            /*
                               Reserved MRR entry number in RDB; only used if
                               the corresponding enable bit is set in
                               mcmnt_chkn_bit2.enable_MRR; default value is 19
                            */
    UINT32 enable_rid_mrr : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000001*/

                            /*
                               Enable bit for served MRR entry in RDB; the
                               corresponding entry number is set in
                               mcmnt_chkn_bit2.rid_MRR_entry
                            */
    UINT32 dqsosc_waittostarttime : 5;

                            /* Bits[29:25], Access Type=RW, default=0x00000014*/

                            /*
                               Time delay between starting to block traffic/new
                               link retry triggers and starting the DQS
                               sequence. Minimum value is 10-dclks which is the
                               stage delay from DQS blocking to new link retrys
                               from starting. CSR is in dclks.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCMNT_CHKN_BIT2_MCDDC_CTL_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_cke_pri_rcb_gate : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Disable RCB Clock Gate in CKE */
    UINT32 dis_thr_pri_rcb_gate : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Disable RCB Clock Gate in THR */
    UINT32 dis_ref_pri_rcb_gate : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Disable RCB Clock Gate in REF */
    UINT32 dis_skx_b307329 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* Disable SKX b307329 */
    UINT32 dis_hpref_blk : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /* Enable high priority refresh */
    UINT32 dis_panicref_blk : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /* Enable panic refresh */
    UINT32 dis_ddrt_srexit_adr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit for DDRT to remain in SR if ADR
                               occurs
                            */
    UINT32 dqsosc_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /* Enable DQS retraining */
    UINT32 dqsosc_blkchl : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               DQS retraining - chicken bit to block entire
                               channel during Tx Retraining
                            */
    UINT32 dqsosc_runtime : 8;

                            /* Bits[16:9], Access Type=RW, default=0x00000040*/

                            /*
                               DQS interval timer run time. CSR should match
                               what MR45 was set to by BIOS.
                            */
    UINT32 zqcal_block_sre_dis : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               disable blocking SRE entry between
                               ZQCalStart/Latch pair
                            */
    UINT32 dll_off_cntr_extend_msb : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1 the range of the values supported
                               for PHY data DLL wakeup time and the
                               corresponding RD block time in #Hclks will be
                               increased by 32Hclks
                            */
    UINT32 rid_mrr_entry : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000012*/

                            /*
                               Reserved MRR entry number in RDB; only used if
                               the corresponding enable bit is set in
                               mcmnt_chkn_bit2.enable_MRR; default value is 19
                            */
    UINT32 enable_rid_mrr : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000001*/

                            /*
                               Enable bit for served MRR entry in RDB; the
                               corresponding entry number is set in
                               mcmnt_chkn_bit2.rid_MRR_entry
                            */
    UINT32 dqsosc_waittostarttime : 5;

                            /* Bits[29:25], Access Type=RW, default=0x00000014*/

                            /*
                               Time delay between starting to block traffic/new
                               link retry triggers and starting the DQS
                               sequence. Minimum value is 10-dclks which is the
                               stage delay from DQS blocking to new link retrys
                               from starting. CSR is in dclks.
                            */
    UINT32 ddrtbusquietsafeafterzqlatch_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000001*/

                            /*
                               DDRT only. Enable bus_quiet_time_req to be gated
                               by DDRT ZQLatch issuing.
                            */
    UINT32 blkmntduringzqcal_dis : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Disable a late coded bug fix on SPR-C0: the
                               blocking of PREA/REF during ZQCal. The CA bus
                               should be quiet during ZQCal, which includes the
                               other RefreshFSMs.
                            */

  } Bits;
  UINT32 Data;

} MCMNT_CHKN_BIT2_MCDDC_CTL_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_cke_pri_rcb_gate : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Disable RCB Clock Gate in CKE */
    UINT32 dis_thr_pri_rcb_gate : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Disable RCB Clock Gate in THR */
    UINT32 dis_ref_pri_rcb_gate : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Disable RCB Clock Gate in REF */
    UINT32 dis_skx_b307329 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* Disable SKX b307329 */
    UINT32 dis_hpref_blk : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /* Enable high priority refresh */
    UINT32 dis_panicref_blk : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /* Enable panic refresh */
    UINT32 dis_ddrt_srexit_adr : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Set this bit for DDRT to remain in SR if ADR
                               occurs
                            */
    UINT32 dqsosc_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /* Enable DQS retraining */
    UINT32 dqsosc_blkchl : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               DQS retraining - chicken bit to block entire
                               channel during Tx Retraining
                            */
    UINT32 dqsosc_runtime : 8;

                            /* Bits[16:9], Access Type=RW, default=0x00000040*/

                            /*
                               DQS interval timer run time. CSR should match
                               what MR45 was set to by BIOS.
                            */
    UINT32 zqcal_block_sre_dis : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               disable blocking SRE entry between
                               ZQCalStart/Latch pair
                            */
    UINT32 dll_off_cntr_extend_msb : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1 the range of the values supported
                               for PHY data DLL wakeup time and the
                               corresponding RD block time in #Hclks will be
                               increased by 32Hclks
                            */
    UINT32 rid_mrr_entry : 5;

                            /* Bits[23:19], Access Type=RW, default=0x00000012*/

                            /*
                               Reserved MRR entry number in RDB; only used if
                               the corresponding enable bit is set in
                               mcmnt_chkn_bit2.enable_MRR; default value is 19
                            */
    UINT32 enable_rid_mrr : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000001*/

                            /*
                               Enable bit for served MRR entry in RDB; the
                               corresponding entry number is set in
                               mcmnt_chkn_bit2.rid_MRR_entry
                            */
    UINT32 rsvd : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCMNT_CHKN_BIT2_MCDDC_CTL_STRUCT;

/* MCMNT_RCB_GATE_CTL_MCDDC_CTL_REG supported on:                               */
/*      SPRA0 (0x20021a60)                                                      */
/*      SPRB0 (0x20021a60)                                                      */
/*      SPRHBM (0x20021a60)                                                     */
/*      SPRC0 (0x20021a60)                                                      */
/*      SPRMCC (0x20021a60)                                                     */
/*      SPRUCC (0x20021a60)                                                     */
/* Register default value on SPRA0: 0x0003FC40                                  */
/* Register default value on SPRB0: 0x0003FC40                                  */
/* Register default value on SPRHBM: 0x0003FC40                                 */
/* Register default value on SPRC0: 0x0003FC40                                  */
/* Register default value on SPRMCC: 0x0003FC40                                 */
/* Register default value on SPRUCC: 0x0003FC40                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Control information for RCB clock gating in mcmnts
*/


#define MCMNT_RCB_GATE_CTL_MCDDC_CTL_REG 0x0B021A60

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rcb_gate_mcmnt_timer : 10;

                            /* Bits[9:0], Access Type=RW, default=0x00000040*/

                            /* Time clock keeps running after triggering events */
    UINT32 dqscaperrorwaittime : 17;

                            /* Bits[26:10], Access Type=RW, default=0x000000FF*/

                            /*
                               Amount of time to wait for CAP error to occur as
                               a result of MRR reads during DQS Interval
                               Oscillator Retraining (DDR5 only)
                            */
    UINT32 rsvd : 5;

                            /* Bits[31:27], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCMNT_RCB_GATE_CTL_MCDDC_CTL_STRUCT;

/* LPMODE_PM_CTRL_N0_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20021a68)                                                      */
/*      SPRB0 (0x20021a68)                                                      */
/*      SPRHBM (0x20021a68)                                                     */
/*      SPRC0 (0x20021a68)                                                      */
/*      SPRMCC (0x20021a68)                                                     */
/*      SPRUCC (0x20021a68)                                                     */
/* Register default value on SPRA0: 0x00088063                                  */
/* Register default value on SPRB0: 0x00088063                                  */
/* Register default value on SPRHBM: 0x00088063                                 */
/* Register default value on SPRC0: 0x00088063                                  */
/* Register default value on SPRMCC: 0x00088063                                 */
/* Register default value on SPRUCC: 0x00088063                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* holds timing controls LPMODE and PM signals on SPID bus
*/


#define LPMODE_PM_CTRL_N0_MCDDC_CTL_REG 0x0B021A68

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lpmode_exit_latency : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000003*/

                            /*
                               LPMODE = non-ACTIVE to ACTIVE state transition
                               to CKE high gap in dclks Internally CKE will
                               brought up after pwr down mode exit, and
                               spid_cke will be suppressed for
                               lpmode_exit_latency number of dclks and spid_cke
                               will be brough up. SPID_lpmode will moved from
                               non-ACTIVe to ACTIVE as soon internal CKE is
                               brought up
                            */
    UINT32 lpmode_entry_latency : 5;

                            /* Bits[8:4], Access Type=RW, default=0x00000006*/

                            /*
                               Self-refresh CKE = 0 to LPMODE = non-ACTIVE
                               state assertion gap in dclks
                            */
    UINT32 lpmode_cke_powerdown_idle : 8;

                            /* Bits[16:9], Access Type=RW, default=0x00000040*/

                            /*
                               Powerdown entry (CKE = 0) to LPMODE = non-ACTIVE
                               state in dclks. If a powerdown exit arrives
                               before this delay, LPMODE will stay in the
                               active state and powerdown exit will occur
                               quicker since the lpmode_exit_latency will not
                               be required. Make sure this field is set larger
                               than or equal to lpmode_entry_latency
                            */
    UINT32 lpmode_min_nonactive : 4;

                            /* Bits[20:17], Access Type=RW, default=0x00000004*/

                            /*
                               Minimum number of dclks LPMODE is in non-active
                               state
                            */
    UINT32 lpmode_block_rd : 9;

                            /* Bits[29:21], Access Type=RW, default=0x00000000*/

                            /*
                               Data DLL OFF power savings feature uses this
                               value to count the number of cycles to block RDs
                               being issued from scheduler. Value is in Hclks.
                               Accounts for any excess time scheduler needs to
                               wait when Data DLL wake up time exceeds the min
                               Rd return latency
                            */
    UINT32 datadllwakeuptime : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /* DataDLL wake up time Number of Hclks */

  } Bits;
  UINT32 Data;

} LPMODE_PM_CTRL_N0_MCDDC_CTL_STRUCT;

/* LPMODE_PM_CTRL_N1_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20021a6c)                                                      */
/*      SPRB0 (0x20021a6c)                                                      */
/*      SPRHBM (0x20021a6c)                                                     */
/*      SPRC0 (0x20021a6c)                                                      */
/*      SPRMCC (0x20021a6c)                                                     */
/*      SPRUCC (0x20021a6c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* holds timing controls LPMODE and PM signals on SPID bus
*/


#define LPMODE_PM_CTRL_N1_MCDDC_CTL_REG 0x0B021A6C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 datadllwakeuptime : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /* DataDLL wake up time Number of Hclks */
    UINT32 datadlloff_enable : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Enable bit to enable DataDLL off during CKE
                               powerdown and OSR power down
                            */
    UINT32 rsvd : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LPMODE_PM_CTRL_N1_MCDDC_CTL_STRUCT;

/* INTERNAL_ERROR_SCHEDSBS_N0_MCDDC_CTL_REG supported on:                       */
/*      SPRA0 (0x20021a70)                                                      */
/*      SPRB0 (0x20021a70)                                                      */
/*      SPRHBM (0x20021a70)                                                     */
/*      SPRC0 (0x20021a70)                                                      */
/*      SPRMCC (0x20021a70)                                                     */
/*      SPRUCC (0x20021a70)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains internal errors from mcscheds_bs
*/


#define INTERNAL_ERROR_SCHEDSBS_N0_MCDDC_CTL_REG 0x0B021A70

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rid_unexpected_alloc0 : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /* RID for CAS is already allocated for DP 0. */
    UINT32 rid_ddrt_unexpected_alloc0 : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /* RID for DDRT is already allocated for DP 0. */
    UINT32 rid_unexpected_alloc1 : 1;

                            /* Bits[2:2], Access Type=RO/V, default=0x00000000*/

                            /* RID for CAS is already allocated for DP 1. */
    UINT32 rid_ddrt_unexpected_alloc1 : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000000*/

                            /* RID for DDRT is already allocated for DP 0. */
    UINT32 rsvd : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} INTERNAL_ERROR_SCHEDSBS_N0_MCDDC_CTL_STRUCT;

/* INTERNAL_ERROR_SCHEDSBS_N1_MCDDC_CTL_REG supported on:                       */
/*      SPRA0 (0x20021a74)                                                      */
/*      SPRB0 (0x20021a74)                                                      */
/*      SPRHBM (0x20021a74)                                                     */
/*      SPRC0 (0x20021a74)                                                      */
/*      SPRMCC (0x20021a74)                                                     */
/*      SPRUCC (0x20021a74)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains internal errors from mcscheds_bs
*/


#define INTERNAL_ERROR_SCHEDSBS_N1_MCDDC_CTL_REG 0x0B021A74

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 32;

                            /* Bits[31:0], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} INTERNAL_ERROR_SCHEDSBS_N1_MCDDC_CTL_STRUCT;

/* DIS_INTERNAL_ERROR_SCHEDSBS_N0_MCDDC_CTL_REG supported on:                   */
/*      SPRA0 (0x20021a78)                                                      */
/*      SPRB0 (0x20021a78)                                                      */
/*      SPRHBM (0x20021a78)                                                     */
/*      SPRC0 (0x20021a78)                                                      */
/*      SPRMCC (0x20021a78)                                                     */
/*      SPRUCC (0x20021a78)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains disable bits for internal errors from mcscheds_bs
*/


#define DIS_INTERNAL_ERROR_SCHEDSBS_N0_MCDDC_CTL_REG 0x0B021A78

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_rid_unexpected_alloc0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by RID for CAS is already
                               allocated for DP 0.
                            */
    UINT32 dis_rid_ddrt_unexpected_alloc0 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by RID for DDRT is already
                               allocated for DP 0.
                            */
    UINT32 dis_rid_unexpected_alloc1 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by RID for CAS is already
                               allocated for DP 1.
                            */
    UINT32 dis_rid_ddrt_unexpected_alloc1 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by RID for DDRT is already
                               allocated for DP 1.
                            */
    UINT32 rsvd : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIS_INTERNAL_ERROR_SCHEDSBS_N0_MCDDC_CTL_STRUCT;

/* DIS_INTERNAL_ERROR_SCHEDSBS_N1_MCDDC_CTL_REG supported on:                   */
/*      SPRA0 (0x20021a7c)                                                      */
/*      SPRB0 (0x20021a7c)                                                      */
/*      SPRHBM (0x20021a7c)                                                     */
/*      SPRC0 (0x20021a7c)                                                      */
/*      SPRMCC (0x20021a7c)                                                     */
/*      SPRUCC (0x20021a7c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains disable bits for internal errors from mcscheds_bs
*/


#define DIS_INTERNAL_ERROR_SCHEDSBS_N1_MCDDC_CTL_REG 0x0B021A7C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 32;

                            /* Bits[31:0], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIS_INTERNAL_ERROR_SCHEDSBS_N1_MCDDC_CTL_STRUCT;

/* SCHEDULER_ADDDC_REGION_CONTROL_0_MCDDC_CTL_REG supported on:                 */
/*      SPRA0 (0x20021a80)                                                      */
/*      SPRB0 (0x20021a80)                                                      */
/*      SPRHBM (0x20021a80)                                                     */
/*      SPRC0 (0x20021a80)                                                      */
/*      SPRMCC (0x20021a80)                                                     */
/*      SPRUCC (0x20021a80)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
          This register specifies the configuration for the regions using ADDDC for operation after the sparing copy is finished for the region.
      
*/


#define SCHEDULER_ADDDC_REGION_CONTROL_0_MCDDC_CTL_REG 0x0B021A80

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 region_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit specifies whether the ADDDC region is
                               in use. 0=ADDDC not enabled for this region
                               1=ADDDC enabled for this region This bit should
                               be set by software before the beginning of the
                               ADDDC sparing copy flow.
                            */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 region_size : 2;

                            /* Bits[3:2], Access Type=RW/V, default=0x00000000*/

                            /*
                               Granularity for this ADDDC region: 00=bank
                               01=rank 10=reserved 11=reserved
                            */
    UINT32 failed_cs : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the Chip Select (rank) to
                               match when determining if this is the failed
                               region participating in either ADDDC or Static
                               Virtual Lockstep. The value in this field is
                               encoded (Chip Selects are normally 1-hot),
                               corresponding to CS0-CS7. When the failed region
                               is a DIMM, two region registers should be
                               programmed corresponding to both Chip Selects of
                               the failed DIMM.
                            */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 failed_c : 3;

                            /* Bits[10:8], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the SubRank to match when
                               determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 failed_ba : 2;

                            /* Bits[12:11], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank address to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 failed_bg : 3;

                            /* Bits[15:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank group to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 nonfailed_cs : 3;

                            /* Bits[18:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the Chip Select (rank) to
                               match when determining if this is the failed
                               region participating in either ADDDC or Static
                               Virtual Lockstep. The value in this field is
                               encoded (Chip Selects are normally 1-hot),
                               corresponding to CS0-CS7. When the failed region
                               is a DIMM, two region registers should be
                               programmed corresponding to both Chip Selects of
                               the failed DIMM. When selecting the failed
                               region refer to page_table_index_selection field
                               when performance is a concern for open-page
                               mode.
                            */
    UINT32 rsvd_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 nonfailed_c : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the SubRank to match when
                               determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 nonfailed_ba : 2;

                            /* Bits[24:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the bank address to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 nonfailed_bg : 3;

                            /* Bits[27:25], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank group to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 copy_in_progress : 1;

                            /* Bits[29:29], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies that ADDDC spare copy is
                               on-going for this region. This bit should be set
                               by BIOS before starting the ADDDC sparing copy
                               flow. This bit should be cleared by hardware at
                               the end of the sparing copy flow.
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_ADDDC_REGION_CONTROL_0_MCDDC_CTL_STRUCT;

/* SCHEDULER_ADDDC_REGION_CONTROL_1_MCDDC_CTL_REG supported on:                 */
/*      SPRA0 (0x20021a84)                                                      */
/*      SPRB0 (0x20021a84)                                                      */
/*      SPRHBM (0x20021a84)                                                     */
/*      SPRC0 (0x20021a84)                                                      */
/*      SPRMCC (0x20021a84)                                                     */
/*      SPRUCC (0x20021a84)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
          This register specifies the configuration for the regions using ADDDC for operation after the sparing copy is finished for the region.
      
*/


#define SCHEDULER_ADDDC_REGION_CONTROL_1_MCDDC_CTL_REG 0x0B021A84

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 region_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit specifies whether the ADDDC region is
                               in use. 0=ADDDC not enabled for this region
                               1=ADDDC enabled for this region This bit should
                               be set by software before the beginning of the
                               ADDDC sparing copy flow.
                            */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 region_size : 2;

                            /* Bits[3:2], Access Type=RW/V, default=0x00000000*/

                            /*
                               Granularity for this ADDDC region: 00=bank
                               01=rank 10=reserved 11=reserved
                            */
    UINT32 failed_cs : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the Chip Select (rank) to
                               match when determining if this is the failed
                               region participating in either ADDDC or Static
                               Virtual Lockstep. The value in this field is
                               encoded (Chip Selects are normally 1-hot),
                               corresponding to CS0-CS7. When the failed region
                               is a DIMM, two region registers should be
                               programmed corresponding to both Chip Selects of
                               the failed DIMM.
                            */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 failed_c : 3;

                            /* Bits[10:8], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the SubRank to match when
                               determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 failed_ba : 2;

                            /* Bits[12:11], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank address to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 failed_bg : 3;

                            /* Bits[15:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank group to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 nonfailed_cs : 3;

                            /* Bits[18:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the Chip Select (rank) to
                               match when determining if this is the failed
                               region participating in either ADDDC or Static
                               Virtual Lockstep. The value in this field is
                               encoded (Chip Selects are normally 1-hot),
                               corresponding to CS0-CS7. When the failed region
                               is a DIMM, two region registers should be
                               programmed corresponding to both Chip Selects of
                               the failed DIMM. When selecting the failed
                               region refer to page_table_index_selection field
                               when performance is a concern for open-page
                               mode.
                            */
    UINT32 rsvd_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 nonfailed_c : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the SubRank to match when
                               determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 nonfailed_ba : 2;

                            /* Bits[24:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the bank address to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 nonfailed_bg : 3;

                            /* Bits[27:25], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank group to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 copy_in_progress : 1;

                            /* Bits[29:29], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies that ADDDC spare copy is
                               on-going for this region. This bit should be set
                               by BIOS before starting the ADDDC sparing copy
                               flow. This bit should be cleared by hardware at
                               the end of the sparing copy flow.
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_ADDDC_REGION_CONTROL_1_MCDDC_CTL_STRUCT;

/* SCHEDULER_ADDDC_REGION_CONTROL_2_MCDDC_CTL_REG supported on:                 */
/*      SPRA0 (0x20021a88)                                                      */
/*      SPRB0 (0x20021a88)                                                      */
/*      SPRHBM (0x20021a88)                                                     */
/*      SPRC0 (0x20021a88)                                                      */
/*      SPRMCC (0x20021a88)                                                     */
/*      SPRUCC (0x20021a88)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
          This register specifies the configuration for the regions using ADDDC for operation after the sparing copy is finished for the region.
      
*/


#define SCHEDULER_ADDDC_REGION_CONTROL_2_MCDDC_CTL_REG 0x0B021A88

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 region_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit specifies whether the ADDDC region is
                               in use. 0=ADDDC not enabled for this region
                               1=ADDDC enabled for this region This bit should
                               be set by software before the beginning of the
                               ADDDC sparing copy flow.
                            */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 region_size : 2;

                            /* Bits[3:2], Access Type=RW/V, default=0x00000000*/

                            /*
                               Granularity for this ADDDC region: 00=bank
                               01=rank 10=reserved 11=reserved
                            */
    UINT32 failed_cs : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the Chip Select (rank) to
                               match when determining if this is the failed
                               region participating in either ADDDC or Static
                               Virtual Lockstep. The value in this field is
                               encoded (Chip Selects are normally 1-hot),
                               corresponding to CS0-CS7. When the failed region
                               is a DIMM, two region registers should be
                               programmed corresponding to both Chip Selects of
                               the failed DIMM.
                            */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 failed_c : 3;

                            /* Bits[10:8], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the SubRank to match when
                               determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 failed_ba : 2;

                            /* Bits[12:11], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank address to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 failed_bg : 3;

                            /* Bits[15:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank group to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 nonfailed_cs : 3;

                            /* Bits[18:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the Chip Select (rank) to
                               match when determining if this is the failed
                               region participating in either ADDDC or Static
                               Virtual Lockstep. The value in this field is
                               encoded (Chip Selects are normally 1-hot),
                               corresponding to CS0-CS7. When the failed region
                               is a DIMM, two region registers should be
                               programmed corresponding to both Chip Selects of
                               the failed DIMM. When selecting the failed
                               region refer to page_table_index_selection field
                               when performance is a concern for open-page
                               mode.
                            */
    UINT32 rsvd_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 nonfailed_c : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the SubRank to match when
                               determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 nonfailed_ba : 2;

                            /* Bits[24:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the bank address to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 nonfailed_bg : 3;

                            /* Bits[27:25], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank group to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 copy_in_progress : 1;

                            /* Bits[29:29], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies that ADDDC spare copy is
                               on-going for this region. This bit should be set
                               by BIOS before starting the ADDDC sparing copy
                               flow. This bit should be cleared by hardware at
                               the end of the sparing copy flow.
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_ADDDC_REGION_CONTROL_2_MCDDC_CTL_STRUCT;

/* SCHEDULER_ADDDC_REGION_CONTROL_3_MCDDC_CTL_REG supported on:                 */
/*      SPRA0 (0x20021a8c)                                                      */
/*      SPRB0 (0x20021a8c)                                                      */
/*      SPRHBM (0x20021a8c)                                                     */
/*      SPRC0 (0x20021a8c)                                                      */
/*      SPRMCC (0x20021a8c)                                                     */
/*      SPRUCC (0x20021a8c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
          This register specifies the configuration for the regions using ADDDC for operation after the sparing copy is finished for the region.
      
*/


#define SCHEDULER_ADDDC_REGION_CONTROL_3_MCDDC_CTL_REG 0x0B021A8C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 region_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit specifies whether the ADDDC region is
                               in use. 0=ADDDC not enabled for this region
                               1=ADDDC enabled for this region This bit should
                               be set by software before the beginning of the
                               ADDDC sparing copy flow.
                            */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 region_size : 2;

                            /* Bits[3:2], Access Type=RW/V, default=0x00000000*/

                            /*
                               Granularity for this ADDDC region: 00=bank
                               01=rank 10=reserved 11=reserved
                            */
    UINT32 failed_cs : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the Chip Select (rank) to
                               match when determining if this is the failed
                               region participating in either ADDDC or Static
                               Virtual Lockstep. The value in this field is
                               encoded (Chip Selects are normally 1-hot),
                               corresponding to CS0-CS7. When the failed region
                               is a DIMM, two region registers should be
                               programmed corresponding to both Chip Selects of
                               the failed DIMM.
                            */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 failed_c : 3;

                            /* Bits[10:8], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the SubRank to match when
                               determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 failed_ba : 2;

                            /* Bits[12:11], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank address to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 failed_bg : 3;

                            /* Bits[15:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank group to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 nonfailed_cs : 3;

                            /* Bits[18:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the Chip Select (rank) to
                               match when determining if this is the failed
                               region participating in either ADDDC or Static
                               Virtual Lockstep. The value in this field is
                               encoded (Chip Selects are normally 1-hot),
                               corresponding to CS0-CS7. When the failed region
                               is a DIMM, two region registers should be
                               programmed corresponding to both Chip Selects of
                               the failed DIMM. When selecting the failed
                               region refer to page_table_index_selection field
                               when performance is a concern for open-page
                               mode.
                            */
    UINT32 rsvd_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 nonfailed_c : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the SubRank to match when
                               determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 nonfailed_ba : 2;

                            /* Bits[24:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the bank address to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 nonfailed_bg : 3;

                            /* Bits[27:25], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank group to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 copy_in_progress : 1;

                            /* Bits[29:29], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies that ADDDC spare copy is
                               on-going for this region. This bit should be set
                               by BIOS before starting the ADDDC sparing copy
                               flow. This bit should be cleared by hardware at
                               the end of the sparing copy flow.
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_ADDDC_REGION_CONTROL_3_MCDDC_CTL_STRUCT;

/* SCHEDULER_ENABLES_BS_MCDDC_CTL_REG supported on:                             */
/*      SPRA0 (0x20021a90)                                                      */
/*      SPRB0 (0x20021a90)                                                      */
/*      SPRHBM (0x20021a90)                                                     */
/*      SPRC0 (0x20021a90)                                                      */
/*      SPRMCC (0x20021a90)                                                     */
/*      SPRUCC (0x20021a90)                                                     */
/* Register default value on SPRA0: 0x00000046                                  */
/* Register default value on SPRB0: 0x00000046                                  */
/* Register default value on SPRHBM: 0x00000046                                 */
/* Register default value on SPRC0: 0x00000046                                  */
/* Register default value on SPRMCC: 0x00000046                                 */
/* Register default value on SPRUCC: 0x00000046                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Configuration
*/


#define SCHEDULER_ENABLES_BS_MCDDC_CTL_REG 0x0B021A90

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 llt_page_mode_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Intelligent scheduling policy that closes page
                               at end of linked list.
                            */
    UINT32 link_major_mode_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Links the Major-Mode Arbiters between scheduler
                               pseudo-channels. DDR4=1, DDR5=0, HBM2=0
                            */
    UINT32 open_page_mode_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Set to 1 for open-page mode or 0 for closed-page
                               mode
                            */
    UINT32 idle_bypass_en : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Enable legacy Read Idle ACT bypass; Must be
                               disabled in 3N command mode
                               (memory_timings_adj.cmd_stretch = 3)
                            */
    UINT32 llt_page_mode_enhanced : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               With llt_page_mode_en=1, set this bit to keep a
                               page-table open if there are no page-close
                               transactions pending.
                            */
    UINT32 disable_buddy_mm : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Disable major-mode preference with the bank-
                               scheduler buddies.
                            */
    UINT32 number_of_banks : 2;

                            /* Bits[7:6], Access Type=RW, default=0x00000001*/

                            /*
                               Number of banks: 0 = 8 banks, 1 = 16 banks, 2 =
                               32 banks, 3 = reserved (RFU). DDR4 has 16 banks
                               for x4/x8 devices, 8 banks for x16 devices.
                               DDR4e has 32 banks for x4/x8 devices and 16
                               banks for x16 devices. HBM2 has 8 banks for 4
                               high 2Gb/channel, 16 banks for 4 high 4Gb or
                               8Gb/channel, and 32 banks for 8 high
                               8Gb/channel.
                            */
    UINT32 high_rank_support : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               DDR4/5: For configurations with one dimm per
                               channel and 16 ranks per channel, set this to
                               one, for all other configurations set this to 0.
                               HBM:0
                            */
    UINT32 rsvd : 3;

                            /* Bits[11:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cpgc_inorder_mode_en : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /* Enable CGPC in-order mode. */
    UINT32 cpgc_second_cas_en : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Enable CGPC HBM2 second cas, it requires in-
                               order mode to be disabled
                            */
    UINT32 implicit_pre_en : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /* Enable HBM2/DDR4E ACT with ImplicitPRE */
    UINT32 enable_vc_preemption : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Enable VC Premption: When set allow transactiosn
                               with no RDB VC credits to be preempted.
                            */
    UINT32 rsvd_16 : 4;

                            /* Bits[19:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 page_table_index_selection : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bank Scheduler Page-Table Mapping: 0=Rank[1],
                               1=Rank[2], 2=SubRank[0], 3=SubRank[1], 4=BA[1]
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 bank_scheduler_selection : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /*
                               0: {BG[2:0],BA[1:0]}; - DDR4/5 1-8 Ranks
                               DDR4:BG2==0 1: {BG[2:0],BA[1], SR[0]}; - DDR4/5
                               9-16 Ranks DDR4:BG2==0 2: {BG[2:0],SR[1:0]}; -
                               DDR4/5 17-32 Ranks DDR4:BG2==0 3:
                               {BG[2:0],R[1],BA[0]}; 4: {BG[2:0],R[1:0]}; 5:
                               {BG[2:0],R[2:1]}; 6,7, reserved
                            */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pseudo_channel_selection : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               Scheduler Pseudo-Channel Selection: DDR4:
                               0=Rank[0], 1=Rank[2], 2= (Rank[0] xor BG[0]),
                               3=(Rank[2] xor BG[0]); DDR5:0; HBM:0
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_ENABLES_BS_MCDDC_CTL_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 llt_page_mode_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Intelligent scheduling policy that closes page
                               at end of linked list.
                            */
    UINT32 link_major_mode_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Links the Major-Mode Arbiters between scheduler
                               pseudo-channels. DDR4=1, DDR5=0, HBM2=0
                            */
    UINT32 open_page_mode_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Set to 1 for open-page mode or 0 for closed-page
                               mode
                            */
    UINT32 idle_bypass_en : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Enable legacy Read Idle ACT bypass; Must be
                               disabled in 3N command mode
                               (memory_timings_adj.cmd_stretch = 3)
                            */
    UINT32 llt_page_mode_enhanced : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               With llt_page_mode_en=1, set this bit to keep a
                               page-table open if there are no page-close
                               transactions pending.
                            */
    UINT32 disable_buddy_mm_col : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Disable major-mode preference with the bank-
                               scheduler buddies for col commands.
                            */
    UINT32 number_of_banks : 2;

                            /* Bits[7:6], Access Type=RW, default=0x00000001*/

                            /*
                               Number of banks: 0 = 8 banks, 1 = 16 banks, 2 =
                               32 banks, 3 = reserved (RFU). DDR4 has 16 banks
                               for x4/x8 devices, 8 banks for x16 devices.
                               DDR4e has 32 banks for x4/x8 devices and 16
                               banks for x16 devices. HBM2 has 8 banks for 4
                               high 2Gb/channel, 16 banks for 4 high 4Gb or
                               8Gb/channel, and 32 banks for 8 high
                               8Gb/channel.
                            */
    UINT32 high_rank_support : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               DDR4/5: For configurations with one dimm per
                               channel and 16 ranks per channel, set this to
                               one, for all other configurations set this to 0.
                               HBM:0
                            */
    UINT32 disable_buddy_mm_row : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Disable major-mode preference with the bank-
                               scheduler buddies for row commands.
                            */
    UINT32 rsvd : 2;

                            /* Bits[11:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cpgc_inorder_mode_en : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /* Enable CGPC in-order mode. */
    UINT32 cpgc_second_cas_en : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Enable CGPC HBM2 second cas, it requires in-
                               order mode to be disabled
                            */
    UINT32 implicit_pre_en : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /* Enable HBM2/DDR4E ACT with ImplicitPRE */
    UINT32 enable_vc_preemption : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Enable VC Premption: When set allow transactiosn
                               with no RDB VC credits to be preempted.
                            */
    UINT32 rsvd_16 : 4;

                            /* Bits[19:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 page_table_index_selection : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bank Scheduler Page-Table Mapping: 0=Rank[1],
                               1=Rank[2], 2=SubRank[0], 3=SubRank[1], 4=BA[1]
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 bank_scheduler_selection : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /*
                               0: {BG[2:0],BA[1:0]}; - DDR4/5 1-8 Ranks
                               DDR4:BG2==0 1: {BG[2:0],BA[0], SR[0]}; - DDR4/5
                               9-16 Ranks DDR4:BG2==0 2: {BG[2:0],SR[1:0]}; -
                               DDR4/5 17-32 Ranks DDR4:BG2==0 3:
                               {BG[2:0],R[1],BA[0]}; 4: {BG[2:0],R[1:0]}; 5:
                               {BG[2:0],R[2:1]}; 6: {BG[2:0],BA[1], SR[0]}; 7,
                               reserved
                            */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pseudo_channel_selection : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               Scheduler Pseudo-Channel Selection: DDR4:
                               0=Rank[0], 1=Rank[2], 2= (Rank[0] xor BG[0]),
                               3=(Rank[2] xor BG[0]); DDR5:0; HBM:0
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_ENABLES_BS_MCDDC_CTL_SPRB0_SPRHBM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 llt_page_mode_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Intelligent scheduling policy that closes page
                               at end of linked list.
                            */
    UINT32 link_major_mode_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Links the Major-Mode Arbiters between scheduler
                               pseudo-channels. DDR4=1, DDR5=0, HBM2=0
                            */
    UINT32 open_page_mode_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Set to 1 for open-page mode or 0 for closed-page
                               mode
                            */
    UINT32 idle_bypass_en : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Enable legacy Read Idle ACT bypass; Must be
                               disabled in 3N command mode
                               (memory_timings_adj.cmd_stretch = 3)
                            */
    UINT32 llt_page_mode_enhanced : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               With llt_page_mode_en=1, set this bit to keep a
                               page-table open if there are no page-close
                               transactions pending.
                            */
    UINT32 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 number_of_banks : 2;

                            /* Bits[7:6], Access Type=RW, default=0x00000001*/

                            /*
                               Number of banks: 0 = 8 banks, 1 = 16 banks, 2 =
                               32 banks, 3 = reserved (RFU). DDR4 has 16 banks
                               for x4/x8 devices, 8 banks for x16 devices.
                               DDR4e has 32 banks for x4/x8 devices and 16
                               banks for x16 devices. HBM2 has 8 banks for 4
                               high 2Gb/channel, 16 banks for 4 high 4Gb or
                               8Gb/channel, and 32 banks for 8 high
                               8Gb/channel.
                            */
    UINT32 high_rank_support : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               DDR4/5: For configurations with one dimm per
                               channel and 16 ranks per channel, set this to
                               one, for all other configurations set this to 0.
                               HBM:0
                            */
    UINT32 rsvd_9 : 3;

                            /* Bits[11:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cpgc_inorder_mode_en : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /* Enable CGPC in-order mode. */
    UINT32 cpgc_second_cas_en : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Enable CGPC HBM2 second cas, it requires in-
                               order mode to be disabled
                            */
    UINT32 implicit_pre_en : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /* Enable HBM2/DDR4E ACT with ImplicitPRE */
    UINT32 enable_vc_preemption : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Enable VC Premption: When set allow transactiosn
                               with no RDB VC credits to be preempted.
                            */
    UINT32 rsvd_16 : 4;

                            /* Bits[19:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 page_table_index_selection : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bank Scheduler Page-Table Mapping: 0=Rank[1],
                               1=Rank[2], 2=SubRank[0], 3=SubRank[1], 4=BA[1]
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 bank_scheduler_selection : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /*
                               0: {BG[2:0],BA[1:0]}; - DDR4/5 1-8 Ranks
                               DDR4:BG2==0 1: {BG[2:0],BA[1], SR[0]}; - DDR4/5
                               9-16 Ranks DDR4:BG2==0 2: {BG[2:0],SR[1:0]}; -
                               DDR4/5 17-32 Ranks DDR4:BG2==0 3:
                               {BG[2:0],R[1],BA[0]}; 4: {BG[2:0],R[1:0]}; 5:
                               {BG[2:0],R[2:1]}; 6,7, reserved
                            */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pseudo_channel_selection : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               Scheduler Pseudo-Channel Selection: DDR4:
                               0=Rank[0], 1=Rank[2], 2= (Rank[0] xor BG[0]),
                               3=(Rank[2] xor BG[0]); DDR5:0; HBM:0
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_ENABLES_BS_MCDDC_CTL_STRUCT;

/* SCHEDULER_DEADLOCK_THRESH_MCDDC_CTL_REG supported on:                        */
/*      SPRA0 (0x20021a94)                                                      */
/*      SPRB0 (0x20021a94)                                                      */
/*      SPRHBM (0x20021a94)                                                     */
/*      SPRC0 (0x20021a94)                                                      */
/*      SPRMCC (0x20021a94)                                                     */
/*      SPRUCC (0x20021a94)                                                     */
/* Register default value on SPRA0: 0x0000007F                                  */
/* Register default value on SPRB0: 0x0000007F                                  */
/* Register default value on SPRHBM: 0x0000007F                                 */
/* Register default value on SPRC0: 0x0000007F                                  */
/* Register default value on SPRMCC: 0x0000007F                                 */
/* Register default value on SPRUCC: 0x0000007F                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Threshold for Deadlock condition
*/


#define SCHEDULER_DEADLOCK_THRESH_MCDDC_CTL_REG 0x0B021A94

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 deprd_threshold : 20;

                            /* Bits[19:0], Access Type=RW, default=0x0000007F*/

                            /*
                               Number of HCLK that dependent read deadlock
                               condition persists to force error to break
                               deadlock.
                            */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_DEADLOCK_THRESH_MCDDC_CTL_STRUCT;

/* SCHEDULER_RID2_STATUS_MCDDC_CTL_REG supported on:                            */
/*      SPRA0 (0x20021a98)                                                      */
/*      SPRB0 (0x20021a98)                                                      */
/*      SPRHBM (0x20021a98)                                                     */
/*      SPRC0 (0x20021a98)                                                      */
/*      SPRMCC (0x20021a98)                                                     */
/*      SPRUCC (0x20021a98)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Free RID register
*/


#define SCHEDULER_RID2_STATUS_MCDDC_CTL_REG 0x0B021A98

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 24;

                            /* Bits[23:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 free_rid : 8;

                            /* Bits[31:24], Access Type=RO/V, default=0x00000000*/

                            /*
                               Indication which RDB entry is free; 1 bit per
                               entry.
                            */

  } Bits;
  UINT32 Data;

} SCHEDULER_RID2_STATUS_MCDDC_CTL_STRUCT;

/* SCHEDULER_RID2_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x20021a9c)                                                      */
/*      SPRB0 (0x20021a9c)                                                      */
/*      SPRHBM (0x20021a9c)                                                     */
/*      SPRC0 (0x20021a9c)                                                      */
/*      SPRMCC (0x20021a9c)                                                     */
/*      SPRUCC (0x20021a9c)                                                     */
/* Register default value on SPRA0: 0xFF000000                                  */
/* Register default value on SPRB0: 0xFF000000                                  */
/* Register default value on SPRHBM: 0xFF000000                                 */
/* Register default value on SPRC0: 0xFF000000                                  */
/* Register default value on SPRMCC: 0xFF000000                                 */
/* Register default value on SPRUCC: 0xFF000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Configuration register
*/


#define SCHEDULER_RID2_MCDDC_CTL_REG 0x0B021A9C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 24;

                            /* Bits[23:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 enable_rid : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000FF*/

                            /*
                               Enable bit for each RDB entry for entries
                               24-31.(ddrr/5 only)
                            */

  } Bits;
  UINT32 Data;

} SCHEDULER_RID2_MCDDC_CTL_STRUCT;

/* MEMORY_TIMINGS_ADJ_MCDDC_CTL_REG supported on:                               */
/*      SPRA0 (0x20021aa0)                                                      */
/*      SPRB0 (0x20021aa0)                                                      */
/*      SPRHBM (0x20021aa0)                                                     */
/*      SPRC0 (0x20021aa0)                                                      */
/*      SPRMCC (0x20021aa0)                                                     */
/*      SPRUCC (0x20021aa0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Timing parameters for adjusting other BANK timing
*/


#define MEMORY_TIMINGS_ADJ_MCDDC_CTL_REG 0x0B021AA0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 read_preamble : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, MC disallows the read-to-read
                               tCCL_S spacing of 5 CK in support for 2tCK read
                               preamble. Note, this is not specifically stated
                               as a JEDEC requirement, so this bit might not be
                               needed to set for 2tCK read preamble mode. Also
                               note that tCCD_S=4 will still occur when tRRSR=4
                               when this bit is set to 1. In addition to
                               setting this bit, the DDRIO PHY and DRAM devices
                               must be appropriately programmed. Also, the
                               following turn-around spacings will need to be
                               increased by 1: tRRDR, tRRDD, tWRDR, tWRDD.
                               These are timings from read/write-to-read
                               between different physical ranks that the
                               minimum spacing is defined by the board-level
                               signal integrity bus turn-around times.
                            */
    UINT32 write_preamble : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, MC increases the CWL by 1 and
                               disallows the write-to-write tCCL_S spacing of 5
                               CK in support for 2tCK write preamble. Note that
                               tCCD_S=4 will still occur when tWWSR=4, however,
                               the 5 cycle spacing is not allowed for 2tCK
                               write preamble. In addition to setting this bit,
                               the DDRIO PHY and DRAM devices must be
                               appropriately programmed. Also, the following
                               turn-around spacings may need to be increased by
                               1: tWWDR, tWWDD. These are timings from write to
                               a write between different physical ranks that
                               the minimum spacing is defined by the board-
                               level signal integrity bus turn-around times.
                               Also, any other turn-around time that is a
                               function of CWL will need to be increased by 1.
                            */
    UINT32 t_cwl_adj_neg : 2;

                            /* Bits[3:2], Access Type=RW, default=0x00000000*/

                            /*
                               This register defines reduction of WR data delay
                               per channel in order to overcome the WR-flyby
                               issue. The total CAS write latency that the DDR
                               sees is the sum of T_CWL and the T_CWL_ADJ minus
                               T_CWL_ADJ_NEG. 00 - no latency reduction
                               (default) 01 - reduce latency by 1 dclk 10 -
                               reduce latency by 2 dclk 11 - reduce latency by
                               3 dclk The total t_cwl (T_CWL + T_CWL_ADJ -
                               T_CWL_ADJ_NEG) should not be less than 6
                            */
    UINT32 t_cwl_adj : 4;

                            /* Bits[7:4], Access Type=RW, default=0x00000000*/

                            /*
                               This register defines additional WR data delay
                               per channel in order to overcome the WR-flyby
                               issue. The total CAS write latency that the DDR
                               sees is the sum of T_CWL and the T_CWL_ADJ minus
                               T_CWL_ADJ_NEG. 000 - no added latency (default)
                               001 to 111 - 1 to 7 dclk of added latency
                            */
    UINT32 en_3ds : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* Enable 3DS DIMM/LRDIMM support */
    UINT32 cmd_stretch : 2;

                            /* Bits[10:9], Access Type=RW, default=0x00000000*/

                            /*
                               defines for how many cycles the command is
                               stretched 00: 1N operation 01: Reserved 10: 2N
                               operation 11: 3N operation
                            */
    UINT32 dparity_latency : 2;

                            /* Bits[12:11], Access Type=RW, default=0x00000000*/

                            /*
                               HBM2 Write or Read DQ parity latency. Only valid
                               when write or read data parity is enabled in
                               mcmtr. Value is in HCLKs. Not used in DDR mode.
                               Values it can take are 0
                            */
    UINT32 odt_value : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /* When set to 1, ODT=H. When set to 0, ODT=L. */
    UINT32 rsvd : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dram_device_type : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Selects the DRAM memory technology when there is
                               a choice. For DDR, this bit enables DDR5 (0
                               selects DDR4, 1 selects DDR5). For HBM, this bit
                               enables HBM2E (0 selects HBM2, 1 selects HBM2E).
                            */
    UINT32 rcd_on_dimm : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Enable double data rate command/address. This
                               field is only used when DDR5 is enabled. This
                               should always be set to 0 otherwise for
                               unbuffered DIMMs (UDIMM/SoDIMM). This should
                               always be set to 1 for RDIMMs and LRDIMMs which
                               have an RCD (registered command/address), even
                               if the commands are issued at single data rate
                               due to 2N command mode.
                            */
    UINT32 rcd_sdr2_mode : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               SDR2 mode is enabled in the RCD. This field is
                               only used when DDR5 is enabled, RDIMMs are
                               populated (rcd_on_dimm=1), and 2N command mode
                               is enabled. Setting this bit assumes that BIOS
                               has also programmed the RCD to enable SDR2 mode.
                               Otherwise this bit should be set to 0.
                            */
    UINT32 tppd_enable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Precharge to Precharge command delay. When set
                               to 0, precharge commands can be issued back-to-
                               back. When set to 1 (default), precharge
                               commands will be separated by at least 2 CK, and
                               should be used to satisfy the DDR5 tPPD
                               requirement. Note that tPPD will be applied to
                               all precharge commands, not just to the same
                               rank.
                            */
    UINT32 tcssr : 6;

                            /* Bits[25:20], Access Type=RW, default=0x00000000*/

                            /*
                               This is the tCSL timing parameter for UDIMMs (no
                               RCD) and the tCSSR timing parameter for RDIMMs
                               (RCD). The value should be specified in number
                               of CK (Dclks) for DDR5 only; when there is a
                               DDRT2 DIMM present, then the value specifies 64x
                               the number of CK (Dclks).
                            */
    UINT32 tcped2srx : 6;

                            /* Bits[31:26], Access Type=RW, default=0x00000000*/

                            /*
                               This is the mimimum time in SR for RDIMMs (RCD)
                               without clock stop; the time from the SRE single
                               CK CS# assertion to the SRX command to the RCD.
                               The value should be specified in number of CK
                               (Dclks) for DDR5 only; when there is a DDRT2
                               DIMM present, then the value specifies 8x the
                               number of CK (Dclks).
                            */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_ADJ_MCDDC_CTL_STRUCT;

/* MEMORY_TIMINGS_BANK_IDLE_BYPASS_MCDDC_CTL_REG supported on:                  */
/*      SPRA0 (0x20021aa8)                                                      */
/*      SPRB0 (0x20021aa8)                                                      */
/*      SPRHBM (0x20021aa8)                                                     */
/*      SPRC0 (0x20021aa8)                                                      */
/*      SPRMCC (0x20021aa8)                                                     */
/*      SPRUCC (0x20021aa8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Timing parameters for the idle bypass path - tRC, tRAS and tRCD; these values are used when the activate is issued from the idle bypass path.
*/


#define MEMORY_TIMINGS_BANK_IDLE_BYPASS_MCDDC_CTL_REG 0x0B021AA8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_rcd_wr_bypass : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bypass Activate to Write CAS delay, same bank:
                               DDR4/5: t_rcd_wr - 5 dclks; HBM2: t_rcd_wr - 2
                               dclks.
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_rcd_rd_bypass : 7;

                            /* Bits[14:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bypass Activate to Read CAS delay, same bank:
                               DDR4/5: t_rcd_rd - 5 dclks; HBM2: t_rcd_rd - 2
                               dclks.
                            */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_rc_bypass : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /*
                               Bypass Activate to Activate delay, same bank:
                               DDR4/5: t_rc - 5 dclks; HBM2: t_rc - 2 dclks.
                            */
    UINT32 t_ras_bypass : 7;

                            /* Bits[30:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bypass Activate to Precharge delay, same bank:
                               DDR4/5: t_ras - 5 dclks; HBM2: t_ras - 0 dclks.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_BANK_IDLE_BYPASS_MCDDC_CTL_STRUCT;

/* MEMORY_TIMINGS_ADJ2_MCDDC_CTL_REG supported on:                              */
/*      SPRA0 (0x20021aac)                                                      */
/*      SPRB0 (0x20021aac)                                                      */
/*      SPRHBM (0x20021aac)                                                     */
/*      SPRC0 (0x20021aac)                                                      */
/*      SPRMCC (0x20021aac)                                                     */
/*      SPRUCC (0x20021aac)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Timing parameters for DDR5 SRE/X

*/


#define MEMORY_TIMINGS_ADJ2_MCDDC_CTL_REG 0x0B021AAC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tstab : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /*
                               This is the tCKACT + tSTABtiming parameter for
                               RDIMMs (RCD); the time from the de-assertion of
                               CS#, which starts the RCD DCK (tCKACT), plus
                               time for the clock to stabilize, to the ealiest
                               time that the RCD SRX command can be issued. The
                               value should be specified in number of CK
                               (Dclks).
                            */
    UINT32 force_sr_rank_sel : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /*
                               Select vector setting SR state during S3 resume
                               flow. This field should only be written once and
                               only during the S3 resume flow before the DDRIO
                               vsshi_en is enabled. This 8-bit vector of select
                               signals corresponds to the 8 bit spid_cs_n
                               signals. Each bit that corresponds to a present
                               rank must be set to 1 in order for the
                               appropriate SRX sequence to occur for that rank.
                               Below are the spid_cs_n[7:0] rank mappings:
                               spid_cs_n[0]: sCH0 DIMM 0 rank 0 spid_cs_n[1]:
                               sCH0 DIMM 0 rank 1 spid_cs_n[2]: sCH0 DIMM 1
                               rank 0 spid_cs_n[3]: sCH0 DIMM 1 rank 1
                               spid_cs_n[4]: sCH1 DIMM 0 rank 0 spid_cs_n[5]:
                               sCH1 DIMM 0 rank 1 spid_cs_n[6]: sCH1 DIMM 1
                               rank 0 spid_cs_n[7]: sCH1 DIMM 1 rank 1
                            */
    UINT32 tsrx2srx : 7;

                            /* Bits[30:24], Access Type=RW, default=0x00000000*/

                            /*
                               This is the tCSH_SRexit timing parameter for
                               UDIMMs (no RCD) and the tSRX2SRX timing paramter
                               for RDIMMs (RCD). The value should be specified
                               in number of CK (Dclks).
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_ADJ2_MCDDC_CTL_STRUCT;

/* MEMORY_TIMINGS_BANK_TCL_TWL_MCDDC_CTL_REG supported on:                      */
/*      SPRA0 (0x20021ab0)                                                      */
/*      SPRB0 (0x20021ab0)                                                      */
/*      SPRHBM (0x20021ab0)                                                     */
/*      SPRC0 (0x20021ab0)                                                      */
/*      SPRMCC (0x20021ab0)                                                     */
/*      SPRUCC (0x20021ab0)                                                     */
/* Register default value on SPRA0: 0x00100010                                  */
/* Register default value on SPRB0: 0x00100010                                  */
/* Register default value on SPRHBM: 0x00100010                                 */
/* Register default value on SPRC0: 0x00100010                                  */
/* Register default value on SPRMCC: 0x00100010                                 */
/* Register default value on SPRUCC: 0x00100010                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Timing parameters for BANK TCL and TWL 
*/


#define MEMORY_TIMINGS_BANK_TCL_TWL_MCDDC_CTL_REG 0x0B021AB0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_cl : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000010*/

                            /* Read CAS to Data delay: tCL dclks. */
    UINT32 rsvd : 10;

                            /* Bits[15:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_wl : 6;

                            /* Bits[21:16], Access Type=RW, default=0x00000010*/

                            /* Write CAS to Data delay: tWL dclks. */
    UINT32 rsvd_22 : 10;

                            /* Bits[31:22], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_BANK_TCL_TWL_MCDDC_CTL_STRUCT;

/* MEMORY_TIMINGS_BANK_TRCD_MCDDC_CTL_REG supported on:                         */
/*      SPRA0 (0x20021ab8)                                                      */
/*      SPRB0 (0x20021ab8)                                                      */
/*      SPRHBM (0x20021ab8)                                                     */
/*      SPRC0 (0x20021ab8)                                                      */
/*      SPRMCC (0x20021ab8)                                                     */
/*      SPRUCC (0x20021ab8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Timing parameters for BANK TRCD 
*/


#define MEMORY_TIMINGS_BANK_TRCD_MCDDC_CTL_REG 0x0B021AB8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_rcd_rd : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               Activate to Read CAS delay: DDR4: t_RCD dclks;
                               HBM2: t_RCD + 1 dclks
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_rcd_wr : 7;

                            /* Bits[14:8], Access Type=RW, default=0x00000000*/

                            /*
                               Activate to Write CAS delay: DDR4: t_RCD dclks;
                               HBM2: t_RCD + 1 dclks
                            */
    UINT32 t_rcd_imprd : 7;

                            /* Bits[21:15], Access Type=RW, default=0x00000000*/

                            /*
                               ImplicitPRE to Read CAS delay: DDR4: 0; HBM2:
                               tRP + tRCD_RD + 1 dclks.
                            */
    UINT32 t_rcd_impwr : 7;

                            /* Bits[28:22], Access Type=RW, default=0x00000000*/

                            /*
                               ImplicitPRE to Write CAS delay: DDR4: 0; HBM2:
                               tRP + tRCD_WR + 1 dclks.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_BANK_TRCD_MCDDC_CTL_STRUCT;

/* MEMORY_TIMINGS_BANK_TRDA_TWRA_TWRPRE_MCDDC_CTL_REG supported on:             */
/*      SPRA0 (0x20021ac0)                                                      */
/*      SPRB0 (0x20021ac0)                                                      */
/*      SPRHBM (0x20021ac0)                                                     */
/*      SPRC0 (0x20021ac0)                                                      */
/*      SPRMCC (0x20021ac0)                                                     */
/*      SPRUCC (0x20021ac0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Timing parameters for BANK T_RDA, T_WRA, T_WRPRE 
*/


#define MEMORY_TIMINGS_BANK_TRDA_TWRA_TWRPRE_MCDDC_CTL_REG 0x0B021AC0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_rda : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               Read CAS w/AutoPrecharge to Activate delay, same
                               bank, closed page mode: DDR4: tRTP + tRP dclks;
                               HBM2: tRTP + tRP - 2 dclks; open-page mode: 0
                            */
    UINT32 t_wra : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Write CAS w/AutoPrecharge to Activate delay,
                               same bank, closed page mode: DDR4: tWL + BL/2 +
                               tWR + tRP dclks; HBM2: tWL + BL/2 + tWR + tRP -
                               2 dclks; open-page mode: 0
                            */
    UINT32 t_wrpre : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /*
                               Write CAS to Precharge delay, same bank: tWL +
                               BL/2 + tWR dclks.
                            */
    UINT32 t_wr_rda : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               Write CAS to Read CAS with AutoPrecharge delay,
                               same bank: WL + BL/2 + MAX[RU(tWR/tCK) - tRTP,
                               tWTR]
                            */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_BANK_TRDA_TWRA_TWRPRE_MCDDC_CTL_STRUCT;

/* MEMORY_TIMINGS_BANK_TRP_TRC_TRAS_MCDDC_CTL_REG supported on:                 */
/*      SPRA0 (0x20021ac8)                                                      */
/*      SPRB0 (0x20021ac8)                                                      */
/*      SPRHBM (0x20021ac8)                                                     */
/*      SPRC0 (0x20021ac8)                                                      */
/*      SPRMCC (0x20021ac8)                                                     */
/*      SPRUCC (0x20021ac8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Timing parameters for BANK TRP, TRC and TRAS 
*/


#define MEMORY_TIMINGS_BANK_TRP_TRC_TRAS_MCDDC_CTL_REG 0x0B021AC8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_rp : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               Precharge to Activate delay, same bank: DDR4:
                               tRP dclks; DDR5 1N: tRP - 1 dclk; DDR5 2N: tRP -
                               2 dclk; HBM2: tRP - 2 dclks
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_rc : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Activate to Activate delay, same bank: DDR4:
                               tRAS + tRP dclks; HBM2: max(tRC, (tRAS+TRP))
                               dclks
                            */
    UINT32 rsvd_16 : 8;

                            /* Bits[23:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_ras : 7;

                            /* Bits[30:24], Access Type=RW, default=0x00000000*/

                            /*
                               Activate to Precharge delay, same bank: DDR4:
                               tRAS dclks; DDR5 1N: tRAS + 1 dclks; DDR5 2N:
                               tRAS + 2 dclks; HBM2: tRAS + 2 dclks.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_BANK_TRP_TRC_TRAS_MCDDC_CTL_STRUCT;

/* MEMORY_TIMINGS_BANK_TRTP_TWR_MCDDC_CTL_REG supported on:                     */
/*      SPRA0 (0x20021ad0)                                                      */
/*      SPRB0 (0x20021ad0)                                                      */
/*      SPRHBM (0x20021ad0)                                                     */
/*      SPRC0 (0x20021ad0)                                                      */
/*      SPRMCC (0x20021ad0)                                                     */
/*      SPRUCC (0x20021ad0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Timing parameters for BANK TRTP and TWR 
*/


#define MEMORY_TIMINGS_BANK_TRTP_TWR_MCDDC_CTL_REG 0x0B021AD0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_rtp : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               Read CAS to Precharge delay, same bank: tRTP
                               dclks.
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_wr : 7;

                            /* Bits[14:8], Access Type=RW, default=0x00000000*/

                            /* unused - replaced by t_wrpre */
    UINT32 rsvd_15 : 17;

                            /* Bits[31:15], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_BANK_TRTP_TWR_MCDDC_CTL_STRUCT;

/* MEMORY_TIMINGS_CAS2CAS_DD_MCDDC_CTL_REG supported on:                        */
/*      SPRA0 (0x20021ad8)                                                      */
/*      SPRB0 (0x20021ad8)                                                      */
/*      SPRHBM (0x20021ad8)                                                     */
/*      SPRC0 (0x20021ad8)                                                      */
/*      SPRMCC (0x20021ad8)                                                     */
/*      SPRUCC (0x20021ad8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Timing parameters for CAS2CAS Different DIMM
*/


#define MEMORY_TIMINGS_CAS2CAS_DD_MCDDC_CTL_REG 0x0B021AD8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_rrdd : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               Read CAS to Read CAS delay, different DIMM.
                               DDR4: BL/2 + turnaround - 2 dclks; DDRT/DDR4
                               mixed DIMMs: BL/2 + turnaround + tCL_DDRT -
                               tCL_DDR4 - 2 dclks; HBM2: 0.
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_wwdd : 7;

                            /* Bits[14:8], Access Type=RW, default=0x00000000*/

                            /*
                               Write CAS to Write CAS delay, different DIMM.
                               DDR4: BL/2 + turnaround - 2 dclks; DDRT/DDR4
                               mixed DIMMs: BL/2 + turnaround + tWL_DDRT -
                               tWL_DDR4 - 2 dclks; HBM2: 0.
                            */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_rwdd : 7;

                            /* Bits[22:16], Access Type=RW, default=0x00000000*/

                            /*
                               Read CAS to Write CAS delay, different DIMM.
                               DDR4: BL/2 + turnaround + tCL - tWL - 2 dclks;
                               DDRT/DDR4 mixed DIMMs: BL/2 + turnaround +
                               tCL_DDRT - tWL_DDR4 - 2 dclks; HBM2: 0.
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_wrdd : 7;

                            /* Bits[30:24], Access Type=RW, default=0x00000000*/

                            /*
                               Write CAS to Read CAS delay, different DIMM.
                               DDR4: BL/2 + turnaround + tWL - tCL - 2 dclks;
                               DDRT/DDR4 mixed DIMMs: BL/2 + turnaround +
                               tWL_DDRT - tCL_DDR4 - 2 dclks; HBM2: 0.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_CAS2CAS_DD_MCDDC_CTL_STRUCT;

/* MEMORY_TIMINGS_CAS2CAS_DR_MCDDC_CTL_REG supported on:                        */
/*      SPRA0 (0x20021ae0)                                                      */
/*      SPRB0 (0x20021ae0)                                                      */
/*      SPRHBM (0x20021ae0)                                                     */
/*      SPRC0 (0x20021ae0)                                                      */
/*      SPRMCC (0x20021ae0)                                                     */
/*      SPRUCC (0x20021ae0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Timing parameters for CAS2CAS Different Rank
*/


#define MEMORY_TIMINGS_CAS2CAS_DR_MCDDC_CTL_REG 0x0B021AE0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_rrdr : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Read CAS to Read CAS delay, different rank.
                               DDR4: BL/2 + turnaround - 2 dclks; HBM2: 0.
                            */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_wwdr : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000000*/

                            /*
                               Write CAS to Write CAS delay, different rank.
                               DDR4: BL/2 + turnaround - 2 dclks; HBM2: 0.
                            */
    UINT32 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_rwdr : 6;

                            /* Bits[21:16], Access Type=RW, default=0x00000000*/

                            /*
                               Read CAS to Write CAS delay, different rank.
                               DDR4: BL/2 + turnaround + tCL - tWL - 2 dclks;
                               HBM2: 0.
                            */
    UINT32 rsvd_22 : 2;

                            /* Bits[23:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_wrdr : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000000*/

                            /*
                               Write CAS to Read CAS delay, different rank.
                               DDR4: BL/2 + turnaround + tWL - tCL - 2 dclks;
                               HBM2: 0.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_CAS2CAS_DR_MCDDC_CTL_STRUCT;

/* MEMORY_TIMINGS_CAS2CAS_DS_MCDDC_CTL_REG supported on:                        */
/*      SPRA0 (0x20021ae8)                                                      */
/*      SPRB0 (0x20021ae8)                                                      */
/*      SPRHBM (0x20021ae8)                                                     */
/*      SPRC0 (0x20021ae8)                                                      */
/*      SPRMCC (0x20021ae8)                                                     */
/*      SPRUCC (0x20021ae8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Timing parameters for CAS2CAS Different SubRanks
*/


#define MEMORY_TIMINGS_CAS2CAS_DS_MCDDC_CTL_REG 0x0B021AE8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_rrds : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Read CAS to Read CAS delay, different SubRanks.
                               DDR4: BL/2 + turnaround - 2 dclks; HBM2: same as
                               SR value.
                            */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_wwds : 6;

                            /* Bits[13:8], Access Type=RW, default=0x00000000*/

                            /*
                               Write CAS to Write CAS delay, different
                               SubRanks. DDR4: BL/2 + turnaround - 2 dclks;
                               HBM2: same as SR value.
                            */
    UINT32 rsvd_14 : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_rwds : 7;

                            /* Bits[22:16], Access Type=RW, default=0x00000000*/

                            /*
                               Read CAS to Write CAS delay, different SubRanks.
                               DDR4: BL/2 + turnaround + tCL - tWL - 2 dclks;
                               HBM2: same as SR value.
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_wrds : 7;

                            /* Bits[30:24], Access Type=RW, default=0x00000000*/

                            /*
                               Write CAS to Read CAS delay, different SubRanks.
                               DDR4: BL/2 + turnaround + tWL - tCL - 2 dclks;
                               HBM2: same as SR value.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_CAS2CAS_DS_MCDDC_CTL_STRUCT;

/* MEMORY_TIMINGS_CAS2CAS_SG_MCDDC_CTL_REG supported on:                        */
/*      SPRA0 (0x20021af0)                                                      */
/*      SPRB0 (0x20021af0)                                                      */
/*      SPRHBM (0x20021af0)                                                     */
/*      SPRC0 (0x20021af0)                                                      */
/*      SPRMCC (0x20021af0)                                                     */
/*      SPRUCC (0x20021af0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Timing parameters for CAS2CAS Same Bank Group 
*/


#define MEMORY_TIMINGS_CAS2CAS_SG_MCDDC_CTL_REG 0x0B021AF0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_rrsg : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Read CAS to Read CAS delay, same bank group:
                               DDR: tCCD_L - 2 dclks, HBM: tCCD_L dclks. t_rrsg
                               needs to be greater than or equal to t_rrsr.
                            */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_wwsg : 6;

                            /* Bits[13:8], Access Type=RW, default=0x00000000*/

                            /*
                               Write CAS to Write CAS delay, same bank group:
                               DDR: tCCD_L - 2 dclks, HBM: tCCD_L dclks. t_wwsg
                               needs to be greater than or equal to t_wwsr.
                            */
    UINT32 rsvd_14 : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_rwsg : 7;

                            /* Bits[22:16], Access Type=RW, default=0x00000000*/

                            /*
                               Read CAS to Write CAS delay, same bank group:
                               DDR: BL/2 + turnaround + tCL - tWL - 2 dclks,
                               HBM: BL/2 + turnaround + tCL - tWL dclks. t_rwsg
                               needs to be greater than or equal to t_rwsr.
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_wrsg : 7;

                            /* Bits[30:24], Access Type=RW, default=0x00000000*/

                            /*
                               Write CAS to Read CAS delay, same bank group:
                               DDR: BL/2 + turnaround + tWL - tCL - 2 dclks,
                               HBM BL/2 + turnaround + tWL - tCL dclks. t_wrsg
                               needs to be greater than or equal to t_wrsr.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_CAS2CAS_SG_MCDDC_CTL_STRUCT;

/* MEMORY_TIMINGS_CAS2CAS_SR_MCDDC_CTL_REG supported on:                        */
/*      SPRA0 (0x20021af8)                                                      */
/*      SPRB0 (0x20021af8)                                                      */
/*      SPRHBM (0x20021af8)                                                     */
/*      SPRC0 (0x20021af8)                                                      */
/*      SPRMCC (0x20021af8)                                                     */
/*      SPRUCC (0x20021af8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Timing parameters for CAS2CAS Same Rank Different Bank Groups 
*/


#define MEMORY_TIMINGS_CAS2CAS_SR_MCDDC_CTL_REG 0x0B021AF8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_rrsr : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Read CAS to Read CAS delay, same rank, different
                               bank groups: DDR: tCCD_S - 2 dclks, HBM: tCCD_S
                               dclks. t_rrsg needs to be greater than or equal
                               to t_rrsr
                            */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_wwsr : 6;

                            /* Bits[13:8], Access Type=RW, default=0x00000000*/

                            /*
                               Write CAS to Write CAS delay, same rank,
                               different bank groups: DDR: tCCD_S - 2 dclks,
                               HBM: tCCD_S dclks. t_wwsg needs to be greater
                               than or equal to t_wwsr.
                            */
    UINT32 rsvd_14 : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_rwsr : 7;

                            /* Bits[22:16], Access Type=RW, default=0x00000000*/

                            /*
                               Read CAS to Write CAS delay, same rank,
                               different bank groups: DDR: BL/2 + turnaround +
                               tCL - tWL - 2 dclks, HBM: BL/2 + turnaround +
                               tCL - tWL dclks. t_rwsg needs to be greater than
                               or equal to t_rwsr.
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_wrsr : 7;

                            /* Bits[30:24], Access Type=RW, default=0x00000000*/

                            /*
                               Write CAS to Read CAS delay, same rank,
                               different bank groups: DDR: BL/2 + turnaround +
                               tWL - tCL - 2 dclks, BL/2 + turnaround + tWL -
                               tCL dclks. t_wrsg needs to be greater than or
                               equal to t_wrsr.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_CAS2CAS_SR_MCDDC_CTL_STRUCT;

/* MEMORY_TIMINGS_RANK_TRRD_3DS_MCDDC_CTL_REG supported on:                     */
/*      SPRA0 (0x20021b00)                                                      */
/*      SPRB0 (0x20021b00)                                                      */
/*      SPRHBM (0x20021b00)                                                     */
/*      SPRC0 (0x20021b00)                                                      */
/*      SPRMCC (0x20021b00)                                                     */
/*      SPRUCC (0x20021b00)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Timing parameters for Rank TRRD for 3DS
*/


#define MEMORY_TIMINGS_RANK_TRRD_3DS_MCDDC_CTL_REG 0x0B021B00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_rrd_dlr : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Activate to Activate delay, different 3DS
                               logical rank. DDR4 3DS:
                               max(tRRD_dlr,(tFAW_dlr/4)); HBM2: 0.
                            */
    UINT32 rsvd : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_RANK_TRRD_3DS_MCDDC_CTL_STRUCT;

/* MEMORY_TIMINGS_RANK_TRRD_IMPLPRE_MCDDC_CTL_REG supported on:                 */
/*      SPRA0 (0x20021b08)                                                      */
/*      SPRB0 (0x20021b08)                                                      */
/*      SPRHBM (0x20021b08)                                                     */
/*      SPRC0 (0x20021b08)                                                      */
/*      SPRMCC (0x20021b08)                                                     */
/*      SPRUCC (0x20021b08)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Timing parameters for RANK TRRD to/from ImplicitPRE
*/


#define MEMORY_TIMINGS_RANK_TRRD_IMPLPRE_MCDDC_CTL_REG 0x0B021B08

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_rrd_s_a2i : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Explicit ACT to ImplicitPRE delay, same psuedo-
                               channel, different bank groups: DDR4: 0; HBM2:
                               max(4 tCK,tRRD_S-tRP) - 2 dclks.
                            */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_rrd_l_a2i : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000000*/

                            /*
                               Explicit ACT to ImplicitPRE delay, same pseudo-
                               channel, same bank group: DDR4: 0; HBM2: max(4
                               tCK,tRRD_L-tRP) - 2 dclks.
                            */
    UINT32 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_rrd_s_i2a : 5;

                            /* Bits[20:16], Access Type=RW, default=0x00000000*/

                            /*
                               ImplicitPRE to Explicit ACT delay, same psuedo-
                               channel, different bank groups: DDR4: 0; HBM2:
                               tRP + tRRD_S - 2 dclks.
                            */
    UINT32 rsvd_21 : 3;

                            /* Bits[23:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_rrd_l_i2a : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000000*/

                            /*
                               ImplicitPRE to Explicit ACT delay, same psuedo-
                               channel, same bank group: DDR4: 0; HBM2:
                               tRP+tRRD_L - 2 dclks.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_RANK_TRRD_IMPLPRE_MCDDC_CTL_STRUCT;

/* MEMORY_TIMINGS_RANK_TRRD_TFAW_MCDDC_CTL_REG supported on:                    */
/*      SPRA0 (0x20021b10)                                                      */
/*      SPRB0 (0x20021b10)                                                      */
/*      SPRHBM (0x20021b10)                                                     */
/*      SPRC0 (0x20021b10)                                                      */
/*      SPRMCC (0x20021b10)                                                     */
/*      SPRUCC (0x20021b10)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0xC0000000                                  */
/* Register default value on SPRHBM: 0xC0000000                                 */
/* Register default value on SPRC0: 0xC0000000                                  */
/* Register default value on SPRMCC: 0xC0000000                                 */
/* Register default value on SPRUCC: 0xC0000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Timing parameters for RANK TRRD and TFAW 
*/


#define MEMORY_TIMINGS_RANK_TRRD_TFAW_MCDDC_CTL_REG 0x0B021B10

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_rrd_s : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Activate to Activate delay, same rank, different
                               bank groups: tRRD_S - 2 dclks.
                            */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_rrd_l : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000000*/

                            /*
                               Activate to Activate delay, same rank, same bank
                               groups: tRRD_L - 2 dclks.
                            */
    UINT32 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_faw : 6;

                            /* Bits[21:16], Access Type=RW, default=0x00000000*/

                            /*
                               Four Activate Window, same rank: DDR4: tFAW - 2
                               dclks; DDR5: tFAW - 4 dclks; HBMtFAW - 2 dclks.
                            */
    UINT32 rsvd_22 : 2;

                            /* Bits[23:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_faw_impre_bypass : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000000*/

                            /*
                               HBM2: Four ImplicitPRE Window: same pseudo-
                               channel: max((tRRD_L+tRP),tFAW) - 2 dclks. DDR:
                               Four Activate Window for Idle Bypass, same rank:
                               DDR4: tFAW - 4 dclks; DDR5: tFAW - 6 dclks; (or
                               the t_faw field - 2).
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_RANK_TRRD_TFAW_MCDDC_CTL_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_rrd_s : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Activate to Activate delay, same rank, different
                               bank groups: tRRD_S - 2 dclks.
                            */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_rrd_l : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000000*/

                            /*
                               Activate to Activate delay, same rank, same bank
                               groups: tRRD_L - 2 dclks.
                            */
    UINT32 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_faw : 6;

                            /* Bits[21:16], Access Type=RW, default=0x00000000*/

                            /*
                               Four Activate Window, same rank: DDR4: tFAW - 2
                               dclks; DDR5: tFAW - 4 dclks; HBMtFAW - 2 dclks.
                            */
    UINT32 rsvd_22 : 2;

                            /* Bits[23:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_faw_impre_bypass : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000000*/

                            /*
                               HBM2: Four ImplicitPRE Window: same pseudo-
                               channel: max((tRRD_L+tRP),tFAW) - 2 dclks. DDR:
                               Four Activate Window for Idle Bypass, same rank:
                               DDR4: tFAW - 4 dclks; DDR5: tFAW - 6 dclks; (or
                               the t_faw field - 2).
                            */
    UINT32 enable_refsb_in_tfaw : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000001*/

                            /*
                               Include refSB in tFAW logic (i.e. refSB is
                               included in tFAW safe counter and tFAW counter
                               blocks refSB). Enable for x16 devices.
                            */
    UINT32 enable_refsb_lp_act_block : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               Enable refSB in HP to block LP ACT in same
                               cycle; required when refresh cmd and ACT can
                               alias to the same FRANK and enable_refSB_in_tFAW
                               is 1'b1.
                            */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_RANK_TRRD_TFAW_MCDDC_CTL_SPRB0_SPRHBM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_rrd_s : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Activate to Activate delay, same rank, different
                               bank groups: tRRD_S - 2 dclks.
                            */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_rrd_l : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000000*/

                            /*
                               Activate to Activate delay, same rank, same bank
                               groups: tRRD_L - 2 dclks.
                            */
    UINT32 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_faw : 6;

                            /* Bits[21:16], Access Type=RW, default=0x00000000*/

                            /*
                               Four Activate Window, same rank: DDR4: tFAW - 2
                               dclks; DDR5: tFAW - 4 dclks; HBMtFAW - 2 dclks.
                            */
    UINT32 rsvd_22 : 2;

                            /* Bits[23:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_faw_impre_bypass : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000000*/

                            /*
                               HBM2: Four ImplicitPRE Window: same pseudo-
                               channel: max((tRRD_L+tRP),tFAW) - 2 dclks. DDR:
                               Four Activate Window for Idle Bypass, same rank:
                               DDR4: tFAW - 4 dclks; DDR5: tFAW - 6 dclks; (or
                               the t_faw field - 2).
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_RANK_TRRD_TFAW_MCDDC_CTL_STRUCT;

/* MEMORY_TIMINGS_TRRD_IDLE_BYPASS_MCDDC_CTL_REG supported on:                  */
/*      SPRA0 (0x20021b18)                                                      */
/*      SPRB0 (0x20021b18)                                                      */
/*      SPRHBM (0x20021b18)                                                     */
/*      SPRC0 (0x20021b18)                                                      */
/*      SPRMCC (0x20021b18)                                                     */
/*      SPRUCC (0x20021b18)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Timing parameters for Rank TRRD for Idle Bypass
*/


#define MEMORY_TIMINGS_TRRD_IDLE_BYPASS_MCDDC_CTL_REG 0x0B021B18

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_rrd_s_bypass : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Bypass Activate to Activate delay, same rank,
                               different bank groups. DDR4/5: tRRD_S - 4 dclks;
                               HBM2: tRRD_S - 1 dclks.
                            */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_rrd_l_bypass : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bypass Activate to Activate delay, same rank,
                               same bank groups. DDR4/5: tRRD_L - 4 dclks;
                               HBM2: tRRD_L - 1 dclks.
                            */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MEMORY_TIMINGS_TRRD_IDLE_BYPASS_MCDDC_CTL_STRUCT;

/* PKGC_CKE_MCDDC_CTL_REG supported on:                                         */
/*      SPRA0 (0x20021b20)                                                      */
/*      SPRB0 (0x20021b20)                                                      */
/*      SPRHBM (0x20021b20)                                                     */
/*      SPRC0 (0x20021b20)                                                      */
/*      SPRMCC (0x20021b20)                                                     */
/*      SPRUCC (0x20021b20)                                                     */
/* Register default value on SPRA0: 0x10000080                                  */
/* Register default value on SPRB0: 0x10000080                                  */
/* Register default value on SPRHBM: 0x10000080                                 */
/* Register default value on SPRC0: 0x10000080                                  */
/* Register default value on SPRMCC: 0x10000080                                 */
/* Register default value on SPRUCC: 0x10000080                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  Control for CKE (DRAM powerdown modes) at Load Line point 0.  Used when PMLink signal PowerModeSelect[1][0]=00 
*/


#define PKGC_CKE_MCDDC_CTL_REG 0x0B021B20

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cke_idle_timer : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000080*/

                            /*
                               This defines the rank idle period that causes
                               CKE power-down entrance. The number of idle
                               cycles (in DCLKs) are based from command CS
                               assertion. It is important to program this
                               parameter to be greater than roundtrip latency
                               parameter in order to avoid the CKE de-assertion
                               sooner than data return. This register field can
                               be updated dynamically.
                            */
    UINT32 apd_en : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               CKE Active Power Down Mode for DDR4 DIMMs: When
                               0, APD is disabled When 1, APD is enabled This
                               register field can be updated dynamically.
                            */
    UINT32 ppd_en : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               CKE Precharge Power Down (PPD): When 0, PPD is
                               disabled When 1, PPD is enabled This register
                               field can be updated dynamically.
                            */
    UINT32 rsvd : 14;

                            /* Bits[23:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddrt_cke_en : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               CKE Active Power Down Mode for DDR-T DIMMs: When
                               0, APD is disabled When 1, APD is enabled This
                               register field can be updated dynamically.
                            */
    UINT32 rsvd_25 : 3;

                            /* Bits[27:25], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 reserved : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000001*/

                            /* Reserved for future use. */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PKGC_CKE_MCDDC_CTL_STRUCT;

/* PM_ADR_MCDDC_CTL_REG supported on:                                           */
/*      SPRA0 (0x20021b24)                                                      */
/*      SPRB0 (0x20021b24)                                                      */
/*      SPRHBM (0x20021b24)                                                     */
/*      SPRC0 (0x20021b24)                                                      */
/*      SPRMCC (0x20021b24)                                                     */
/*      SPRUCC (0x20021b24)                                                     */
/* Register default value on SPRA0: 0x0000FF23                                  */
/* Register default value on SPRB0: 0x0000FF23                                  */
/* Register default value on SPRHBM: 0x0000FF23                                 */
/* Register default value on SPRC0: 0x0000FF23                                  */
/* Register default value on SPRMCC: 0x0000FF23                                 */
/* Register default value on SPRUCC: 0x0000FF23                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Controls aspects of the DDR ADR and DDR-T ADR flows
*/


#define PM_ADR_MCDDC_CTL_REG 0x0B021B24

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 num_pwr_fail_cmds : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000003*/

                            /*
                               Configures the number of power fail commands are
                               sent on DDR-T to the FMC during a DDR-T ADR
                               Event.
                            */
    UINT32 ddrt_adr_en : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               When set, channel will enter DDR-T ADR flow when
                               in 1LM Mode when ADR event seen. Note: must be
                               set when in 2LM Mode. Channel should always do
                               DDR-T ADR in 2LM mode.
                            */
    UINT32 ddrt_early_warning_s_state : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000001*/

                            /*
                               Specifies the S-state for DDR-T S-State command
                               that should be sent as an early warning to FMC.
                               Default value is 001 = ADR.
                            */
    UINT32 drain_wpq_wait : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000FF*/

                            /*
                               Specifies how long to wait after wpq entries are
                               stale and no wpq command has won arbitration
                               before considering the wpq drained. Used for
                               both DDR ADR and DDR-T ADR.
                            */
    UINT32 t_between_power_fail_cmds : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the minimum amount of time to wait
                               between scheduling power fail commands on the
                               same rank. A value of 0 disables this feature.
                            */
    UINT32 ddrt_adr_sref_timer : 5;

                            /* Bits[24:20], Access Type=RW, default=0x00000000*/

                            /*
                               This field defines number of DCLK of wait time
                               after PCU asserts AsyncSR before telling the
                               refresh FSMs to start a DDR-T ADR flow.
                            */
    UINT32 rsvd : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PM_ADR_MCDDC_CTL_STRUCT;

/* PM_CMD_PWR_0_MCDDC_CTL_REG supported on:                                     */
/*      SPRA0 (0x20021b28)                                                      */
/*      SPRB0 (0x20021b28)                                                      */
/*      SPRHBM (0x20021b28)                                                     */
/*      SPRC0 (0x20021b28)                                                      */
/*      SPRMCC (0x20021b28)                                                     */
/*      SPRUCC (0x20021b28)                                                     */
/* Register default value on SPRA0: 0x84000000                                  */
/* Register default value on SPRB0: 0x84000000                                  */
/* Register default value on SPRHBM: 0x84000000                                 */
/* Register default value on SPRC0: 0x84000000                                  */
/* Register default value on SPRMCC: 0x84000000                                 */
/* Register default value on SPRUCC: 0x84000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Power per command on DIMM 0
*/


#define PM_CMD_PWR_0_MCDDC_CTL_REG 0x0B021B28

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pwrcasr_dimm : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               Power contribution of CAS RD/RDS4 command in
                               both OLTT and ET energy counters.
                            */
    UINT32 pwrcasw_dimm : 4;

                            /* Bits[7:4], Access Type=RW, default=0x00000000*/

                            /*
                               Power contribution of CAS WR/WRS4 command in
                               both OLTT and ET energy counters.
                            */
    UINT32 pwract_dimm : 6;

                            /* Bits[13:8], Access Type=RW, default=0x00000000*/

                            /*
                               Power contribution of ACT command in both OLTT
                               and ET energy counters.
                            */
    UINT32 pwrref_dimm : 8;

                            /* Bits[21:14], Access Type=RW, default=0x00000000*/

                            /*
                               Power contribution of 1x REF or SRE command. The
                               8b refresh weight defined here is actually being
                               multiplied by 8 (shift left by 3 bits) before
                               being accumulated in the electrical throttling
                               and OLTT counters. Note, when using per-bank
                               refresh put the weight for per-rank here and the
                               weight for per-bank in pm_cmd_pwr_extra.
                            */
    UINT32 active_idle_dimm : 5;

                            /* Bits[26:22], Access Type=RW, default=0x00000010*/

                            /*
                               Defines number of DCLK of CKE-assertion to
                               increase the OLTT and ET energy counters (i.e.
                               corresponding PMSUMPCCXRY, ET_DIMMSUM and
                               ET_CH_SUM) by 4. Hardware provides internal CKE
                               counters (two per DIMM slot) to track each CKE.
                               When the internal count decrement to zero, the
                               corresponding OLTT and ET energy counters are
                               increment by 4 and the internal CKE counter is
                               loaded with the content of this register field.
                               PSMI wipe will clear the internal CKE counters.
                               Valid Range of the register field : 1 - 31.
                               Others: reserved. Due to the energy accumulator
                               width limitation, we have imposed additional
                               programming limitation - this field must be
                               programmed equal or greater than 4 DCLKs
                               Programming below 4 is not validated and may
                               jeopardize losing a thermal event or proper
                               electrical/power throttling during certain
                               corner cases due to energy accumulator over-
                               flow.
                            */
    UINT32 pwrodt_cnt_dimm : 5;

                            /* Bits[31:27], Access Type=RW, default=0x00000010*/

                            /*
                               Defines number of DCLK of ODT-assertion to
                               increase the OLTT and ET energy counters (i.e.
                               corresponding PMSUMPCCXRY, ET_DIMMSUM and
                               ET_CH_SUM) by 16. Hardware provides internal ODT
                               counters (two per DIMM slot) to track each ODT.
                               When the internal count decrement to zero, the
                               corresponding OLTT and ET energy counters are
                               incremented by 16 and the internal ODT counter
                               is loaded with the content of this register
                               field. PSMI wipe will clear the internal ODT
                               counters. Possible Valid Range of the register
                               field : 1 - 31. Others: reserved. Due to the
                               energy accumulator width limitation, we have
                               imposed additional programming limitation - this
                               field must be programmed equal or greater than 4
                               DCLKs Programming below 4 is not validated and
                               may jeopardize losing a thermal event or proper
                               electrical/power throttling during certain
                               corner cases due to energy accumulator over-
                               flow.
                            */

  } Bits;
  UINT32 Data;

} PM_CMD_PWR_0_MCDDC_CTL_STRUCT;

/* PM_CMD_PWR_1_MCDDC_CTL_REG supported on:                                     */
/*      SPRA0 (0x20021b2c)                                                      */
/*      SPRB0 (0x20021b2c)                                                      */
/*      SPRHBM (0x20021b2c)                                                     */
/*      SPRC0 (0x20021b2c)                                                      */
/*      SPRMCC (0x20021b2c)                                                     */
/*      SPRUCC (0x20021b2c)                                                     */
/* Register default value on SPRA0: 0x84000000                                  */
/* Register default value on SPRB0: 0x84000000                                  */
/* Register default value on SPRHBM: 0x84000000                                 */
/* Register default value on SPRC0: 0x84000000                                  */
/* Register default value on SPRMCC: 0x84000000                                 */
/* Register default value on SPRUCC: 0x84000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Power per command on DIMM 1
*/


#define PM_CMD_PWR_1_MCDDC_CTL_REG 0x0B021B2C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pwrcasr_dimm : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               Power contribution of CAS RD/RDS4 command in
                               both OLTT and ET energy counters.
                            */
    UINT32 pwrcasw_dimm : 4;

                            /* Bits[7:4], Access Type=RW, default=0x00000000*/

                            /*
                               Power contribution of CAS WR/WRS4 command in
                               both OLTT and ET energy counters.
                            */
    UINT32 pwract_dimm : 6;

                            /* Bits[13:8], Access Type=RW, default=0x00000000*/

                            /*
                               Power contribution of ACT command in both OLTT
                               and ET energy counters.
                            */
    UINT32 pwrref_dimm : 8;

                            /* Bits[21:14], Access Type=RW, default=0x00000000*/

                            /*
                               Power contribution of 1x REF or SRE command. The
                               8b refresh weight defined here is actually being
                               multiplied by 8 (shift left by 3 bits) before
                               being accumulated in the electrical throttling
                               and OLTT counters. Note, when using per-bank
                               refresh put the weight for per-rank here and the
                               weight for per-bank in pm_cmd_pwr_extra.
                            */
    UINT32 active_idle_dimm : 5;

                            /* Bits[26:22], Access Type=RW, default=0x00000010*/

                            /*
                               Defines number of DCLK of CKE-assertion to
                               increase the OLTT and ET energy counters (i.e.
                               corresponding PMSUMPCCXRY, ET_DIMMSUM and
                               ET_CH_SUM) by 4. Hardware provides internal CKE
                               counters (two per DIMM slot) to track each CKE.
                               When the internal count decrement to zero, the
                               corresponding OLTT and ET energy counters are
                               increment by 4 and the internal CKE counter is
                               loaded with the content of this register field.
                               PSMI wipe will clear the internal CKE counters.
                               Valid Range of the register field : 1 - 31.
                               Others: reserved. Due to the energy accumulator
                               width limitation, we have imposed additional
                               programming limitation - this field must be
                               programmed equal or greater than 4 DCLKs
                               Programming below 4 is not validated and may
                               jeopardize losing a thermal event or proper
                               electrical/power throttling during certain
                               corner cases due to energy accumulator over-
                               flow.
                            */
    UINT32 pwrodt_cnt_dimm : 5;

                            /* Bits[31:27], Access Type=RW, default=0x00000010*/

                            /*
                               Defines number of DCLK of ODT-assertion to
                               increase the OLTT and ET energy counters (i.e.
                               corresponding PMSUMPCCXRY, ET_DIMMSUM and
                               ET_CH_SUM) by 16. Hardware provides internal ODT
                               counters (two per DIMM slot) to track each ODT.
                               When the internal count decrement to zero, the
                               corresponding OLTT and ET energy counters are
                               incremented by 16 and the internal ODT counter
                               is loaded with the content of this register
                               field. PSMI wipe will clear the internal ODT
                               counters. Possible Valid Range of the register
                               field : 1 - 31. Others: reserved. Due to the
                               energy accumulator width limitation, we have
                               imposed additional programming limitation - this
                               field must be programmed equal or greater than 4
                               DCLKs Programming below 4 is not validated and
                               may jeopardize losing a thermal event or proper
                               electrical/power throttling during certain
                               corner cases due to energy accumulator over-
                               flow.
                            */

  } Bits;
  UINT32 Data;

} PM_CMD_PWR_1_MCDDC_CTL_STRUCT;

/* PM_CMD_PWR_EXTRA_MCDDC_CTL_REG supported on:                                 */
/*      SPRA0 (0x20021b30)                                                      */
/*      SPRB0 (0x20021b30)                                                      */
/*      SPRHBM (0x20021b30)                                                     */
/*      SPRC0 (0x20021b30)                                                      */
/*      SPRMCC (0x20021b30)                                                     */
/*      SPRUCC (0x20021b30)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Power per command extra settings
*/


#define PM_CMD_PWR_EXTRA_MCDDC_CTL_REG 0x0B021B30

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pwrpbref_dimm0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               Power contribution of per-bank REF for DIMM 0.
                               The 8b refresh weight defined here is actually
                               being multiplied by 8 (shift left by 3 bits)
                               before being accumulated in the energy counters.
                            */
    UINT32 pwrpbref_dimm1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Power contribution of per-bank REF for DIMM 1.
                               The 8b refresh weight defined here is actually
                               being multiplied by 8 (shift left by 3 bits)
                               before being accumulated in the energy counters.
                            */
    UINT32 cpgc_throttle_en : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Enable Throttling for CPGC operation (when not
                               in Normal Mode)
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PM_CMD_PWR_EXTRA_MCDDC_CTL_STRUCT;

/* PWMM_STARV_CNTR_PRESCALER_MCDDC_CTL_REG supported on:                        */
/*      SPRA0 (0x20021b34)                                                      */
/*      SPRB0 (0x20021b34)                                                      */
/*      SPRHBM (0x20021b34)                                                     */
/*      SPRC0 (0x20021b34)                                                      */
/*      SPRMCC (0x20021b34)                                                     */
/*      SPRUCC (0x20021b34)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Partial Write Starvation Counter Pre-scaler
*/


#define PWMM_STARV_CNTR_PRESCALER_MCDDC_CTL_REG 0x0B021B34

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 spare : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* spare */
    UINT32 en_wptr_cadb : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable write pointer for CADB
                               lmn_fifo.
                            */
    UINT32 rsvd : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PWMM_STARV_CNTR_PRESCALER_MCDDC_CTL_STRUCT;

/* PXPCAP_MCDDC_CTL_REG supported on:                                           */
/*      SPRA0 (0x20021b38)                                                      */
/*      SPRB0 (0x20021b38)                                                      */
/*      SPRHBM (0x20021b38)                                                     */
/*      SPRC0 (0x20021b38)                                                      */
/*      SPRMCC (0x20021b38)                                                     */
/*      SPRUCC (0x20021b38)                                                     */
/* Register default value on SPRA0: 0x00910010                                  */
/* Register default value on SPRB0: 0x00910010                                  */
/* Register default value on SPRHBM: 0x00910010                                 */
/* Register default value on SPRC0: 0x00910010                                  */
/* Register default value on SPRMCC: 0x00910010                                 */
/* Register default value on SPRUCC: 0x00910010                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x040
*/


#define PXPCAP_MCDDC_CTL_REG 0x0B021B38

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 capability_id : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000010*/

                            /*
                               Provides the PCI Express capability ID assigned
                               by PCI-SIG.
                            */
    UINT32 next_ptr : 8;

                            /* Bits[15:8], Access Type=RO, default=0x00000000*/

                            /*
                               Pointer to the next capability. Set to 0 to
                               indicate there are no more capability
                               structures.
                            */
    UINT32 capability_version : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               PCI Express Capability is Compliant with Version
                               1.0 of the PCI Express Spec. Note: This
                               capability structure is not compliant with
                               Versions beyond 1.0, since they require
                               additional capability registers to be reserved.
                               The only purpose for this capability structure
                               is to make enhanced configuration space
                               available. Minimizing the size of this structure
                               is accomplished by reporting version 1.0
                               compliancy and reporting that this is an
                               integrated root port device. As such, only three
                               Dwords of configuration space are required for
                               this structure.
                            */
    UINT32 device_port_type : 4;

                            /* Bits[23:20], Access Type=RO, default=0x00000009*/

                            /* Device type is Root Complex Integrated Endpoint */
    UINT32 slot_implemented : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000000*/

                            /* N/A for integrated endpoints */
    UINT32 interrupt_message_number : 5;

                            /* Bits[29:25], Access Type=RO, default=0x00000000*/

                            /* N/A for this device */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PXPCAP_MCDDC_CTL_STRUCT;

/* RD_ODT_TBL0_MCDDC_CTL_REG supported on:                                      */
/*      SPRA0 (0x20021b40)                                                      */
/*      SPRB0 (0x20021b40)                                                      */
/*      SPRHBM (0x20021b40)                                                     */
/*      SPRC0 (0x20021b40)                                                      */
/*      SPRMCC (0x20021b40)                                                     */
/*      SPRUCC (0x20021b40)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* One entry for each physical rank on each channel.  Each entry defines which ODT signals are asserted when accessing that rank.Also includes ODT timing control.
Here is the recommended BIOS settings to keep the MC_TERM_RNK_MSK consistent:
Set Read ODT mapping - read ODT specifies all ODT pins assertion for a read targeting at this rank. Please clear read target DIMMs termination rank bit. The non-target DIMMs termination rank bits must be set. All non-termination rank in the ODT mapping table must be cleared.
*/


#define RD_ODT_TBL0_MCDDC_CTL_REG 0x0B021B40

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rd_odt_rank0 : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /* Rank 0 Read ODT pins */
    UINT32 rsvd : 4;

                            /* Bits[7:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rd_odt_rank1 : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000000*/

                            /* Rank 1 Read ODT pins */
    UINT32 rsvd_12 : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rd_odt_rank2 : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000000*/

                            /* Rank 2 Read ODT pins */
    UINT32 rsvd_20 : 4;

                            /* Bits[23:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rd_odt_rank3 : 4;

                            /* Bits[27:24], Access Type=RW, default=0x00000000*/

                            /* Rank 3 Read ODT pins */
    UINT32 rsvd_28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RD_ODT_TBL0_MCDDC_CTL_STRUCT;

/* PXPENHCAP_MCDDC_CTL_REG supported on:                                        */
/*      SPRA0 (0x20021b4c)                                                      */
/*      SPRB0 (0x20021b4c)                                                      */
/*      SPRHBM (0x20021b4c)                                                     */
/*      SPRC0 (0x20021b4c)                                                      */
/*      SPRMCC (0x20021b4c)                                                     */
/*      SPRUCC (0x20021b4c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This field points to the next Capability in extended configuration space.
*/


#define PXPENHCAP_MCDDC_CTL_REG 0x0B021B4C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 capability_id : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates there are no capability structures in
                               the enhanced configuration space.
                            */
    UINT32 capability_version : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates there are no capability structures in
                               the enhanced configuration space.
                            */
    UINT32 next_capability_offset : 12;

                            /* Bits[31:20], Access Type=RO, default=0x00000000*/

                            /* Next capability offset. */

  } Bits;
  UINT32 Data;

} PXPENHCAP_MCDDC_CTL_STRUCT;

/* RD_ODT_TBL1_MCDDC_CTL_REG supported on:                                      */
/*      SPRA0 (0x20021b54)                                                      */
/*      SPRB0 (0x20021b54)                                                      */
/*      SPRHBM (0x20021b54)                                                     */
/*      SPRC0 (0x20021b54)                                                      */
/*      SPRMCC (0x20021b54)                                                     */
/*      SPRUCC (0x20021b54)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* One entry for each physical rank on each channel.  Each entry defines which ODT signals are asserted when accessing that rank.Also includes ODT timing control.
Here is the recommended BIOS settings to keep the MC_TERM_RNK_MSK consistent:
Set Read ODT mapping - read ODT specifies all ODT pins assertion for a read targeting at this rank. Please clear read target DIMMs termination rank bit. The non-target DIMMs termination rank bits must be set. All non-termination rank in the ODT mapping table must be cleared.
*/


#define RD_ODT_TBL1_MCDDC_CTL_REG 0x0B021B54

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rd_odt_rank4 : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /* Rank 4 Read ODT pins */
    UINT32 rsvd : 4;

                            /* Bits[7:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rd_odt_rank5 : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000000*/

                            /* Rank 5 Read ODT pins */
    UINT32 rsvd_12 : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rd_odt_rank6 : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000000*/

                            /* Rank 6 Read ODT pins */
    UINT32 rsvd_20 : 4;

                            /* Bits[23:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rd_odt_rank7 : 4;

                            /* Bits[27:24], Access Type=RW, default=0x00000000*/

                            /* Rank 7 Read ODT pins */
    UINT32 rsvd_28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RD_ODT_TBL1_MCDDC_CTL_STRUCT;

/* RD_ODT_TBL2_MCDDC_CTL_REG supported on:                                      */
/*      SPRA0 (0x20021b58)                                                      */
/*      SPRB0 (0x20021b58)                                                      */
/*      SPRHBM (0x20021b58)                                                     */
/*      SPRC0 (0x20021b58)                                                      */
/*      SPRMCC (0x20021b58)                                                     */
/*      SPRUCC (0x20021b58)                                                     */
/* Register default value on SPRA0: 0x00800000                                  */
/* Register default value on SPRB0: 0x00800000                                  */
/* Register default value on SPRHBM: 0x00800000                                 */
/* Register default value on SPRC0: 0x00800000                                  */
/* Register default value on SPRMCC: 0x00800000                                 */
/* Register default value on SPRUCC: 0x00800000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* One entry for each physical rank on each channel.  Each entry defines which ODT signals are asserted when accessing that rank.Also includes ODT timing control.
Here is the recommended BIOS settings to keep the MC_TERM_RNK_MSK consistent:
Set Read ODT mapping - read ODT specifies all ODT pins assertion for a read targeting at this rank. Please clear read target DIMM's termination rank bit. The non-target DIMM's termination rank bits must be set. All non-termination rank in the ODT mapping table must be cleared.
*/


#define RD_ODT_TBL2_MCDDC_CTL_REG 0x0B021B58

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 16;

                            /* Bits[15:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 extraleadingodt : 2;

                            /* Bits[17:16], Access Type=RW, default=0x00000000*/

                            /* Extra Leading ODT cycles */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 extratrailingodt : 2;

                            /* Bits[21:20], Access Type=RW, default=0x00000000*/

                            /* Extra Trailing ODT cycles */
    UINT32 read_delay_odt : 4;

                            /* Bits[25:22], Access Type=RW, default=0x00000002*/

                            /* Read ODT delay. */
    UINT32 rsvd_26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RD_ODT_TBL2_MCDDC_CTL_STRUCT;

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* MR_CONFIG_MCDDC_CTL_REG supported on:                                        */
/*      SPRB0 (0x20021b64)                                                      */
/*      SPRHBM (0x20021b64)                                                     */
/*      SPRC0 (0x20021b64)                                                      */
/*      SPRMCC (0x20021b64)                                                     */
/*      SPRUCC (0x20021b64)                                                     */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Usages are for periodically reading the ECS results from MR15 thru MR20 and the DRAM temperature updates from MR4.  Access to ECS MRs also requires writing to MR14 to set the CID for 3DS devices.

*/


#define MR_CONFIG_MCDDC_CTL_REG 0x0B021B64

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 start_inprogress : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is used to initiate an MRR to a
                               specified MR address or an MRW to MR14. It is
                               cleared by HW when the operation has completed.
                            */
    UINT32 failed : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /*
                               Indicates the success or failure of the
                               requested MR command. Only valid when the
                               start_inprogress bit is 0.
                            */
    UINT32 mrw : 1;

                            /* Bits[2:2], Access Type=RW/V, default=0x00000000*/

                            /*
                               Set to 1 to issue an MRW to MR14. Set to 0 to
                               issue an MRR to the specified address in
                               mrr_addr.
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 subchannel : 1;

                            /* Bits[4:4], Access Type=RW/V, default=0x00000000*/

                            /* Selects the subchannel for the requested MRR/MRW */
    UINT32 rank : 2;

                            /* Bits[6:5], Access Type=RW/V, default=0x00000000*/

                            /*
                               Selects the physical rank for the requested
                               MRR/MRW command
                            */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrr_addr : 8;

                            /* Bits[15:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               Selects the MR address for the MRR command. Not
                               used for MRW commands. The only supported
                               address for MRW commands is MR14 and this
                               address is auto selected when mrw=1.
                            */
    UINT32 mrw_op : 8;

                            /* Bits[23:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               Sets the MRW write data (OP[7:0]) for MRW
                               commands; not used for MRR commands.
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MR_CONFIG_MCDDC_CTL_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* REFRESH_TIMINGS_MCDDC_CTL_REG supported on:                                  */
/*      SPRB0 (0x20021b68)                                                      */
/*      SPRHBM (0x20021b68)                                                     */
/*      SPRC0 (0x20021b68)                                                      */
/*      SPRMCC (0x20021b68)                                                     */
/*      SPRUCC (0x20021b68)                                                     */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* DIMM staggering configuration

*/


#define REFRESH_TIMINGS_MCDDC_CTL_REG 0x0B021B68

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_dimm_stagger_refab : 10;

                            /* Bits[9:0], Access Type=RW, default=0x00000000*/

                            /*
                               Limits the number of simultaneous refresh
                               commands sent to a DIMM. The value of this field
                               sets the window size for allowing 4 all bank
                               refreshes. The spec limit is 40 DRAM die per
                               DIMM can have overlapping refreshes. For DIMMs
                               with x4 devices and ECC, that is 10 devices per
                               physical rank; so this value should be set to
                               tRFC expressed in Hclks, to allow at most 40 die
                               to be refreshed in any window size of tRFC
                               (expressed in Hclks). For x8 devices, tRFC/2
                               could be used since each all bank refresh only
                               uses 5 devices.
                            */
    UINT32 rsvd : 2;

                            /* Bits[11:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_dimm_stagger_refsb : 10;

                            /* Bits[21:12], Access Type=RW, default=0x00000000*/

                            /*
                               Limits the number of simultaneous refresh
                               commands sent to a DIMM. The value of this field
                               sets the window size for allowing 4 all bank
                               refreshes.. There is no specification for DIMM
                               staggering for same bank refreshes at this time;
                               so this value should be set to 0. The maximum
                               value that should be used would be
                               t_dimm_stagger_refab/4, since same bank refresh
                               commands refresh 1/4 as much of the DRAM as does
                               an all bank refresh command.
                            */
    UINT32 rsvd_22 : 2;

                            /* Bits[23:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_dimm_stagger_any_ref : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               Sets the minimum stagger between any refresh on
                               one subchannel to a refresh on the other
                               subchannel. Default is 0; only apply DIMM
                               staggering rules and t_stagger_ref (stagger of
                               refreshes on the same subchannel).
                            */

  } Bits;
  UINT32 Data;

} REFRESH_TIMINGS_MCDDC_CTL_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

/* RDIMMTIMINGCNTL2_MCDDC_CTL_REG supported on:                                 */
/*      SPRA0 (0x20021b6c)                                                      */
/*      SPRB0 (0x20021b6c)                                                      */
/*      SPRHBM (0x20021b6c)                                                     */
/*      SPRC0 (0x20021b6c)                                                      */
/*      SPRMCC (0x20021b6c)                                                     */
/*      SPRUCC (0x20021b6c)                                                     */
/* Register default value on SPRA0: 0x03201404                                  */
/* Register default value on SPRB0: 0x03201404                                  */
/* Register default value on SPRHBM: 0x03201404                                 */
/* Register default value on SPRC0: 0x03201404                                  */
/* Register default value on SPRMCC: 0x03201404                                 */
/* Register default value on SPRUCC: 0x03201404                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x240
*/


#define RDIMMTIMINGCNTL2_MCDDC_CTL_REG 0x0B021B6C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_ckev : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000004*/

                            /*
                               Input buffers (DCKE0 and DCKE1) disable time
                               (float) after Ck/CK# = LOW (not needed since
                               DDRIO cannot program the CKE to be tristated.
                            */
    UINT32 t_ckoff : 10;

                            /* Bits[17:8], Access Type=RW, default=0x00000014*/

                            /*
                               tCKOFF timing parameter: Number of command
                               clocks required after self-refresh entry before
                               the clock can be turned off. This corresponds to
                               tCKESRE. With cmd/address parity error recovery
                               enabled. THis shold be set a number large enough
                               to assure that parity error on a self refresh
                               entry has enough time to get back into MC and
                               start the recovery before clocks are turned off.
                               This field (t_ckoff) must be set larger than
                               lpmode_pm_ctrl.lpmode_entry_latency (a 4 bit
                               field).
                            */
    UINT32 t_bank_stagger : 10;

                            /* Bits[27:18], Access Type=RW, default=0x000000C8*/

                            /*
                               Used for per-bank refresh to determine number of
                               clocks between refresh commands to the same rank
                               but different bank sets.
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RDIMMTIMINGCNTL2_MCDDC_CTL_STRUCT;

/* RDIMMTIMINGCNTL_MCDDC_CTL_REG supported on:                                  */
/*      SPRA0 (0x20021b70)                                                      */
/*      SPRB0 (0x20021b70)                                                      */
/*      SPRHBM (0x20021b70)                                                     */
/*      SPRC0 (0x20021b70)                                                      */
/*      SPRMCC (0x20021b70)                                                     */
/*      SPRUCC (0x20021b70)                                                     */
/* Register default value on SPRA0: 0x012C0000                                  */
/* Register default value on SPRB0: 0x012C0000                                  */
/* Register default value on SPRHBM: 0x012C0000                                 */
/* Register default value on SPRC0: 0x012C0000                                  */
/* Register default value on SPRMCC: 0x012C0000                                 */
/* Register default value on SPRUCC: 0x012C0000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x23c
*/


#define RDIMMTIMINGCNTL_MCDDC_CTL_REG 0x0B021B70

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 12;

                            /* Bits[11:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_stab : 20;

                            /* Bits[31:12], Access Type=RW, default=0x000012C0*/

                            /*
                               Stablizing time in number of DCLK, i.e. the DCLK
                               must be stable for T_STAB before any access to
                               the device take place. tCKSRX is included in the
                               T_STAB programming since there is not a separate
                               tCKSRX parameter control to delay self-refresh
                               exit latency from clock stopped conditions. zero
                               value in T_STAB is reserved and it is important
                               to AVOID programming a zero value in the T_STAB.
                               Recommended settings (Note: contains stretch
                               goal and/or over-clock frequency examples): FREQ
                               T_STAB for RDIMM (including tCKSRX value) 0800
                               0960h+5h=0965h 1067 0C80h+5h=0c85h 1333
                               0FA0h+7h=0FA7h 1600 12C0h+8h=12C8h 1867
                               15E0h+Ah=15EAh 2133 1900h+Bh=190Bh FREQ T_STAB
                               for UDIMM (i.e. tCKSRX value) 0800 5h 1067 5h
                               1333 7h 1600 8h 1867 Ah 2133 Bh
                            */

  } Bits;
  UINT32 Data;

} RDIMMTIMINGCNTL_MCDDC_CTL_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecs_refab_interval : 10;

                            /* Bits[9:0], Access Type=RW, default=0x00000000*/

                            /*
                               The ECS REFab interval is used to set the
                               periodic issuing of all bank refreshes instead
                               of same bank refreshes, which might be needed
                               for certain DRAMs to support the automatic mode
                               of ECS. When set to 0, the refresh engine will
                               never periodically switch from issuing REFsb
                               refreshes to issuing a REFab refresh. Otherwise,
                               a non-zero value will result in one REFab
                               refresh to be issued at the interval specified
                               by the value in ecs_refab_interval. For example,
                               setting the value to decimal 300 will result in
                               299 REFsb refreshes followed by 1 REFab refresh.
                               Note, setting the value to 1 will effectively
                               disable same bank refresh mode.
                            */
    UINT32 rsvd : 2;

                            /* Bits[11:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_stab : 20;

                            /* Bits[31:12], Access Type=RW, default=0x000012C0*/

                            /*
                               Stablizing time in number of DCLK, i.e. the DCLK
                               must be stable for T_STAB before any access to
                               the device take place. tCKSRX is included in the
                               T_STAB programming since there is not a separate
                               tCKSRX parameter control to delay self-refresh
                               exit latency from clock stopped conditions. zero
                               value in T_STAB is reserved and it is important
                               to AVOID programming a zero value in the T_STAB.
                               Recommended settings (Note: contains stretch
                               goal and/or over-clock frequency examples): FREQ
                               T_STAB for RDIMM (including tCKSRX value) 0800
                               0960h+5h=0965h 1067 0C80h+5h=0c85h 1333
                               0FA0h+7h=0FA7h 1600 12C0h+8h=12C8h 1867
                               15E0h+Ah=15EAh 2133 1900h+Bh=190Bh FREQ T_STAB
                               for UDIMM (i.e. tCKSRX value) 0800 5h 1067 5h
                               1333 7h 1600 8h 1867 Ah 2133 Bh
                            */

  } Bits;
  UINT32 Data;

} RDIMMTIMINGCNTL_MCDDC_CTL_SPRB0_SPRHBM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 12;

                            /* Bits[11:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 t_stab : 20;

                            /* Bits[31:12], Access Type=RW, default=0x000012C0*/

                            /*
                               Stablizing time in number of DCLK, i.e. the DCLK
                               must be stable for T_STAB before any access to
                               the device take place. tCKSRX is included in the
                               T_STAB programming since there is not a separate
                               tCKSRX parameter control to delay self-refresh
                               exit latency from clock stopped conditions. zero
                               value in T_STAB is reserved and it is important
                               to AVOID programming a zero value in the T_STAB.
                               Recommended settings (Note: contains stretch
                               goal and/or over-clock frequency examples): FREQ
                               T_STAB for RDIMM (including tCKSRX value) 0800
                               0960h+5h=0965h 1067 0C80h+5h=0c85h 1333
                               0FA0h+7h=0FA7h 1600 12C0h+8h=12C8h 1867
                               15E0h+Ah=15EAh 2133 1900h+Bh=190Bh FREQ T_STAB
                               for UDIMM (i.e. tCKSRX value) 0800 5h 1067 5h
                               1333 7h 1600 8h 1867 Ah 2133 Bh
                            */

  } Bits;
  UINT32 Data;

} RDIMMTIMINGCNTL_MCDDC_CTL_STRUCT;

/* SCHEDULER_BLOCKING_RULES_MCDDC_CTL_REG supported on:                         */
/*      SPRA0 (0x20021b74)                                                      */
/*      SPRB0 (0x20021b74)                                                      */
/*      SPRHBM (0x20021b74)                                                     */
/*      SPRC0 (0x20021b74)                                                      */
/*      SPRMCC (0x20021b74)                                                     */
/*      SPRUCC (0x20021b74)                                                     */
/* Register default value on SPRA0: 0x1C1C0000                                  */
/* Register default value on SPRB0: 0x1C1C0000                                  */
/* Register default value on SPRHBM: 0x1C1C0000                                 */
/* Register default value on SPRC0: 0x1C1C0000                                  */
/* Register default value on SPRMCC: 0x1C1C0000                                 */
/* Register default value on SPRUCC: 0x1C1C0000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Global Scheduler Blocking Rules
*/


#define SCHEDULER_BLOCKING_RULES_MCDDC_CTL_REG 0x0B021B74

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 top_strv_blck_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Top Starved CAS blocks all other CAS */
    UINT32 crit_maj_blck_noncrit_min_rmm_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Read CAS blocks minor-mode
                               non-critical Write CAS
                            */
    UINT32 crit_maj_blck_noncrit_min_wmm_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Write CAS blocks minor-mode
                               non-critical Read CAS
                            */
    UINT32 crit_maj_blck_crit_min_rmm_en : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Read CAS blocks minor-mode
                               critical Write CAS
                            */
    UINT32 crit_maj_blck_crit_min_wmm_en : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Write CAS blocks minor-mode
                               critical Read CAS
                            */
    UINT32 crit_min_blck_noncrit_maj_rmm_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Critical minor-mode Write CAS blocks major-mode
                               non-critical Read CAS
                            */
    UINT32 crit_min_blck_noncrit_maj_wmm_en : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Critical minor-mode Read CAS blocks major-mode
                               non-critical Write CAS
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 top_strv_act_blck_act_sr_en : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* Top Starved ACT blocks all other ACTs. */
    UINT32 crit_act_bclk_noncrit_act_sr_en : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Critical ACT blocks non-critical ACTs of the
                               same logical rank (same PCH for HBM2)
                            */
    UINT32 noncrit_maj_act_blck_noncrit_min_act_sr_en : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Non-critical major-mode ACT blocks non-critical
                               minor-mode ACT of the same logical rank (same
                               PCH for HBM2)
                            */
    UINT32 noncrit_maj_read_act_blck_noncrit_min_write_act_threshold_en : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Non-critical major-mode Read ACT blocks non-
                               critical minor-mode Write ACT to same Rank on
                               WPQ Loaded Threshold (block wpq occupancy <=
                               wpq_loaded_threshold) (same PCH for HBM2),
                               exclude underfills, ignored when low on RDB
                               credits.
                            */
    UINT32 noncrit_maj_write_act_blck_noncrit_min_read_act_threshold_en : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Non-critical major-mode Write ACT blocks non-
                               critical minor-mode Read ACT to same Rank on RPQ
                               Loaded Threshold (block rpq occupancy <=
                               rpq_loaded_threshold) (same PCH for HBM2),
                               exclude underfills.
                            */
    UINT32 noncrit_maj_read_cas_blck_noncrit_min_write_cas_threshold_en : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Non-critical major-mode Read CAS blocks non-
                               critical minor-mode Write CAS to same Rank on
                               WPQ Loaded Threshold (block wpq occupancy <=
                               wpq_loaded_threshold) (same PCH for HBM2),
                               exclude underfills, ignored when low on RDB
                               credits.
                            */
    UINT32 noncrit_maj_write_cas_blck_noncrit_min_read_cas_threshold_en : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Non-critical major-mode Write CAS blocks non-
                               critical minor-mode Read CAS to same Rank on RPQ
                               Loaded Threshold (block rpq occupancy <=
                               rpq_loaded_threshold) (same PCH for HBM2),
                               exclude underfills.
                            */
    UINT32 maj_exp_act_blck_noncrit_impre_sp_en : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Major-mode explicit ACT blocks non-critical
                               ImplicitPRE of the same PCH (HBM2 only)
                            */
    UINT32 wpq_loaded_threshold : 6;

                            /* Bits[21:16], Access Type=RW, default=0x0000001C*/

                            /*
                               Watermark value when available write pending
                               queue (WPQ) falls below the value, i.e. block =
                               occupancy <= watermark. Watermark needs to be
                               below the number of enabled pending queue
                               entries.
                            */
    UINT32 rsvd_22 : 2;

                            /* Bits[23:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rpq_loaded_threshold : 6;

                            /* Bits[29:24], Access Type=RW, default=0x0000001C*/

                            /*
                               Watermark value when available read pending
                               queue (RPQ) falls above the value, i.e. block =
                               occupancy <= watermark. Watermark needs to be
                               below the number of enabled pending queue
                               entries.
                            */
    UINT32 crit_maj_blck_noncrit_maj_rmm_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Read CAS blocks major-mode
                               non-critical Read CAS
                            */
    UINT32 crit_maj_blck_noncrit_maj_wmm_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Write CAS blocks major-mode
                               non-critical Write CAS
                            */

  } Bits;
  UINT32 Data;

} SCHEDULER_BLOCKING_RULES_MCDDC_CTL_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 top_strv_blck_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Top Starved CAS blocks all other CAS */
    UINT32 crit_maj_blck_noncrit_min_rmm_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Read CAS blocks minor-mode
                               non-critical Write CAS
                            */
    UINT32 crit_maj_blck_noncrit_min_wmm_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Write CAS blocks minor-mode
                               non-critical Read CAS
                            */
    UINT32 crit_maj_blck_crit_min_rmm_en : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Read CAS blocks minor-mode
                               critical Write CAS
                            */
    UINT32 crit_maj_blck_crit_min_wmm_en : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Write CAS blocks minor-mode
                               critical Read CAS
                            */
    UINT32 crit_min_blck_noncrit_maj_rmm_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Critical minor-mode Write CAS blocks major-mode
                               non-critical Read CAS
                            */
    UINT32 crit_min_blck_noncrit_maj_wmm_en : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Critical minor-mode Read CAS blocks major-mode
                               non-critical Write CAS
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 top_strv_act_blck_act_sr_en : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* Top Starved ACT blocks all other ACTs. */
    UINT32 crit_act_bclk_noncrit_act_sr_en : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Critical ACT blocks non-critical ACTs of the
                               same logical rank (same PCH for HBM2)
                            */
    UINT32 noncrit_maj_act_blck_noncrit_min_act_sr_en : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Non-critical major-mode ACT blocks non-critical
                               minor-mode ACT of the same logical rank (same
                               PCH for HBM2)
                            */
    UINT32 noncrit_maj_read_act_blck_noncrit_min_write_act_threshold_en : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Non-critical major-mode Read ACT blocks non-
                               critical minor-mode Write ACT to same Rank on
                               WPQ Loaded Threshold (block wpq occupancy <=
                               wpq_loaded_threshold) (same PCH for HBM2),
                               exclude underfills, ignored when low on RDB
                               credits.
                            */
    UINT32 noncrit_maj_write_act_blck_noncrit_min_read_act_threshold_en : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Non-critical major-mode Write ACT blocks non-
                               critical minor-mode Read ACT to same Rank on RPQ
                               Loaded Threshold (block rpq occupancy <=
                               rpq_loaded_threshold) (same PCH for HBM2),
                               exclude underfills.
                            */
    UINT32 noncrit_maj_read_cas_blck_noncrit_min_write_cas_threshold_en : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Non-critical major-mode Read CAS blocks non-
                               critical minor-mode Write CAS to same Rank on
                               WPQ Loaded Threshold (block wpq occupancy <=
                               wpq_loaded_threshold) (same PCH for HBM2),
                               exclude underfills, ignored when low on RDB
                               credits.
                            */
    UINT32 noncrit_maj_write_cas_blck_noncrit_min_read_cas_threshold_en : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Non-critical major-mode Write CAS blocks non-
                               critical minor-mode Read CAS to same Rank on RPQ
                               Loaded Threshold (block rpq occupancy <=
                               rpq_loaded_threshold) (same PCH for HBM2),
                               exclude underfills.
                            */
    UINT32 maj_exp_act_blck_noncrit_impre_sp_en : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Major-mode explicit ACT blocks non-critical
                               ImplicitPRE of the same PCH (HBM2 only)
                            */
    UINT32 wpq_loaded_threshold : 6;

                            /* Bits[21:16], Access Type=RW, default=0x0000001C*/

                            /*
                               Watermark value when available write pending
                               queue (WPQ) falls below the value, i.e. block =
                               occupancy <= watermark. Watermark needs to be
                               below the number of enabled pending queue
                               entries.
                            */
    UINT32 first_maj_cas_blck_noncrit_min_cas_en : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               First major-mode CAS blocks minor-mode non-
                               critical CAS
                            */
    UINT32 first_maj_cas_blck_noncrit_min_act_en : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               First major-mode CAS blocks minor-mode non-
                               critical ACT
                            */
    UINT32 rpq_loaded_threshold : 6;

                            /* Bits[29:24], Access Type=RW, default=0x0000001C*/

                            /*
                               Watermark value when available read pending
                               queue (RPQ) falls above the value, i.e. block =
                               occupancy <= watermark. Watermark needs to be
                               below the number of enabled pending queue
                               entries.
                            */
    UINT32 crit_maj_blck_noncrit_maj_rmm_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Read CAS blocks major-mode
                               non-critical Read CAS
                            */
    UINT32 crit_maj_blck_noncrit_maj_wmm_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Write CAS blocks major-mode
                               non-critical Write CAS
                            */

  } Bits;
  UINT32 Data;

} SCHEDULER_BLOCKING_RULES_MCDDC_CTL_SPRB0_SPRHBM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 top_strv_blck_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Top Starved CAS blocks all other CAS */
    UINT32 crit_maj_blck_noncrit_min_rmm_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Read CAS blocks minor-mode
                               non-critical Write CAS
                            */
    UINT32 crit_maj_blck_noncrit_min_wmm_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Write CAS blocks minor-mode
                               non-critical Read CAS
                            */
    UINT32 crit_maj_blck_crit_min_rmm_en : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Read CAS blocks minor-mode
                               critical Write CAS
                            */
    UINT32 crit_maj_blck_crit_min_wmm_en : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Write CAS blocks minor-mode
                               critical Read CAS
                            */
    UINT32 crit_min_blck_noncrit_maj_rmm_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Critical minor-mode Write CAS blocks major-mode
                               non-critical Read CAS
                            */
    UINT32 crit_min_blck_noncrit_maj_wmm_en : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Critical minor-mode Read CAS blocks major-mode
                               non-critical Write CAS
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 top_strv_act_blck_act_sr_en : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* Top Starved ACT blocks all other ACTs. */
    UINT32 crit_act_bclk_noncrit_act_sr_en : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Critical ACT blocks non-critical ACTs of the
                               same logical rank (same PCH for HBM2)
                            */
    UINT32 noncrit_maj_act_blck_noncrit_min_act_sr_en : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Non-critical major-mode ACT blocks non-critical
                               minor-mode ACT of the same logical rank (same
                               PCH for HBM2)
                            */
    UINT32 noncrit_maj_read_act_blck_noncrit_min_write_act_threshold_en : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Non-critical major-mode Read ACT blocks non-
                               critical minor-mode Write ACT to same Rank on
                               WPQ Loaded Threshold (block wpq occupancy <=
                               wpq_loaded_threshold) (same PCH for HBM2),
                               exclude underfills, ignored when low on RDB
                               credits.
                            */
    UINT32 noncrit_maj_write_act_blck_noncrit_min_read_act_threshold_en : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Non-critical major-mode Write ACT blocks non-
                               critical minor-mode Read ACT to same Rank on RPQ
                               Loaded Threshold (block rpq occupancy <=
                               rpq_loaded_threshold) (same PCH for HBM2),
                               exclude underfills.
                            */
    UINT32 noncrit_maj_read_cas_blck_noncrit_min_write_cas_threshold_en : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Non-critical major-mode Read CAS blocks non-
                               critical minor-mode Write CAS to same Rank on
                               WPQ Loaded Threshold (block wpq occupancy <=
                               wpq_loaded_threshold) (same PCH for HBM2),
                               exclude underfills, ignored when low on RDB
                               credits.
                            */
    UINT32 noncrit_maj_write_cas_blck_noncrit_min_read_cas_threshold_en : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Non-critical major-mode Write CAS blocks non-
                               critical minor-mode Read CAS to same Rank on RPQ
                               Loaded Threshold (block rpq occupancy <=
                               rpq_loaded_threshold) (same PCH for HBM2),
                               exclude underfills.
                            */
    UINT32 maj_exp_act_blck_noncrit_impre_sp_en : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Major-mode explicit ACT blocks non-critical
                               ImplicitPRE of the same PCH (HBM2 only)
                            */
    UINT32 wpq_loaded_threshold : 6;

                            /* Bits[21:16], Access Type=RW, default=0x0000001C*/

                            /*
                               Watermark value when available write pending
                               queue (WPQ) falls below the value, i.e. block =
                               occupancy <= watermark. Watermark needs to be
                               below the number of enabled pending queue
                               entries.
                            */
    UINT32 rsvd_22 : 2;

                            /* Bits[23:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rpq_loaded_threshold : 6;

                            /* Bits[29:24], Access Type=RW, default=0x0000001C*/

                            /*
                               Watermark value when available read pending
                               queue (RPQ) falls above the value, i.e. block =
                               occupancy <= watermark. Watermark needs to be
                               below the number of enabled pending queue
                               entries.
                            */
    UINT32 crit_maj_blck_noncrit_maj_rmm_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Read CAS blocks major-mode
                               non-critical Read CAS
                            */
    UINT32 crit_maj_blck_noncrit_maj_wmm_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Critical major-mode Write CAS blocks major-mode
                               non-critical Write CAS
                            */

  } Bits;
  UINT32 Data;

} SCHEDULER_BLOCKING_RULES_MCDDC_CTL_STRUCT;

/* SCHEDULER_CMD_DEBUG_MCDDC_CTL_REG supported on:                              */
/*      SPRA0 (0x20021b78)                                                      */
/*      SPRB0 (0x20021b78)                                                      */
/*      SPRHBM (0x20021b78)                                                     */
/*      SPRC0 (0x20021b78)                                                      */
/*      SPRMCC (0x20021b78)                                                     */
/*      SPRUCC (0x20021b78)                                                     */
/* Register default value on SPRA0: 0x01FFFFFF                                  */
/* Register default value on SPRB0: 0x01FFFFFF                                  */
/* Register default value on SPRHBM: 0x01FFFFFF                                 */
/* Register default value on SPRC0: 0x01FFFFFF                                  */
/* Register default value on SPRMCC: 0x01FFFFFF                                 */
/* Register default value on SPRUCC: 0x01FFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Command Debug 
*/


#define SCHEDULER_CMD_DEBUG_MCDDC_CTL_REG 0x0B021B78

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_cke_oe : 4;

                            /* Bits[3:0], Access Type=RW, default=0x0000000F*/

                            /*
                               When cmd_cke_on is set, overrides with
                               cmd_cke_oe values
                            */
    UINT32 cmd_odt_oe : 4;

                            /* Bits[7:4], Access Type=RW, default=0x0000000F*/

                            /*
                               When cmd_odt_on is set, overrides with
                               cmd_odt_oe values
                            */
    UINT32 cmd_cs_oe : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000FF*/

                            /*
                               When cmd_cs_on is set, overrides with cmd_cs_oe
                               values
                            */
    UINT32 cmd_type_oe : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000FF*/

                            /*
                               When cmd_cs_on is set, overrides with cmd_cs_oe
                               values
                            */
    UINT32 cmd_ca_oe : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000001*/

                            /*
                               When cmd_ca_on is set, overrides with cmd_odt_oe
                               values
                            */
    UINT32 rsvd : 2;

                            /* Bits[26:25], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_type_on : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               When cmd_cke_on is set, overrides with
                               cmd_cke_oe values
                            */
    UINT32 cmd_cke_on : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               When cmd_cke_on is set, overrides with
                               cmd_cke_oe values
                            */
    UINT32 cmd_cs_on : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               When cmd_cs_on is set, overrides with cmd_cs_oe
                               values
                            */
    UINT32 cmd_odt_on : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               When cmd_odt_on is set, overrides with
                               cmd_odt_oe values
                            */
    UINT32 cmd_ca_on : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               When cmd_ca_on is set, overrides with cmd_odt_oe
                               values
                            */

  } Bits;
  UINT32 Data;

} SCHEDULER_CMD_DEBUG_MCDDC_CTL_STRUCT;

/* SCHEDULER_CMD_OPCODE_DEBUG_MCDDC_CTL_REG supported on:                       */
/*      SPRA0 (0x20021b7c)                                                      */
/*      SPRB0 (0x20021b7c)                                                      */
/*      SPRHBM (0x20021b7c)                                                     */
/*      SPRC0 (0x20021b7c)                                                      */
/*      SPRMCC (0x20021b7c)                                                     */
/*      SPRUCC (0x20021b7c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Block or throttles the commands listed below by the global response triggers.  To configure:   0:disabled, 1:Trigger0, 2:Trigger1, 3:Trigger2 per opcode type
*/


#define SCHEDULER_CMD_OPCODE_DEBUG_MCDDC_CTL_REG 0x0B021B7C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cmd_block_act : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               If configured blocks ACTs when triggered. This
                               doesn't not include ImplicitPRE, IdleBypass
                               ACTs, disable idle-bypass as needed
                            */
    UINT32 cmd_block_imp : 2;

                            /* Bits[3:2], Access Type=RW, default=0x00000000*/

                            /* If configured blocks ImplicitPRE when triggered. */
    UINT32 cmd_block_pre : 2;

                            /* Bits[5:4], Access Type=RW, default=0x00000000*/

                            /*
                               If configured blocks PREs when triggered. This
                               doesn't include ImplicitPRE, PREALL or CAS
                               w/AutoPrecharge, disable refresh as needed
                            */
    UINT32 cmd_block_rcas : 2;

                            /* Bits[7:6], Access Type=RW, default=0x00000000*/

                            /*
                               If configured blocks Read CASs when triggered.
                               This doesn't includes Read CAS w/AutoPrecharge.
                               This does include underfill and dependent reads.
                            */
    UINT32 cmd_block_wcas : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000000*/

                            /*
                               If configured blocks Write CASs when triggered.
                               This doesn't includes Write CAS w/AutoPrecharge
                            */
    UINT32 cmd_block_rcas_pre : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /*
                               If configured blocks Read CAS w/AutoPrecharge
                               when triggered. This doesn't includes CAS, for
                               HBM2 in closed-page mode, only the second CAS on
                               a CL read or write will be blocked unless
                               cmd_block_rcas is also set
                            */
    UINT32 cmd_block_wcas_pre : 2;

                            /* Bits[13:12], Access Type=RW, default=0x00000000*/

                            /*
                               If configured blocks Write CAS w/AutoPrecharge
                               when triggered. This doesn't includes CAS, for
                               HBM2 in closed-page mode, only the second CAS on
                               a CL read or write will be blocked unless
                               cmd_block_wcas is also set
                            */
    UINT32 rsvd : 10;

                            /* Bits[23:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cmd_par_inj_trigger : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               If configured causes a parity injection based on
                               the cmd_par masks
                            */
    UINT32 rsvd_26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_CMD_OPCODE_DEBUG_MCDDC_CTL_STRUCT;

/* SCHEDULER_CMD_STARVATION_MCDDC_CTL_REG supported on:                         */
/*      SPRA0 (0x20021b80)                                                      */
/*      SPRB0 (0x20021b80)                                                      */
/*      SPRHBM (0x20021b80)                                                     */
/*      SPRC0 (0x20021b80)                                                      */
/*      SPRMCC (0x20021b80)                                                     */
/*      SPRUCC (0x20021b80)                                                     */
/* Register default value on SPRA0: 0x000F0F31                                  */
/* Register default value on SPRB0: 0x000F0F31                                  */
/* Register default value on SPRHBM: 0x000F0F31                                 */
/* Register default value on SPRC0: 0x000F0F31                                  */
/* Register default value on SPRMCC: 0x000F0F31                                 */
/* Register default value on SPRUCC: 0x000F0F31                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Bank Scheduler Command Starvation
*/


#define SCHEDULER_CMD_STARVATION_MCDDC_CTL_REG 0x0B021B80

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 starved_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Enable Bank Scheduler promotion of transaction
                               to Starved. non-critical to critical and
                               critical to starved
                            */
    UINT32 rsvd : 3;

                            /* Bits[3:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 granularity : 2;

                            /* Bits[5:4], Access Type=RW, default=0x00000003*/

                            /*
                               Granularity selection that defines the heartbeat
                               duration in HCLKs: 0=8, 1=16, 2=32, 3=64
                            */
    UINT32 rsvd_6 : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 critical_count : 4;

                            /* Bits[11:8], Access Type=RW, default=0x0000000F*/

                            /*
                               Number of heartbeats needed to transpire before
                               promoting a pending non-critical to critical
                            */
    UINT32 rsvd_12 : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 starved_count : 4;

                            /* Bits[19:16], Access Type=RW, default=0x0000000F*/

                            /*
                               Number of heartbeats needed to transpire before
                               promoting a pending critical to starved
                            */
    UINT32 rsvd_20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_CMD_STARVATION_MCDDC_CTL_STRUCT;

/* SCHEDULER_IDLETIME2_MCDDC_CTL_REG supported on:                              */
/*      SPRA0 (0x20021b84)                                                      */
/*      SPRB0 (0x20021b84)                                                      */
/*      SPRHBM (0x20021b84)                                                     */
/*      SPRC0 (0x20021b84)                                                      */
/*      SPRMCC (0x20021b84)                                                     */
/*      SPRUCC (0x20021b84)                                                     */
/* Register default value on SPRA0: 0xA00C0040                                  */
/* Register default value on SPRB0: 0xA00C0040                                  */
/* Register default value on SPRHBM: 0xA00C0040                                 */
/* Register default value on SPRC0: 0xA00C0040                                  */
/* Register default value on SPRMCC: 0xA00C0040                                 */
/* Register default value on SPRUCC: 0xA00C0040                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* At a high level, the goal of any page closing policy is to trade off some Premature Page Closes (PPCs) in order to avoid more Overdue Page Closes (OPCs).  In other words, we want to avoid costly Page Misses and turn them into Page Empties at the expense of occasionally missing a Page Hit and instead getting a Page Empty.  The scheme achieves this by tracking the number of PPCs and OPCs over a certain configurable window (of requests).  It then compares the two values to configurable thresholds, and adjusts the amount of time before closing pages accordingly.
*/


#define SCHEDULER_IDLETIME2_MCDDC_CTL_REG 0x0B021B84

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 win_size : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000040*/

                            /*
                               Window Size (WS): The number of requests that we
                               track before making a decision to adapt the RV.
                            */
    UINT32 idle_page_rst_val : 12;

                            /* Bits[27:16], Access Type=RW, default=0x0000000C*/

                            /*
                               Idle Counter Reset Value (RV) in DCLKs: This is
                               the value that effectively adapts. It determines
                               what value the various ICs are set to whenever
                               they are reset. It therefore controls the number
                               of cycles before an automatic page close is
                               triggered for an entire channel. Note that in
                               current implementation, the power up value of
                               0xc is in HCLKs and the value programmed into
                               this field after that is in DCLKs
                            */
    UINT32 rsvd : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 opp_pg_en : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               If enabled (1), idle_timer works normally and
                               its expiration causes precharges to close pages
                               which have been idle for some time. If disabled
                               (0), idle_timer is disabled and will never
                               expire. This is a debug mode.
                            */
    UINT32 idle_page_max_limit_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               If enabled (set to 1), limits maximum adaptive
                               value of the idle_page_timer reset value to 0x7f
                               HCLKs (0xFF DCLKs), This requires
                               idle_page_rst_val to be programmed to <=0x7f
                               HCLKs (<=0xFF DCLKs) If disabled (cleared to 0),
                               maximum adaptive value of the idle_page_timer
                               reset value is 0xFFF HCLKs
                            */
    UINT32 adapt_pg_clse : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               This register is programmed in conjunction with
                               MCMTR.CLOSE_PG and opp_pg_en to enable the
                               following modes: Closed Page Mode:
                               MCMTR.CLOSE_PG = 1 and ADAPT_PG_CLSE= x and
                               opp_pg_en=x. Open Page Mode: - Adaptive idle
                               timer= MCMTR.CLOSE_PG = 0 and ADAPT_PG_CLSE= 1
                               and opp_pg_en=1. - Static idle timer =
                               MCMTR.CLOSE_PG = 0 and ADAPT_PG_CLSE= 0 and
                               opp_pg_en=1. - Disable idle timer =
                               MCMTR.CLOSE_PG = 0 and ADAPT_PG_CLSE= x and
                               opp_pg_en=0.
                            */

  } Bits;
  UINT32 Data;

} SCHEDULER_IDLETIME2_MCDDC_CTL_STRUCT;

/* SCHEDULER_IDLETIME_MCDDC_CTL_REG supported on:                               */
/*      SPRA0 (0x20021b88)                                                      */
/*      SPRB0 (0x20021b88)                                                      */
/*      SPRHBM (0x20021b88)                                                     */
/*      SPRC0 (0x20021b88)                                                      */
/*      SPRMCC (0x20021b88)                                                     */
/*      SPRUCC (0x20021b88)                                                     */
/* Register default value on SPRA0: 0x00060006                                  */
/* Register default value on SPRB0: 0x00060006                                  */
/* Register default value on SPRHBM: 0x00060006                                 */
/* Register default value on SPRC0: 0x00060006                                  */
/* Register default value on SPRMCC: 0x00060006                                 */
/* Register default value on SPRUCC: 0x00060006                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* At a high level, the goal of any page closing policy is to trade off some Premature Page Closes (PPCs) in order to avoid more Overdue Page Closes (OPCs).  In other words, we want to avoid costly Page Misses and turn them into Page Empties at the expense of occasionally missing a Page Hit and instead getting a Page Empty.  The scheme achieves this by tracking the number of PPCs and OPCs over a certain configurable window (of requests).  It then compares the two values to configurable thresholds, and adjusts the amount of time before closing pages accordingly.
*/


#define SCHEDULER_IDLETIME_MCDDC_CTL_REG 0x0B021B88

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ppc_th : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000006*/

                            /*
                               Premature Page Close (PPC) Threshold If the
                               number of PPCs in a given window is larger than
                               this threshold, we increase the RV
                            */
    UINT32 opc_th : 16;

                            /* Bits[31:16], Access Type=RW, default=0x00000006*/

                            /*
                               Overdue Page Close (OPC) Threshold If the number
                               of OPCs in a given window is larger than this
                               threshold, we decrease the RV.
                            */

  } Bits;
  UINT32 Data;

} SCHEDULER_IDLETIME_MCDDC_CTL_STRUCT;

/* SCHEDULER_PREEMPTION_MCDDC_CTL_REG supported on:                             */
/*      SPRA0 (0x20021b8c)                                                      */
/*      SPRB0 (0x20021b8c)                                                      */
/*      SPRHBM (0x20021b8c)                                                     */
/*      SPRC0 (0x20021b8c)                                                      */
/*      SPRMCC (0x20021b8c)                                                     */
/*      SPRUCC (0x20021b8c)                                                     */
/* Register default value on SPRA0: 0x1C1C0105                                  */
/* Register default value on SPRB0: 0x1C1C0105                                  */
/* Register default value on SPRHBM: 0x1C1C0105                                 */
/* Register default value on SPRC0: 0x1C1C0105                                  */
/* Register default value on SPRMCC: 0x1C1C0105                                 */
/* Register default value on SPRUCC: 0x1C1C0105                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Bank Scheduler Preemption Configuration
*/


#define SCHEDULER_PREEMPTION_MCDDC_CTL_REG 0x0B021B8C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rdb_preempt_watermark : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000005*/

                            /*
                               Watermark value when available read data buffer
                               (RDB) falls below the value, i.e. preempt = free
                               count < watermark. Reserved entries reserved for
                               underfill, VC0, VC1, VC2, VC3 and loopback.
                            */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 enable_rdb_preemption : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Enable RDB Preemption - When the RDB credits are
                               unavailable, allow a write transaction to
                               preempt a read while in write major-mode. Should
                               always be enabled and is influenced by the
                               rdb_preempt_watermark.
                            */
    UINT32 enable_refresh_preemption : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Enable Refresh Preemption - preempt transaction
                               if bank-scheduler is blocked by refresh. Enable
                               on HBM2 8H or DDR4 configurations with more than
                               2 ranks.
                            */
    UINT32 enable_omm_hit_preemption : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Enable Opposing Mode Preemption on page-table
                               hit after a major-mode switch.
                            */
    UINT32 enable_omm_miss_preemption : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Enable Opposing Mode Preemption on page-table
                               miss or empty after a major-mode switch.
                            */
    UINT32 enable_rmm_write_preemption : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Enable Write Preemption in RMM when
                               rpq_preempt_watermark condition is met
                            */
    UINT32 enable_wmm_read_preemption : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Enable Read Preemption in WMM when
                               wpq_preempt_watermark condition is met
                            */
    UINT32 enable_critical_preemption : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Enable Critical Preemption - a critical
                               transaction can preempt the target bank-
                               scheduler if transaction is not critical
                            */
    UINT32 enable_critical_promotion : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Enable Critical Promotion - a critical
                               transaction can promote the target bank-
                               scheduler's page-hit transaction to critical. If
                               the transaction in the bank-scheduler is a page
                               miss or page empty it can be preempted.
                               enable_critical_preemption should be set
                            */
    UINT32 wpq_preempt_watermark : 6;

                            /* Bits[21:16], Access Type=RW, default=0x0000001C*/

                            /*
                               Watermark value when available write pending
                               queue (WPQ) falls below the value, i.e. preempt
                               = occupancy > watermark. Watermark needs to be
                               below the number of enabled pending queue
                               entries.
                            */
    UINT32 rsvd_22 : 2;

                            /* Bits[23:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rpq_preempt_watermark : 6;

                            /* Bits[29:24], Access Type=RW, default=0x0000001C*/

                            /*
                               Watermark value when available read pending
                               queue (RPQ) falls above the value, i.e. preempt
                               = occupancy > watermark. Watermark needs to be
                               below the number of enabled pending queue
                               entries.
                            */
    UINT32 rsvd_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 enable_omm_hit_promotion : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Enable Opposing Mode critical Promotion on page-
                               table hit after a major-mode switch. When this
                               is set it will override
                               enable_omm_hit_preemption.
                            */

  } Bits;
  UINT32 Data;

} SCHEDULER_PREEMPTION_MCDDC_CTL_STRUCT;

/* SCHEDULER_RID_ENTRY_MCDDC_CTL_REG supported on:                              */
/*      SPRA0 (0x20021b90)                                                      */
/*      SPRB0 (0x20021b90)                                                      */
/*      SPRHBM (0x20021b90)                                                     */
/*      SPRC0 (0x20021b90)                                                      */
/*      SPRMCC (0x20021b90)                                                     */
/*      SPRUCC (0x20021b90)                                                     */
/* Register default value on SPRA0: 0x2D5AD2F3                                  */
/* Register default value on SPRB0: 0x2D5AD2F3                                  */
/* Register default value on SPRHBM: 0x2D5AD2F3                                 */
/* Register default value on SPRC0: 0x2D5AD2F3                                  */
/* Register default value on SPRMCC: 0x2D5AD2F3                                 */
/* Register default value on SPRUCC: 0x2D5AD2F3                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Configuration register
*/


#define SCHEDULER_RID_ENTRY_MCDDC_CTL_REG 0x0B021B90

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rid_loopback_entry : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000013*/

                            /*
                               Reserved IOT loopback write entry number in RDB;
                               only used if the corresponding enable bit is set
                               in scheduler_rid.enable_rid_loopback; default
                               value is 19; only expected to be used in debug
                               mode
                            */
    UINT32 rid_underfill_entry : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000017*/

                            /*
                               Reserved underfill read number in RDB; only used
                               if the corresponding enable bit is set in
                               scheduler_rid.enable_rid_underfill; default
                               value is 23; also used for DDRT starve cases
                            */
    UINT32 rid_vc0_entry : 5;

                            /* Bits[14:10], Access Type=RW, default=0x00000014*/

                            /*
                               Reserved VC0 entry number in RDB; only used if
                               the corresponding enable bit is set in
                               scheduler_rid.enable_rid_vc0; default value is
                               20
                            */
    UINT32 rid_vc1_entry : 5;

                            /* Bits[19:15], Access Type=RW, default=0x00000015*/

                            /*
                               Reserved VC1 entry number in RDB; only used if
                               the corresponding enable bit is set in
                               scheduler_rid.enable_rid_vc1; default value is
                               21; VC1 and VC2 are not expected to be enabled
                               at the same time
                            */
    UINT32 rid_vc2_entry : 5;

                            /* Bits[24:20], Access Type=RW, default=0x00000015*/

                            /*
                               Reserved VC2 entry number in RDB; only used if
                               the corresponding enable bit is set in
                               scheduler_rid.enable_rid_vc2; default value is
                               21; VC1 and VC2 are not expected to be enabled
                               at the same time
                            */
    UINT32 rid_vc3_entry : 5;

                            /* Bits[29:25], Access Type=RW, default=0x00000016*/

                            /*
                               Reserved VC3 entry number in RDB; only used if
                               the corresponding enable bit is set in
                               scheduler_rid.enable_rid_vc3; default value is
                               22
                            */
    UINT32 enable_rid_loopback : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Enable bit for reserved IOT loopback entry in
                               RDB; the corresponding entry number is set in
                               scheduler_rid_entry.rid_loopback_entry
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_RID_ENTRY_MCDDC_CTL_STRUCT;

/* SCHEDULER_RID_STATUS_MCDDC_CTL_REG supported on:                             */
/*      SPRA0 (0x20021b94)                                                      */
/*      SPRB0 (0x20021b94)                                                      */
/*      SPRHBM (0x20021b94)                                                     */
/*      SPRC0 (0x20021b94)                                                      */
/*      SPRMCC (0x20021b94)                                                     */
/*      SPRUCC (0x20021b94)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Free RID register
*/


#define SCHEDULER_RID_STATUS_MCDDC_CTL_REG 0x0B021B94

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 free_rid : 24;

                            /* Bits[23:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Indication which RDB entry is free; 1 bit per
                               entry.
                            */
    UINT32 rsvd : 7;

                            /* Bits[30:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rid_monitor_selection : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Select which RDB to monitor. DDR: 0; HBM2E:0 or
                               1 for PCH/DP 0 or PCH/DP 1
                            */

  } Bits;
  UINT32 Data;

} SCHEDULER_RID_STATUS_MCDDC_CTL_STRUCT;

/* SCHEDULER_RID_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20021b98)                                                      */
/*      SPRB0 (0x20021b98)                                                      */
/*      SPRHBM (0x20021b98)                                                     */
/*      SPRC0 (0x20021b98)                                                      */
/*      SPRMCC (0x20021b98)                                                     */
/*      SPRUCC (0x20021b98)                                                     */
/* Register default value on SPRA0: 0x7BFFFFFF                                  */
/* Register default value on SPRB0: 0x7BFFFFFF                                  */
/* Register default value on SPRHBM: 0x7BFFFFFF                                 */
/* Register default value on SPRC0: 0x7BFFFFFF                                  */
/* Register default value on SPRMCC: 0x7BFFFFFF                                 */
/* Register default value on SPRUCC: 0x7BFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Configuration register
*/


#define SCHEDULER_RID_MCDDC_CTL_REG 0x0B021B98

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 enable_rid : 24;

                            /* Bits[23:0], Access Type=RW, default=0x00FFFFFF*/

                            /* Enable bit for each RDB entry. */
    UINT32 enable_rid_underfill : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000001*/

                            /*
                               Enable bit for reserved underfill read entry in
                               RDB; the corresponding entry number is set in
                               scheduler_rid_entry.rid_underfill_entry
                            */
    UINT32 enable_rid_vc0 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000001*/

                            /*
                               Enable bit for reserved VC0 entry in RDB; the
                               corresponding entry number is set in
                               scheduler_rid_entry.rid_vc0_entry
                            */
    UINT32 enable_rid_vc1 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Enable bit for reserved VC1 entry in RDB; the
                               corresponding entry number is set in
                               scheduler_rid_entry.rid_vc1_entry
                            */
    UINT32 enable_rid_vc2 : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000001*/

                            /*
                               Enable bit for reserved VC2 entry in RDB; the
                               corresponding entry number is set in
                               scheduler_rid_entry.rid_vc2_entry
                            */
    UINT32 enable_rid_vc3 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000001*/

                            /*
                               Enable bit for reserved VC3 entry in RDB; the
                               corresponding entry number is set in
                               scheduler_rid_entry.rid_vc3_entry
                            */
    UINT32 rid_vc2_low_threshold : 3;

                            /* Bits[31:29], Access Type=RW, default=0x00000003*/

                            /*
                               Low threshold for DDRT (VC2) RDB credits. If the
                               number of RDB credits (unreserved + reserved)
                               falls below this value then DDRT GNTs are
                               scheduled with an additional 4 dclk delay over
                               the programmed CMD2GNT.
                            */

  } Bits;
  UINT32 Data;

} SCHEDULER_RID_MCDDC_CTL_STRUCT;

/* SREF_LL0_MCDDC_CTL_REG supported on:                                         */
/*      SPRA0 (0x20021b9c)                                                      */
/*      SPRB0 (0x20021b9c)                                                      */
/*      SPRHBM (0x20021b9c)                                                     */
/*      SPRC0 (0x20021b9c)                                                      */
/*      SPRMCC (0x20021b9c)                                                     */
/*      SPRUCC (0x20021b9c)                                                     */
/* Register default value on SPRA0: 0x080FFFFF                                  */
/* Register default value on SPRB0: 0x080FFFFF                                  */
/* Register default value on SPRHBM: 0x080FFFFF                                 */
/* Register default value on SPRC0: 0x080FFFFF                                  */
/* Register default value on SPRMCC: 0x080FFFFF                                 */
/* Register default value on SPRUCC: 0x080FFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  Self Refresh controls at Load Line point 0.  Used when PMLink PowerModeSelect[1][0]=00 
*/


#define SREF_LL0_MCDDC_CTL_REG 0x0B021B9C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sref_idle_timer : 20;

                            /* Bits[19:0], Access Type=RW/P, default=0x000FFFFF*/

                            /*
                               This field defines the rank idle period that
                               causes self-refresh entrance. This value is used
                               when the SREF_EN field is set. It defines the
                               number of idle cycles (in DCLKs) after the
                               command issue that there should not be any
                               transaction in order to enter self-refresh for
                               DDR4 DIMMs or PM Idle for DDR-T DIMMs. It is
                               programmable 1 to 1M-1 dynamically. FFFFEh is a
                               reserved value and should not be used in normal
                               operation. The min setting needs to allow for a
                               refresh, a zqcal, a retry read, and a handfull
                               of cycles for Mesh2Mem to issue a demand scrub
                               write: TCZQCAL.T_ZQCS + TCRFTP.T_RFC + 100
                               decimal. In reality, the idle counter should be
                               much larger in order avoid unnecessary SRE+SRX
                               overhead. This register field can be updated
                               dynamically.
                            */
    UINT32 opp_sref_en : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit enables opportunistic Self
                               Refresh entry based on the SREF_IDLE_TIMER
                               expiration. FORCE_SR and AsyncSR are other
                               sources of SR entry independent of the setting
                               of SREF_EN. When 0, Opportunistic SR Entry is
                               disabled and SR can only be entered on
                               Force_SR_Entry assertion or AsyncSR. A write to
                               this register must be respected by iMC. If iMC
                               has entered self-refresh opportunistically, it
                               must return to the state specified by this
                               register. PCU however needs to ensure that
                               modifications happen only under legal
                               conditions. For example clocks must be available
                               before asking iMC to return to DLL on and SR
                               exit state.
                            */
    UINT32 rsvd : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mdll_off_en : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               When 0 Master DLLs (MDLL) cannot be turned off.
                               When 1 MDLLs can be turned off in Self Refresh.
                               A write to this register must be respected by
                               IMC. If IMC is already in a deeper state, it
                               must return to the state specified by this
                               register. PCU however needs to ensure that the
                               modifications happen only under legal
                               conditions. For example clocks must be
                               available, before asking MC to return to MDLL on
                               and SR exit state.
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ck_mode : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               The field defines how CK and CK# are turned off
                               during Self Refresh: CK_MODE=00, CK_ON: In this
                               mode CK continues to be driven during self-
                               refresh. CK_MODE=01 is not supported.
                               CK_MODE=10, CK_PULL_LOW_MODE: after tCKEoff
                               timing delay from SRE CKE de-assertion, IMC wait
                               for tCKoff before dropping CK-ALIGN and
                               CK#-ALIGN (internal signal to DDRIO) to LOW
                               thoughout the self-refresh. CK_MODE=11 is not
                               supported. CKE tri-state is under separate
                               control in DDRIO. All other signals (except
                               DDR_RESET#) are tri-stated after tCKEv delay. A
                               write to this register must be respected by iMC.
                               If iMC is already in a deeper state, it must
                               return to the state specified by this register.
                               PCU however needs to ensure that the
                               modifications happen only under legal
                               conditions. For example clocks must be
                               available, before asking MC to return to DLL on
                               and SR exit state. Note: CK_MODE defines whether
                               CK is turn off during any self-refresh; however,
                               it does not control how CK is turn off based on
                               the RDIMM/UDIMM configuration.
                            */
    UINT32 ddrt_idle_cmd : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000002*/

                            /*
                               Bits to send as part of the DDR-T PM Idle
                               command to indicate the specific command to be
                               executed. Encoding is as per the DDR-T spec.
                            */
    UINT32 reserved : 4;

                            /* Bits[31:28], Access Type=RW, default=0x00000000*/

                            /* Reserved for future use. */

  } Bits;
  UINT32 Data;

} SREF_LL0_MCDDC_CTL_STRUCT;

/* SREF_LL1_MCDDC_CTL_REG supported on:                                         */
/*      SPRA0 (0x20021ba0)                                                      */
/*      SPRB0 (0x20021ba0)                                                      */
/*      SPRHBM (0x20021ba0)                                                     */
/*      SPRC0 (0x20021ba0)                                                      */
/*      SPRMCC (0x20021ba0)                                                     */
/*      SPRUCC (0x20021ba0)                                                     */
/* Register default value on SPRA0: 0x000FFFFF                                  */
/* Register default value on SPRB0: 0x000FFFFF                                  */
/* Register default value on SPRHBM: 0x000FFFFF                                 */
/* Register default value on SPRC0: 0x000FFFFF                                  */
/* Register default value on SPRMCC: 0x000FFFFF                                 */
/* Register default value on SPRUCC: 0x000FFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  Self Refresh controls at Load Line point 1.  Used when PMLink signal PowerModeSelect[1][0]=01 
*/


#define SREF_LL1_MCDDC_CTL_REG 0x0B021BA0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sref_idle_timer : 20;

                            /* Bits[19:0], Access Type=RW/P, default=0x000FFFFF*/

                            /*
                               This field defines the rank idle period that
                               causes self-refresh entrance. This value is used
                               when the SREF_EN field is set. It defines the
                               number of idle cycles (in DCLKs) after the
                               command issue that there should not be any
                               transaction in order to enter self-refresh for
                               DDR4 DIMMs or PM Idle for DDR-T DIMMs. It is
                               programmable 1 to 1M-1 dynamically. FFFFEh is a
                               reserved value and should not be used in normal
                               operation. The min setting needs to allow for a
                               refresh, a zqcal, a retry read, and a handfull
                               of cycles for Mesh2Mem to issue a demand scrub
                               write: TCZQCAL.T_ZQCS + TCRFTP.T_RFC + 100
                               decimal. In reality, the idle counter should be
                               much larger in order avoid unnecessary SRE+SRX
                               overhead. This register field can be updated
                               dynamically.
                            */
    UINT32 opp_sref_en : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit enables opportunistic Self
                               Refresh entry based on the SREF_IDLE_TIMER
                               expiration. FORCE_SR and AsyncSR are other
                               sources of SR entry independent of the setting
                               of SREF_EN. When 0, Opportunistic SR Entry is
                               disabled and SR can only be entered on
                               Force_SR_Entry assertion or AsyncSR. A write to
                               this register must be respected by iMC. If iMC
                               has entered self-refresh opportunistically, it
                               must return to the state specified by this
                               register. PCU however needs to ensure that
                               modifications happen only under legal
                               conditions. For example clocks must be available
                               before asking iMC to return to DLL on and SR
                               exit state.
                            */
    UINT32 rsvd : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mdll_off_en : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               When 0 Master DLLs (MDLL) cannot be turned off.
                               When 1 MDLLs can be turned off in Self Refresh.
                               A write to this register must be respected by
                               IMC. If IMC is already in a deeper state, it
                               must return to the state specified by this
                               register. PCU however needs to ensure that the
                               modifications happen only under legal
                               conditions. For example clocks must be
                               available, before asking MC to return to MDLL on
                               and SR exit state.
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ck_mode : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               The field defines how CK and CK# are turned off
                               during Self Refresh: CK_MODE=00, CK_ON: In this
                               mode CK continues to be driven during self-
                               refresh. CK_NODE=01 is not supported CK_MODE=10,
                               CK_PULL_LOW_MODE: after tCKEoff timing delay
                               from SRE CKE de-assertion, IMC wait for tCKoff
                               before dropping CK-ALIGN and CK#-ALIGN (internal
                               signal to DDRIO) to LOW thoughout the self-
                               refresh. CK_NODE=11 is not supported CKE tri-
                               state is under separate control in DDRIO. All
                               other signals (except DDR_RESET#) are tri-stated
                               after tCKEv delay. A write to this register must
                               be respected by iMC. If iMC is already in a
                               deeper state, it must return to the state
                               specified by this register. PCU however needs to
                               ensure that the modifications happen only under
                               legal conditions. For example clocks must be
                               available, before asking MC to return to DLL on
                               and SR exit state. Note: CK_MODE defines whether
                               CK is turn off during any self-refresh; however,
                               it does not control how CK is turn off based on
                               the RDIMM/UDIMM configuration.
                            */
    UINT32 ddrt_idle_cmd : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bits to send as part of the DDR-T PM Idle
                               command to indicate the specific command to be
                               executed. Encoding is as per the DDR-T spec.
                            */
    UINT32 reserved : 4;

                            /* Bits[31:28], Access Type=RW, default=0x00000000*/

                            /* Reserved for future use. */

  } Bits;
  UINT32 Data;

} SREF_LL1_MCDDC_CTL_STRUCT;

/* SREF_LL2_MCDDC_CTL_REG supported on:                                         */
/*      SPRA0 (0x20021ba4)                                                      */
/*      SPRB0 (0x20021ba4)                                                      */
/*      SPRHBM (0x20021ba4)                                                     */
/*      SPRC0 (0x20021ba4)                                                      */
/*      SPRMCC (0x20021ba4)                                                     */
/*      SPRUCC (0x20021ba4)                                                     */
/* Register default value on SPRA0: 0x080FFFFF                                  */
/* Register default value on SPRB0: 0x080FFFFF                                  */
/* Register default value on SPRHBM: 0x080FFFFF                                 */
/* Register default value on SPRC0: 0x080FFFFF                                  */
/* Register default value on SPRMCC: 0x080FFFFF                                 */
/* Register default value on SPRUCC: 0x080FFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  Self Refresh controls at Load Line point 2.  Used when PMLink PowerModeSelect[1][0]=10 
*/


#define SREF_LL2_MCDDC_CTL_REG 0x0B021BA4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sref_idle_timer : 20;

                            /* Bits[19:0], Access Type=RW/P, default=0x000FFFFF*/

                            /*
                               This field defines the rank idle period that
                               causes self-refresh entrance. This value is used
                               when the SREF_EN field is set. It defines the
                               number of idle cycles (in DCLKs) after the
                               command issue that there should not be any
                               transaction in order to enter self-refresh for
                               DDR4 DIMMs or PM Idle for DDR-T DIMMs. It is
                               programmable 1 to 1M-1 dynamically. FFFFEh is a
                               reserved value and should not be used in normal
                               operation. The min setting needs to allow for a
                               refresh, a zqcal, a retry read, and a handfull
                               of cycles for Mesh2Mem to issue a demand scrub
                               write: TCZQCAL.T_ZQCS + TCRFTP.T_RFC + 100
                               decimal. In reality, the idle counter should be
                               much larger in order avoid unnecessary SRE+SRX
                               overhead. This register field can be updated
                               dynamically.
                            */
    UINT32 opp_sref_en : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit enables opportunistic Self
                               Refresh entry based on the SREF_IDLE_TIMER
                               expiration. FORCE_SR and AsyncSR are other
                               sources of SR entry independent of the setting
                               of SREF_EN. When 0, Opportunistic SR Entry is
                               disabled and SR can only be entered on
                               Force_SR_Entry assertion or AsyncSR. A write to
                               this register must be respected by iMC. If iMC
                               has entered self-refresh opportunistically, it
                               must return to the state specified by this
                               register. PCU however needs to ensure that
                               modifications happen only under legal
                               conditions. For example clocks must be available
                               before asking iMC to return to DLL on and SR
                               exit state.
                            */
    UINT32 rsvd : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mdll_off_en : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               When 0 Master DLLs (MDLL) cannot be turned off.
                               When 1 MDLLs can be turned off in Self Refresh.
                               A write to this register must be respected by
                               IMC. If IMC is already in a deeper state, it
                               must return to the state specified by this
                               register. PCU however needs to ensure that the
                               modifications happen only under legal
                               conditions. For example clocks must be
                               available, before asking MC to return to MDLL on
                               and SR exit state.
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ck_mode : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               The field defines how CK and CK# are turned off
                               during Self Refresh: CK_MODE=00, CK_ON: In this
                               mode CK continues to be driven during self-
                               refresh. CK_NODE=01 is not supported CK_MODE=10,
                               CK_PULL_LOW_MODE: after tCKEoff timing delay
                               from SRE CKE de-assertion, IMC wait for tCKoff
                               before dropping CK-ALIGN and CK#-ALIGN (internal
                               signal to DDRIO) to LOW thoughout the self-
                               refresh. CK_NODE=11 is not supported CKE tri-
                               state is under separate control in DDRIO. All
                               other signals (except DDR_RESET#) are tri-stated
                               after tCKEv delay. A write to this register must
                               be respected by iMC. If iMC is already in a
                               deeper state, it must return to the state
                               specified by this register. PCU however needs to
                               ensure that the modifications happen only under
                               legal conditions. For example clocks must be
                               available, before asking MC to return to DLL on
                               and SR exit state. Note: CK_MODE defines whether
                               CK is turn off during any self-refresh; however,
                               it does not control how CK is turn off based on
                               the RDIMM/UDIMM configuration.
                            */
    UINT32 ddrt_idle_cmd : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000002*/

                            /*
                               Bits to send as part of the DDR-T PM Idle
                               command to indicate the specific command to be
                               executed. Encoding is as per the DDR-T spec.
                            */
    UINT32 reserved : 4;

                            /* Bits[31:28], Access Type=RW, default=0x00000000*/

                            /* Reserved for future use. */

  } Bits;
  UINT32 Data;

} SREF_LL2_MCDDC_CTL_STRUCT;

/* SREF_LL3_MCDDC_CTL_REG supported on:                                         */
/*      SPRA0 (0x20021ba8)                                                      */
/*      SPRB0 (0x20021ba8)                                                      */
/*      SPRHBM (0x20021ba8)                                                     */
/*      SPRC0 (0x20021ba8)                                                      */
/*      SPRMCC (0x20021ba8)                                                     */
/*      SPRUCC (0x20021ba8)                                                     */
/* Register default value on SPRA0: 0x080FFFFF                                  */
/* Register default value on SPRB0: 0x080FFFFF                                  */
/* Register default value on SPRHBM: 0x080FFFFF                                 */
/* Register default value on SPRC0: 0x080FFFFF                                  */
/* Register default value on SPRMCC: 0x080FFFFF                                 */
/* Register default value on SPRUCC: 0x080FFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  Self Refresh controls at Load Line point 3.  Used when PMLink PowerModeSelect[1][0]=11 
*/


#define SREF_LL3_MCDDC_CTL_REG 0x0B021BA8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sref_idle_timer : 20;

                            /* Bits[19:0], Access Type=RW/P, default=0x000FFFFF*/

                            /*
                               This field defines the rank idle period that
                               causes self-refresh entrance. This value is used
                               when the SREF_EN field is set. It defines the
                               number of idle cycles (in DCLKs) after the
                               command issue that there should not be any
                               transaction in order to enter self-refresh for
                               DDR4 DIMMs or PM Idle for DDR-T DIMMs. It is
                               programmable 1 to 1M-1 dynamically. FFFFEh is a
                               reserved value and should not be used in normal
                               operation. The min setting needs to allow for a
                               refresh, a zqcal, a retry read, and a handfull
                               of cycles for Mesh2Mem to issue a demand scrub
                               write: TCZQCAL.T_ZQCS + TCRFTP.T_RFC + 100
                               decimal. In reality, the idle counter should be
                               much larger in order avoid unnecessary SRE+SRX
                               overhead. This register field can be updated
                               dynamically.
                            */
    UINT32 opp_sref_en : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               When set, this bit enables opportunistic Self
                               Refresh entry based on the SREF_IDLE_TIMER
                               expiration. FORCE_SR and AsyncSR are other
                               sources of SR entry independent of the setting
                               of SREF_EN. When 0, Opportunistic SR Entry is
                               disabled and SR can only be entered on
                               Force_SR_Entry assertion or AsyncSR. A write to
                               this register must be respected by iMC. If iMC
                               has entered self-refresh opportunistically, it
                               must return to the state specified by this
                               register. PCU however needs to ensure that
                               modifications happen only under legal
                               conditions. For example clocks must be available
                               before asking iMC to return to DLL on and SR
                               exit state.
                            */
    UINT32 rsvd : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mdll_off_en : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               When 0 Master DLLs (MDLL) cannot be turned off.
                               When 1 MDLLs can be turned off in Self Refresh.
                               A write to this register must be respected by
                               IMC. If IMC is already in a deeper state, it
                               must return to the state specified by this
                               register. PCU however needs to ensure that the
                               modifications happen only under legal
                               conditions. For example clocks must be
                               available, before asking MC to return to MDLL on
                               and SR exit state.
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ck_mode : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               The field defines how CK and CK# are turned off
                               during Self Refresh: CK_MODE=00, CK_ON: In this
                               mode CK continues to be driven during self-
                               refresh. CK_NODE=01 is not supported CK_MODE=10,
                               CK_PULL_LOW_MODE: after tCKEoff timing delay
                               from SRE CKE de-assertion, IMC wait for tCKoff
                               before dropping CK-ALIGN and CK#-ALIGN (internal
                               signal to DDRIO) to LOW thoughout the self-
                               refresh. CK_NODE=11 is not supported CKE tri-
                               state is under separate control in DDRIO. All
                               other signals (except DDR_RESET#) are tri-stated
                               after tCKEv delay. A write to this register must
                               be respected by iMC. If iMC is already in a
                               deeper state, it must return to the state
                               specified by this register. PCU however needs to
                               ensure that the modifications happen only under
                               legal conditions. For example clocks must be
                               available, before asking MC to return to DLL on
                               and SR exit state. Note: CK_MODE defines whether
                               CK is turn off during any self-refresh; however,
                               it does not control how CK is turn off based on
                               the RDIMM/UDIMM configuration.
                            */
    UINT32 ddrt_idle_cmd : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000002*/

                            /*
                               Bits to send as part of the DDR-T PM Idle
                               command to indicate the specific command to be
                               executed. Encoding is as per the DDR-T spec.
                            */
    UINT32 reserved : 4;

                            /* Bits[31:28], Access Type=RW, default=0x00000000*/

                            /* Reserved for future use. */

  } Bits;
  UINT32 Data;

} SREF_LL3_MCDDC_CTL_STRUCT;

/* SREF_PKGC_MCDDC_CTL_REG supported on:                                        */
/*      SPRA0 (0x20021bac)                                                      */
/*      SPRB0 (0x20021bac)                                                      */
/*      SPRHBM (0x20021bac)                                                     */
/*      SPRC0 (0x20021bac)                                                      */
/*      SPRMCC (0x20021bac)                                                     */
/*      SPRUCC (0x20021bac)                                                     */
/* Register default value on SPRA0: 0x0800000F                                  */
/* Register default value on SPRB0: 0x0800000F                                  */
/* Register default value on SPRHBM: 0x0800000F                                 */
/* Register default value on SPRC0: 0x0800000F                                  */
/* Register default value on SPRMCC: 0x0800000F                                 */
/* Register default value on SPRUCC: 0x0800000F                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  Self Refresh controls in PkgC.  Used when PCU/PMLink has asserted Force_SR_Enter and Force_SR_Exit.  Overrides equivalent fields in SREF_LL0 and SREF_LL1. 
*/


#define SREF_PKGC_MCDDC_CTL_REG 0x0B021BAC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sref_idle_timer : 20;

                            /* Bits[19:0], Access Type=RW/P, default=0x0000000F*/

                            /*
                               This field defines the rank idle period that
                               causes self-refresh entrance. This value is used
                               when the SREF_EN field is set. It defines the
                               number of idle cycles (in DCLKs) after the
                               command issue that there should not be any
                               transaction in order to enter self-refresh for
                               DDR4 DIMMs or PM Idle for DDR-T DIMMs. It is
                               programmable 1 to 1M-1 dynamically. FFFFEh is a
                               reserved value and should not be used in normal
                               operation. The min setting needs to allow for a
                               refresh, a zqcal, a retry read, and a handfull
                               of cycles for Mesh2Mem to issue a demand scrub
                               write: TCZQCAL.T_ZQCS + TCRFTP.T_RFC + 100
                               decimal. In reality, the idle counter should be
                               much larger in order avoid unnecessary SRE+SRX
                               overhead. This register field can be updated
                               dynamically.
                            */
    UINT32 opp_sref_en : 1;

                            /* Bits[20:20], Access Type=RO, default=0x00000000*/

                            /*
                               When set, this bit enables opportunistic Self
                               Refresh entry based on the SREF_IDLE_TIMER
                               expiration. FORCE_SR and AsyncSR are other
                               sources of SR entry independent of the setting
                               of SREF_EN. When 0, Opportunistic SR Entry is
                               disabled and SR can only be entered on
                               Force_SR_Entry assertion or AsyncSR. A write to
                               this register must be respected by iMC. If iMC
                               has entered self-refresh opportunistically, it
                               must return to the state specified by this
                               register. PCU however needs to ensure that
                               modifications happen only under legal
                               conditions. For example clocks must be available
                               before asking iMC to return to DLL on and SR
                               exit state.
                            */
    UINT32 rsvd : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mdll_off_en : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               When 0 Master DLLs (MDLL) cannot be turned off.
                               When 1 MDLLs can be turned off in Self Refresh.
                               A write to this register must be respected by
                               IMC. If IMC is already in a deeper state, it
                               must return to the state specified by this
                               register. PCU however needs to ensure that the
                               modifications happen only under legal
                               conditions. For example clocks must be
                               available, before asking MC to return to MDLL on
                               and SR exit state.
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ck_mode : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               The field defines how CK and CK# are turned off
                               during Self Refresh: CK_MODE=00, CK_ON: In this
                               mode CK continues to be driven during self-
                               refresh. CK_NODE=01 is not supported CK_MODE=10,
                               CK_PULL_LOW_MODE: after tCKEoff timing delay
                               from SRE CKE de-assertion, IMC wait for tCKoff
                               before dropping CK-ALIGN and CK#-ALIGN (internal
                               signal to DDRIO) to LOW thoughout the self-
                               refresh. CK_NODE=11 is not supported CKE tri-
                               state is under separate control in DDRIO. All
                               other signals (except DDR_RESET#) are tri-stated
                               after tCKEv delay. A write to this register must
                               be respected by iMC. If iMC is already in a
                               deeper state, it must return to the state
                               specified by this register. PCU however needs to
                               ensure that the modifications happen only under
                               legal conditions. For example clocks must be
                               available, before asking MC to return to DLL on
                               and SR exit state. Note: CK_MODE defines whether
                               CK is turn off during any self-refresh; however,
                               it does not control how CK is turn off based on
                               the RDIMM/UDIMM configuration.
                            */
    UINT32 ddrt_idle_cmd : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000002*/

                            /*
                               Bits to send as part of the DDR-T PM Idle
                               command to indicate the specific command to be
                               executed. Encoding is as per the DDR-T spec.
                            */
    UINT32 reserved : 4;

                            /* Bits[31:28], Access Type=RW, default=0x00000000*/

                            /* Reserved for future use. */

  } Bits;
  UINT32 Data;

} SREF_PKGC_MCDDC_CTL_STRUCT;

/* SREF_STATIC2_MCDDC_CTL_REG supported on:                                     */
/*      SPRA0 (0x20021bb0)                                                      */
/*      SPRB0 (0x20021bb0)                                                      */
/*      SPRHBM (0x20021bb0)                                                     */
/*      SPRC0 (0x20021bb0)                                                      */
/*      SPRMCC (0x20021bb0)                                                     */
/*      SPRUCC (0x20021bb0)                                                     */
/* Register default value on SPRA0: 0x30070303                                  */
/* Register default value on SPRB0: 0x30070303                                  */
/* Register default value on SPRHBM: 0x30070303                                 */
/* Register default value on SPRC0: 0x30070303                                  */
/* Register default value on SPRMCC: 0x30070303                                 */
/* Register default value on SPRUCC: 0x30070303                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  Second Control for Self Refresh.  Not impacted by PowerModeSelect signal from PMLink.  
*/


#define SREF_STATIC2_MCDDC_CTL_REG 0x0B021BB0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 idle_cmd_to_cke_drops_timer : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000003*/

                            /*
                               This field defines delay from S Command for SRE
                               enter to chip select assertion. The delay is to
                               ensure that the DDRT controller decodes the
                               S-command before the MC pulls CS. This CSR
                               should cover higher of the round trip latency
                               from command to error assertion (flight time for
                               command, delay in controller to decode command
                               and drive Error and flight time for the Error
                               signal back to the host) or tCPEDED It is
                               expected that the round trip delay will be
                               several clocks higher than tCPEDED
                            */
    UINT32 t_ddrt_cke : 7;

                            /* Bits[14:8], Access Type=RW, default=0x00000003*/

                            /*
                               CKE minimum pulse width (must be at least the
                               larger value of 3 DCLK or 5ns)
                            */
    UINT32 rsvd : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 sre_cmd_to_cke_drops_timer : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000007*/

                            /*
                               This field defines delay from SREnter to CKE low
                               to make sure SREnter command doesnt have parity
                               error. This CSR should cover the round trip
                               latency to decode the command, check for Error
                               and drive the Error signal back to the host.
                            */
    UINT32 rsvd_24 : 3;

                            /* Bits[26:24], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 tcpded : 5;

                            /* Bits[31:27], Access Type=RW, default=0x00000006*/

                            /*
                               This is the tCPDED parameter, only used with
                               DDR5. The value programmed should be tCPDED-2.
                               The DDR5 spec indicates that tCPDED =
                               max(5ns,8nCK). Example: For DDR5-3200,
                               tCK=625ps, so 5ns is 8nCK, so tCPDED = 8nCK and
                               the programmed vallue for this field would be 6.
                            */

  } Bits;
  UINT32 Data;

} SREF_STATIC2_MCDDC_CTL_STRUCT;

/* SREF_STATIC_MCDDC_CTL_REG supported on:                                      */
/*      SPRA0 (0x20021bb4)                                                      */
/*      SPRB0 (0x20021bb4)                                                      */
/*      SPRHBM (0x20021bb4)                                                     */
/*      SPRC0 (0x20021bb4)                                                      */
/*      SPRMCC (0x20021bb4)                                                     */
/*      SPRUCC (0x20021bb4)                                                     */
/* Register default value on SPRA0: 0x403FFFFF                                  */
/* Register default value on SPRB0: 0x403FFFFF                                  */
/* Register default value on SPRHBM: 0x403FFFFF                                 */
/* Register default value on SPRC0: 0x403FFFFF                                  */
/* Register default value on SPRMCC: 0x403FFFFF                                 */
/* Register default value on SPRUCC: 0x403FFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  Control for Self Refresh.  Not impacted by PowerModeSelect signal from PMLink.  
*/


#define SREF_STATIC_MCDDC_CTL_REG 0x0B021BB4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 adr_sref_timer : 5;

                            /* Bits[4:0], Access Type=RW, default=0x0000001F*/

                            /*
                               This field defines number of DCLK of wait time
                               after all pending writes have been drained from
                               WPQ before entering self-refresh.
                            */
    UINT32 ufs_sref_idle_timer : 5;

                            /* Bits[9:5], Access Type=RW/P, default=0x0000001F*/

                            /*
                               This is an idle timer (5-bit) to cover the
                               corner case when Mesh2Mem may have no pending
                               transactions to iMC, but may be preparing to
                               send something to the iMC, but iMC enters SR
                               seeing that it has nothing in its queues. In
                               such a case, MC could potentially enter SR and
                               then exit temporarily and then enter into SR
                               again. This happens primarily because it is hard
                               for Pcode to observe the Mesh2Mem block_ack,
                               since the GV block_ack goes to the hardware and
                               does not generate a fastpath to the Pcode.
                            */
    UINT32 mdll_timer : 12;

                            /* Bits[21:10], Access Type=RW, default=0x00000FFF*/

                            /*
                               Master DLL wake up timer (delay in DCLK). The
                               MDLL lock time after the DLL Enable is issued,
                               approximately 500ns. This field is defaulted to
                               533MHz DCLK initial boot setting. BIOS should
                               reprogram this register for ~500ns equivalent at
                               target speed. Here is the set of the recommended
                               setting for each DCLK speed: DDR Speed Setting
                               ddr4-1600 190h ddr4-1867 1D3h ddr4-2133 258h
                               ddr4-2667 29Ch
                            */
    UINT32 rsvd : 4;

                            /* Bits[25:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddrt_idle_l : 4;

                            /* Bits[29:26], Access Type=RW, default=0x00000000*/

                            /*
                               Bits to send as part of the DDR-T PM Idle
                               command to indicate the exit latency. Encoding
                               is as per the DDR-T spec.
                            */
    UINT32 pkgc_sref_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000001*/

                            /*
                               Defeature to make sure we have a way to not go
                               into Self Refresh during the PkgC flow for
                               survivability.
                            */
    UINT32 reserved : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Reserved for future use. */

  } Bits;
  UINT32 Data;

} SREF_STATIC_MCDDC_CTL_STRUCT;

/* TCKE_MCDDC_CTL_REG supported on:                                             */
/*      SPRA0 (0x20021bb8)                                                      */
/*      SPRB0 (0x20021bb8)                                                      */
/*      SPRHBM (0x20021bb8)                                                     */
/*      SPRC0 (0x20021bb8)                                                      */
/*      SPRMCC (0x20021bb8)                                                     */
/*      SPRUCC (0x20021bb8)                                                     */
/* Register default value on SPRA0: 0x31FFFFFF                                  */
/* Register default value on SPRB0: 0x31FFFFFF                                  */
/* Register default value on SPRHBM: 0x31FFFFFF                                 */
/* Register default value on SPRC0: 0x31FFFFFF                                  */
/* Register default value on SPRMCC: 0x31FFFFFF                                 */
/* Register default value on SPRUCC: 0x31FFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x208
*/


#define TCKE_MCDDC_CTL_REG 0x0B021BB8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_wrpden : 7;

                            /* Bits[6:0], Access Type=RW, default=0x0000007F*/

                            /*
                               tWRPDEN (CASwr to CKE low time): Recommended
                               formula = tCWL + BL/2 + tWR
                            */
    UINT32 t_rdpden : 7;

                            /* Bits[13:7], Access Type=RW, default=0x0000007F*/

                            /*
                               tRDPDEN (CASrd to CKE low time): Recommended
                               formula = tCL + BL/2 + (2 (for 2N) or 3 (for
                               3N))
                            */
    UINT32 t_xp : 7;

                            /* Bits[20:14], Access Type=RW, default=0x0000007F*/

                            /*
                               tXP (CKE low exit time (time before a new
                               command can be sent after CKE comes up)
                            */
    UINT32 t_cke : 7;

                            /* Bits[27:21], Access Type=RW, default=0x0000000F*/

                            /* tCKE (minimum CKE low or high time) */
    UINT32 t_prpden : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000003*/

                            /*
                               tPRPDEN, tACTPDEN, tREFPDEN will use this single
                               value.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TCKE_MCDDC_CTL_STRUCT;

/* TCMR2SHADOW_MCDDC_CTL_REG supported on:                                      */
/*      SPRA0 (0x20021bbc)                                                      */
/*      SPRB0 (0x20021bbc)                                                      */
/*      SPRHBM (0x20021bbc)                                                     */
/*      SPRC0 (0x20021bbc)                                                      */
/*      SPRMCC (0x20021bbc)                                                     */
/*      SPRUCC (0x20021bbc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x21c
*/


#define TCMR2SHADOW_MCDDC_CTL_REG 0x0B021BBC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_bit_swizzle : 2;

                            /* Bits[1:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Each bit is set in case of the corresponding
                               2-rank UDIMM or certain LRDIMM requires address
                               mirroring/swizzling. It indicates that some of
                               the address bits are swizzled for rank 1 (or
                               rank 3), and this has to be considerred in MRS
                               command. The address swizzling bits: A3 and A4
                               A5 and A6 A7 and A8 A11 and A13 BA0 and BA1 BG0
                               and BG1 Bit 0 refers to DIMM 0 Bit 1 refers to
                               DIMM 1
                            */
    UINT32 two_mrs_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is added for ddr4 rdimm,lrdimm,3ds
                               support. These devices use Address inversion
                               which requires the host to issue 2 MRS to
                               support these devices. This bit only affects
                               mode register sets issued part of faulty DIMM
                               isolation. The MRS issued by CPGC engine are not
                               affected by this bit. If this bit is 0, only one
                               MRS will be sent to the target chip_select. If
                               1, two back to back MRS will be sent to the
                               traget chip_select once for A-side and once for
                               B-side.
                            */
    UINT32 scratch : 16;

                            /* Bits[18:3], Access Type=RW, default=0x00000000*/

                            /* Scratch space for BIOS memory configuration data */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TCMR2SHADOW_MCDDC_CTL_STRUCT;

/* TCMRS_MCDDC_CTL_REG supported on:                                            */
/*      SPRA0 (0x20021bc0)                                                      */
/*      SPRB0 (0x20021bc0)                                                      */
/*      SPRHBM (0x20021bc0)                                                     */
/*      SPRC0 (0x20021bc0)                                                      */
/*      SPRMCC (0x20021bc0)                                                     */
/*      SPRUCC (0x20021bc0)                                                     */
/* Register default value on SPRA0: 0x0FD00508                                  */
/* Register default value on SPRB0: 0x0FD00508                                  */
/* Register default value on SPRHBM: 0x0FD00508                                 */
/* Register default value on SPRC0: 0x0FD00508                                  */
/* Register default value on SPRMCC: 0x0FD00508                                 */
/* Register default value on SPRUCC: 0x0FD00508                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Used to hold MRS timing for CAP or write CRC faulty DIMM isolation and other Refresh timing paramaters
*/


#define TCMRS_MCDDC_CTL_REG 0x0B021BC0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tmrd_ddr3 : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000008*/

                            /*
                               DDR tMRD timing parameter. MRS to MRS minimum
                               delay in number of DCLK.
                            */
    UINT32 trefsbrd_dlr : 6;

                            /* Bits[11:6], Access Type=RW, default=0x00000014*/

                            /*
                               tREFSBRD_DLR timing parameter for DDR5. Minimum
                               delay between same bank Refresh and Activate
                               command, REFsb to ACT.
                            */
    UINT32 enable_full_stack_act_block : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Enable blocking of ACT commands for entire DDR5
                               3DS stack
                            */
    UINT32 tzqcal_ddr5 : 14;

                            /* Bits[26:13], Access Type=RW, default=0x00003E80*/

                            /*
                               Time from ZQCal Start MPC command to when host
                               can send ZQCal Latch MCP comand. DDR5/T2 only.
                               The value is specified in Hclks.
                            */
    UINT32 zqcsreqdelay : 5;

                            /* Bits[31:27], Access Type=RW, default=0x00000001*/

                            /*
                               Delay the issuing of ZQCAL so it doesn't overlap
                               with DQ bus toggling due to a previous command.
                               Will be delayed by 4x this CSR value.
                            */

  } Bits;
  UINT32 Data;

} TCMRS_MCDDC_CTL_STRUCT;

/* TCRFP_MCDDC_CTL_REG supported on:                                            */
/*      SPRA0 (0x20021bc4)                                                      */
/*      SPRB0 (0x20021bc4)                                                      */
/*      SPRHBM (0x20021bc4)                                                     */
/*      SPRC0 (0x20021bc4)                                                      */
/*      SPRMCC (0x20021bc4)                                                     */
/*      SPRUCC (0x20021bc4)                                                     */
/* Register default value on SPRA0: 0x0603863F                                  */
/* Register default value on SPRB0: 0x0603863F                                  */
/* Register default value on SPRHBM: 0x0603863F                                 */
/* Register default value on SPRC0: 0x0603863F                                  */
/* Register default value on SPRMCC: 0x0603863F                                 */
/* Register default value on SPRUCC: 0x0603863F                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x210
*/


#define TCRFP_MCDDC_CTL_REG 0x0B021BC4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 orefni : 8;

                            /* Bits[7:0], Access Type=RW, default=0x0000003F*/

                            /*
                               Rank idle period that defines an opportunity for
                               refresh, in DCLK cycles
                            */
    UINT32 ref_hi_wm : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000006*/

                            /*
                               tREFI count level that turns the refresh
                               priority to high (default is 6 to leave time to
                               service request before spec violation of 9
                               tREFI)
                            */
    UINT32 rsvd : 3;

                            /* Bits[14:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ref_panic_wm : 4;

                            /* Bits[18:15], Access Type=RW, default=0x00000007*/

                            /*
                               tREFI count level in which the refresh priority
                               is panic (default is 7). It is recommended to
                               set the panic WM high enough to utilize the
                               maximum no-refresh period possible but also low
                               enough to give the MC time to service the panic
                               refreshes before the spec limit of 9 tREFI.
                            */
    UINT32 rsvd_19 : 5;

                            /* Bits[23:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 max_channel_ref : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000006*/

                            /*
                               When enable_6ref_window is set to 1, this field
                               determine the maximum number of refresh commands
                               active in the channel.
                            */
    UINT32 enable_6ref_window : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, the machine will only have at
                               most 6 refresh commands executing in parallel on
                               the channel. The default value of 6 can be
                               modified by changing the value of
                               max_channel_ref.
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TCRFP_MCDDC_CTL_STRUCT;

/* TCRFTP_MCDDC_CTL_REG supported on:                                           */
/*      SPRA0 (0x20021bc8)                                                      */
/*      SPRB0 (0x20021bc8)                                                      */
/*      SPRHBM (0x20021bc8)                                                     */
/*      SPRC0 (0x20021bc8)                                                      */
/*      SPRMCC (0x20021bc8)                                                     */
/*      SPRUCC (0x20021bc8)                                                     */
/* Register default value on SPRA0: 0x1640062C                                  */
/* Register default value on SPRB0: 0x1640062C                                  */
/* Register default value on SPRHBM: 0x1640062C                                 */
/* Register default value on SPRC0: 0x1640062C                                  */
/* Register default value on SPRMCC: 0x1640062C                                 */
/* Register default value on SPRUCC: 0x1640062C                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x214
*/


#define TCRFTP_MCDDC_CTL_REG 0x0B021BC8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_refi : 15;

                            /* Bits[14:0], Access Type=RW, default=0x0000062C*/

                            /*
                               Sets the average period between refreshes in
                               DCLK cycles. Note that the actual refresh rate
                               is dependent on the current temperature and the
                               refresh temperature limits as well as enables to
                               allow 1/2x, 2x and 4x refresh rates. Please look
                               at dimm_temp_ev_ofst_*.dimm_temp_offset,dimm_tem
                               p_refresh_*.temp_fourxref,dimm_temp_refresh_*.te
                               mp_twoxref,dimm_temp_refresh_*.temp_halfxref for
                               the temperature thresholds and dimm_temp_ev_ofst
                               _*.ev_4x_ref_en,dimm_temp_ev_ofst_*.ev_2x_ref_en
                               ,dimm_temp_ev_ofst_*.ev_halfx_ref_en to see if
                               the various rate changes are enabled. The
                               current temperature is saved in
                               pcode_temp_output.pcode_temp_output_dimm*
                            */
    UINT32 t_rfc : 10;

                            /* Bits[24:15], Access Type=RW, default=0x00000080*/

                            /*
                               Time of refresh - from beginning of refresh
                               until next ACT or refresh is allowed (in HCLK
                               cycles) Here are the recommended T_RFC for 2Gb
                               DDR3: 0800MT/s : 020h 1067MT/s : 02Bh 1333MT/s :
                               036h 1600MT/s : 040h 1867MT/s : 04Bh
                            */
    UINT32 t_ref_block : 5;

                            /* Bits[29:25], Access Type=RW, default=0x0000000B*/

                            /*
                               Number of D clocks to block scheduler before
                               checking returned safe signals. The minimum
                               value of 0x0C should be used; Valid range is
                               even values from 0x0C to 0x18.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TCRFTP_MCDDC_CTL_STRUCT;

/* TCSRFTP_MCDDC_CTL_REG supported on:                                          */
/*      SPRA0 (0x20021bcc)                                                      */
/*      SPRB0 (0x20021bcc)                                                      */
/*      SPRHBM (0x20021bcc)                                                     */
/*      SPRC0 (0x20021bcc)                                                      */
/*      SPRMCC (0x20021bcc)                                                     */
/*      SPRUCC (0x20021bcc)                                                     */
/* Register default value on SPRA0: 0x6100B100                                  */
/* Register default value on SPRB0: 0x6100B100                                  */
/* Register default value on SPRHBM: 0x6100B100                                 */
/* Register default value on SPRC0: 0x6100B100                                  */
/* Register default value on SPRMCC: 0x6100B100                                 */
/* Register default value on SPRUCC: 0x6100B100                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x218
*/


#define TCSRFTP_MCDDC_CTL_REG 0x0B021BCC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_xsdll : 12;

                            /* Bits[11:0], Access Type=RW, default=0x00000100*/

                            /*
                               Exit Self Refresh to commands requiring a locked
                               DLL in the range of 128 to 4095 DCLK cycles
                            */
    UINT32 t_xsoffset : 4;

                            /* Bits[15:12], Access Type=RW, default=0x0000000B*/

                            /*
                               tXS = T_RFC+10ns. Set this field to the number
                               of 1/2 the number of Dclks to get 10ns (the
                               value is shifted left by 1)
                            */
    UINT32 t_zqoper : 10;

                            /* Bits[25:16], Access Type=RW, default=0x00000100*/

                            /* Normal operation Full calibration time */
    UINT32 enzqcalerfsrx : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Enable ZQCAL on SRX as part of Error Recovery
                               Flow (DDR5/DDRT2 => expect value to be 1'b0)
                            */
    UINT32 t_mod : 5;

                            /* Bits[31:27], Access Type=RW, default=0x0000000C*/

                            /* Mode Register Set command update delay. */

  } Bits;
  UINT32 Data;

} TCSRFTP_MCDDC_CTL_STRUCT;

/* TCSTAGGER_REF_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20021bd0)                                                      */
/*      SPRB0 (0x20021bd0)                                                      */
/*      SPRHBM (0x20021bd0)                                                     */
/*      SPRC0 (0x20021bd0)                                                      */
/*      SPRMCC (0x20021bd0)                                                     */
/*      SPRUCC (0x20021bd0)                                                     */
/* Register default value on SPRA0: 0x20C17880                                  */
/* Register default value on SPRB0: 0x20C17880                                  */
/* Register default value on SPRHBM: 0x20C17880                                 */
/* Register default value on SPRC0: 0x20C17880                                  */
/* Register default value on SPRMCC: 0x20C17880                                 */
/* Register default value on SPRUCC: 0x20C17880                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* tRFC like timing constraint parameter except it is a timing constraint applicable to REF-REF separation between different ranks on a channel.
*/


#define TCSTAGGER_REF_MCDDC_CTL_REG 0x0B021BD0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 t_stagger_ref : 10;

                            /* Bits[9:0], Access Type=RW, default=0x00000080*/

                            /*
                               Limits the rate of refresh commands sent to a
                               single channel. The value of this field sets the
                               minimum time between REF or REFpb commands on
                               the channel. This value must be less than:
                               0.5*t_refi/(num_of_slices_per_channel *
                               num_ref_per_rank) as when the DIMMs are hot
                               twice as many refresh commands need to be sent.
                               For example with two non-3DS dual ranked DIMMs,
                               the number_of_slices_per_channel is 4. With two
                               quad-ranked LRDIMMs the value is 8. With two 8H
                               dual-ranked 3DS DIMMs, the value is 32.
                               Num_ref_per_rank is either 1 (perbank_mode=0), 4
                               (DDR4E perbank_mode=1) or 16 (HBM
                               perbank_mode=1)
                            */
    UINT32 t_slice_stagger : 10;

                            /* Bits[19:10], Access Type=RW, default=0x0000005E*/

                            /*
                               3DS specific field which determines delay
                               between sub-rank refresh commands. This value
                               should be set to: t_slice_stagger[9:0] =
                               INT(2*(tcrftp.t_rfc/3) - tcrftp.t_ref_block -
                               memory_timings_trp_trc_tras.t_rp - 22).
                               Ultimately, the time between refreshes to
                               different logical ranks is summed to be the time
                               it takes to block the channel (t_ref_block),
                               issue the PREA, issue the REFA, and finally
                               whatever time is necessary to not violate the
                               minimum refresh to different logical rank of
                               tRFC_dlr (t_slice_stagger). t_ref_block/2 +
                               tRP/2 + t_slice_stagger/2 + 11 >= tRFC_dlr.
                            */
    UINT32 rsvd : 1;

                            /* Bits[20:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 perbank_mode : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Enable perbank refresh. Only valid with DDR4E
                               memory or HBM
                            */
    UINT32 no_bank_overlap : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /*
                               When set to one, each per-bank refresh must
                               complete before the next one is issued to the
                               same rank or sub-rank. Only valid with DDR4E
                               memory or HBM
                            */
    UINT32 keep_cke_high_during_trfc : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000001*/

                            /*
                               When set to one, CKE will be kept high for
                               entire tRFC after a REFresh command. When zero,
                               CKE will be allowed to go low tREFPDEN after a
                               REFresh command and then got back high before
                               tRFC expires.
                            */
    UINT32 tmrr_plus_tprepostamble : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000020*/

                            /*
                               Limits the number of ERF MRR commands that can
                               be requested by the Refresh machine across the
                               entire channel. The time should be tMRR (MRR to
                               MRR spacing, 16tCK) plus time allowed for Read
                               pre/postambles (4+1.5tCK). Setting default to 32
                               hclks to give more than sufficient time.
                            */
    UINT32 tcstagger_ref_rsv : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /* Spare CSR */

  } Bits;
  UINT32 Data;

} TCSTAGGER_REF_MCDDC_CTL_STRUCT;

/* TCZQCAL_MCDDC_CTL_REG supported on:                                          */
/*      SPRA0 (0x20021bd4)                                                      */
/*      SPRB0 (0x20021bd4)                                                      */
/*      SPRHBM (0x20021bd4)                                                     */
/*      SPRC0 (0x20021bd4)                                                      */
/*      SPRMCC (0x20021bd4)                                                     */
/*      SPRUCC (0x20021bd4)                                                     */
/* Register default value on SPRA0: 0x34804080                                  */
/* Register default value on SPRB0: 0x34804080                                  */
/* Register default value on SPRHBM: 0x34804080                                 */
/* Register default value on SPRC0: 0x34804080                                  */
/* Register default value on SPRMCC: 0x34804080                                 */
/* Register default value on SPRUCC: 0x34804080                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x220
*/


#define TCZQCAL_MCDDC_CTL_REG 0x0B021BD4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 zqcsperiod : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000080*/

                            /*
                               Time between ZQ-FSM initiated ZQCS operations in
                               tREFI*128 (2 to 255, default is 128). Note: ZQCx
                               is issued at SRX.
                            */
    UINT32 t_zqcs : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000040*/

                            /*
                               tZQCS in DCLK cycles (32 to 255, default is 64).
                               DDR5 is tZQLAT, needs this to be
                               max(30ns,8*dclk).
                            */
    UINT32 t_rfcpb : 10;

                            /* Bits[25:16], Access Type=RW, default=0x00000080*/

                            /*
                               Perbank refresh cycle time (tRFCPB for DDR or
                               tREFSB for HBM)
                            */
    UINT32 t_rrefd : 6;

                            /* Bits[31:26], Access Type=RW, default=0x0000000D*/

                            /*
                               For HBM this is tRREFD in DCLK cycles. HBM only
                               Single bank refresh command period (different
                               bank) For DDR5 this is tREFSBRD in HCLK cycles.
                            */

  } Bits;
  UINT32 Data;

} TCZQCAL_MCDDC_CTL_STRUCT;

/* WR_ODT_TBL0_MCDDC_CTL_REG supported on:                                      */
/*      SPRA0 (0x20021bd8)                                                      */
/*      SPRB0 (0x20021bd8)                                                      */
/*      SPRHBM (0x20021bd8)                                                     */
/*      SPRC0 (0x20021bd8)                                                      */
/*      SPRMCC (0x20021bd8)                                                     */
/*      SPRUCC (0x20021bd8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* One entry for each physical rank on each channel.  Each entry defines which ODT signals are asserted when accessing that rank.Also includes ODT timing control.
Here is the recommended BIOS settings to keep the MC_TERM_RNK_MSK consistent:
Set Write ODT mapping - write ODT specified all ODT pins assertion for a write targeting at this rank. All DIMMs termination rank must have the ODT mask asserted. All non-termination rank in the ODT mapping table must be cleared.
*/


#define WR_ODT_TBL0_MCDDC_CTL_REG 0x0B021BD8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wr_odt_rank0 : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /* Rank 0 Write ODT */
    UINT32 rsvd : 4;

                            /* Bits[7:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 wr_odt_rank1 : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000000*/

                            /* Rank 1 Write ODT */
    UINT32 rsvd_12 : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 wr_odt_rank2 : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000000*/

                            /* Rank 2 Write ODT */
    UINT32 rsvd_20 : 4;

                            /* Bits[23:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 wr_odt_rank3 : 4;

                            /* Bits[27:24], Access Type=RW, default=0x00000000*/

                            /* Rank 3 Write ODT */
    UINT32 rsvd_28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} WR_ODT_TBL0_MCDDC_CTL_STRUCT;

/* WR_ODT_TBL1_MCDDC_CTL_REG supported on:                                      */
/*      SPRA0 (0x20021bdc)                                                      */
/*      SPRB0 (0x20021bdc)                                                      */
/*      SPRHBM (0x20021bdc)                                                     */
/*      SPRC0 (0x20021bdc)                                                      */
/*      SPRMCC (0x20021bdc)                                                     */
/*      SPRUCC (0x20021bdc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* One entry for each physical rank on each channel.  Each entry defines which ODT signals are asserted when accessing that rank.Also includes ODT timing control.
Here is the recommended BIOS settings to keep the MC_TERM_RNK_MSK consistent:
Set Write ODT mapping - write ODT specified all ODT pins assertion for a write targeting at this rank. All DIMMs termination rank must have the ODT mask asserted. All non-termination rank in the ODT mapping table must be cleared
*/


#define WR_ODT_TBL1_MCDDC_CTL_REG 0x0B021BDC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wr_odt_rank4 : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /* Rank 4 Write ODT */
    UINT32 rsvd : 4;

                            /* Bits[7:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 wr_odt_rank5 : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000000*/

                            /* Rank 5 Write ODT */
    UINT32 rsvd_12 : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 wr_odt_rank6 : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000000*/

                            /* Rank 6 Write ODT */
    UINT32 rsvd_20 : 4;

                            /* Bits[23:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 wr_odt_rank7 : 4;

                            /* Bits[27:24], Access Type=RW, default=0x00000000*/

                            /* Rank 7 Write ODT */
    UINT32 rsvd_28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} WR_ODT_TBL1_MCDDC_CTL_STRUCT;

/* WR_ODT_TBL2_MCDDC_CTL_REG supported on:                                      */
/*      SPRA0 (0x20021be0)                                                      */
/*      SPRB0 (0x20021be0)                                                      */
/*      SPRHBM (0x20021be0)                                                     */
/*      SPRC0 (0x20021be0)                                                      */
/*      SPRMCC (0x20021be0)                                                     */
/*      SPRUCC (0x20021be0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* One entry for each physical rank on each channel.  Each entry defines which ODT signals are asserted when accessing that rank.Also includes ODT timing control.
Here is the recommended BIOS settings to keep the MC_TERM_RNK_MSK consistent:
Set Write ODT mapping - write ODT specified all ODT pins assertion for a write targeting at this rank. All DIMMs termination rank must have the ODT mask asserted. All non-termination rank in the ODT mapping table must be cleared
*/


#define WR_ODT_TBL2_MCDDC_CTL_REG 0x0B021BE0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 16;

                            /* Bits[15:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 extra_leading_odt : 2;

                            /* Bits[17:16], Access Type=RW, default=0x00000000*/

                            /*
                               Extra Leading ODT cycles. Only value of 0 or 1
                               should be used.
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 extra_trailing_odt : 2;

                            /* Bits[21:20], Access Type=RW, default=0x00000000*/

                            /* Extra Trailing ODT cycles */
    UINT32 rsvd_22 : 10;

                            /* Bits[31:22], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} WR_ODT_TBL2_MCDDC_CTL_STRUCT;

/* SCHEDULER_CAS_TIMING_MCDDC_CTL_REG supported on:                             */
/*      SPRA0 (0x20021be4)                                                      */
/*      SPRB0 (0x20021be4)                                                      */
/*      SPRHBM (0x20021be4)                                                     */
/*      SPRC0 (0x20021be4)                                                      */
/*      SPRMCC (0x20021be4)                                                     */
/*      SPRUCC (0x20021be4)                                                     */
/* Register default value on SPRA0: 0x00000003                                  */
/* Register default value on SPRB0: 0x00000003                                  */
/* Register default value on SPRHBM: 0x00000003                                 */
/* Register default value on SPRC0: 0x00000003                                  */
/* Register default value on SPRMCC: 0x00000003                                 */
/* Register default value on SPRUCC: 0x00000003                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Configuration register
*/


#define SCHEDULER_CAS_TIMING_MCDDC_CTL_REG 0x0B021BE4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 enable_rd_cas_hclk_spacing : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Enables 1 hclk spacing between read CAS's on
                               different sub-channels so that there can't be a
                               HP read in the next hclk cycle after a LP read
                               in the current hclk cycle
                            */
    UINT32 enable_wr_cas_hclk_spacing : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Enables 1 hclk spacing between write CAS's on
                               different sub-channels so that there can't be a
                               HP write in the next hclk cycle after a LP write
                               in the current hclk cycle
                            */
    UINT32 rsvd : 14;

                            /* Bits[15:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 disable_rcas_hp : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* Disable Read CAS on high-phase (debug) */
    UINT32 disable_rcas_lp : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Disable read CAS on low-phase (debug) */
    UINT32 disable_wcas_hp : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /* Disable Write CAS HP (debug) */
    UINT32 disable_wcas_lp : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /* Disable HP Read CAS (debug) */
    UINT32 disable_act_hp : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /* Disable Activates on high-phase (debug) */
    UINT32 disable_act_lp : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* Disable Activates on low-phase (debug) */
    UINT32 rsvd_22 : 10;

                            /* Bits[31:22], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_CAS_TIMING_MCDDC_CTL_STRUCT;

/* SCHEDULER_DUMP_INDEX_MCDDC_CTL_REG supported on:                             */
/*      SPRA0 (0x20021be8)                                                      */
/*      SPRB0 (0x20021be8)                                                      */
/*      SPRHBM (0x20021be8)                                                     */
/*      SPRC0 (0x20021be8)                                                      */
/*      SPRMCC (0x20021be8)                                                     */
/*      SPRUCC (0x20021be8)                                                     */
/* Register default value on SPRA0: 0x01000000                                  */
/* Register default value on SPRB0: 0x01000000                                  */
/* Register default value on SPRHBM: 0x01000000                                 */
/* Register default value on SPRC0: 0x01000000                                  */
/* Register default value on SPRMCC: 0x01000000                                 */
/* Register default value on SPRUCC: 0x01000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_bs_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Scheduler dump indexes. This register is locked by epmcctrl_dfx_lck_cntl.mc_array_dump_lck.
         group selects RPQ/WPQ/BR/BS
         pch   selects which pseudo channel
         index selects which entry
         
*/


#define SCHEDULER_DUMP_INDEX_MCDDC_CTL_REG 0x0B021BE8

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dumpindex_entry : 5;

                            /* Bits[4:0], Access Type=RW/L, default=0x00000000*/

                            /* entry */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dumpindex_pch : 2;

                            /* Bits[9:8], Access Type=RW/L, default=0x00000000*/

                            /* pch */
    UINT32 rsvd_10 : 6;

                            /* Bits[15:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dumpindex_group : 3;

                            /* Bits[18:16], Access Type=RW/L, default=0x00000000*/

                            /* group */
    UINT32 rsvd_19 : 5;

                            /* Bits[23:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dumpindex_enable : 1;

                            /* Bits[24:24], Access Type=RW/L, default=0x00000001*/

                            /* Enable CSR load signal for dump0,1,2,3 */
    UINT32 rsvd_25 : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_DUMP_INDEX_MCDDC_CTL_SPRA0_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dumpindex_entry : 6;

                            /* Bits[5:0], Access Type=RW/L, default=0x00000000*/

                            /* entry */
    UINT32 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dumpindex_pch : 2;

                            /* Bits[9:8], Access Type=RW/L, default=0x00000000*/

                            /* pch */
    UINT32 rsvd_10 : 6;

                            /* Bits[15:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dumpindex_group : 3;

                            /* Bits[18:16], Access Type=RW/L, default=0x00000000*/

                            /* group */
    UINT32 rsvd_19 : 5;

                            /* Bits[23:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dumpindex_enable : 1;

                            /* Bits[24:24], Access Type=RW/L, default=0x00000001*/

                            /* Enable CSR load signal for dump0,1,2,3 */
    UINT32 rsvd_25 : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_DUMP_INDEX_MCDDC_CTL_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 8;

                            /* Bits[7:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dumpindex_pch : 2;

                            /* Bits[9:8], Access Type=RW/L, default=0x00000000*/

                            /* pch */
    UINT32 rsvd_10 : 6;

                            /* Bits[15:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dumpindex_group : 3;

                            /* Bits[18:16], Access Type=RW/L, default=0x00000000*/

                            /* group */
    UINT32 rsvd_19 : 5;

                            /* Bits[23:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dumpindex_enable : 1;

                            /* Bits[24:24], Access Type=RW/L, default=0x00000001*/

                            /* Enable CSR load signal for dump0,1,2,3 */
    UINT32 rsvd_25 : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_DUMP_INDEX_MCDDC_CTL_STRUCT;





/* PMONUNITCTRL_MCDDC_CTL_REG supported on:                                     */
/*      SPRA0 (0x20022800)                                                      */
/*      SPRB0 (0x20022800)                                                      */
/*      SPRHBM (0x20022800)                                                     */
/*      SPRC0 (0x20022800)                                                      */
/*      SPRMCC (0x20022800)                                                     */
/*      SPRUCC (0x20022800)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* generated by critter 20_0_0x0f4
*/


#define PMONUNITCTRL_MCDDC_CTL_REG 0x0B022800

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 freezecounters : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit is written to when the counters should
                               be frozen. If this bit is written to and freeze
                               is enabled, the counters in the unit will stop
                               counting.
                            */
    UINT32 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 resetcounterconfigs : 1;

                            /* Bits[8:8], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counter
                               configuration registers will be reset. This does
                               not effect the values in the counters.
                            */
    UINT32 resetcounters : 1;

                            /* Bits[9:9], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is written to, the counters data
                               fields will be reset. The configuration values
                               will not be reset.
                            */
    UINT32 rsvd_10 : 22;

                            /* Bits[31:10], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONUNITCTRL_MCDDC_CTL_STRUCT;

/* PMONCNTR_0_N0_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20022808)                                                      */
/*      SPRB0 (0x20022808)                                                      */
/*      SPRHBM (0x20022808)                                                     */
/*      SPRC0 (0x20022808)                                                      */
/*      SPRMCC (0x20022808)                                                     */
/*      SPRUCC (0x20022808)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is a perfmon counter.  Software can both read it and write it.
*/


#define PMONCNTR_0_N0_MCDDC_CTL_REG 0x0B022808

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /* This is the current value of the counter. */

  } Bits;
  UINT32 Data;

} PMONCNTR_0_N0_MCDDC_CTL_STRUCT;

/* PMONCNTR_0_N1_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x2002280c)                                                      */
/*      SPRB0 (0x2002280c)                                                      */
/*      SPRHBM (0x2002280c)                                                     */
/*      SPRC0 (0x2002280c)                                                      */
/*      SPRMCC (0x2002280c)                                                     */
/*      SPRUCC (0x2002280c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is a perfmon counter.  Software can both read it and write it.
*/


#define PMONCNTR_0_N1_MCDDC_CTL_REG 0x0B02280C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 16;

                            /* Bits[15:0], Access Type=RW/V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONCNTR_0_N1_MCDDC_CTL_STRUCT;

/* PMONCNTR_1_N0_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20022810)                                                      */
/*      SPRB0 (0x20022810)                                                      */
/*      SPRHBM (0x20022810)                                                     */
/*      SPRC0 (0x20022810)                                                      */
/*      SPRMCC (0x20022810)                                                     */
/*      SPRUCC (0x20022810)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is a perfmon counter.  Software can both read it and write it.
*/


#define PMONCNTR_1_N0_MCDDC_CTL_REG 0x0B022810

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /* This is the current value of the counter. */

  } Bits;
  UINT32 Data;

} PMONCNTR_1_N0_MCDDC_CTL_STRUCT;

/* PMONCNTR_1_N1_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20022814)                                                      */
/*      SPRB0 (0x20022814)                                                      */
/*      SPRHBM (0x20022814)                                                     */
/*      SPRC0 (0x20022814)                                                      */
/*      SPRMCC (0x20022814)                                                     */
/*      SPRUCC (0x20022814)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is a perfmon counter.  Software can both read it and write it.
*/


#define PMONCNTR_1_N1_MCDDC_CTL_REG 0x0B022814

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 16;

                            /* Bits[15:0], Access Type=RW/V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONCNTR_1_N1_MCDDC_CTL_STRUCT;

/* PMONCNTR_2_N0_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20022818)                                                      */
/*      SPRB0 (0x20022818)                                                      */
/*      SPRHBM (0x20022818)                                                     */
/*      SPRC0 (0x20022818)                                                      */
/*      SPRMCC (0x20022818)                                                     */
/*      SPRUCC (0x20022818)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is a perfmon counter.  Software can both read it and write it.
*/


#define PMONCNTR_2_N0_MCDDC_CTL_REG 0x0B022818

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /* This is the current value of the counter. */

  } Bits;
  UINT32 Data;

} PMONCNTR_2_N0_MCDDC_CTL_STRUCT;

/* PMONCNTR_2_N1_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x2002281c)                                                      */
/*      SPRB0 (0x2002281c)                                                      */
/*      SPRHBM (0x2002281c)                                                     */
/*      SPRC0 (0x2002281c)                                                      */
/*      SPRMCC (0x2002281c)                                                     */
/*      SPRUCC (0x2002281c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is a perfmon counter.  Software can both read it and write it.
*/


#define PMONCNTR_2_N1_MCDDC_CTL_REG 0x0B02281C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 16;

                            /* Bits[15:0], Access Type=RW/V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONCNTR_2_N1_MCDDC_CTL_STRUCT;

/* PMONCNTR_3_N0_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20022820)                                                      */
/*      SPRB0 (0x20022820)                                                      */
/*      SPRHBM (0x20022820)                                                     */
/*      SPRC0 (0x20022820)                                                      */
/*      SPRMCC (0x20022820)                                                     */
/*      SPRUCC (0x20022820)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is a perfmon counter.  Software can both read it and write it.
*/


#define PMONCNTR_3_N0_MCDDC_CTL_REG 0x0B022820

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /* This is the current value of the counter. */

  } Bits;
  UINT32 Data;

} PMONCNTR_3_N0_MCDDC_CTL_STRUCT;

/* PMONCNTR_3_N1_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20022824)                                                      */
/*      SPRB0 (0x20022824)                                                      */
/*      SPRHBM (0x20022824)                                                     */
/*      SPRC0 (0x20022824)                                                      */
/*      SPRMCC (0x20022824)                                                     */
/*      SPRUCC (0x20022824)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is a perfmon counter.  Software can both read it and write it.
*/


#define PMONCNTR_3_N1_MCDDC_CTL_REG 0x0B022824

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 16;

                            /* Bits[15:0], Access Type=RW/V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONCNTR_3_N1_MCDDC_CTL_STRUCT;

/* PMONCNTR_4_N0_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20022828)                                                      */
/*      SPRB0 (0x20022828)                                                      */
/*      SPRHBM (0x20022828)                                                     */
/*      SPRC0 (0x20022828)                                                      */
/*      SPRMCC (0x20022828)                                                     */
/*      SPRUCC (0x20022828)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is a perfmon counter.  Software can both read it and write it.
*/


#define PMONCNTR_4_N0_MCDDC_CTL_REG 0x0B022828

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /* This is the current value of the counter. */

  } Bits;
  UINT32 Data;

} PMONCNTR_4_N0_MCDDC_CTL_STRUCT;

/* PMONCNTR_4_N1_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x2002282c)                                                      */
/*      SPRB0 (0x2002282c)                                                      */
/*      SPRHBM (0x2002282c)                                                     */
/*      SPRC0 (0x2002282c)                                                      */
/*      SPRMCC (0x2002282c)                                                     */
/*      SPRUCC (0x2002282c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is a perfmon counter.  Software can both read it and write it.
*/


#define PMONCNTR_4_N1_MCDDC_CTL_REG 0x0B02282C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 16;

                            /* Bits[15:0], Access Type=RW/V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONCNTR_4_N1_MCDDC_CTL_STRUCT;

/* PMONCNTR_FIXED_N0_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20022838)                                                      */
/*      SPRB0 (0x20022838)                                                      */
/*      SPRHBM (0x20022838)                                                     */
/*      SPRC0 (0x20022838)                                                      */
/*      SPRMCC (0x20022838)                                                     */
/*      SPRUCC (0x20022838)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is a perfmon counter.  Software can both read it and write it.
*/


#define PMONCNTR_FIXED_N0_MCDDC_CTL_REG 0x0B022838

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /* This is the current value of the counter. */

  } Bits;
  UINT32 Data;

} PMONCNTR_FIXED_N0_MCDDC_CTL_STRUCT;

/* PMONCNTR_FIXED_N1_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x2002283c)                                                      */
/*      SPRB0 (0x2002283c)                                                      */
/*      SPRHBM (0x2002283c)                                                     */
/*      SPRC0 (0x2002283c)                                                      */
/*      SPRMCC (0x2002283c)                                                     */
/*      SPRUCC (0x2002283c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is a perfmon counter.  Software can both read it and write it.
*/


#define PMONCNTR_FIXED_N1_MCDDC_CTL_REG 0x0B02283C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 countervalue : 16;

                            /* Bits[15:0], Access Type=RW/V, default=0x00000000*/

                            /* This is the current value of the counter. */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONCNTR_FIXED_N1_MCDDC_CTL_STRUCT;

/* PMONCNTRCFG_0_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20022840)                                                      */
/*      SPRB0 (0x20022840)                                                      */
/*      SPRHBM (0x20022840)                                                     */
/*      SPRC0 (0x20022840)                                                      */
/*      SPRMCC (0x20022840)                                                     */
/*      SPRUCC (0x20022840)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Perfmon Counter Control Register
*/


#define PMONCNTRCFG_0_MCDDC_CTL_REG 0x0B022840

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 eventselect : 8;

                            /* Bits[7:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective performance monitoring sections.
                            */
    UINT32 unitmask : 8;

                            /* Bits[15:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bit-wise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a 1 is written to it.
                               No action is taken when a 0 is written. Note:
                               Since the queue occupancy counters never drop
                               below zero, it is possible for the counters to
                               catch up with the real occupancy of the queue in
                               question when the real occupancy drop to zero.
                            */
    UINT32 counterreset : 1;

                            /* Bits[17:17], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 edgedetect : 1;

                            /* Bits[18:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with thresh-holding. This is true even for
                               events that can only increment by 1 in a given
                               cycle (like the L1 example above). In this case,
                               one should set a threshold of 1. One can also
                               use Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would select the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 rsvd : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 frz_on_ov : 1;

                            /* Bits[20:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 rsvd_21 : 2;

                            /* Bits[22:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 invert : 1;

                            /* Bits[23:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold < event. The invert
                               bit only works when Threshold != 0. So, if one
                               would like to invert a non-occupancy event (like
                               LLC Hit), one needs to set the threshold to 1.
                            */
    UINT32 res_threshold : 8;

                            /* Bits[31:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the invert bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;
  UINT32 Data;

} PMONCNTRCFG_0_MCDDC_CTL_STRUCT;

/* PMONCNTRCFG_1_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20022844)                                                      */
/*      SPRB0 (0x20022844)                                                      */
/*      SPRHBM (0x20022844)                                                     */
/*      SPRC0 (0x20022844)                                                      */
/*      SPRMCC (0x20022844)                                                     */
/*      SPRUCC (0x20022844)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Perfmon Counter Control Register
*/


#define PMONCNTRCFG_1_MCDDC_CTL_REG 0x0B022844

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 eventselect : 8;

                            /* Bits[7:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective performance monitoring sections.
                            */
    UINT32 unitmask : 8;

                            /* Bits[15:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bit-wise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a 1 is written to it.
                               No action is taken when a 0 is written. Note:
                               Since the queue occupancy counters never drop
                               below zero, it is possible for the counters to
                               catch up with the real occupancy of the queue in
                               question when the real occupancy drop to zero.
                            */
    UINT32 counterreset : 1;

                            /* Bits[17:17], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 edgedetect : 1;

                            /* Bits[18:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with thresh-holding. This is true even for
                               events that can only increment by 1 in a given
                               cycle (like the L1 example above). In this case,
                               one should set a threshold of 1. One can also
                               use Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would select the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 rsvd : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 frz_on_ov : 1;

                            /* Bits[20:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 rsvd_21 : 2;

                            /* Bits[22:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 invert : 1;

                            /* Bits[23:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold < event. The invert
                               bit only works when Threshold != 0. So, if one
                               would like to invert a non-occupancy event (like
                               LLC Hit), one needs to set the threshold to 1.
                            */
    UINT32 res_threshold : 8;

                            /* Bits[31:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the invert bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;
  UINT32 Data;

} PMONCNTRCFG_1_MCDDC_CTL_STRUCT;

/* PMONCNTRCFG_2_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20022848)                                                      */
/*      SPRB0 (0x20022848)                                                      */
/*      SPRHBM (0x20022848)                                                     */
/*      SPRC0 (0x20022848)                                                      */
/*      SPRMCC (0x20022848)                                                     */
/*      SPRUCC (0x20022848)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Perfmon Counter Control Register
*/


#define PMONCNTRCFG_2_MCDDC_CTL_REG 0x0B022848

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 eventselect : 8;

                            /* Bits[7:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective performance monitoring sections.
                            */
    UINT32 unitmask : 8;

                            /* Bits[15:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bit-wise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a 1 is written to it.
                               No action is taken when a 0 is written. Note:
                               Since the queue occupancy counters never drop
                               below zero, it is possible for the counters to
                               catch up with the real occupancy of the queue in
                               question when the real occupancy drop to zero.
                            */
    UINT32 counterreset : 1;

                            /* Bits[17:17], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 edgedetect : 1;

                            /* Bits[18:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with thresh-holding. This is true even for
                               events that can only increment by 1 in a given
                               cycle (like the L1 example above). In this case,
                               one should set a threshold of 1. One can also
                               use Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would select the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 rsvd : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 frz_on_ov : 1;

                            /* Bits[20:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 rsvd_21 : 2;

                            /* Bits[22:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 invert : 1;

                            /* Bits[23:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold < event. The invert
                               bit only works when Threshold != 0. So, if one
                               would like to invert a non-occupancy event (like
                               LLC Hit), one needs to set the threshold to 1.
                            */
    UINT32 res_threshold : 8;

                            /* Bits[31:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the invert bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;
  UINT32 Data;

} PMONCNTRCFG_2_MCDDC_CTL_STRUCT;

/* PMONCNTRCFG_3_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x2002284c)                                                      */
/*      SPRB0 (0x2002284c)                                                      */
/*      SPRHBM (0x2002284c)                                                     */
/*      SPRC0 (0x2002284c)                                                      */
/*      SPRMCC (0x2002284c)                                                     */
/*      SPRUCC (0x2002284c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Perfmon Counter Control Register
*/


#define PMONCNTRCFG_3_MCDDC_CTL_REG 0x0B02284C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 eventselect : 8;

                            /* Bits[7:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective performance monitoring sections.
                            */
    UINT32 unitmask : 8;

                            /* Bits[15:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bit-wise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a 1 is written to it.
                               No action is taken when a 0 is written. Note:
                               Since the queue occupancy counters never drop
                               below zero, it is possible for the counters to
                               catch up with the real occupancy of the queue in
                               question when the real occupancy drop to zero.
                            */
    UINT32 counterreset : 1;

                            /* Bits[17:17], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 edgedetect : 1;

                            /* Bits[18:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with thresh-holding. This is true even for
                               events that can only increment by 1 in a given
                               cycle (like the L1 example above). In this case,
                               one should set a threshold of 1. One can also
                               use Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would select the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 rsvd : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 frz_on_ov : 1;

                            /* Bits[20:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 rsvd_21 : 2;

                            /* Bits[22:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 invert : 1;

                            /* Bits[23:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold < event. The invert
                               bit only works when Threshold != 0. So, if one
                               would like to invert a non-occupancy event (like
                               LLC Hit), one needs to set the threshold to 1.
                            */
    UINT32 res_threshold : 8;

                            /* Bits[31:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the invert bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;
  UINT32 Data;

} PMONCNTRCFG_3_MCDDC_CTL_STRUCT;

/* PMONCNTRCFG_4_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20022850)                                                      */
/*      SPRB0 (0x20022850)                                                      */
/*      SPRHBM (0x20022850)                                                     */
/*      SPRC0 (0x20022850)                                                      */
/*      SPRMCC (0x20022850)                                                     */
/*      SPRUCC (0x20022850)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Perfmon Counter Control Register
*/


#define PMONCNTRCFG_4_MCDDC_CTL_REG 0x0B022850

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 eventselect : 8;

                            /* Bits[7:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is used to decode the PerfMon event
                               which is selected. The encodings for each of the
                               valid UnCore PerfMon events can be found in the
                               respective performance monitoring sections.
                            */
    UINT32 unitmask : 8;

                            /* Bits[15:8], Access Type=RW/V, default=0x00000000*/

                            /*
                               This mask selects the sub-events to be selected
                               for creation of the event. The selected sub-
                               events are bit-wise OR-ed together to create
                               event. At least one sub-event must be selected
                               otherwise the PerfMon event signals will not
                               ever get asserted. Events with no sub-events
                               listed effectively have only one sub-event
                               =event -1 bit 8 must be set to 1 in this case.
                            */
    UINT32 queueoccupancyreset : 1;

                            /* Bits[16:16], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               This write only bit causes the queue occupancy
                               counter of the PerfMon counter for which this
                               Perf event select register is associated to be
                               cleared to all zeroes when a 1 is written to it.
                               No action is taken when a 0 is written. Note:
                               Since the queue occupancy counters never drop
                               below zero, it is possible for the counters to
                               catch up with the real occupancy of the queue in
                               question when the real occupancy drop to zero.
                            */
    UINT32 counterreset : 1;

                            /* Bits[17:17], Access Type=RW/1S/V, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 edgedetect : 1;

                            /* Bits[18:18], Access Type=RW/V, default=0x00000000*/

                            /*
                               Edge Detect allows one to count either 0 to 1 or
                               1 to 0 transitions of a given event. For
                               example, we have an event that counts the number
                               of cycles in L1 mode in Intel QPI. By using edge
                               detect, one can count the number of times that
                               we entered L1 mode (by detecting the rising
                               edge). Edge detect only works in conjunction
                               with thresh-holding. This is true even for
                               events that can only increment by 1 in a given
                               cycle (like the L1 example above). In this case,
                               one should set a threshold of 1. One can also
                               use Edge Detect with queue occupancy events. For
                               example, if one wanted to count the number of
                               times when the TOR occupancy was larger than 5,
                               one would select the TOR occupancy event with a
                               threshold of 5 and set the Edge Detect bit. Edge
                               detect can also be used with the invert. This is
                               generally not particularly useful, as the count
                               of falling edges compared to rising edges will
                               always on differ by 1.
                            */
    UINT32 rsvd : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 frz_on_ov : 1;

                            /* Bits[20:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 rsvd_21 : 2;

                            /* Bits[22:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 invert : 1;

                            /* Bits[23:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold < event. The invert
                               bit only works when Threshold != 0. So, if one
                               would like to invert a non-occupancy event (like
                               LLC Hit), one needs to set the threshold to 1.
                            */
    UINT32 res_threshold : 8;

                            /* Bits[31:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is compared directly against an
                               incoming event value for events that can
                               increment by 1 or more in a given cycle. Since
                               the widest event from the UnCore is 7bits (queue
                               occupancy), bit 31 is unused. The result of the
                               comparison is effectively a 1 bit wide event,
                               i.e., the counter will be incremented by 1 when
                               the comparison is true (the type of comparison
                               depends on the setting of the invert bit - see
                               bit 23 below) no matter how wide the original
                               event was. When this field is zero, threshold
                               comparison is disabled and the event is passed
                               without modification.
                            */

  } Bits;
  UINT32 Data;

} PMONCNTRCFG_4_MCDDC_CTL_STRUCT;

/* PMONCNTRCFGFIXED_MCDDC_CTL_REG supported on:                                 */
/*      SPRA0 (0x20022854)                                                      */
/*      SPRB0 (0x20022854)                                                      */
/*      SPRHBM (0x20022854)                                                     */
/*      SPRC0 (0x20022854)                                                      */
/*      SPRMCC (0x20022854)                                                     */
/*      SPRUCC (0x20022854)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* generated by critter 20_0_0x0f0
*/


#define PMONCNTRCFGFIXED_MCDDC_CTL_REG 0x0B022854

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 19;

                            /* Bits[18:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 counterreset : 1;

                            /* Bits[19:19], Access Type=WO, default=0x00000000*/

                            /*
                               When this bit is set, the corresponding counter
                               will be reset to 0. This allows for a quick
                               reset of the counter when changing event
                               encodings.
                            */
    UINT32 overflowenable : 1;

                            /* Bits[20:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               Setting this bit will enable the counter to send
                               an overflow signal. If this bit is not set, the
                               counter will wrap around when it overflows
                               without triggering anything. If this bit is set
                               and the Units configuration register has
                               Overflow enabled, then a signal will be
                               transmitted to the Ubox.
                            */
    UINT32 rsvd_21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 counterenable : 1;

                            /* Bits[22:22], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field is the local enable for the PerfMon
                               Counter. This bit must be asserted in order for
                               the PerfMon counter to begin counting the events
                               selected by the event select, unit mask, and
                               internal bits (see the fields below). There is
                               one bit per PerfMon Counter. Note that if this
                               bit is set to 1 but the Unit Control Registers
                               have determined that counting is disabled, then
                               the counter will not count.
                            */
    UINT32 invert : 1;

                            /* Bits[23:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit indicates how the threshold field will
                               be compared to the incoming event. When 0, the
                               comparison that will be done is threshold >=
                               event. When set to 1, the comparison that will
                               be done is inverted from the case where this bit
                               is set to 0, i.e., threshold < event. If the
                               threshold is set to 0 on an event that only has
                               one bit (for example LLC Hit), and the invert
                               bit is enabled, the counter will increment by 1
                               in every cycle when the event is not true (for
                               example, every cycle when there is not an llc
                               hit).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONCNTRCFGFIXED_MCDDC_CTL_STRUCT;

/* PMONUNITSTATUS_MCDDC_CTL_REG supported on:                                   */
/*      SPRA0 (0x2002285c)                                                      */
/*      SPRB0 (0x2002285c)                                                      */
/*      SPRHBM (0x2002285c)                                                     */
/*      SPRC0 (0x2002285c)                                                      */
/*      SPRMCC (0x2002285c)                                                     */
/*      SPRUCC (0x2002285c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This field shows which registers have overflowed in the unit.
Whenever a register overflows, it should set the relevant bit to 1.  An overflow should not effect the other status bits.  This status should only be cleared by software.
We have defined 7 bits for this status.  This is overkill for many units.  See below for the bits that are used in the different units.
In general, if the unit has a fixed counter, it will use bit 0.  Counter 0 would use the next LSB, and the largest counter would use the MSB.
IMC: [5:0] w/ [0] = Fixed; [1] = Counter0 and [5] = Counter4
*/


#define PMONUNITSTATUS_MCDDC_CTL_REG 0x0B02285C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 counteroverflowbitmask : 6;

                            /* Bits[5:0], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               This is a bit-mask that specifies which counter
                               (or counters) have overflowed. If the unit has a
                               fixed counter, its corresponding bit-mask will
                               be stored at position 0.
                            */
    UINT32 rsvd : 26;

                            /* Bits[31:6], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONUNITSTATUS_MCDDC_CTL_STRUCT;

/* SCHEDULER_ECC_MODE_RANK_0_MCDDC_CTL_REG supported on:                        */
/*      SPRA0 (0x228a0)                                                         */
/*      SPRB0 (0x228a0)                                                         */
/*      SPRHBM (0x228a0)                                                        */
/*      SPRC0 (0x228a0)                                                         */
/*      SPRMCC (0x228a0)                                                        */
/*      SPRUCC (0x228a0)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
          This register specifies the current ECC configuration for each rank, for portions of the rank not participating in an ADDDC region.
      
*/


#define SCHEDULER_ECC_MODE_RANK_0_MCDDC_CTL_REG 0x0B0028A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mode : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the ECC in use for this
                               rank, for portions of the rank not participating
                               in an ADDDC region. 0 = No failure 1 = Parity
                               substitution. EP: Detect only, EX: Single bit
                               correction This field is set by software at the
                               beginning of a sparing flow.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} SCHEDULER_ECC_MODE_RANK_0_MCDDC_CTL_STRUCT;

/* SCHEDULER_ECC_MODE_RANK_1_MCDDC_CTL_REG supported on:                        */
/*      SPRA0 (0x228a1)                                                         */
/*      SPRB0 (0x228a1)                                                         */
/*      SPRHBM (0x228a1)                                                        */
/*      SPRC0 (0x228a1)                                                         */
/*      SPRMCC (0x228a1)                                                        */
/*      SPRUCC (0x228a1)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
          This register specifies the current ECC configuration for each rank, for portions of the rank not participating in an ADDDC region.
      
*/


#define SCHEDULER_ECC_MODE_RANK_1_MCDDC_CTL_REG 0x0B0028A1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mode : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the ECC in use for this
                               rank, for portions of the rank not participating
                               in an ADDDC region. 0 = No failure 1 = Parity
                               substitution. EP: Detect only, EX: Single bit
                               correction This field is set by software at the
                               beginning of a sparing flow.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} SCHEDULER_ECC_MODE_RANK_1_MCDDC_CTL_STRUCT;

/* SCHEDULER_ECC_MODE_RANK_2_MCDDC_CTL_REG supported on:                        */
/*      SPRA0 (0x228a2)                                                         */
/*      SPRB0 (0x228a2)                                                         */
/*      SPRHBM (0x228a2)                                                        */
/*      SPRC0 (0x228a2)                                                         */
/*      SPRMCC (0x228a2)                                                        */
/*      SPRUCC (0x228a2)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
          This register specifies the current ECC configuration for each rank, for portions of the rank not participating in an ADDDC region.
      
*/


#define SCHEDULER_ECC_MODE_RANK_2_MCDDC_CTL_REG 0x0B0028A2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mode : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the ECC in use for this
                               rank, for portions of the rank not participating
                               in an ADDDC region. 0 = No failure 1 = Parity
                               substitution. EP: Detect only, EX: Single bit
                               correction This field is set by software at the
                               beginning of a sparing flow.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} SCHEDULER_ECC_MODE_RANK_2_MCDDC_CTL_STRUCT;

/* SCHEDULER_ECC_MODE_RANK_3_MCDDC_CTL_REG supported on:                        */
/*      SPRA0 (0x228a3)                                                         */
/*      SPRB0 (0x228a3)                                                         */
/*      SPRHBM (0x228a3)                                                        */
/*      SPRC0 (0x228a3)                                                         */
/*      SPRMCC (0x228a3)                                                        */
/*      SPRUCC (0x228a3)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
          This register specifies the current ECC configuration for each rank, for portions of the rank not participating in an ADDDC region.
      
*/


#define SCHEDULER_ECC_MODE_RANK_3_MCDDC_CTL_REG 0x0B0028A3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mode : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the ECC in use for this
                               rank, for portions of the rank not participating
                               in an ADDDC region. 0 = No failure 1 = Parity
                               substitution. EP: Detect only, EX: Single bit
                               correction This field is set by software at the
                               beginning of a sparing flow.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} SCHEDULER_ECC_MODE_RANK_3_MCDDC_CTL_STRUCT;

/* SCHEDULER_ECC_MODE_RANK_4_MCDDC_CTL_REG supported on:                        */
/*      SPRA0 (0x228a4)                                                         */
/*      SPRB0 (0x228a4)                                                         */
/*      SPRHBM (0x228a4)                                                        */
/*      SPRC0 (0x228a4)                                                         */
/*      SPRMCC (0x228a4)                                                        */
/*      SPRUCC (0x228a4)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
          This register specifies the current ECC configuration for each rank, for portions of the rank not participating in an ADDDC region.
      
*/


#define SCHEDULER_ECC_MODE_RANK_4_MCDDC_CTL_REG 0x0B0028A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mode : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the ECC in use for this
                               rank, for portions of the rank not participating
                               in an ADDDC region. 0 = No failure 1 = Parity
                               substitution. EP: Detect only, EX: Single bit
                               correction This field is set by software at the
                               beginning of a sparing flow.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} SCHEDULER_ECC_MODE_RANK_4_MCDDC_CTL_STRUCT;

/* SCHEDULER_ECC_MODE_RANK_5_MCDDC_CTL_REG supported on:                        */
/*      SPRA0 (0x228a5)                                                         */
/*      SPRB0 (0x228a5)                                                         */
/*      SPRHBM (0x228a5)                                                        */
/*      SPRC0 (0x228a5)                                                         */
/*      SPRMCC (0x228a5)                                                        */
/*      SPRUCC (0x228a5)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
          This register specifies the current ECC configuration for each rank, for portions of the rank not participating in an ADDDC region.
      
*/


#define SCHEDULER_ECC_MODE_RANK_5_MCDDC_CTL_REG 0x0B0028A5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mode : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the ECC in use for this
                               rank, for portions of the rank not participating
                               in an ADDDC region. 0 = No failure 1 = Parity
                               substitution. EP: Detect only, EX: Single bit
                               correction This field is set by software at the
                               beginning of a sparing flow.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} SCHEDULER_ECC_MODE_RANK_5_MCDDC_CTL_STRUCT;

/* SCHEDULER_ECC_MODE_RANK_6_MCDDC_CTL_REG supported on:                        */
/*      SPRA0 (0x228a6)                                                         */
/*      SPRB0 (0x228a6)                                                         */
/*      SPRHBM (0x228a6)                                                        */
/*      SPRC0 (0x228a6)                                                         */
/*      SPRMCC (0x228a6)                                                        */
/*      SPRUCC (0x228a6)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
          This register specifies the current ECC configuration for each rank, for portions of the rank not participating in an ADDDC region.
      
*/


#define SCHEDULER_ECC_MODE_RANK_6_MCDDC_CTL_REG 0x0B0028A6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mode : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the ECC in use for this
                               rank, for portions of the rank not participating
                               in an ADDDC region. 0 = No failure 1 = Parity
                               substitution. EP: Detect only, EX: Single bit
                               correction This field is set by software at the
                               beginning of a sparing flow.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} SCHEDULER_ECC_MODE_RANK_6_MCDDC_CTL_STRUCT;

/* SCHEDULER_ECC_MODE_RANK_7_MCDDC_CTL_REG supported on:                        */
/*      SPRA0 (0x228a7)                                                         */
/*      SPRB0 (0x228a7)                                                         */
/*      SPRHBM (0x228a7)                                                        */
/*      SPRC0 (0x228a7)                                                         */
/*      SPRMCC (0x228a7)                                                        */
/*      SPRUCC (0x228a7)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
          This register specifies the current ECC configuration for each rank, for portions of the rank not participating in an ADDDC region.
      
*/


#define SCHEDULER_ECC_MODE_RANK_7_MCDDC_CTL_REG 0x0B0028A7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mode : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the ECC in use for this
                               rank, for portions of the rank not participating
                               in an ADDDC region. 0 = No failure 1 = Parity
                               substitution. EP: Detect only, EX: Single bit
                               correction This field is set by software at the
                               beginning of a sparing flow.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} SCHEDULER_ECC_MODE_RANK_7_MCDDC_CTL_STRUCT;

/* PMONDBGCNTRESETVAL_N0_MCDDC_CTL_REG supported on:                            */
/*      SPRA0 (0x200228c0)                                                      */
/*      SPRB0 (0x200228c0)                                                      */
/*      SPRHBM (0x200228c0)                                                     */
/*      SPRC0 (0x200228c0)                                                      */
/*      SPRMCC (0x200228c0)                                                     */
/*      SPRUCC (0x200228c0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Perfmon counter reset value.  This is for debug only.  Whenever counter 4 is reset, it will load this value instead of resetting to zero.
*/


#define PMONDBGCNTRESETVAL_N0_MCDDC_CTL_REG 0x0B0228C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 resetval : 32;

                            /* Bits[31:0], Access Type=RW/L, default=0x00000000*/

                            /* The value to reset the counter to. */

  } Bits;
  UINT32 Data;

} PMONDBGCNTRESETVAL_N0_MCDDC_CTL_STRUCT;

/* PMONDBGCNTRESETVAL_N1_MCDDC_CTL_REG supported on:                            */
/*      SPRA0 (0x200228c4)                                                      */
/*      SPRB0 (0x200228c4)                                                      */
/*      SPRHBM (0x200228c4)                                                     */
/*      SPRC0 (0x200228c4)                                                      */
/*      SPRMCC (0x200228c4)                                                     */
/*      SPRUCC (0x200228c4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Perfmon counter reset value.  This is for debug only.  Whenever counter 4 is reset, it will load this value instead of resetting to zero.
*/


#define PMONDBGCNTRESETVAL_N1_MCDDC_CTL_REG 0x0B0228C4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 resetval : 16;

                            /* Bits[15:0], Access Type=RW/L, default=0x00000000*/

                            /* The value to reset the counter to. */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONDBGCNTRESETVAL_N1_MCDDC_CTL_STRUCT;

/* PMONDBGCTRL_MCDDC_CTL_REG supported on:                                      */
/*      SPRA0 (0x200228c8)                                                      */
/*      SPRB0 (0x200228c8)                                                      */
/*      SPRHBM (0x200228c8)                                                     */
/*      SPRC0 (0x200228c8)                                                      */
/*      SPRMCC (0x200228c8)                                                     */
/*      SPRUCC (0x200228c8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Control register for the special debug wrapper around counter 4 in the Home Agent.
*/


#define PMONDBGCTRL_MCDDC_CTL_REG 0x0B0228C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 1;

                            /* Bits[0:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 othereventstopen : 1;

                            /* Bits[1:1], Access Type=RW/L, default=0x00000000*/

                            /*
                               When this is set, the counters enable bit will
                               be set to 0 whenever the partner counters event
                               occurs. This should be used with the Pulse Width
                               and A after B usage models.
                            */
    UINT32 rsvd_2 : 3;

                            /* Bits[4:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 othereventstarten : 1;

                            /* Bits[5:5], Access Type=RW/L, default=0x00000000*/

                            /*
                               When this bit is set, the counters enable bit
                               will be set to 1 whenever the partner counters
                               event occurs. This is an optional event, which
                               is generally intended for cases when we need to
                               use the queue occupancy counter, which only
                               exists on counter 3.
                            */
    UINT32 rsvd_6 : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 myeventstarten : 1;

                            /* Bits[7:7], Access Type=RW/L, default=0x00000000*/

                            /*
                               When this is set, the counters enable bit will
                               automatically be set to 1 whenever the event
                               occurs. It is generally used with the
                               ClockedIncEn bit. It is used in the Pulse Widge,
                               A after B, and Inactivity usage models.
                            */
    UINT32 rsvd_8 : 1;

                            /* Bits[8:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 othereventreseten : 1;

                            /* Bits[9:9], Access Type=RW/L, default=0x00000000*/

                            /*
                               When this bit is set, the counter will reset
                               whenever the partner counters event occurs. This
                               is used by the Pulse Width and A after B usage
                               models.
                            */
    UINT32 rsvd_10 : 1;

                            /* Bits[10:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 myeventreseten : 1;

                            /* Bits[11:11], Access Type=RW/L, default=0x00000000*/

                            /*
                               When this is enabled, the counter will reset
                               whenever the counters event is triggered. This
                               is used by the Inactivity usage model.
                            */
    UINT32 rsvd_12 : 1;

                            /* Bits[12:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 clockedincenable : 1;

                            /* Bits[13:13], Access Type=RW/L, default=0x00000000*/

                            /*
                               Changes when the counter increments. Rather than
                               incrementing based on the event, the counter
                               will increment by 1 in each cycle. This is used
                               by the Pulse Widge, A after B, and Inactivity
                               usage models.
                            */
    UINT32 rsvd_14 : 18;

                            /* Bits[31:14], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PMONDBGCTRL_MCDDC_CTL_STRUCT;

/* DDRT_MM_DDR4_CMD_THRESH_MCDDC_CTL_REG supported on:                          */
/*      SPRA0 (0x20022900)                                                      */
/*      SPRB0 (0x20022900)                                                      */
/*      SPRHBM (0x20022900)                                                     */
/*      SPRC0 (0x20022900)                                                      */
/*      SPRMCC (0x20022900)                                                     */
/*      SPRUCC (0x20022900)                                                     */
/* Register default value on SPRA0: 0x00001B1B                                  */
/* Register default value on SPRB0: 0x00001B1B                                  */
/* Register default value on SPRHBM: 0x00001B1B                                 */
/* Register default value on SPRC0: 0x00001B1B                                  */
/* Register default value on SPRMCC: 0x00001B1B                                 */
/* Register default value on SPRUCC: 0x00001B1B                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler DDR4 command thresholds to switch from DDR4 to DDRT mode
*/


#define DDRT_MM_DDR4_CMD_THRESH_MCDDC_CTL_REG 0x0B022900

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddr4_wr_cmd_threshold : 6;

                            /* Bits[5:0], Access Type=RW, default=0x0000001B*/

                            /*
                               Number of pending DDR4 Writes per pseudo-channel
                               to force a switch from DDRT to DDR4.
                            */
    UINT32 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddr4_rd_cmd_threshold : 6;

                            /* Bits[13:8], Access Type=RW, default=0x0000001B*/

                            /*
                               Number of pending DDR4 Reads per pseudo-channel
                               to force a switch from DDRT to DDR4.
                            */
    UINT32 rsvd_14 : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ignore_aged_pwr : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Default behavior is for aged partial-write (PWR)
                               to force a switch from DDRT to DDR4. Set this
                               bit to ignore starved PWRs
                            */
    UINT32 enable_wpq_critical : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Enable a critical priority write to force a
                               switch from DDRT to DDR4.
                            */
    UINT32 rsvd_18 : 6;

                            /* Bits[23:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 enable_rpq_critical : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Enable a critical priority read to force a
                               switch from DDRT to DDR4.
                            */
    UINT32 rsvd_25 : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DDRT_MM_DDR4_CMD_THRESH_MCDDC_CTL_STRUCT;

/* MCSCHEDS_CMI_N0_MCDDC_CTL_REG supported on:                                  */
/*      SPRA0 (0x20022908)                                                      */
/*      SPRB0 (0x20022908)                                                      */
/*      SPRHBM (0x20022908)                                                     */
/*      SPRC0 (0x20022908)                                                      */
/*      SPRMCC (0x20022908)                                                     */
/*      SPRUCC (0x20022908)                                                     */
/* Register default value on SPRA0: 0xC02CC02D                                  */
/* Register default value on SPRB0: 0xC02CC02D                                  */
/* Register default value on SPRHBM: 0xC02CC02D                                 */
/* Register default value on SPRC0: 0xC02CC02D                                  */
/* Register default value on SPRMCC: 0xC02CC02D                                 */
/* Register default value on SPRUCC: 0xC02CC02D                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* MC scheds CMI configuration register.
*/


#define MCSCHEDS_CMI_N0_MCDDC_CTL_REG 0x0B022908

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ddr4_rd_cpl_tid_parity_vld : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /* Valid bit to qualify rd_cpl tid parity bit */
    UINT32 ddr4_tid_parity_inj_enable : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Enable bit to control ddr4 rd_cpl tid parity
                               error injection
                            */
    UINT32 ddr4_tid_parity_inj_once : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               When set, only one parity error will be
                               injected. When cleared, errors will be
                               continually injected via the lfsr.
                            */
    UINT32 ddr4_tid_parity_inj_seed : 10;

                            /* Bits[12:3], Access Type=RW, default=0x00000005*/

                            /* Seed for parity injection lfsr */
    UINT32 ddr4_tid_parity_inj_width : 4;

                            /* Bits[16:13], Access Type=RW, default=0x00000006*/

                            /* Width of parity injection lfsr */
    UINT32 rpb_entry_parity_inj_enable : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Enable bit to control rpb entry parity error
                               injection
                            */
    UINT32 rpb_entry_parity_inj_once : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000001*/

                            /*
                               When set, only one rpb entry parity error will
                               be injected. When cleared, errors will be
                               continually injected via the lfsr.
                            */
    UINT32 rpb_entry_parity_inj_seed : 10;

                            /* Bits[28:19], Access Type=RW, default=0x00000005*/

                            /* Seed for rpb entry parity injection lfsr */
    UINT32 rpb_entry_parity_inj_width : 3;

                            /* Bits[31:29], Access Type=RW, default=0x00000006*/

                            /* Width of rpb entry parity injection lfsr */

  } Bits;
  UINT32 Data;

} MCSCHEDS_CMI_N0_MCDDC_CTL_STRUCT;

/* MCSCHEDS_CMI_N1_MCDDC_CTL_REG supported on:                                  */
/*      SPRA0 (0x2002290c)                                                      */
/*      SPRB0 (0x2002290c)                                                      */
/*      SPRHBM (0x2002290c)                                                     */
/*      SPRC0 (0x2002290c)                                                      */
/*      SPRMCC (0x2002290c)                                                     */
/*      SPRUCC (0x2002290c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* MC scheds CMI configuration register.
*/


#define MCSCHEDS_CMI_N1_MCDDC_CTL_REG 0x0B02290C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rpb_entry_parity_inj_width : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Width of rpb entry parity injection lfsr */
    UINT32 vld : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Valid bit to signify firmware has programmed the
                               necessary fields
                            */
    UINT32 rsvd : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCSCHEDS_CMI_N1_MCDDC_CTL_STRUCT;

/* MCSCHEDS_ECC_RETRY_MCDDC_CTL_REG supported on:                               */
/*      SPRA0 (0x20022910)                                                      */
/*      SPRB0 (0x20022910)                                                      */
/*      SPRHBM (0x20022910)                                                     */
/*      SPRC0 (0x20022910)                                                      */
/*      SPRMCC (0x20022910)                                                     */
/*      SPRUCC (0x20022910)                                                     */
/* Register default value on SPRA0: 0x2001000F                                  */
/* Register default value on SPRB0: 0x2001000F                                  */
/* Register default value on SPRHBM: 0x2001000F                                 */
/* Register default value on SPRC0: 0x2001000F                                  */
/* Register default value on SPRMCC: 0x2001000F                                 */
/* Register default value on SPRUCC: 0x2001000F                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* ECC retry configuration register.
*/


#define MCSCHEDS_ECC_RETRY_MCDDC_CTL_REG 0x0B022910

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecc_retry_fail_limit : 16;

                            /* Bits[15:0], Access Type=RW, default=0x0000000F*/

                            /* ECC retry fail limit */
    UINT32 mc_ecc_scrub_wr_count : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000001*/

                            /*
                               Wait time for ECC retry FSM to wait for scrub
                               write
                            */
    UINT32 disable_pat_scrub_corr : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /* Disable patrol scrub for correctable error */
    UINT32 disable_pat_scrub_uncorr : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /* Disable patrol scrub for uncorrectable error */
    UINT32 mc_ecc_infinite_retries : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /* Set infinite number of retries */
    UINT32 mc_pwr_uc_dealloc : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               De-allocate 1LM partial writes from WPQ in the
                               case of an uncorrectable error
                            */
    UINT32 mc_ecc_on_retry : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /* When set, skip transient retry */
    UINT32 mc_skip_pwr_retry_after_patrol_merge : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000001*/

                            /*
                               Enable bug fix for 1909297286; when set, the
                               retry FSM will skip retrying the 1st PWR ECC
                               error because it should be retried during
                               PATROL_DRAIN/RETRY due to merging with a patrol
                               entry.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCSCHEDS_ECC_RETRY_MCDDC_CTL_STRUCT;

/* SCHEDULER_DELAY_MCDDC_CTL_REG supported on:                                  */
/*      SPRA0 (0x20022920)                                                      */
/*      SPRB0 (0x20022920)                                                      */
/*      SPRHBM (0x20022920)                                                     */
/*      SPRC0 (0x20022920)                                                      */
/*      SPRMCC (0x20022920)                                                     */
/*      SPRUCC (0x20022920)                                                     */
/* Register default value on SPRA0: 0x00190000                                  */
/* Register default value on SPRB0: 0x00190000                                  */
/* Register default value on SPRHBM: 0x00190000                                 */
/* Register default value on SPRC0: 0x00190000                                  */
/* Register default value on SPRMCC: 0x00190000                                 */
/* Register default value on SPRUCC: 0x00190000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Configuration register
*/


#define SCHEDULER_DELAY_MCDDC_CTL_REG 0x0B022920

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 16;

                            /* Bits[15:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 write_err_latency : 6;

                            /* Bits[21:16], Access Type=RW, default=0x00000019*/

                            /*
                               GS Write Error Latency Delay line, program the
                               number of HCLKs needed to cover the latency for
                               CAP or WrCRC error: (link_err_latency/2-2) where
                               the divide by 2 is used to account for HCLK
                               instead of dclk. Without CAP or WrCRC error: tWL
                               (tWL/2). Value needs to be 3 or greater.
                            */
    UINT32 rsvd_22 : 10;

                            /* Bits[31:22], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_DELAY_MCDDC_CTL_STRUCT;

/* SCHEDULER_ENABLES_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20022928)                                                      */
/*      SPRB0 (0x20022928)                                                      */
/*      SPRHBM (0x20022928)                                                     */
/*      SPRC0 (0x20022928)                                                      */
/*      SPRMCC (0x20022928)                                                     */
/*      SPRUCC (0x20022928)                                                     */
/* Register default value on SPRA0: 0x00001F10                                  */
/* Register default value on SPRB0: 0x00001F10                                  */
/* Register default value on SPRHBM: 0x00001F10                                 */
/* Register default value on SPRC0: 0x00001F10                                  */
/* Register default value on SPRMCC: 0x00001F10                                 */
/* Register default value on SPRUCC: 0x00001F10                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Configuration
*/


#define SCHEDULER_ENABLES_MCDDC_CTL_REG 0x0B022928

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 idle_bypass_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Enable Read Idle ACT bypass; Must be disabled in
                               3N command mode (memory_timings_adj.cmd_stretch
                               = 3), Must program the required bypass safe
                               logic registers
                            */
    UINT32 bank_idle_bypass_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Enable Read BankIdle Bypass */
    UINT32 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 xpq_llt_en : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               If open-page mode, if set enables pending queue
                               tracker that connects select chains across the
                               WPQ and RPQ to improve page hits.
                            */
    UINT32 rpq_vc1_llt_en : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               For the RPQ, if set, forces all VC1 traffic
                               ignore page-hit optimizations (single-entry
                               linked-list)
                            */
    UINT32 deprd_after_write : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               For the RPQ, if set, dependent read will fetch
                               from dram
                            */
    UINT32 rsvd_6 : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 deprd_wpq_threshold : 5;

                            /* Bits[12:8], Access Type=RW, default=0x0000001F*/

                            /*
                               Number of WPQ entry (per PCH) to start the
                               counter to break deadlock; should be equal to
                               number of WPQ entry used. The value should be
                               equal to min(cmi_mc_wpq4_1_shared_credits,
                               cmi_mc_wpq4_0_shared_credits) + min
                               (cmi_mc_wr_req_credits_floor[0],
                               cmi_mc_wr_req_credits_floor[1],
                               cmi_mc_wr_req_credits_floor[3]), where
                               cmi_mc_wr_req_credits_floor[*] included should
                               have non-zero value. If the value is zero, this
                               implies that the VC is not in use. There is no
                               need to include the term then.
                            */
    UINT32 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cpgc_inorder_mode_en : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* Enable CGPC in-order mode. */
    UINT32 cpgc_second_cas_en : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Enable CGPC HBM2 second cas, it requires in-
                               order mode to be disabled
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 page_table_index_selection : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bank Scheduler Page-Table Mapping: 0=Rank[1],
                               1=Rank[2], 2=SubRank[0], 3=SubRank[1], 4=BA[1]
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 bank_scheduler_selection : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /*
                               0: {BG[2:0],BA[1:0]}; - DDR4/5 1-8 Ranks
                               DDR4:BG2==0 1: {BG[2:0],BA[1], SR[0]}; - DDR4/5
                               9-16 Ranks DDR4:BG2==0 2: {BG[2:0],SR[1:0]}; -
                               DDR4/5 17-32 Ranks DDR4:BG2==0 3:
                               {BG[2:0],R[1],BA[0]}; 4: {BG[2:0],R[1:0]}; 5:
                               {BG[2:0],R[2:1]}; 6,7, reserved
                            */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pseudo_channel_selection : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               Scheduler Pseudo-Channel Selection: DDR4:
                               0=Rank[0], 1=Rank[2], 2= (Rank[0] xor BG[0]),
                               3=(Rank[2] xor BG[0]); DDR5:0; HBM:0
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_ENABLES_MCDDC_CTL_SPRA0_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 idle_bypass_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Enable Read Idle ACT bypass; Must be disabled in
                               3N command mode (memory_timings_adj.cmd_stretch
                               = 3), Must program the required bypass safe
                               logic registers
                            */
    UINT32 bank_idle_bypass_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Enable Read BankIdle Bypass */
    UINT32 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 xpq_llt_en : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               If open-page mode, if set enables pending queue
                               tracker that connects select chains across the
                               WPQ and RPQ to improve page hits.
                            */
    UINT32 rpq_vc1_llt_en : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               For the RPQ, if set, forces all VC1 traffic
                               ignore page-hit optimizations (single-entry
                               linked-list)
                            */
    UINT32 deprd_after_write : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               For the RPQ, if set, dependent read will fetch
                               from dram
                            */
    UINT32 rsvd_6 : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 deprd_wpq_threshold : 5;

                            /* Bits[12:8], Access Type=RW, default=0x0000001F*/

                            /*
                               Number of WPQ entry (per PCH) to start the
                               counter to break deadlock; should be equal to
                               number of WPQ entry used. The value should be
                               equal to min(cmi_mc_wpq4_1_shared_credits,
                               cmi_mc_wpq4_0_shared_credits) + min
                               (cmi_mc_wr_req_credits_floor[0],
                               cmi_mc_wr_req_credits_floor[1],
                               cmi_mc_wr_req_credits_floor[3]), where
                               cmi_mc_wr_req_credits_floor[*] included should
                               have non-zero value. If the value is zero, this
                               implies that the VC is not in use. There is no
                               need to include the term then.
                            */
    UINT32 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cpgc_inorder_mode_en : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* Enable CGPC in-order mode. */
    UINT32 cpgc_second_cas_en : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Enable CGPC HBM2 second cas, it requires in-
                               order mode to be disabled
                            */
    UINT32 qr_force_throttle_en : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               If set, pushes all throttling checks from the
                               queue-router to the pending queue. Required for
                               CPGC inorder mode.
                            */
    UINT32 rsvd_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 page_table_index_selection : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bank Scheduler Page-Table Mapping: 0=Rank[1],
                               1=Rank[2], 2=SubRank[0], 3=SubRank[1], 4=BA[1]
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 bank_scheduler_selection : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /*
                               0: {BG[2:0],BA[1:0]}; - DDR4/5 1-8 Ranks
                               DDR4:BG2==0 1: {BG[2:0],BA[0], SR[0]}; - DDR4/5
                               9-16 Ranks DDR4:BG2==0 2: {BG[2:0],SR[1:0]}; -
                               DDR4/5 17-32 Ranks DDR4:BG2==0 3:
                               {BG[2:0],R[1],BA[0]}; 4: {BG[2:0],R[1:0]}; 5:
                               {BG[2:0],R[2:1]}; 6: {BG[2:0],BA[1], SR[0]}; 7,
                               reserved
                            */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pseudo_channel_selection : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               Scheduler Pseudo-Channel Selection: DDR4:
                               0=Rank[0], 1=Rank[2], 2= (Rank[0] xor BG[0]),
                               3=(Rank[2] xor BG[0]); DDR5:0; HBM:0
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_ENABLES_MCDDC_CTL_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 idle_bypass_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Enable Read Idle ACT bypass; Must be disabled in
                               3N command mode (memory_timings_adj.cmd_stretch
                               = 3), Must program the required bypass safe
                               logic registers
                            */
    UINT32 bank_idle_bypass_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Enable Read BankIdle Bypass */
    UINT32 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 xpq_llt_en : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               If open-page mode, if set enables pending queue
                               tracker that connects select chains across the
                               WPQ and RPQ to improve page hits.
                            */
    UINT32 rpq_vc1_llt_en : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               For the RPQ, if set, forces all VC1 traffic
                               ignore page-hit optimizations (single-entry
                               linked-list)
                            */
    UINT32 deprd_after_write : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               For the RPQ, if set, dependent read will fetch
                               from dram
                            */
    UINT32 rsvd_6 : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 deprd_wpq_threshold : 5;

                            /* Bits[12:8], Access Type=RW, default=0x0000001F*/

                            /*
                               Number of WPQ entry (per PCH) to start the
                               counter to break deadlock; should be equal to
                               number of WPQ entry used. The value should be
                               equal to min(cmi_mc_wpq4_1_shared_credits,
                               cmi_mc_wpq4_0_shared_credits) + min
                               (cmi_mc_wr_req_credits_floor[0],
                               cmi_mc_wr_req_credits_floor[1],
                               cmi_mc_wr_req_credits_floor[3]), where
                               cmi_mc_wr_req_credits_floor[*] included should
                               have non-zero value. If the value is zero, this
                               implies that the VC is not in use. There is no
                               need to include the term then.
                            */
    UINT32 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 cpgc_inorder_mode_en : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* Enable CGPC in-order mode. */
    UINT32 cpgc_second_cas_en : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Enable CGPC HBM2 second cas, it requires in-
                               order mode to be disabled
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 page_table_index_selection : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bank Scheduler Page-Table Mapping: 0=Rank[1],
                               1=Rank[2], 2=SubRank[0], 3=SubRank[1], 4=BA[1]
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 bank_scheduler_selection : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /*
                               0: {BG[2:0],BA[1:0]}; - DDR4/5 1-8 Ranks
                               DDR4:BG2==0 1: {BG[2:0],BA[1], SR[0]}; - DDR4/5
                               9-16 Ranks DDR4:BG2==0 2: {BG[2:0],SR[1:0]}; -
                               DDR4/5 17-32 Ranks DDR4:BG2==0 3:
                               {BG[2:0],R[1],BA[0]}; 4: {BG[2:0],R[1:0]}; 5:
                               {BG[2:0],R[2:1]}; 6,7, reserved
                            */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pseudo_channel_selection : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               Scheduler Pseudo-Channel Selection: DDR4:
                               0=Rank[0], 1=Rank[2], 2= (Rank[0] xor BG[0]),
                               3=(Rank[2] xor BG[0]); DDR5:0; HBM:0
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_ENABLES_MCDDC_CTL_STRUCT;

/* SCHEDULER_PENDINGQ_MCDDC_CTL_REG supported on:                               */
/*      SPRA0 (0x20022930)                                                      */
/*      SPRB0 (0x20022930)                                                      */
/*      SPRHBM (0x20022930)                                                     */
/*      SPRC0 (0x20022930)                                                      */
/*      SPRMCC (0x20022930)                                                     */
/*      SPRUCC (0x20022930)                                                     */
/* Register default value on SPRA0: 0x04040001                                  */
/* Register default value on SPRB0: 0x04040001                                  */
/* Register default value on SPRHBM: 0x04040001                                 */
/* Register default value on SPRC0: 0x04040001                                  */
/* Register default value on SPRMCC: 0x04040001                                 */
/* Register default value on SPRUCC: 0x04040001                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Pending Queue Configurations
*/


#define SCHEDULER_PENDINGQ_MCDDC_CTL_REG 0x0B022930

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rpq_priority_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Enables arbitration based on Prioritization of
                               transactions, requires PQ QOS and/or VC1 (ISOCH)
                               prioritization
                            */
    UINT32 rpq_empty_llt_priority_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Enable arbitration that allows page-empty
                               linked-lists size greater than one equal
                               priority as page-hits to alternate page-table of
                               the same bank-scheduler.
                            */
    UINT32 rsvd : 6;

                            /* Bits[7:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 wpq_priority_en : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Enables arbitration based on Prioritization of
                               transactions, requires PQ QOS and/or VC1 (ISOCH)
                               prioritization
                            */
    UINT32 wpq_empty_llt_priority_en : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Enable arbitration that allows page-empty
                               linked-lists size greater than one equal
                               priority as page-hits to alternate page-table of
                               the same bank-scheduler.
                            */
    UINT32 rsvd_10 : 6;

                            /* Bits[15:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rpq_link_list_threshold : 6;

                            /* Bits[21:16], Access Type=RW, default=0x00000004*/

                            /*
                               Number of additional transactions to process on
                               a given linked-list before looking for alternate
                               list to a given page-table. Value of 0 is
                               disabled, a value of 1 will send 2 transactions
                               on the same page before looking for another
                               linked list.
                            */
    UINT32 rsvd_22 : 2;

                            /* Bits[23:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 wpq_link_list_threshold : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000004*/

                            /*
                               Number of additional transactions to process on
                               a given linked-list before looking for alternate
                               list to a given page-table. Value of 0 is
                               disabled, a value of 1 will send 2 transactions
                               on the same page before looking for another
                               linked list.
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_PENDINGQ_MCDDC_CTL_STRUCT;

/* SCHEDULER_QOS_HIGH_MCDDC_CTL_REG supported on:                               */
/*      SPRA0 (0x20022934)                                                      */
/*      SPRB0 (0x20022934)                                                      */
/*      SPRHBM (0x20022934)                                                     */
/*      SPRC0 (0x20022934)                                                      */
/*      SPRMCC (0x20022934)                                                     */
/*      SPRUCC (0x20022934)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Configuration Promotion HIGH register
*/


#define SCHEDULER_QOS_HIGH_MCDDC_CTL_REG 0x0B022934

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 qos_hightimer_lim : 12;

                            /* Bits[11:0], Access Type=RW, default=0x00000000*/

                            /*
                               QOS Timer heartbeat (in HCLKs) for HIGH priority
                               promotions.
                            */
    UINT32 rsvd : 12;

                            /* Bits[23:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 qos_highenable : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Enable Promotion of HIGH priority transactions.
                               A promotion of an entry requires two heartbeats
                               where the second heartbeat will be the full
                               window.
                            */
    UINT32 rsvd_25 : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_QOS_HIGH_MCDDC_CTL_STRUCT;

/* SCHEDULER_QOS_LOW_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20022938)                                                      */
/*      SPRB0 (0x20022938)                                                      */
/*      SPRHBM (0x20022938)                                                     */
/*      SPRC0 (0x20022938)                                                      */
/*      SPRMCC (0x20022938)                                                     */
/*      SPRUCC (0x20022938)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Configuration Promotion LOW register
*/


#define SCHEDULER_QOS_LOW_MCDDC_CTL_REG 0x0B022938

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 qos_lowtimer_lim : 12;

                            /* Bits[11:0], Access Type=RW, default=0x00000000*/

                            /*
                               QOS Timer heartbeat (in HCLKs) for LOW priority
                               promotions.
                            */
    UINT32 rsvd : 12;

                            /* Bits[23:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 qos_lowenable : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Enable Promotion of LOW priority transactions. A
                               promotion of an entry requires two heartbeats
                               where the second heartbeat will be the full
                               window.
                            */
    UINT32 rsvd_25 : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_QOS_LOW_MCDDC_CTL_STRUCT;

/* SCHEDULER_QOS_MED_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x2002293c)                                                      */
/*      SPRB0 (0x2002293c)                                                      */
/*      SPRHBM (0x2002293c)                                                     */
/*      SPRC0 (0x2002293c)                                                      */
/*      SPRMCC (0x2002293c)                                                     */
/*      SPRUCC (0x2002293c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Configuration Promotion MEDIUM register
*/


#define SCHEDULER_QOS_MED_MCDDC_CTL_REG 0x0B02293C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 qos_medtimer_lim : 12;

                            /* Bits[11:0], Access Type=RW, default=0x00000000*/

                            /*
                               QOS Timer heartbeat (in HCLKs) for MEDIUM
                               priority promotions.
                            */
    UINT32 rsvd : 12;

                            /* Bits[23:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 qos_medenable : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Enable Promotion of MEDIUM priority
                               transactions. A promotion of an entry requires
                               two heartbeats where the second heartbeat will
                               be the full window.
                            */
    UINT32 rsvd_25 : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_QOS_MED_MCDDC_CTL_STRUCT;

/* SCHEDULER_READ_STARVE_MCDDC_CTL_REG supported on:                            */
/*      SPRA0 (0x20022940)                                                      */
/*      SPRB0 (0x20022940)                                                      */
/*      SPRHBM (0x20022940)                                                     */
/*      SPRC0 (0x20022940)                                                      */
/*      SPRMCC (0x20022940)                                                     */
/*      SPRUCC (0x20022940)                                                     */
/* Register default value on SPRA0: 0x00640032                                  */
/* Register default value on SPRB0: 0x00640032                                  */
/* Register default value on SPRHBM: 0x00640032                                 */
/* Register default value on SPRC0: 0x00640032                                  */
/* Register default value on SPRMCC: 0x00640032                                 */
/* Register default value on SPRUCC: 0x00640032                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Read starvation configuration
*/


#define SCHEDULER_READ_STARVE_MCDDC_CTL_REG 0x0B022940

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 read_starve_count : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000032*/

                            /*
                               The number of HCLK before before a Read can be
                               considered starved by the Major-Mode Arbiter. A
                               value of 0 will disable this state.
                            */
    UINT32 rsvd : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 read_wait_count : 13;

                            /* Bits[28:16], Access Type=RW, default=0x00000064*/

                            /*
                               Maximum Duration (in HCLK) in the Major-Mode
                               Arbiter Read Starved State
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_READ_STARVE_MCDDC_CTL_STRUCT;

/* SCHEDULER_RMM_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20022944)                                                      */
/*      SPRB0 (0x20022944)                                                      */
/*      SPRHBM (0x20022944)                                                     */
/*      SPRC0 (0x20022944)                                                      */
/*      SPRMCC (0x20022944)                                                     */
/*      SPRUCC (0x20022944)                                                     */
/* Register default value on SPRA0: 0x00040304                                  */
/* Register default value on SPRB0: 0x00040304                                  */
/* Register default value on SPRHBM: 0x00040304                                 */
/* Register default value on SPRC0: 0x00040304                                  */
/* Register default value on SPRMCC: 0x00040304                                 */
/* Register default value on SPRUCC: 0x00040304                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Read Major Mode configuration
*/


#define SCHEDULER_RMM_MCDDC_CTL_REG 0x0B022944

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rmm_starved_exit_selection : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               While in starved-read major-mode, If set, use
                               the wmm_enter_threshold value, else use the
                               wmm_exit threshold
                            */
    UINT32 rmm_leaky_bucket_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Enable accumulation of leaky bucket credits
                               after amount of HCLKs specified by
                               RMM_Opportunistic_Timer in RMM
                            */
    UINT32 rpq_empty_opp_wr_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000001*/

                            /*
                               Enable selection of opportunistic transactions
                               in RMM if RPQ is empty
                            */
    UINT32 rmm_opp_write_limit_gran : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Leaky bucket credit increment value for a given
                               window: 0x0 = +1, 0x1 = +rmm_opp_write_limit
                            */
    UINT32 rmm_opp_timer_gran : 2;

                            /* Bits[5:4], Access Type=RW, default=0x00000000*/

                            /*
                               Leaky Bucket timer granularity for
                               rmm_opp_timer: 0x0 = x8, 0x1 = x16, 0x2 = x32,
                               0x3 = Reserved
                            */
    UINT32 ignore_opp_wr_on_starved_rmm : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Ignore opportunistic write transactions while in
                               starved read state
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rmm_opp_write_limit : 6;

                            /* Bits[13:8], Access Type=RW, default=0x00000003*/

                            /*
                               Maximum amount of Leaky Bucket credits that can
                               be available for a given window for writes to
                               use while in RMM
                            */
    UINT32 rmm_opp_timer : 4;

                            /* Bits[17:14], Access Type=RW, default=0x00000000*/

                            /*
                               Amount of HCLKs (value * rmm_opp_timer_gran)
                               that need to transpire before accumulating a
                               leaky bucket credit in RMM
                            */
    UINT32 rmm_write_hit_en : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000001*/

                            /*
                               Enable sending write hits while in read-major-
                               mode, per page-table limit will be configured by
                               wpq_link_list_threshold
                            */
    UINT32 rsvd_19 : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_RMM_MCDDC_CTL_STRUCT;

/* SCHEDULER_RPQ_PCH0_ENTRY_EN_MCDDC_CTL_REG supported on:                      */
/*      SPRA0 (0x20022948)                                                      */
/*      SPRB0 (0x20022948)                                                      */
/*      SPRHBM (0x20022948)                                                     */
/*      SPRC0 (0x20022948)                                                      */
/*      SPRMCC (0x20022948)                                                     */
/*      SPRUCC (0x20022948)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Read Pending Queue (RPQ) Entry Enable for the given scheduler pseudo channel
*/


#define SCHEDULER_RPQ_PCH0_ENTRY_EN_MCDDC_CTL_REG 0x0B022948

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rpq_pch0_entry_en : 32;

                            /* Bits[31:0], Access Type=RW, default=0xFFFFFFFF*/

                            /* RPQ Entries 0 - 31 enable */

  } Bits;
  UINT32 Data;

} SCHEDULER_RPQ_PCH0_ENTRY_EN_MCDDC_CTL_STRUCT;

/* SCHEDULER_RPQ_PCH1_ENTRY_EN_MCDDC_CTL_REG supported on:                      */
/*      SPRA0 (0x2002294c)                                                      */
/*      SPRB0 (0x2002294c)                                                      */
/*      SPRHBM (0x2002294c)                                                     */
/*      SPRC0 (0x2002294c)                                                      */
/*      SPRMCC (0x2002294c)                                                     */
/*      SPRUCC (0x2002294c)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Read Pending Queue (RPQ) Entry Enable for the given scheduler pseudo channel
*/


#define SCHEDULER_RPQ_PCH1_ENTRY_EN_MCDDC_CTL_REG 0x0B02294C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rpq_pch1_entry_en : 32;

                            /* Bits[31:0], Access Type=RW, default=0xFFFFFFFF*/

                            /* RPQ Entries 32 - 63 enable */

  } Bits;
  UINT32 Data;

} SCHEDULER_RPQ_PCH1_ENTRY_EN_MCDDC_CTL_STRUCT;

/* SCHEDULER_SCRATCH_MCDDC_CTL_REG supported on:                                */
/*      SPRA0 (0x20022950)                                                      */
/*      SPRB0 (0x20022950)                                                      */
/*      SPRHBM (0x20022950)                                                     */
/*      SPRC0 (0x20022950)                                                      */
/*      SPRMCC (0x20022950)                                                     */
/*      SPRUCC (0x20022950)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* reserved register for future ECOs
*/


#define SCHEDULER_SCRATCH_MCDDC_CTL_REG 0x0B022950

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 scratch : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* reserved register */

  } Bits;
  UINT32 Data;

} SCHEDULER_SCRATCH_MCDDC_CTL_STRUCT;

/* SCHEDULER_WMM_MCDDC_CTL_REG supported on:                                    */
/*      SPRA0 (0x20022954)                                                      */
/*      SPRB0 (0x20022954)                                                      */
/*      SPRHBM (0x20022954)                                                     */
/*      SPRC0 (0x20022954)                                                      */
/*      SPRMCC (0x20022954)                                                     */
/*      SPRUCC (0x20022954)                                                     */
/* Register default value on SPRA0: 0x981C00C2                                  */
/* Register default value on SPRB0: 0x981C00C2                                  */
/* Register default value on SPRHBM: 0x981C00C2                                 */
/* Register default value on SPRC0: 0x981C00C2                                  */
/* Register default value on SPRMCC: 0x981C00C2                                 */
/* Register default value on SPRUCC: 0x981C00C2                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Write Major Mode configuration
*/


#define SCHEDULER_WMM_MCDDC_CTL_REG 0x0B022954

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wmm_leaky_bucket_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Enable accumulation of leaky bucket credits
                               after amount of HCLKs specified by
                               WMM_Opportunistic_Timer in RMM
                            */
    UINT32 wpq_empty_opp_rd_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Enable selection of opportunistic transactions
                               in WMM if WPQ is empty
                            */
    UINT32 wmm_opp_read_limit_gran : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Leaky Bucket credit increment value for a given
                               window: 0x0 = +1, 0x1 = +wmm_opp_write_limit
                            */
    UINT32 wmm_opp_timer_gran : 2;

                            /* Bits[4:3], Access Type=RW, default=0x00000000*/

                            /*
                               Leaky Bucket timer granularity for
                               wmm_opp_timer: 0x0 = x8, 0x1 = x16, 0x2 = x32,
                               0x3 = Reserved
                            */
    UINT32 ignore_opp_rd_on_starved_wmm : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Ignore opportunistic read transactions while in
                               starved WMM
                            */
    UINT32 wmm_opp_read_limit : 6;

                            /* Bits[11:6], Access Type=RW, default=0x00000003*/

                            /*
                               Maximum amount of Leaky Bucket credits that can
                               be available for a given window for reads to use
                               while in WMM
                            */
    UINT32 wmm_opp_timer : 4;

                            /* Bits[15:12], Access Type=RW, default=0x00000000*/

                            /*
                               Amount of HCLKs (value * wmm_opp_timer_gran)that
                               need to transpire before accumulating a Leaky
                               Bucket credit in WMM
                            */
    UINT32 wmm_enter_threshold : 6;

                            /* Bits[21:16], Access Type=RW, default=0x0000001C*/

                            /*
                               Number of Ready WPQ entries required before
                               switching to WMM.. WPQ Occupancy >= Threshold.
                               For sparing, set this greater than 5
                            */
    UINT32 rsvd : 2;

                            /* Bits[23:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 wmm_exit_threshold : 6;

                            /* Bits[29:24], Access Type=RW, default=0x00000018*/

                            /*
                               Number of Ready WPQ entries required to leave
                               WMM. WPQ Occupancy < Exit Threshold. For
                               sparing, set this greater than 4.
                            */
    UINT32 rsvd_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 wmm_read_hit_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               Enable sending read hits while in write-major-
                               mode, per bank-scheduler limit will be
                               configured by rpq_link_list_threshold
                            */

  } Bits;
  UINT32 Data;

} SCHEDULER_WMM_MCDDC_CTL_STRUCT;

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST)
/* SCHEDULER_WPQ_PCH0_ENTRY_EN_MCDDC_CTL_REG supported on:                      */
/*      SPRA0 (0x20022958)                                                      */
/*      SPRB0 (0x20022958)                                                      */
/*      SPRHBM (0x20022958)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* Write Pending Queue (WPQ) Entry Enable for the given scheduler pseudo channel
*/


#define SCHEDULER_WPQ_PCH0_ENTRY_EN_MCDDC_CTL_REG 0x0B022958

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wpq_pch0_entry_en : 32;

                            /* Bits[31:0], Access Type=RW, default=0xFFFFFFFF*/

                            /* WPQ Entries 0 - 31 enable */

  } Bits;
  UINT32 Data;

} SCHEDULER_WPQ_PCH0_ENTRY_EN_MCDDC_CTL_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* SCHEDULER_WPQ_PCH0_ENTRY_EN_N0_MCDDC_CTL_REG supported on:                   */
/*      SPRC0 (0x20022958)                                                      */
/*      SPRMCC (0x20022958)                                                     */
/*      SPRUCC (0x20022958)                                                     */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRC0 BDF: 0_0_0                                       */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Write Pending Queue (WPQ) Entry Enable for the given scheduler pseudo channel
*/


#define SCHEDULER_WPQ_PCH0_ENTRY_EN_N0_MCDDC_CTL_REG 0x0B022958

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wpq_pch0_entry_en : 32;

                            /* Bits[31:0], Access Type=RW, default=0xFFFFFFFF*/

                            /*
                               WPQ PCH0 Entries 0 - 39 enable; Entries 32-39
                               can only be enabled for non-Crystal Ridge
                               platforms
                            */

  } Bits;
  UINT32 Data;

} SCHEDULER_WPQ_PCH0_ENTRY_EN_N0_MCDDC_CTL_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST)
/* SCHEDULER_WPQ_PCH1_ENTRY_EN_MCDDC_CTL_REG supported on:                      */
/*      SPRA0 (0x2002295c)                                                      */
/*      SPRB0 (0x2002295c)                                                      */
/*      SPRHBM (0x2002295c)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* Write Pending Queue (WPQ) Entry Enable for the given scheduler pseudo channel
*/


#define SCHEDULER_WPQ_PCH1_ENTRY_EN_MCDDC_CTL_REG 0x0B02295C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wpq_pch1_entry_en : 32;

                            /* Bits[31:0], Access Type=RW, default=0xFFFFFFFF*/

                            /* WPQ Entries 32 - 63 enable */

  } Bits;
  UINT32 Data;

} SCHEDULER_WPQ_PCH1_ENTRY_EN_MCDDC_CTL_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* SCHEDULER_WPQ_PCH0_ENTRY_EN_N1_MCDDC_CTL_REG supported on:                   */
/*      SPRC0 (0x2002295c)                                                      */
/*      SPRMCC (0x2002295c)                                                     */
/*      SPRUCC (0x2002295c)                                                     */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRC0 BDF: 0_0_0                                       */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Write Pending Queue (WPQ) Entry Enable for the given scheduler pseudo channel
*/


#define SCHEDULER_WPQ_PCH0_ENTRY_EN_N1_MCDDC_CTL_REG 0x0B02295C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wpq_pch0_entry_en : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               WPQ PCH0 Entries 0 - 39 enable; Entries 32-39
                               can only be enabled for non-Crystal Ridge
                               platforms
                            */
    UINT32 rsvd : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_WPQ_PCH0_ENTRY_EN_N1_MCDDC_CTL_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

/* SCHEDULER_WRITE_STARVE_MCDDC_CTL_REG supported on:                           */
/*      SPRA0 (0x20022960)                                                      */
/*      SPRB0 (0x20022960)                                                      */
/*      SPRHBM (0x20022960)                                                     */
/*      SPRC0 (0x20022960)                                                      */
/*      SPRMCC (0x20022960)                                                     */
/*      SPRUCC (0x20022960)                                                     */
/* Register default value on SPRA0: 0x00C80064                                  */
/* Register default value on SPRB0: 0x00C80064                                  */
/* Register default value on SPRHBM: 0x00C80064                                 */
/* Register default value on SPRC0: 0x00C80064                                  */
/* Register default value on SPRMCC: 0x00C80064                                 */
/* Register default value on SPRUCC: 0x00C80064                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Write starvation configuration
*/


#define SCHEDULER_WRITE_STARVE_MCDDC_CTL_REG 0x0B022960

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 write_starve_count : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000064*/

                            /*
                               The number of HCLK before before a Write can be
                               considered starved by the Major-Mode Arbiter. A
                               value of 0 disables this state
                            */
    UINT32 rsvd : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 write_wait_count : 13;

                            /* Bits[28:16], Access Type=RW, default=0x000000C8*/

                            /*
                               Maximum Duration (in HCLK) in the Major-Mode
                               Write Starved State
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_WRITE_STARVE_MCDDC_CTL_STRUCT;

/* SCHEDULER_URGENT_STARVE_MCDDC_CTL_REG supported on:                          */
/*      SPRA0 (0x20022964)                                                      */
/*      SPRB0 (0x20022964)                                                      */
/*      SPRHBM (0x20022964)                                                     */
/*      SPRC0 (0x20022964)                                                      */
/*      SPRMCC (0x20022964)                                                     */
/*      SPRUCC (0x20022964)                                                     */
/* Register default value on SPRA0: 0x00640032                                  */
/* Register default value on SPRB0: 0x00640032                                  */
/* Register default value on SPRHBM: 0x00640032                                 */
/* Register default value on SPRC0: 0x00640032                                  */
/* Register default value on SPRMCC: 0x00640032                                 */
/* Register default value on SPRUCC: 0x00640032                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Read starvation configuration
*/


#define SCHEDULER_URGENT_STARVE_MCDDC_CTL_REG 0x0B022964

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 urgent_read_starve_count : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000032*/

                            /*
                               The number of HCLK before before a Read can be
                               considered starved by the Major-Mode Arbiter. A
                               value of 0 will disable this state.
                            */
    UINT32 rsvd : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 urgent_read_wait_count : 13;

                            /* Bits[28:16], Access Type=RW, default=0x00000064*/

                            /*
                               Maximum Duration (in HCLK) in the Major-Mode
                               Arbiter Read Starved State
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_URGENT_STARVE_MCDDC_CTL_STRUCT;

/* SCHEDULER_MMA_URGENT_WRITE_MCDDC_CTL_REG supported on:                       */
/*      SPRA0 (0x20022968)                                                      */
/*      SPRB0 (0x20022968)                                                      */
/*      SPRHBM (0x20022968)                                                     */
/*      SPRC0 (0x20022968)                                                      */
/*      SPRMCC (0x20022968)                                                     */
/*      SPRUCC (0x20022968)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Write starvation configuration
*/


#define SCHEDULER_MMA_URGENT_WRITE_MCDDC_CTL_REG 0x0B022968

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 urgent_write_threshold : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /* WPQ urgent write threshold */
    UINT32 rsvd : 10;

                            /* Bits[15:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 urgent_write_en : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* Number of directory writes to */
    UINT32 rsvd_17 : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_MMA_URGENT_WRITE_MCDDC_CTL_STRUCT;

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* SCHEDULER_MM_MCDDC_CTL_REG supported on:                                     */
/*      SPRB0 (0x2002296c)                                                      */
/*      SPRHBM (0x2002296c)                                                     */
/*      SPRC0 (0x2002296c)                                                      */
/*      SPRMCC (0x2002296c)                                                     */
/*      SPRUCC (0x2002296c)                                                     */
/* Register default value on SPRB0: 0x00000803                                  */
/* Register default value on SPRHBM: 0x00000803                                 */
/* Register default value on SPRC0: 0x00000803                                  */
/* Register default value on SPRMCC: 0x00000803                                 */
/* Register default value on SPRUCC: 0x00000803                                 */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Read Major Mode configuration
*/


#define SCHEDULER_MM_MCDDC_CTL_REG 0x0B02296C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sr_rmm_exit_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000001*/

                            /*
                               Enable rmm_exit_threshold check from starved-
                               read state to preferred read state in the Major-
                               Mode Arbiter.
                            */
    UINT32 pr_duration_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /*
                               Enable preferred read duration check from
                               preferred read state to preferred write state in
                               the Major-Mode Arbiter.
                            */
    UINT32 select_wpq_avail_occupancy : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               When set, the Major-Mode Arbiter will count
                               entries blocked by refresh for states that use
                               the WPQ_AVAIL occupancy count as defined in the
                               FSM
                            */
    UINT32 select_wpq_occupancy : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               When set, the Major-Mode Arbiter will not cunt
                               entries blocked by refresh for states that use
                               WPQ occupancy count as defined in the FSM
                            */
    UINT32 select_rpq_avail_occupancy : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               When set, the Major-Mode Aribter will count
                               entries blocked by refresh for states that use
                               RPQ_AVAIL occupancy count as defined in the FSM
                            */
    UINT32 select_rpq_sent_occupancy : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               When set, the Major-Mode Arbiter will count rpq
                               entries in the sent states that use RPQ_AVAIL
                               occupancy count as defined in the FSM
                            */
    UINT32 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rmm_exit_threshold : 6;

                            /* Bits[13:8], Access Type=RW, default=0x00000008*/

                            /*
                               Number of Ready RPQ entries required to leave
                               RMM. RPQ Occupancy < Exit Threshold.
                            */
    UINT32 rsvd_14 : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pr_min_stay : 9;

                            /* Bits[24:16], Access Type=RW, default=0x00000000*/

                            /*
                               The minimum number of HCLKs required to be in
                               preferred read state before considering the
                               rmm_exit_threshold. A value of 0 disables this
                               check.
                            */
    UINT32 rsvd_25 : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_MM_MCDDC_CTL_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* SCHEDULER_MMA_PREFERRED_STARVE_MCDDC_CTL_REG supported on:                   */
/*      SPRB0 (0x20022970)                                                      */
/*      SPRHBM (0x20022970)                                                     */
/*      SPRC0 (0x20022970)                                                      */
/*      SPRMCC (0x20022970)                                                     */
/*      SPRUCC (0x20022970)                                                     */
/* Register default value on SPRB0: 0x0FD00100                                  */
/* Register default value on SPRHBM: 0x0FD00100                                 */
/* Register default value on SPRC0: 0x0FD00100                                  */
/* Register default value on SPRMCC: 0x0FD00100                                 */
/* Register default value on SPRUCC: 0x0FD00100                                 */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Read starvation configuration
*/


#define SCHEDULER_MMA_PREFERRED_STARVE_MCDDC_CTL_REG 0x0B022970

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 read_starve_sr_count : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000100*/

                            /*
                               The number of HCLK before before a Read can be
                               considered starved by the Major-Mode Arbiter. A
                               value of 0 will disable this state.
                            */
    UINT32 rsvd : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 write_starve_sr_count : 13;

                            /* Bits[28:16], Access Type=RW, default=0x00000FD0*/

                            /*
                               Maximum Duration (in HCLK) in the Major-Mode
                               Arbiter Read Starved State
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_MMA_PREFERRED_STARVE_MCDDC_CTL_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* SCHEDULER_RMM_PREFERRED_DURATION_MCDDC_CTL_REG supported on:                 */
/*      SPRB0 (0x20022974)                                                      */
/*      SPRHBM (0x20022974)                                                     */
/*      SPRC0 (0x20022974)                                                      */
/*      SPRMCC (0x20022974)                                                     */
/*      SPRUCC (0x20022974)                                                     */
/* Register default value on SPRB0: 0x01CE0200                                  */
/* Register default value on SPRHBM: 0x01CE0200                                 */
/* Register default value on SPRC0: 0x01CE0200                                  */
/* Register default value on SPRMCC: 0x01CE0200                                 */
/* Register default value on SPRUCC: 0x01CE0200                                 */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Read starvation configuration
*/


#define SCHEDULER_RMM_PREFERRED_DURATION_MCDDC_CTL_REG 0x0B022974

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pr_duration_pw : 13;

                            /* Bits[12:0], Access Type=RW, default=0x00000200*/

                            /*
                               The minimum number of HCLKs required to be in
                               preferred read state before considering the
                               wpq_enter_threshold. Disable this check by
                               clearing en_pr_duration.
                            */
    UINT32 rsvd : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pr_duration_sr : 13;

                            /* Bits[28:16], Access Type=RW, default=0x000001CE*/

                            /*
                               The minimum number of HCLKs required to be in
                               preferred read state before considering the
                               wpq_enter_threshold. Disable this check by
                               clearing en_pr_duration.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_RMM_PREFERRED_DURATION_MCDDC_CTL_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* SCHEDULER_MM_CAS_BLOCK_MCDDC_CTL_REG supported on:                           */
/*      SPRB0 (0x20022978)                                                      */
/*      SPRHBM (0x20022978)                                                     */
/*      SPRC0 (0x20022978)                                                      */
/*      SPRMCC (0x20022978)                                                     */
/*      SPRUCC (0x20022978)                                                     */
/* Register default value on SPRB0: 0x000003CF                                  */
/* Register default value on SPRHBM: 0x000003CF                                 */
/* Register default value on SPRC0: 0x000003CF                                  */
/* Register default value on SPRMCC: 0x000003CF                                 */
/* Register default value on SPRUCC: 0x000003CF                                 */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRB0 BDF: 0_0_0                                       */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Scheduler Major Mode CAS Block configuration
*/


#define SCHEDULER_MM_CAS_BLOCK_MCDDC_CTL_REG 0x0B022978

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wpq_major_cas_block_threshold : 6;

                            /* Bits[5:0], Access Type=RW, default=0x0000000F*/

                            /*
                               In RMM if WPQ occupancy is above or equal to
                               this watermark and first_maj_cas_blck_noncrit_mi
                               n_cas_en/first_maj_cas_blck_noncrit_min_act_en
                               are set, after the first major-mode CAS all
                               minor-mode non-critical CAS/ACT respectively are
                               blocked (i.e. block = occupancy >= watermark).
                               Watermark needs to be below the number of
                               enabled pending queue entries.
                            */
    UINT32 rpq_major_cas_block_threshold : 6;

                            /* Bits[11:6], Access Type=RW, default=0x0000000F*/

                            /*
                               In WMM if RPQ occupancy is above or equal to
                               this watermark and first_maj_cas_blck_noncrit_mi
                               n_cas_en/first_maj_cas_blck_noncrit_min_act_en
                               are set, after the first major-mode CAS all
                               minor-mode non-critical CAS/ACT respectively are
                               blocked (i.e. block = occupancy >= watermark).
                               Watermark needs to be below the number of
                               enabled pending queue entries.
                            */
    UINT32 rsvd : 20;

                            /* Bits[31:12], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_MM_CAS_BLOCK_MCDDC_CTL_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

/* INTERNAL_ERROR_SCHEDSPQ_N0_MCDDC_CTL_REG supported on:                       */
/*      SPRA0 (0x20022980)                                                      */
/*      SPRB0 (0x20022980)                                                      */
/*      SPRHBM (0x20022980)                                                     */
/*      SPRC0 (0x20022980)                                                      */
/*      SPRMCC (0x20022980)                                                     */
/*      SPRUCC (0x20022980)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains internal errors from mcscheds_pq
*/


#define INTERNAL_ERROR_SCHEDSPQ_N0_MCDDC_CTL_REG 0x0B022980

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rpq_overflow0 : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /* RPQ credit overflow in PQ set 0 */
    UINT32 wpq_overflow0 : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /* WPQ credit overflow in PQ set 0 */
    UINT32 rpq_overflow1 : 1;

                            /* Bits[2:2], Access Type=RO/V, default=0x00000000*/

                            /* RPQ credit overflow in PQ set 1 */
    UINT32 wpq_overflow1 : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000000*/

                            /* WPQ credit overflow in PQ set 1 */
    UINT32 rsvd : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} INTERNAL_ERROR_SCHEDSPQ_N0_MCDDC_CTL_STRUCT;

/* INTERNAL_ERROR_SCHEDSPQ_N1_MCDDC_CTL_REG supported on:                       */
/*      SPRA0 (0x20022984)                                                      */
/*      SPRB0 (0x20022984)                                                      */
/*      SPRHBM (0x20022984)                                                     */
/*      SPRC0 (0x20022984)                                                      */
/*      SPRMCC (0x20022984)                                                     */
/*      SPRUCC (0x20022984)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains internal errors from mcscheds_pq
*/


#define INTERNAL_ERROR_SCHEDSPQ_N1_MCDDC_CTL_REG 0x0B022984

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 32;

                            /* Bits[31:0], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} INTERNAL_ERROR_SCHEDSPQ_N1_MCDDC_CTL_STRUCT;

/* DIS_INTERNAL_ERROR_SCHEDSPQ_N0_MCDDC_CTL_REG supported on:                   */
/*      SPRA0 (0x20022988)                                                      */
/*      SPRB0 (0x20022988)                                                      */
/*      SPRHBM (0x20022988)                                                     */
/*      SPRC0 (0x20022988)                                                      */
/*      SPRMCC (0x20022988)                                                     */
/*      SPRUCC (0x20022988)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains disable bits for internal errors from mcscheds_pq
*/


#define DIS_INTERNAL_ERROR_SCHEDSPQ_N0_MCDDC_CTL_REG 0x0B022988

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_rpq_overflow0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by RPQ credit overflow in
                               PQ set 0
                            */
    UINT32 dis_wpq_overflow0 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by WPQ credit overflow in
                               PQ set 0
                            */
    UINT32 dis_rpq_overflow1 : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by RPQ credit overflow in
                               PQ set 1
                            */
    UINT32 dis_wpq_overflow1 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by WPQ credit overflow in
                               PQ set 1
                            */
    UINT32 rsvd : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIS_INTERNAL_ERROR_SCHEDSPQ_N0_MCDDC_CTL_STRUCT;

/* DIS_INTERNAL_ERROR_SCHEDSPQ_N1_MCDDC_CTL_REG supported on:                   */
/*      SPRA0 (0x2002298c)                                                      */
/*      SPRB0 (0x2002298c)                                                      */
/*      SPRHBM (0x2002298c)                                                     */
/*      SPRC0 (0x2002298c)                                                      */
/*      SPRMCC (0x2002298c)                                                     */
/*      SPRUCC (0x2002298c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains disable bits for internal errors from mcscheds_pq
*/


#define DIS_INTERNAL_ERROR_SCHEDSPQ_N1_MCDDC_CTL_REG 0x0B02298C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 32;

                            /* Bits[31:0], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIS_INTERNAL_ERROR_SCHEDSPQ_N1_MCDDC_CTL_STRUCT;

/* MCSCHEDS_PQ_LCBSAFEMODE_MCDDC_CTL_REG supported on:                          */
/*      SPRA0 (0x20022990)                                                      */
/*      SPRB0 (0x20022990)                                                      */
/*      SPRHBM (0x20022990)                                                     */
/*      SPRC0 (0x20022990)                                                      */
/*      SPRMCC (0x20022990)                                                     */
/*      SPRUCC (0x20022990)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* disables select LCBs and clock-gates.
*/


#define MCSCHEDS_PQ_LCBSAFEMODE_MCDDC_CTL_REG 0x0B022990

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_clk_gate : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* general LCB clock-gate disable */
    UINT32 dis_clk_gate_pmon : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* disables the clock-gate for the PMON LCB */
    UINT32 rsvd : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCSCHEDS_PQ_LCBSAFEMODE_MCDDC_CTL_STRUCT;

/* MCSCHEDS_PQ_CHKN_BIT_MCDDC_CTL_REG supported on:                             */
/*      SPRA0 (0x20022994)                                                      */
/*      SPRB0 (0x20022994)                                                      */
/*      SPRHBM (0x20022994)                                                     */
/*      SPRC0 (0x20022994)                                                      */
/*      SPRMCC (0x20022994)                                                     */
/*      SPRUCC (0x20022994)                                                     */
/* Register default value on SPRA0: 0x00010000                                  */
/* Register default value on SPRB0: 0x00010100                                  */
/* Register default value on SPRHBM: 0x00010100                                 */
/* Register default value on SPRC0: 0x00010000                                  */
/* Register default value on SPRMCC: 0x00010000                                 */
/* Register default value on SPRUCC: 0x00010000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 20_0_0x704
*/


#define MCSCHEDS_PQ_CHKN_BIT_MCDDC_CTL_REG 0x0B022994

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 spare_0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* unused */
    UINT32 rsvd : 8;

                            /* Bits[15:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 spare_1 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000001*/

                            /* unused */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCSCHEDS_PQ_CHKN_BIT_MCDDC_CTL_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 spare_0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /* unused */
    UINT32 sel_write_err_latency : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               when set to 1, use write_err_latency field from
                               spare wire
                            */
    UINT32 rsvd : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 spare_1 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000001*/

                            /* unused */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCSCHEDS_PQ_CHKN_BIT_MCDDC_CTL_SPRB0_SPRHBM_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 spare_0 : 9;

                            /* Bits[8:0], Access Type=RW, default=0x00000000*/

                            /* unused */
    UINT32 rsvd : 7;

                            /* Bits[15:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 spare_1 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000001*/

                            /* unused */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCSCHEDS_PQ_CHKN_BIT_MCDDC_CTL_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 16;

                            /* Bits[15:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 spare_1 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000001*/

                            /* unused */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCSCHEDS_PQ_CHKN_BIT_MCDDC_CTL_STRUCT;


/* CRDEFEATURE1_PQ_MCDDC_CTL_REG supported on:                                  */
/*      SPRA0 (0x100229a0)                                                      */
/*      SPRB0 (0x100229a0)                                                      */
/*      SPRHBM (0x100229a0)                                                     */
/*      SPRC0 (0x100229a0)                                                      */
/*      SPRMCC (0x100229a0)                                                     */
/*      SPRUCC (0x100229a0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* spare
*/


#define CRDEFEATURE1_PQ_MCDDC_CTL_REG 0x0B0129A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 spare : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* spare */

  } Bits;
  UINT16 Data;

} CRDEFEATURE1_PQ_MCDDC_CTL_STRUCT;

/* CRDEFEATURE2_PQ_MCDDC_CTL_REG supported on:                                  */
/*      SPRA0 (0x100229a8)                                                      */
/*      SPRB0 (0x100229a8)                                                      */
/*      SPRHBM (0x100229a8)                                                     */
/*      SPRC0 (0x100229a8)                                                      */
/*      SPRMCC (0x100229a8)                                                     */
/*      SPRUCC (0x100229a8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* spare
*/


#define CRDEFEATURE2_PQ_MCDDC_CTL_REG 0x0B0129A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 spare : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* spare */

  } Bits;
  UINT16 Data;

} CRDEFEATURE2_PQ_MCDDC_CTL_STRUCT;

/* CRDEFEATURE3_PQ_MCDDC_CTL_REG supported on:                                  */
/*      SPRA0 (0x100229b0)                                                      */
/*      SPRB0 (0x100229b0)                                                      */
/*      SPRHBM (0x100229b0)                                                     */
/*      SPRC0 (0x100229b0)                                                      */
/*      SPRMCC (0x100229b0)                                                     */
/*      SPRUCC (0x100229b0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* spare
*/


#define CRDEFEATURE3_PQ_MCDDC_CTL_REG 0x0B0129B0

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 spare : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /* spare */

  } Bits;
  UINT16 Data;

} CRDEFEATURE3_PQ_MCDDC_CTL_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 integrity_enabled : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Integrity enable configuration; should only be
                               set for DDR5 mode
                            */
    UINT16 spare : 15;

                            /* Bits[15:1], Access Type=RW, default=0x00000000*/

                            /* spare */

  } Bits;
  UINT16 Data;

} CRDEFEATURE3_PQ_MCDDC_CTL_SPRB0_SPRHBM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* SCHEDULER_WPQ_PCH1_ENTRY_EN_N0_MCDDC_CTL_REG supported on:                   */
/*      SPRC0 (0x200229c0)                                                      */
/*      SPRMCC (0x200229c0)                                                     */
/*      SPRUCC (0x200229c0)                                                     */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRC0 BDF: 0_0_0                                       */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Write Pending Queue (WPQ) Entry Enable for the given scheduler pseudo channel
*/


#define SCHEDULER_WPQ_PCH1_ENTRY_EN_N0_MCDDC_CTL_REG 0x0B0229C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wpq_pch1_entry_en : 32;

                            /* Bits[31:0], Access Type=RW, default=0xFFFFFFFF*/

                            /*
                               WPQ PCH1 Entries 0 - 39 enable; Entries 32-39
                               can only be enabled for non-Crystal Ridge
                               platforms
                            */

  } Bits;
  UINT32 Data;

} SCHEDULER_WPQ_PCH1_ENTRY_EN_N0_MCDDC_CTL_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* SCHEDULER_WPQ_PCH1_ENTRY_EN_N1_MCDDC_CTL_REG supported on:                   */
/*      SPRC0 (0x200229c4)                                                      */
/*      SPRMCC (0x200229c4)                                                     */
/*      SPRUCC (0x200229c4)                                                     */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcscheds_pq_crnode/MEM_MCSCHEDS_CSR*/
/* Struct generated from SPRC0 BDF: 0_0_0                                       */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Write Pending Queue (WPQ) Entry Enable for the given scheduler pseudo channel
*/


#define SCHEDULER_WPQ_PCH1_ENTRY_EN_N1_MCDDC_CTL_REG 0x0B0229C4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wpq_pch1_entry_en : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               WPQ PCH1 Entries 0 - 39 enable; Entries 32-39
                               can only be enabled for non-Crystal Ridge
                               platforms
                            */
    UINT32 rsvd : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCHEDULER_WPQ_PCH1_ENTRY_EN_N1_MCDDC_CTL_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */
#endif /* _MCDDC_CTL_h */
