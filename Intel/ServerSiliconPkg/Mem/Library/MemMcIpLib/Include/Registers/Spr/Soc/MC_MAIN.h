
/** @file
  MC_MAIN.h

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2007 - 2020 Intel Corporation. <BR>
  
  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.
  
  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.
  
  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
  
  This file contains Silicon register definitions.
  
  This is a generated file; please do not modify it directly.
  
**/

/* The following security policy groups are used by registers in this file:     */

/* SPRA0 Security Policy Groups:                                                */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRB0 Security Policy Groups:                                                */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRHBM Security Policy Groups:                                               */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRC0 Security Policy Groups:                                                */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRMCC Security Policy Groups:                                               */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRUCC Security Policy Groups:                                               */
/* BIOS_W                                                                       */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | OOB_MSM_SAI                                                             */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* COR_CNT                                                                      */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_UCODE_SAI |             */
/*    HOSTIA_SMM_SAI | HOSTIA_BOOT_SAI | OOB_MSM_SAI | PM_PCS_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_THIRDPARTY_SAI | DFX_UNTRUSTED_SAI                                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* CPGC                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |    */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* DFX                                                                          */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI | UNCORE_PMA_SAI |     */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | OOB_MSM_SAI      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_MCHECK_W                                                                  */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* LB_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | HOSTIA_BOOT_SAI  */
/*    | HOSTIA_SMM_SAI | OOB_MSM_SAI                                            */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* OS_W                                                                         */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | SAI_Reserved_5 | SAI_Reserved_6 |  */
/*    SAI_Reserved_7 | GT_SAI | PM_PCS_SAI | HW_CPU_SAI | MEM_CPL_SAI | VTD_SAI */
/*    | PM_DIE_TO_DIE_SAI | OOB_MSM_UNTRUSTED_SAI | HOSTCP_PMA_SAI |            */
/*    CSE_INTEL_SAI | CSE_OEM_SAI | FUSE_CTRL_SAI | FUSE_PULLER_SAI |           */
/*    PECI_MSM_SAI | PM_IOSS_SAI | CSE_DNX_SAI | FXR_INTERNAL_SAI |             */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_UNTRUSTED_SAI | SAI_Reserved_26 |       */
/*    IRC_SAI | NPK_SAI | DISPLAY2_SAI | DISPLAY3_SAI | HW_PCH_SAI |            */
/*    SAI_Reserved_32 | SAI_Reserved_33 | SAI_Reserved_34 | GT_PMA_SAI |        */
/*    HSP_SAI | SAI_Reserved_37 | SAI_Reserved_38 | SAI_Reserved_39 |           */
/*    UNCORE_PMA_SAI | RC_MORPHED_SAI | DFX_INTEL_PRODUCTION_SAI |              */
/*    DFX_THIRDPARTY_SAI | DISPLAY_SAI | SAI_Reserved_45 | SAI_Reserved_46 |    */
/*    DISPLAY_KVM_SAI | GT2_SAI | SAI_Reserved_49 | DEVICE_UNTRUSTED_IAL_SAI |  */
/*    SAI_Reserved_51 | CORE_EVENT_PROXY_SAI | DEVICE_ABORT_SAI |               */
/*    RCIOMMU_BYPASS_SAI | SAI_Reserved_55 | SAI_Reserved_56 | IE_CSE_SAI |     */
/*    SAI_Reserved_58 | SAI_Reserved_59 | CPM_SAI | OOB_MSM_SAI | XGBE_SAI |    */
/*    DEVICE_UNTRUSTED_SAI                                                      */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_POSTBOOT_SAI | HOSTIA_UCODE_SAI | HOSTIA_SMM_SAI |                 */
/*    HOSTIA_SUNPASS_SAI | HOSTIA_BOOT_SAI | PM_PCS_SAI |                       */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI |                  */
/*    DFX_UNTRUSTED_SAI | OOB_MSM_SAI | DFX_THIRDPARTY_SAI                      */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */
/* P_U_CODE                                                                     */
/*  Security_ReadAccess_Str:                                                    */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI | UNCORE_PMA_SAI | */
/*    OOB_MSM_SAI                                                               */
/*  Security_WriteAccess_Str:                                                   */
/*    HOSTIA_UCODE_SAI | HOSTIA_SUNPASS_SAI | PM_PCS_SAI |                      */
/*    DFX_INTEL_MANUFACTURING_SAI | DFX_INTEL_PRODUCTION_SAI                    */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */


#ifndef _MC_MAIN_h
#define _MC_MAIN_h
#include <Base.h>

/* DIMMMTR_0_MC_MAIN_REG supported on:                                          */
/*      SPRA0 (0x2002080c)                                                      */
/*      SPRB0 (0x2002080c)                                                      */
/*      SPRHBM (0x2002080c)                                                     */
/*      SPRC0 (0x2002080c)                                                      */
/*      SPRMCC (0x2002080c)                                                     */
/*      SPRUCC (0x2002080c)                                                     */
/* Register default value on SPRA0: 0x0000000C                                  */
/* Register default value on SPRB0: 0x0000000C                                  */
/* Register default value on SPRHBM: 0x0000000C                                 */
/* Register default value on SPRC0: 0x0000000C                                  */
/* Register default value on SPRMCC: 0x0000000C                                 */
/* Register default value on SPRUCC: 0x0000000C                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Per-DIMM configurability for DIMM 0.
*/


#define DIMMMTR_0_MC_MAIN_REG 0x0702080C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ca_width : 2;

                            /* Bits[1:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               00. DDR4 : 10 bits; DDR5 : 10 bits HBM : 6 bits.
                               01 - DDR5 : 11 bits; Others - reserved. 10-11 :
                               Reserved
                            */
    UINT32 ra_width : 3;

                            /* Bits[4:2], Access Type=RW/P, default=0x00000003*/

                            /*
                               000 - reserved 001 - 13 bits 010 - 14 bits 011 -
                               15 bits 100 - 16 bits 101 - 17 bits 110 - 18
                               bits 111: reserved
                            */
    UINT32 ddr3_dnsty : 3;

                            /* Bits[7:5], Access Type=RW/P, default=0x00000000*/

                            /*
                               000 - Reserved 001 - 2Gb 010 - 4Gb 011 - 8Gb 100
                               - 16Gb 101 - 12Gb 110 - 24Gb 111 - 32Gb His
                               field applies to ddr4.
                            */
    UINT32 ddr3_width : 2;

                            /* Bits[9:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               00 - x4 01 - x8 10 - x16 11 - reserved This
                               field applies to ddr4.
                            */
    UINT32 ba_shrink : 2;

                            /* Bits[11:10], Access Type=RW/P, default=0x00000000*/

                            /*
                               00=normal, otherwise remove a device dependent
                               bit (01=HBM:BA1, 01=DDR4:BG1, x1=DDR5:BG2,
                               1x=DDR5:BA1) Used for x16 devices in DDR4 and
                               DDR5. Used for 8Gb devices in DDR5.
                            */
    UINT32 rank_cnt : 2;

                            /* Bits[13:12], Access Type=RW/P, default=0x00000000*/

                            /* 00 - SR 01 - DR 10 - QR 11 - reserved */
    UINT32 rsvd : 1;

                            /* Bits[14:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dimm_pop : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /*
                               DDR4 DIMM populated if set; otherwise,
                               unpopulated. Should be set to 0 when this slot
                               is populated with a DDR-T DIMM.
                            */
    UINT32 rank_disable : 4;

                            /* Bits[19:16], Access Type=RW/P, default=0x00000000*/

                            /*
                               RANK Disable Control to disable refresh and
                               ZQCAL operation. This bit setting must be set
                               consistently with TERM_RNK_MSK, i.e. both
                               corresponding bits cannot be set at the same
                               time. In the other word, a disabled rank must
                               not be selected for the terminaton rank.
                               RANK_DISABLE[3], i.e. bit 19: rank 3 disable.
                               Note DIMMMTR_2.RANK_DISABLE[3] is dont care
                               since DIMM 2 must not be quad-rank
                               RANK_DISABLE[2], i.e. bit 18: rank 2 disable.
                               Note DIMMMTR_2.RANK_DISABLE[2] is dont care
                               since DIMM 2 must not be quad-rank
                               RANK_DISABLE[1], i.e. bit 17: rank 1 disable
                               RANK_DISABLE[0], i.e. bit 16: rank 0 disable
                               when set, no refresh will be perform on this
                               rank. ODT termination is not affected by this
                               bit. Note that patrols are disabled by
                               dimm*_pat_rank_disable of amap register now and
                               not affected by this bit field.
                            */
    UINT32 rsvd_20 : 1;

                            /* Bits[20:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 hdrl : 1;

                            /* Bits[21:21], Access Type=RW/P, default=0x00000000*/

                            /* Reserved - unused. */
    UINT32 hdrl_parity : 1;

                            /* Bits[22:22], Access Type=RW/P, default=0x00000000*/

                            /* Reserved - unused. */
    UINT32 ddr4_3dsnumranks_cs : 2;

                            /* Bits[24:23], Access Type=RW/P, default=0x00000000*/

                            /*
                               Number of sub ranks per chip select per dimm of
                               DDR4 3DS and non3ds_lrdimm (this is a dimm
                               specific field. There are restriction on
                               rank_cnt field if this field is nonzero fro 3ds
                               devices. Can not mix 2 chip_select parts and 1
                               chip_select part on the same channel) 00-
                               3ds/non3ds_lrdimm ddr4 multiple ranks/chip
                               select disabled 01- 2 ranks per chip select 10-
                               4 ranks per chip select 11- 8 ranks per chip
                               select
                            */
    UINT32 rsvd_25 : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIMMMTR_0_MC_MAIN_STRUCT;

/* DIMMMTR_1_MC_MAIN_REG supported on:                                          */
/*      SPRA0 (0x20020810)                                                      */
/*      SPRB0 (0x20020810)                                                      */
/*      SPRHBM (0x20020810)                                                     */
/*      SPRC0 (0x20020810)                                                      */
/*      SPRMCC (0x20020810)                                                     */
/*      SPRUCC (0x20020810)                                                     */
/* Register default value on SPRA0: 0x0000000C                                  */
/* Register default value on SPRB0: 0x0000000C                                  */
/* Register default value on SPRHBM: 0x0000000C                                 */
/* Register default value on SPRC0: 0x0000000C                                  */
/* Register default value on SPRMCC: 0x0000000C                                 */
/* Register default value on SPRUCC: 0x0000000C                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Option 1 indicates the option 1 mapping is automatically selected when 3rd DIMM slot (DS#2) is
unpopulated (DIMMMTR2), including single, dual, and quad-rank DIMMs in any of the 2 slots. Default
mapping is automatically selected any time a DIMM is loaded in the 3th slot (DS#2).
*/


#define DIMMMTR_1_MC_MAIN_REG 0x07020810

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ca_width : 2;

                            /* Bits[1:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               00. DDR4 : 10 bits; DDR5 : 10 bits HBM : 6 bits.
                               01 - DDR5 : 11 bits; Others - reserved. 10-11 :
                               Reserved
                            */
    UINT32 ra_width : 3;

                            /* Bits[4:2], Access Type=RW/P, default=0x00000003*/

                            /*
                               000 - reserved 001 - 13 bits 010 - 14 bits 011 -
                               15 bits 100 - 16 bits 101 - 17 bits 110 - 18
                               bits 111: reserved
                            */
    UINT32 ddr3_dnsty : 3;

                            /* Bits[7:5], Access Type=RW/P, default=0x00000000*/

                            /*
                               000 - Reserved 001 - 2Gb 010 - 4Gb 011 - 8Gb 100
                               - 16Gb 101 - 12Gb 110 - 24Gb 111 - 32Gb This
                               field applies to ddr4.
                            */
    UINT32 ddr3_width : 2;

                            /* Bits[9:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               00 - x4 01 - x8 10 - x16 11 - reserved This
                               field applies to ddr4.
                            */
    UINT32 ba_shrink : 2;

                            /* Bits[11:10], Access Type=RW/P, default=0x00000000*/

                            /*
                               00=normal, otherwise remove a device dependent
                               bit (01=HBM:BA1, 01=DDR4:BG1, x1=DDR5:BG2,
                               1x=DDR5:BA1) Used for x16 devices in DDR4 and
                               DDR5. Used for 8Gb devices in DDR5.
                            */
    UINT32 rank_cnt : 2;

                            /* Bits[13:12], Access Type=RW/P, default=0x00000000*/

                            /* 00 - SR 01 - DR 10 - QR 11 - reserved */
    UINT32 rsvd : 1;

                            /* Bits[14:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dimm_pop : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /*
                               DDR4 DIMM populated if set; otherwise,
                               unpopulated. Should be set to 0 when this slot
                               is populated with a DDR-T DIMM.
                            */
    UINT32 rank_disable : 4;

                            /* Bits[19:16], Access Type=RW/P, default=0x00000000*/

                            /*
                               RANK Disable Control to disable refresh and
                               ZQCAL operation. This bit setting must be set
                               consistently with TERM_RNK_MSK, i.e. both
                               corresponding bits cannot be set at the same
                               time. In the other word, a disabled rank must
                               not be selected for the terminaton rank.
                               RANK_DISABLE[3], i.e. bit 19: rank 3 disable.
                               Note DIMMMTR_2.RANK_DISABLE[3] is dont care
                               since DIMM 2 must not be quad-rank
                               RANK_DISABLE[2], i.e. bit 18: rank 2 disable.
                               Note DIMMMTR_2.RANK_DISABLE[2] is dont care
                               since DIMM 2 must not be quad-rank
                               RANK_DISABLE[1], i.e. bit 17: rank 1 disable
                               RANK_DISABLE[0], i.e. bit 16: rank 0 disable
                               when set, no refresh will be perform on this
                               rank. ODT termination is not affected by this
                               bit. Note that patrols are disabled by
                               dimm*_pat_rank_disable of amap register now and
                               not affected by this bit field.
                            */
    UINT32 rsvd_20 : 3;

                            /* Bits[22:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ddr4_3dsnumranks_cs : 2;

                            /* Bits[24:23], Access Type=RW/P, default=0x00000000*/

                            /*
                               Number of sub ranks per chip select per dimm of
                               DDR4 3DS and non3ds_lrdimm (this is a dimm
                               specific field. There are restriction on
                               rank_cnt field if this field is nonzero fro 3ds
                               devices. Can not mix 2 chip_select parts and 1
                               chip_select part on the same channel) 00-
                               3ds/non3ds_lrdimm ddr4 multiple ranks/chip
                               select disabled 01- 2 ranks per chip select 10-
                               4 ranks per chip select 11- 8 ranks per chip
                               select
                            */
    UINT32 rsvd_25 : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIMMMTR_1_MC_MAIN_STRUCT;

/* AMAP_MC_MAIN_REG supported on:                                               */
/*      SPRA0 (0x20020814)                                                      */
/*      SPRB0 (0x20020814)                                                      */
/*      SPRHBM (0x20020814)                                                     */
/*      SPRC0 (0x20020814)                                                      */
/*      SPRMCC (0x20020814)                                                     */
/*      SPRUCC (0x20020814)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* address map variations.
*/


#define AMAP_MC_MAIN_REG 0x07020814

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cgbg_interleave : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               coarse grain bank group interleaving mode.
                               0=BANK_INT_6_10_11_13 (HBM) CGBG (DDR4) (Coarse
                               grained bank group interleave)
                               1=BANK_INT_7_10_11_13 (HBM) FGBG_INT_2 (DDR4/5)
                               (Fine grained bank group interleave of one bank
                               bit) 2=BANK_INT_8_10_11_13 (HBM) or FGBG_INT_4
                               (DDR4) or FGBG_INT_8 (DDR5) (Fine grained bank
                               group interleave on two bank bits)
                               3=BANK_INT_8_9_11_13 (HBM) 4=BANK_INT_6_11_12_13
                               (HBM) 5=BANK_INT_7_11_12_13 (HBM)
                               6=BANK_INT_7_8_9_10 (HBM) 7=BANK_INT_10_11_12_13
                               (HBM)
                            */
    UINT32 device_type : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Device type. 0=DDR4 1=DDR5 This field is a don't
                               care in HBM mode.
                            */
    UINT32 force_lat : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               When setting to 1, force additional 1 cycle
                               latency in decoding logic (same latency as 3
                               channel mode); expected to set to 1 when channel
                               mirroring is enabled. Also expect to set to 1
                               when NmCachingOffsetEn is set to 1.
                            */
    UINT32 mirr_adddc_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enabling special spare copy mode for ADDDC and
                               mirroring enable. In this mode, system addresses
                               will be gone through 3 times, with first pass
                               for non-mirror addresses. second pass for mirror
                               primary addresses, and third pass for mirror
                               secondary addresses. This function will only
                               work if sparing_control.mirr_adddc_en is set to
                               1
                            */
    UINT32 wait4bothhalves : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to disable critical chunk support. This
                               bit should always be set to 1 by software.
                            */
    UINT32 dev_sub_dly_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to enable datapath delay for device
                               substitution.
                            */
    UINT32 adddc_plus1_dly_en : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* Set to 1 to enable datapath delay for ADDDC+1. */
    UINT32 force_no_lat : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               When setting to 1, disable additional 1 cycle
                               latency in decoding logic (3 channel mode);
                               expected to set to 1 when only TADs that have 3
                               channels are in 2LM mode only.
                            */
    UINT32 spr_sys_cmp : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, Select system address instead of
                               channel address for determining if an incoming
                               M2M request has been spare copied or not during
                               rank or sddc sparing flow. Should be set to 1
                               when mirroring is enabled. Should be kept at 0
                               in 2LM mode.
                            */
    UINT32 fast_decode : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, decoding logic takes the fast
                               path and finishes in one cycle. One certain
                               combinations of decoder configurations are
                               allowed on the fast path. Incorrect selection
                               will result in wrong address begin decoded.
                            */
    UINT32 rsvd : 3;

                            /* Bits[14:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dimm0_pat_rank_disable : 4;

                            /* Bits[18:15], Access Type=RW, default=0x00000000*/

                            /*
                               This field is similar to dimmmtr_*.rank_disable;
                               but it affects only patrol operations. Each bit
                               controls 1 Chip_selects patrol in a given dimm.
                               If 1, patrol engine will skip that ChipSelect;
                               other wise it will patrol it if dimm is populted
                               and all other patrol conditions are true. This
                               is intended to be used after rank_sparing to
                               skip patrol of the spared rank.
                            */
    UINT32 dimm1_pat_rank_disable : 4;

                            /* Bits[22:19], Access Type=RW, default=0x00000000*/

                            /*
                               This field is similar to dimmmtr_*.rank_disable;
                               but it affects only patrol operations. Each bit
                               controls 1 Chip_selects patrol in a given dimm.
                               If 1, patrol engine will skip that ChipSelect;
                               other wise it will patrol it if dimm is populted
                               and all other patrol conditions are true. This
                               is intended to be used after rank_sparing to
                               skip patrol of the spared rank.
                            */
    UINT32 rsvd_23 : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} AMAP_MC_MAIN_STRUCT;

/* PXPCAP_MC_MAIN_REG supported on:                                             */
/*      SPRA0 (0x20020818)                                                      */
/*      SPRB0 (0x20020818)                                                      */
/*      SPRHBM (0x20020818)                                                     */
/*      SPRC0 (0x20020818)                                                      */
/*      SPRMCC (0x20020818)                                                     */
/*      SPRUCC (0x20020818)                                                     */
/* Register default value on SPRA0: 0x00910010                                  */
/* Register default value on SPRB0: 0x00910010                                  */
/* Register default value on SPRHBM: 0x00910010                                 */
/* Register default value on SPRC0: 0x00910010                                  */
/* Register default value on SPRMCC: 0x00910010                                 */
/* Register default value on SPRUCC: 0x00910010                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 19_2_0x040
*/


#define PXPCAP_MC_MAIN_REG 0x07020818

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 capability_id : 8;

                            /* Bits[7:0], Access Type=RO, default=0x00000010*/

                            /*
                               Provides the PCI Express capability ID assigned
                               by PCI-SIG.
                            */
    UINT32 next_ptr : 8;

                            /* Bits[15:8], Access Type=RO, default=0x00000000*/

                            /*
                               Pointer to the next capability. Set to 0 to
                               indicate there are no more capability
                               structures.
                            */
    UINT32 capability_version : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000001*/

                            /*
                               PCI Express Capability is Compliant with Version
                               1.0 of the PCI Express Spec. Note: This
                               capability structure is not compliant with
                               Versions beyond 1.0, since they require
                               additional capability registers to be reserved.
                               The only purpose for this capability structure
                               is to make enhanced configuration space
                               available. Minimizing the size of this structure
                               is accomplished by reporting version 1.0
                               compliancy and reporting that this is an
                               integrated root port device. As such, only three
                               Dwords of configuration space are required for
                               this structure.
                            */
    UINT32 device_port_type : 4;

                            /* Bits[23:20], Access Type=RO, default=0x00000009*/

                            /* Device type is Root Complex Integrated Endpoint */
    UINT32 slot_implemented : 1;

                            /* Bits[24:24], Access Type=RO, default=0x00000000*/

                            /* N/A for integrated endpoints */
    UINT32 interrupt_message_number : 5;

                            /* Bits[29:25], Access Type=RO, default=0x00000000*/

                            /* N/A for this device */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PXPCAP_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_0_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020820)                                                      */
/*      SPRB0 (0x20020820)                                                      */
/*      SPRHBM (0x20020820)                                                     */
/*      SPRC0 (0x20020820)                                                      */
/*      SPRMCC (0x20020820)                                                     */
/*      SPRUCC (0x20020820)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
*/


#define TADCHNILVOFFSET_0_N0_MC_MAIN_REG 0x07020820

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_ways : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               target interleave wayness 000 = 1 way, 001 = 2
                               way, 010 = 4 way, 011 = 8 way. 100 = 16 way.
                            */
    UINT32 chn_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Channel interleave wayness 000 = 1 way 001 = 2
                               way 010 = 3 way 011 = 8 way 100 = 4 way 101 -
                               111 = Reserved
                            */
    UINT32 target_gran : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 chn_gran : 4;

                            /* Bits[13:10], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 tad_offset : 18;

                            /* Bits[31:14], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_0_N0_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_0_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020824)                                                      */
/*      SPRB0 (0x20020824)                                                      */
/*      SPRHBM (0x20020824)                                                     */
/*      SPRC0 (0x20020824)                                                      */
/*      SPRMCC (0x20020824)                                                     */
/*      SPRUCC (0x20020824)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
*/


#define TADCHNILVOFFSET_0_N1_MC_MAIN_REG 0x07020824

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tad_offset : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */
    UINT32 tad_offset_sign : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When 0, the tad_offset is subtracted from the
                               system address. When 1, the tad_offset is added
                               to the system address.
                            */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_0_N1_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_1_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020828)                                                      */
/*      SPRB0 (0x20020828)                                                      */
/*      SPRHBM (0x20020828)                                                     */
/*      SPRC0 (0x20020828)                                                      */
/*      SPRMCC (0x20020828)                                                     */
/*      SPRUCC (0x20020828)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_1_N0_MC_MAIN_REG 0x07020828

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_ways : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               target interleave wayness 000 = 1 way, 001 = 2
                               way, 010 = 4 way, 011 = 8 way. 100 = 16 way.
                            */
    UINT32 chn_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Channel interleave wayness 000 = 1 way 001 = 2
                               way 010 = 3 way 011 = 8 way 100 = 4 way 101 -
                               111 = Reserved
                            */
    UINT32 target_gran : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 chn_gran : 4;

                            /* Bits[13:10], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 tad_offset : 18;

                            /* Bits[31:14], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_1_N0_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_1_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x2002082c)                                                      */
/*      SPRB0 (0x2002082c)                                                      */
/*      SPRHBM (0x2002082c)                                                     */
/*      SPRC0 (0x2002082c)                                                      */
/*      SPRMCC (0x2002082c)                                                     */
/*      SPRUCC (0x2002082c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_1_N1_MC_MAIN_REG 0x0702082C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tad_offset : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */
    UINT32 tad_offset_sign : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When 0, the tad_offset is subtracted from the
                               system address. When 1, the tad_offset is added
                               to the system address.
                            */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_1_N1_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_2_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020830)                                                      */
/*      SPRB0 (0x20020830)                                                      */
/*      SPRHBM (0x20020830)                                                     */
/*      SPRC0 (0x20020830)                                                      */
/*      SPRMCC (0x20020830)                                                     */
/*      SPRUCC (0x20020830)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_2_N0_MC_MAIN_REG 0x07020830

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_ways : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               target interleave wayness 000 = 1 way, 001 = 2
                               way, 010 = 4 way, 011 = 8 way. 100 = 16 way.
                            */
    UINT32 chn_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Channel interleave wayness 000 = 1 way 001 = 2
                               way 010 = 3 way 011 = 8 way 100 = 4 way 101 -
                               111 = Reserved
                            */
    UINT32 target_gran : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 chn_gran : 4;

                            /* Bits[13:10], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 tad_offset : 18;

                            /* Bits[31:14], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_2_N0_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_2_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020834)                                                      */
/*      SPRB0 (0x20020834)                                                      */
/*      SPRHBM (0x20020834)                                                     */
/*      SPRC0 (0x20020834)                                                      */
/*      SPRMCC (0x20020834)                                                     */
/*      SPRUCC (0x20020834)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_2_N1_MC_MAIN_REG 0x07020834

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tad_offset : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */
    UINT32 tad_offset_sign : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When 0, the tad_offset is subtracted from the
                               system address. When 1, the tad_offset is added
                               to the system address.
                            */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_2_N1_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_3_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020838)                                                      */
/*      SPRB0 (0x20020838)                                                      */
/*      SPRHBM (0x20020838)                                                     */
/*      SPRC0 (0x20020838)                                                      */
/*      SPRMCC (0x20020838)                                                     */
/*      SPRUCC (0x20020838)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_3_N0_MC_MAIN_REG 0x07020838

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_ways : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               target interleave wayness 000 = 1 way, 001 = 2
                               way, 010 = 4 way, 011 = 8 way. 100 = 16 way.
                            */
    UINT32 chn_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Channel interleave wayness 000 = 1 way 001 = 2
                               way 010 = 3 way 011 = 8 way 100 = 4 way 101 -
                               111 = Reserved
                            */
    UINT32 target_gran : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 chn_gran : 4;

                            /* Bits[13:10], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 tad_offset : 18;

                            /* Bits[31:14], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_3_N0_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_3_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x2002083c)                                                      */
/*      SPRB0 (0x2002083c)                                                      */
/*      SPRHBM (0x2002083c)                                                     */
/*      SPRC0 (0x2002083c)                                                      */
/*      SPRMCC (0x2002083c)                                                     */
/*      SPRUCC (0x2002083c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_3_N1_MC_MAIN_REG 0x0702083C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tad_offset : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */
    UINT32 tad_offset_sign : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When 0, the tad_offset is subtracted from the
                               system address. When 1, the tad_offset is added
                               to the system address.
                            */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_3_N1_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_4_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020840)                                                      */
/*      SPRB0 (0x20020840)                                                      */
/*      SPRHBM (0x20020840)                                                     */
/*      SPRC0 (0x20020840)                                                      */
/*      SPRMCC (0x20020840)                                                     */
/*      SPRUCC (0x20020840)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_4_N0_MC_MAIN_REG 0x07020840

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_ways : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               target interleave wayness 000 = 1 way, 001 = 2
                               way, 010 = 4 way, 011 = 8 way. 100 = 16 way.
                            */
    UINT32 chn_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Channel interleave wayness 000 = 1 way 001 = 2
                               way 010 = 3 way 011 = 8 way 100 = 4 way 101 -
                               111 = Reserved
                            */
    UINT32 target_gran : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 chn_gran : 4;

                            /* Bits[13:10], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 tad_offset : 18;

                            /* Bits[31:14], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_4_N0_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_4_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020844)                                                      */
/*      SPRB0 (0x20020844)                                                      */
/*      SPRHBM (0x20020844)                                                     */
/*      SPRC0 (0x20020844)                                                      */
/*      SPRMCC (0x20020844)                                                     */
/*      SPRUCC (0x20020844)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_4_N1_MC_MAIN_REG 0x07020844

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tad_offset : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */
    UINT32 tad_offset_sign : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When 0, the tad_offset is subtracted from the
                               system address. When 1, the tad_offset is added
                               to the system address.
                            */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_4_N1_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_5_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020848)                                                      */
/*      SPRB0 (0x20020848)                                                      */
/*      SPRHBM (0x20020848)                                                     */
/*      SPRC0 (0x20020848)                                                      */
/*      SPRMCC (0x20020848)                                                     */
/*      SPRUCC (0x20020848)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
          
*/


#define TADCHNILVOFFSET_5_N0_MC_MAIN_REG 0x07020848

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_ways : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               target interleave wayness 000 = 1 way, 001 = 2
                               way, 010 = 4 way, 011 = 8 way. 100 = 16 way.
                            */
    UINT32 chn_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Channel interleave wayness 000 = 1 way 001 = 2
                               way 010 = 3 way 011 = 8 way 100 = 4 way 101 -
                               111 = Reserved
                            */
    UINT32 target_gran : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 chn_gran : 4;

                            /* Bits[13:10], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 tad_offset : 18;

                            /* Bits[31:14], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_5_N0_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_5_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x2002084c)                                                      */
/*      SPRB0 (0x2002084c)                                                      */
/*      SPRHBM (0x2002084c)                                                     */
/*      SPRC0 (0x2002084c)                                                      */
/*      SPRMCC (0x2002084c)                                                     */
/*      SPRUCC (0x2002084c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
          
*/


#define TADCHNILVOFFSET_5_N1_MC_MAIN_REG 0x0702084C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tad_offset : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */
    UINT32 tad_offset_sign : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When 0, the tad_offset is subtracted from the
                               system address. When 1, the tad_offset is added
                               to the system address.
                            */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_5_N1_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_6_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020850)                                                      */
/*      SPRB0 (0x20020850)                                                      */
/*      SPRHBM (0x20020850)                                                     */
/*      SPRC0 (0x20020850)                                                      */
/*      SPRMCC (0x20020850)                                                     */
/*      SPRUCC (0x20020850)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_6_N0_MC_MAIN_REG 0x07020850

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_ways : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               target interleave wayness 000 = 1 way, 001 = 2
                               way, 010 = 4 way, 011 = 8 way. 100 = 16 way.
                            */
    UINT32 chn_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Channel interleave wayness 000 = 1 way 001 = 2
                               way 010 = 3 way 011 = 8 way 100 = 4 way 101 -
                               111 = Reserved
                            */
    UINT32 target_gran : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 chn_gran : 4;

                            /* Bits[13:10], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 tad_offset : 18;

                            /* Bits[31:14], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_6_N0_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_6_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020854)                                                      */
/*      SPRB0 (0x20020854)                                                      */
/*      SPRHBM (0x20020854)                                                     */
/*      SPRC0 (0x20020854)                                                      */
/*      SPRMCC (0x20020854)                                                     */
/*      SPRUCC (0x20020854)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_6_N1_MC_MAIN_REG 0x07020854

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tad_offset : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */
    UINT32 tad_offset_sign : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When 0, the tad_offset is subtracted from the
                               system address. When 1, the tad_offset is added
                               to the system address.
                            */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_6_N1_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_7_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020858)                                                      */
/*      SPRB0 (0x20020858)                                                      */
/*      SPRHBM (0x20020858)                                                     */
/*      SPRC0 (0x20020858)                                                      */
/*      SPRMCC (0x20020858)                                                     */
/*      SPRUCC (0x20020858)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
          
*/


#define TADCHNILVOFFSET_7_N0_MC_MAIN_REG 0x07020858

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_ways : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               target interleave wayness 000 = 1 way, 001 = 2
                               way, 010 = 4 way, 011 = 8 way. 100 = 16 way.
                            */
    UINT32 chn_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Channel interleave wayness 000 = 1 way 001 = 2
                               way 010 = 3 way 011 = 8 way 100 = 4 way 101 -
                               111 = Reserved
                            */
    UINT32 target_gran : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 chn_gran : 4;

                            /* Bits[13:10], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 tad_offset : 18;

                            /* Bits[31:14], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_7_N0_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_7_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x2002085c)                                                      */
/*      SPRB0 (0x2002085c)                                                      */
/*      SPRHBM (0x2002085c)                                                     */
/*      SPRC0 (0x2002085c)                                                      */
/*      SPRMCC (0x2002085c)                                                     */
/*      SPRUCC (0x2002085c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
          
*/


#define TADCHNILVOFFSET_7_N1_MC_MAIN_REG 0x0702085C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tad_offset : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */
    UINT32 tad_offset_sign : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When 0, the tad_offset is subtracted from the
                               system address. When 1, the tad_offset is added
                               to the system address.
                            */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_7_N1_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_8_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020860)                                                      */
/*      SPRB0 (0x20020860)                                                      */
/*      SPRHBM (0x20020860)                                                     */
/*      SPRC0 (0x20020860)                                                      */
/*      SPRMCC (0x20020860)                                                     */
/*      SPRUCC (0x20020860)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_8_N0_MC_MAIN_REG 0x07020860

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_ways : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               target interleave wayness 000 = 1 way, 001 = 2
                               way, 010 = 4 way, 011 = 8 way. 100 = 16 way.
                            */
    UINT32 chn_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Channel interleave wayness 000 = 1 way 001 = 2
                               way 010 = 3 way 011 = 8 way 100 = 4 way 101 -
                               111 = Reserved
                            */
    UINT32 target_gran : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 chn_gran : 4;

                            /* Bits[13:10], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 tad_offset : 18;

                            /* Bits[31:14], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_8_N0_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_8_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020864)                                                      */
/*      SPRB0 (0x20020864)                                                      */
/*      SPRHBM (0x20020864)                                                     */
/*      SPRC0 (0x20020864)                                                      */
/*      SPRMCC (0x20020864)                                                     */
/*      SPRUCC (0x20020864)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_8_N1_MC_MAIN_REG 0x07020864

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tad_offset : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */
    UINT32 tad_offset_sign : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When 0, the tad_offset is subtracted from the
                               system address. When 1, the tad_offset is added
                               to the system address.
                            */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_8_N1_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_9_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020868)                                                      */
/*      SPRB0 (0x20020868)                                                      */
/*      SPRHBM (0x20020868)                                                     */
/*      SPRC0 (0x20020868)                                                      */
/*      SPRMCC (0x20020868)                                                     */
/*      SPRUCC (0x20020868)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_9_N0_MC_MAIN_REG 0x07020868

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_ways : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               target interleave wayness 000 = 1 way, 001 = 2
                               way, 010 = 4 way, 011 = 8 way. 100 = 16 way.
                            */
    UINT32 chn_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Channel interleave wayness 000 = 1 way 001 = 2
                               way 010 = 3 way 011 = 8 way 100 = 4 way 101 -
                               111 = Reserved
                            */
    UINT32 target_gran : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 chn_gran : 4;

                            /* Bits[13:10], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 tad_offset : 18;

                            /* Bits[31:14], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_9_N0_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_9_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x2002086c)                                                      */
/*      SPRB0 (0x2002086c)                                                      */
/*      SPRHBM (0x2002086c)                                                     */
/*      SPRC0 (0x2002086c)                                                      */
/*      SPRMCC (0x2002086c)                                                     */
/*      SPRUCC (0x2002086c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_9_N1_MC_MAIN_REG 0x0702086C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tad_offset : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */
    UINT32 tad_offset_sign : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When 0, the tad_offset is subtracted from the
                               system address. When 1, the tad_offset is added
                               to the system address.
                            */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_9_N1_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_10_N0_MC_MAIN_REG supported on:                              */
/*      SPRA0 (0x20020870)                                                      */
/*      SPRB0 (0x20020870)                                                      */
/*      SPRHBM (0x20020870)                                                     */
/*      SPRC0 (0x20020870)                                                      */
/*      SPRMCC (0x20020870)                                                     */
/*      SPRUCC (0x20020870)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_10_N0_MC_MAIN_REG 0x07020870

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_ways : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               target interleave wayness 000 = 1 way, 001 = 2
                               way, 010 = 4 way, 011 = 8 way. 100 = 16 way.
                            */
    UINT32 chn_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Channel interleave wayness 000 = 1 way 001 = 2
                               way 010 = 3 way 011 = 8 way 100 = 4 way 101 -
                               111 = Reserved
                            */
    UINT32 target_gran : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 chn_gran : 4;

                            /* Bits[13:10], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 tad_offset : 18;

                            /* Bits[31:14], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_10_N0_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_10_N1_MC_MAIN_REG supported on:                              */
/*      SPRA0 (0x20020874)                                                      */
/*      SPRB0 (0x20020874)                                                      */
/*      SPRHBM (0x20020874)                                                     */
/*      SPRC0 (0x20020874)                                                      */
/*      SPRMCC (0x20020874)                                                     */
/*      SPRUCC (0x20020874)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_10_N1_MC_MAIN_REG 0x07020874

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tad_offset : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */
    UINT32 tad_offset_sign : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When 0, the tad_offset is subtracted from the
                               system address. When 1, the tad_offset is added
                               to the system address.
                            */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_10_N1_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_11_N0_MC_MAIN_REG supported on:                              */
/*      SPRA0 (0x20020878)                                                      */
/*      SPRB0 (0x20020878)                                                      */
/*      SPRHBM (0x20020878)                                                     */
/*      SPRC0 (0x20020878)                                                      */
/*      SPRMCC (0x20020878)                                                     */
/*      SPRUCC (0x20020878)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_11_N0_MC_MAIN_REG 0x07020878

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_ways : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               target interleave wayness 000 = 1 way, 001 = 2
                               way, 010 = 4 way, 011 = 8 way. 100 = 16 way.
                            */
    UINT32 chn_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Channel interleave wayness 000 = 1 way 001 = 2
                               way 010 = 3 way 011 = 8 way 100 = 4 way 101 -
                               111 = Reserved
                            */
    UINT32 target_gran : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 chn_gran : 4;

                            /* Bits[13:10], Access Type=RW, default=0x00000000*/

                            /*
                               Specifies the granularity of the ch_way
                               interleave b0001 256B (based off PA[8] and up)
                               b0010 4KB (based off PA[12] and up) b0111 2KB
                               (based off PA[11] and up) Others Reserved Note:
                               Only certain combinations of
                               chn_gran/target_gran are valid.
                            */
    UINT32 tad_offset : 18;

                            /* Bits[31:14], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_11_N0_MC_MAIN_STRUCT;

/* TADCHNILVOFFSET_11_N1_MC_MAIN_REG supported on:                              */
/*      SPRA0 (0x2002087c)                                                      */
/*      SPRB0 (0x2002087c)                                                      */
/*      SPRHBM (0x2002087c)                                                     */
/*      SPRC0 (0x2002087c)                                                      */
/*      SPRMCC (0x2002087c)                                                     */
/*      SPRUCC (0x2002087c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* 
          TAD Interleaves and Offsets
          This register should be programmned while training_mode=1 or else the register write will be missed.  
          Will be available 0x4F DCLK cycles after we enter normal mode.
      
*/


#define TADCHNILVOFFSET_11_N1_MC_MAIN_REG 0x0702087C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 tad_offset : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               channel interleave 0 offset, i.e.
                               CHANNELOFFSET[51:26] == channel interleave i
                               offset, 64MB granularity. Negative offset is
                               programmed by setting tad_offset_sign to 1.
                            */
    UINT32 tad_offset_sign : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When 0, the tad_offset is subtracted from the
                               system address. When 1, the tad_offset is added
                               to the system address.
                            */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} TADCHNILVOFFSET_11_N1_MC_MAIN_STRUCT;

/* RIRWAYNESSLIMIT_0_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020884)                                                      */
/*      SPRB0 (0x20020884)                                                      */
/*      SPRHBM (0x20020884)                                                     */
/*      SPRC0 (0x20020884)                                                      */
/*      SPRMCC (0x20020884)                                                     */
/*      SPRUCC (0x20020884)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* There are 4 RIR ranges (represents how many rank interleave ranges supported to cover DIMM configurations).
*/


#define RIRWAYNESSLIMIT_0_MC_MAIN_REG 0x07020884

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 1;

                            /* Bits[0:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_limit : 13;

                            /* Bits[13:1], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[4:0].LIMIT[39:29] == highest address of the
                               range in channel address space, 384GB in lock-
                               step/192GB in independent channel, 512MB
                               granularity.
                            */
    UINT32 rsvd_14 : 14;

                            /* Bits[27:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_way : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               rank interleave wayness00 = 1 way, 01 = 2 way,
                               10 = 4 way, 11 = 8 way.
                            */
    UINT32 rsvd_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_val : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Range Valid when set; otherwise, invalid */

  } Bits;
  UINT32 Data;

} RIRWAYNESSLIMIT_0_MC_MAIN_STRUCT;

/* RIRWAYNESSLIMIT_1_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020888)                                                      */
/*      SPRB0 (0x20020888)                                                      */
/*      SPRHBM (0x20020888)                                                     */
/*      SPRC0 (0x20020888)                                                      */
/*      SPRMCC (0x20020888)                                                     */
/*      SPRUCC (0x20020888)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* There are 4 RIR ranges (represents how many rank interleave ranges supported to cover DIMM configurations).
*/


#define RIRWAYNESSLIMIT_1_MC_MAIN_REG 0x07020888

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 1;

                            /* Bits[0:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_limit : 13;

                            /* Bits[13:1], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[4:0].LIMIT[39:29] == highest address of the
                               range in channel address space, 384GB in lock-
                               step/192GB in independent channel, 512MB
                               granularity.
                            */
    UINT32 rsvd_14 : 14;

                            /* Bits[27:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_way : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               rank interleave wayness00 = 1 way, 01 = 2 way,
                               10 = 4 way, 11 = 8 way.
                            */
    UINT32 rsvd_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_val : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Range Valid when set; otherwise, invalid */

  } Bits;
  UINT32 Data;

} RIRWAYNESSLIMIT_1_MC_MAIN_STRUCT;

/* RIRWAYNESSLIMIT_2_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x2002088c)                                                      */
/*      SPRB0 (0x2002088c)                                                      */
/*      SPRHBM (0x2002088c)                                                     */
/*      SPRC0 (0x2002088c)                                                      */
/*      SPRMCC (0x2002088c)                                                     */
/*      SPRUCC (0x2002088c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* There are 4 RIR ranges (represents how many rank interleave ranges supported to cover DIMM configurations).
*/


#define RIRWAYNESSLIMIT_2_MC_MAIN_REG 0x0702088C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 1;

                            /* Bits[0:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_limit : 13;

                            /* Bits[13:1], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[4:0].LIMIT[39:29] == highest address of the
                               range in channel address space, 384GB in lock-
                               step/192GB in independent channel, 512MB
                               granularity.
                            */
    UINT32 rsvd_14 : 14;

                            /* Bits[27:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_way : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               rank interleave wayness00 = 1 way, 01 = 2 way,
                               10 = 4 way, 11 = 8 way.
                            */
    UINT32 rsvd_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_val : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Range Valid when set; otherwise, invalid */

  } Bits;
  UINT32 Data;

} RIRWAYNESSLIMIT_2_MC_MAIN_STRUCT;

/* RIRWAYNESSLIMIT_3_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020890)                                                      */
/*      SPRB0 (0x20020890)                                                      */
/*      SPRHBM (0x20020890)                                                     */
/*      SPRC0 (0x20020890)                                                      */
/*      SPRMCC (0x20020890)                                                     */
/*      SPRUCC (0x20020890)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* There are 4 RIR ranges (represents how many rank interleave ranges supported to cover DIMM configurations).
*/


#define RIRWAYNESSLIMIT_3_MC_MAIN_REG 0x07020890

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 1;

                            /* Bits[0:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_limit : 13;

                            /* Bits[13:1], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[4:0].LIMIT[39:29] == highest address of the
                               range in channel address space, 384GB in lock-
                               step/192GB in independent channel, 512MB
                               granularity.
                            */
    UINT32 rsvd_14 : 14;

                            /* Bits[27:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_way : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               rank interleave wayness00 = 1 way, 01 = 2 way,
                               10 = 4 way, 11 = 8 way.
                            */
    UINT32 rsvd_30 : 1;

                            /* Bits[30:30], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_val : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Range Valid when set; otherwise, invalid */

  } Bits;
  UINT32 Data;

} RIRWAYNESSLIMIT_3_MC_MAIN_STRUCT;

/* RIRILV0OFFSET_0_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x20020894)                                                      */
/*      SPRB0 (0x20020894)                                                      */
/*      SPRHBM (0x20020894)                                                     */
/*      SPRC0 (0x20020894)                                                      */
/*      SPRMCC (0x20020894)                                                     */
/*      SPRUCC (0x20020894)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv0offset, one per RIR
*/


#define RIRILV0OFFSET_0_MC_MAIN_REG 0x07020894

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset0 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET0[39:26] == rank interleave 0
                               offset, 64MB granularity
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt0 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 0 (used for
                               1/2/4/8-way RIR interleaving). In DDR5 mode, if
                               rir_rnk_tgt0_diff is set, this field is used for
                               sub-channel 0 only. Otherwise, it is used for
                               both sub-channels.
                            */
    UINT32 rir_rnk_tgt0_s1 : 4;

                            /* Bits[27:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 0 (used for
                               1/2/4/8-way RIR interleaving). only used in DDR5
                               mode for sub-channel 1 if rir_rnk_tgt0_diff bit
                               is set.
                            */
    UINT32 rir_rnk_tgt0_diff : 1;

                            /* Bits[28:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               only used in DDR5 mode to indicate 2 sub-
                               channels uses rir_rnk_tgt0 and rir_rnk_tgt0_s1
                               fields respectively.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV0OFFSET_0_MC_MAIN_STRUCT;

/* RIRILV0OFFSET_1_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x20020898)                                                      */
/*      SPRB0 (0x20020898)                                                      */
/*      SPRHBM (0x20020898)                                                     */
/*      SPRC0 (0x20020898)                                                      */
/*      SPRMCC (0x20020898)                                                     */
/*      SPRUCC (0x20020898)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv0offset, one per RIR
*/


#define RIRILV0OFFSET_1_MC_MAIN_REG 0x07020898

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset0 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET0[39:26] == rank interleave 0
                               offset, 64MB granularity
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt0 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 0 (used for
                               1/2/4/8-way RIR interleaving). In DDR5 mode, if
                               rir_rnk_tgt0_diff is set, this field is used for
                               sub-channel 0 only. Otherwise, it is used for
                               both sub-channels.
                            */
    UINT32 rir_rnk_tgt0_s1 : 4;

                            /* Bits[27:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 0 (used for
                               1/2/4/8-way RIR interleaving). only used in DDR5
                               mode for sub-channel 1 if rir_rnk_tgt0_diff bit
                               is set.
                            */
    UINT32 rir_rnk_tgt0_diff : 1;

                            /* Bits[28:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               only used in DDR5 mode to indicate 2 sub-
                               channels uses rir_rnk_tgt0 and rir_rnk_tgt0_s1
                               fields respectively.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV0OFFSET_1_MC_MAIN_STRUCT;

/* RIRILV0OFFSET_2_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x2002089c)                                                      */
/*      SPRB0 (0x2002089c)                                                      */
/*      SPRHBM (0x2002089c)                                                     */
/*      SPRC0 (0x2002089c)                                                      */
/*      SPRMCC (0x2002089c)                                                     */
/*      SPRUCC (0x2002089c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv0offset, one per RIR
*/


#define RIRILV0OFFSET_2_MC_MAIN_REG 0x0702089C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset0 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET0[39:26] == rank interleave 0
                               offset, 64MB granularity
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt0 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 0 (used for
                               1/2/4/8-way RIR interleaving). In DDR5 mode, if
                               rir_rnk_tgt0_diff is set, this field is used for
                               sub-channel 0 only. Otherwise, it is used for
                               both sub-channels.
                            */
    UINT32 rir_rnk_tgt0_s1 : 4;

                            /* Bits[27:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 0 (used for
                               1/2/4/8-way RIR interleaving). only used in DDR5
                               mode for sub-channel 1 if rir_rnk_tgt0_diff bit
                               is set.
                            */
    UINT32 rir_rnk_tgt0_diff : 1;

                            /* Bits[28:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               only used in DDR5 mode to indicate 2 sub-
                               channels uses rir_rnk_tgt0 and rir_rnk_tgt0_s1
                               fields respectively.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV0OFFSET_2_MC_MAIN_STRUCT;

/* RIRILV0OFFSET_3_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208a0)                                                      */
/*      SPRB0 (0x200208a0)                                                      */
/*      SPRHBM (0x200208a0)                                                     */
/*      SPRC0 (0x200208a0)                                                      */
/*      SPRMCC (0x200208a0)                                                     */
/*      SPRUCC (0x200208a0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv0offset, one per RIR
*/


#define RIRILV0OFFSET_3_MC_MAIN_REG 0x070208A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset0 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET0[39:26] == rank interleave 0
                               offset, 64MB granularity
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt0 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 0 (used for
                               1/2/4/8-way RIR interleaving). In DDR5 mode, if
                               rir_rnk_tgt0_diff is set, this field is used for
                               sub-channel 0 only. Otherwise, it is used for
                               both sub-channels.
                            */
    UINT32 rir_rnk_tgt0_s1 : 4;

                            /* Bits[27:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 0 (used for
                               1/2/4/8-way RIR interleaving). only used in DDR5
                               mode for sub-channel 1 if rir_rnk_tgt0_diff bit
                               is set.
                            */
    UINT32 rir_rnk_tgt0_diff : 1;

                            /* Bits[28:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               only used in DDR5 mode to indicate 2 sub-
                               channels uses rir_rnk_tgt0 and rir_rnk_tgt0_s1
                               fields respectively.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV0OFFSET_3_MC_MAIN_STRUCT;

/* RIRILV1OFFSET_0_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208a4)                                                      */
/*      SPRB0 (0x200208a4)                                                      */
/*      SPRHBM (0x200208a4)                                                     */
/*      SPRC0 (0x200208a4)                                                      */
/*      SPRMCC (0x200208a4)                                                     */
/*      SPRUCC (0x200208a4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv1offset, one per RIR
*/


#define RIRILV1OFFSET_0_MC_MAIN_REG 0x070208A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset1 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET1[39:26] == rank interleave 1
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt1 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 1 (used for
                               1/2/4/8-way RIR interleaving). In DDR5 mode, if
                               rir_rnk_tgt1_diff is set, this field is used for
                               sub-channel 0 only. Otherwise, it is used for
                               both sub-channels.
                            */
    UINT32 rir_rnk_tgt1_s1 : 4;

                            /* Bits[27:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 1 (used for
                               1/2/4/8-way RIR interleaving). only used in DDR5
                               mode for sub-channel 1 if rir_rnk_tgt1_diff bit
                               is set.
                            */
    UINT32 rir_rnk_tgt1_diff : 1;

                            /* Bits[28:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               only used in DDR5 mode to indicate 2 sub-
                               channels uses rir_rnk_tgt1 and rir_rnk_tgt1_s1
                               fields respectively.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV1OFFSET_0_MC_MAIN_STRUCT;

/* RIRILV1OFFSET_1_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208a8)                                                      */
/*      SPRB0 (0x200208a8)                                                      */
/*      SPRHBM (0x200208a8)                                                     */
/*      SPRC0 (0x200208a8)                                                      */
/*      SPRMCC (0x200208a8)                                                     */
/*      SPRUCC (0x200208a8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv1offset, one per RIR
*/


#define RIRILV1OFFSET_1_MC_MAIN_REG 0x070208A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset1 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET1[39:26] == rank interleave 1
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt1 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 1 (used for
                               1/2/4/8-way RIR interleaving). In DDR5 mode, if
                               rir_rnk_tgt1_diff is set, this field is used for
                               sub-channel 0 only. Otherwise, it is used for
                               both sub-channels.
                            */
    UINT32 rir_rnk_tgt1_s1 : 4;

                            /* Bits[27:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 1 (used for
                               1/2/4/8-way RIR interleaving). only used in DDR5
                               mode for sub-channel 1 if rir_rnk_tgt1_diff bit
                               is set.
                            */
    UINT32 rir_rnk_tgt1_diff : 1;

                            /* Bits[28:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               only used in DDR5 mode to indicate 2 sub-
                               channels uses rir_rnk_tgt1 and rir_rnk_tgt1_s1
                               fields respectively.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV1OFFSET_1_MC_MAIN_STRUCT;

/* RIRILV1OFFSET_2_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208ac)                                                      */
/*      SPRB0 (0x200208ac)                                                      */
/*      SPRHBM (0x200208ac)                                                     */
/*      SPRC0 (0x200208ac)                                                      */
/*      SPRMCC (0x200208ac)                                                     */
/*      SPRUCC (0x200208ac)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv1offset, one per RIR
*/


#define RIRILV1OFFSET_2_MC_MAIN_REG 0x070208AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset1 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET1[39:26] == rank interleave 1
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt1 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 1 (used for
                               1/2/4/8-way RIR interleaving). In DDR5 mode, if
                               rir_rnk_tgt1_diff is set, this field is used for
                               sub-channel 0 only. Otherwise, it is used for
                               both sub-channels.
                            */
    UINT32 rir_rnk_tgt1_s1 : 4;

                            /* Bits[27:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 1 (used for
                               1/2/4/8-way RIR interleaving). only used in DDR5
                               mode for sub-channel 1 if rir_rnk_tgt1_diff bit
                               is set.
                            */
    UINT32 rir_rnk_tgt1_diff : 1;

                            /* Bits[28:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               only used in DDR5 mode to indicate 2 sub-
                               channels uses rir_rnk_tgt1 and rir_rnk_tgt1_s1
                               fields respectively.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV1OFFSET_2_MC_MAIN_STRUCT;

/* RIRILV1OFFSET_3_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208b0)                                                      */
/*      SPRB0 (0x200208b0)                                                      */
/*      SPRHBM (0x200208b0)                                                     */
/*      SPRC0 (0x200208b0)                                                      */
/*      SPRMCC (0x200208b0)                                                     */
/*      SPRUCC (0x200208b0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv1offset, one per RIR
*/


#define RIRILV1OFFSET_3_MC_MAIN_REG 0x070208B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset1 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET1[39:26] == rank interleave 1
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt1 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 1 (used for
                               1/2/4/8-way RIR interleaving). In DDR5 mode, if
                               rir_rnk_tgt1_diff is set, this field is used for
                               sub-channel 0 only. Otherwise, it is used for
                               both sub-channels.
                            */
    UINT32 rir_rnk_tgt1_s1 : 4;

                            /* Bits[27:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 1 (used for
                               1/2/4/8-way RIR interleaving). only used in DDR5
                               mode for sub-channel 1 if rir_rnk_tgt1_diff bit
                               is set.
                            */
    UINT32 rir_rnk_tgt1_diff : 1;

                            /* Bits[28:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               only used in DDR5 mode to indicate 2 sub-
                               channels uses rir_rnk_tgt1 and rir_rnk_tgt1_s1
                               fields respectively.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV1OFFSET_3_MC_MAIN_STRUCT;

/* RIRILV2OFFSET_0_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208b4)                                                      */
/*      SPRB0 (0x200208b4)                                                      */
/*      SPRHBM (0x200208b4)                                                     */
/*      SPRC0 (0x200208b4)                                                      */
/*      SPRMCC (0x200208b4)                                                     */
/*      SPRUCC (0x200208b4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv2offset, one per RIR
*/


#define RIRILV2OFFSET_0_MC_MAIN_REG 0x070208B4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset2 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET2[39:26] == rank interleave 2
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt2 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 2 (used for
                               1/2/4/8-way RIR interleaving). In DDR5 mode, if
                               rir_rnk_tgt2_diff is set, this field is used for
                               sub-channel 0 only. Otherwise, it is used for
                               both sub-channels.
                            */
    UINT32 rir_rnk_tgt2_s1 : 4;

                            /* Bits[27:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 2 (used for
                               1/2/4/8-way RIR interleaving). only used in DDR5
                               mode for sub-channel 1 if rir_rnk_tgt2_diff bit
                               is set.
                            */
    UINT32 rir_rnk_tgt2_diff : 1;

                            /* Bits[28:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               only used in DDR5 mode to indicate 2 sub-
                               channels uses rir_rnk_tgt2 and rir_rnk_tgt2_s1
                               fields respectively.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV2OFFSET_0_MC_MAIN_STRUCT;

/* RIRILV2OFFSET_1_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208b8)                                                      */
/*      SPRB0 (0x200208b8)                                                      */
/*      SPRHBM (0x200208b8)                                                     */
/*      SPRC0 (0x200208b8)                                                      */
/*      SPRMCC (0x200208b8)                                                     */
/*      SPRUCC (0x200208b8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv2offset, one per RIR
*/


#define RIRILV2OFFSET_1_MC_MAIN_REG 0x070208B8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset2 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET2[39:26] == rank interleave 2
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt2 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 2 (used for
                               1/2/4/8-way RIR interleaving). In DDR5 mode, if
                               rir_rnk_tgt2_diff is set, this field is used for
                               sub-channel 0 only. Otherwise, it is used for
                               both sub-channels.
                            */
    UINT32 rir_rnk_tgt2_s1 : 4;

                            /* Bits[27:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 2 (used for
                               1/2/4/8-way RIR interleaving). only used in DDR5
                               mode for sub-channel 1 if rir_rnk_tgt2_diff bit
                               is set.
                            */
    UINT32 rir_rnk_tgt2_diff : 1;

                            /* Bits[28:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               only used in DDR5 mode to indicate 2 sub-
                               channels uses rir_rnk_tgt2 and rir_rnk_tgt2_s1
                               fields respectively.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV2OFFSET_1_MC_MAIN_STRUCT;

/* RIRILV2OFFSET_2_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208bc)                                                      */
/*      SPRB0 (0x200208bc)                                                      */
/*      SPRHBM (0x200208bc)                                                     */
/*      SPRC0 (0x200208bc)                                                      */
/*      SPRMCC (0x200208bc)                                                     */
/*      SPRUCC (0x200208bc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv2offset, one per RIR
*/


#define RIRILV2OFFSET_2_MC_MAIN_REG 0x070208BC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset2 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET2[39:26] == rank interleave 2
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt2 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 2 (used for
                               1/2/4/8-way RIR interleaving). In DDR5 mode, if
                               rir_rnk_tgt2_diff is set, this field is used for
                               sub-channel 0 only. Otherwise, it is used for
                               both sub-channels.
                            */
    UINT32 rir_rnk_tgt2_s1 : 4;

                            /* Bits[27:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 2 (used for
                               1/2/4/8-way RIR interleaving). only used in DDR5
                               mode for sub-channel 1 if rir_rnk_tgt2_diff bit
                               is set.
                            */
    UINT32 rir_rnk_tgt2_diff : 1;

                            /* Bits[28:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               only used in DDR5 mode to indicate 2 sub-
                               channels uses rir_rnk_tgt2 and rir_rnk_tgt2_s1
                               fields respectively.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV2OFFSET_2_MC_MAIN_STRUCT;

/* RIRILV2OFFSET_3_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208c0)                                                      */
/*      SPRB0 (0x200208c0)                                                      */
/*      SPRHBM (0x200208c0)                                                     */
/*      SPRC0 (0x200208c0)                                                      */
/*      SPRMCC (0x200208c0)                                                     */
/*      SPRUCC (0x200208c0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv2offset, one per RIR
*/


#define RIRILV2OFFSET_3_MC_MAIN_REG 0x070208C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset2 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET2[39:26] == rank interleave 2
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt2 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 2 (used for
                               1/2/4/8-way RIR interleaving). In DDR5 mode, if
                               rir_rnk_tgt2_diff is set, this field is used for
                               sub-channel 0 only. Otherwise, it is used for
                               both sub-channels.
                            */
    UINT32 rir_rnk_tgt2_s1 : 4;

                            /* Bits[27:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 2 (used for
                               1/2/4/8-way RIR interleaving). only used in DDR5
                               mode for sub-channel 1 if rir_rnk_tgt2_diff bit
                               is set.
                            */
    UINT32 rir_rnk_tgt2_diff : 1;

                            /* Bits[28:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               only used in DDR5 mode to indicate 2 sub-
                               channels uses rir_rnk_tgt2 and rir_rnk_tgt2_s1
                               fields respectively.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV2OFFSET_3_MC_MAIN_STRUCT;

/* RIRILV3OFFSET_0_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208c4)                                                      */
/*      SPRB0 (0x200208c4)                                                      */
/*      SPRHBM (0x200208c4)                                                     */
/*      SPRC0 (0x200208c4)                                                      */
/*      SPRMCC (0x200208c4)                                                     */
/*      SPRUCC (0x200208c4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv3offset, one per RIR
*/


#define RIRILV3OFFSET_0_MC_MAIN_REG 0x070208C4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset3 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET3[39:26] == rank interleave 3
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt3 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 3 (used for
                               1/2/4/8-way RIR interleaving). In DDR5 mode, if
                               rir_rnk_tgt3_diff is set, this field is used for
                               sub-channel 0 only. Otherwise, it is used for
                               both sub-channels.
                            */
    UINT32 rir_rnk_tgt3_s1 : 4;

                            /* Bits[27:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 3 (used for
                               1/2/4/8-way RIR interleaving). only used in DDR5
                               mode for sub-channel 1 if rir_rnk_tgt3_diff bit
                               is set.
                            */
    UINT32 rir_rnk_tgt3_diff : 1;

                            /* Bits[28:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               only used in DDR5 mode to indicate 2 sub-
                               channels uses rir_rnk_tgt3 and rir_rnk_tgt3_s1
                               fields respectively.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV3OFFSET_0_MC_MAIN_STRUCT;

/* RIRILV3OFFSET_1_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208c8)                                                      */
/*      SPRB0 (0x200208c8)                                                      */
/*      SPRHBM (0x200208c8)                                                     */
/*      SPRC0 (0x200208c8)                                                      */
/*      SPRMCC (0x200208c8)                                                     */
/*      SPRUCC (0x200208c8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv3offset, one per RIR
*/


#define RIRILV3OFFSET_1_MC_MAIN_REG 0x070208C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset3 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET3[39:26] == rank interleave 3
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt3 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 3 (used for
                               1/2/4/8-way RIR interleaving). In DDR5 mode, if
                               rir_rnk_tgt3_diff is set, this field is used for
                               sub-channel 0 only. Otherwise, it is used for
                               both sub-channels.
                            */
    UINT32 rir_rnk_tgt3_s1 : 4;

                            /* Bits[27:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 3 (used for
                               1/2/4/8-way RIR interleaving). only used in DDR5
                               mode for sub-channel 1 if rir_rnk_tgt3_diff bit
                               is set.
                            */
    UINT32 rir_rnk_tgt3_diff : 1;

                            /* Bits[28:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               only used in DDR5 mode to indicate 2 sub-
                               channels uses rir_rnk_tgt3 and rir_rnk_tgt3_s1
                               fields respectively.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV3OFFSET_1_MC_MAIN_STRUCT;

/* RIRILV3OFFSET_2_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208cc)                                                      */
/*      SPRB0 (0x200208cc)                                                      */
/*      SPRHBM (0x200208cc)                                                     */
/*      SPRC0 (0x200208cc)                                                      */
/*      SPRMCC (0x200208cc)                                                     */
/*      SPRUCC (0x200208cc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv3offset, one per RIR
*/


#define RIRILV3OFFSET_2_MC_MAIN_REG 0x070208CC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset3 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET3[39:26] == rank interleave 3
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt3 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 3 (used for
                               1/2/4/8-way RIR interleaving). In DDR5 mode, if
                               rir_rnk_tgt3_diff is set, this field is used for
                               sub-channel 0 only. Otherwise, it is used for
                               both sub-channels.
                            */
    UINT32 rir_rnk_tgt3_s1 : 4;

                            /* Bits[27:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 3 (used for
                               1/2/4/8-way RIR interleaving). only used in DDR5
                               mode for sub-channel 1 if rir_rnk_tgt3_diff bit
                               is set.
                            */
    UINT32 rir_rnk_tgt3_diff : 1;

                            /* Bits[28:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               only used in DDR5 mode to indicate 2 sub-
                               channels uses rir_rnk_tgt3 and rir_rnk_tgt3_s1
                               fields respectively.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV3OFFSET_2_MC_MAIN_STRUCT;

/* RIRILV3OFFSET_3_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208d0)                                                      */
/*      SPRB0 (0x200208d0)                                                      */
/*      SPRHBM (0x200208d0)                                                     */
/*      SPRC0 (0x200208d0)                                                      */
/*      SPRMCC (0x200208d0)                                                     */
/*      SPRUCC (0x200208d0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv3offset, one per RIR
*/


#define RIRILV3OFFSET_3_MC_MAIN_REG 0x070208D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset3 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET3[39:26] == rank interleave 3
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt3 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 3 (used for
                               1/2/4/8-way RIR interleaving). In DDR5 mode, if
                               rir_rnk_tgt3_diff is set, this field is used for
                               sub-channel 0 only. Otherwise, it is used for
                               both sub-channels.
                            */
    UINT32 rir_rnk_tgt3_s1 : 4;

                            /* Bits[27:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 3 (used for
                               1/2/4/8-way RIR interleaving). only used in DDR5
                               mode for sub-channel 1 if rir_rnk_tgt3_diff bit
                               is set.
                            */
    UINT32 rir_rnk_tgt3_diff : 1;

                            /* Bits[28:28], Access Type=RW/V, default=0x00000000*/

                            /*
                               only used in DDR5 mode to indicate 2 sub-
                               channels uses rir_rnk_tgt3 and rir_rnk_tgt3_s1
                               fields respectively.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV3OFFSET_3_MC_MAIN_STRUCT;

/* RIRILV4OFFSET_0_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208d4)                                                      */
/*      SPRB0 (0x200208d4)                                                      */
/*      SPRHBM (0x200208d4)                                                     */
/*      SPRC0 (0x200208d4)                                                      */
/*      SPRMCC (0x200208d4)                                                     */
/*      SPRUCC (0x200208d4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv4offset, one per RIR
*/


#define RIRILV4OFFSET_0_MC_MAIN_REG 0x070208D4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset4 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET4[39:26] == rank interleave 4
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt4 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 4 (used for
                               1/2/4/8-way RIR interleaving).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV4OFFSET_0_MC_MAIN_STRUCT;

/* RIRILV4OFFSET_1_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208d8)                                                      */
/*      SPRB0 (0x200208d8)                                                      */
/*      SPRHBM (0x200208d8)                                                     */
/*      SPRC0 (0x200208d8)                                                      */
/*      SPRMCC (0x200208d8)                                                     */
/*      SPRUCC (0x200208d8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv4offset, one per RIR
*/


#define RIRILV4OFFSET_1_MC_MAIN_REG 0x070208D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset4 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET4[39:26] == rank interleave 4
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt4 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 4 (used for
                               1/2/4/8-way RIR interleaving).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV4OFFSET_1_MC_MAIN_STRUCT;

/* RIRILV4OFFSET_2_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208dc)                                                      */
/*      SPRB0 (0x200208dc)                                                      */
/*      SPRHBM (0x200208dc)                                                     */
/*      SPRC0 (0x200208dc)                                                      */
/*      SPRMCC (0x200208dc)                                                     */
/*      SPRUCC (0x200208dc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv4offset, one per RIR
*/


#define RIRILV4OFFSET_2_MC_MAIN_REG 0x070208DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset4 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET4[39:26] == rank interleave 4
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt4 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 4 (used for
                               1/2/4/8-way RIR interleaving).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV4OFFSET_2_MC_MAIN_STRUCT;

/* RIRILV4OFFSET_3_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208e0)                                                      */
/*      SPRB0 (0x200208e0)                                                      */
/*      SPRHBM (0x200208e0)                                                     */
/*      SPRC0 (0x200208e0)                                                      */
/*      SPRMCC (0x200208e0)                                                     */
/*      SPRUCC (0x200208e0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv4offset, one per RIR
*/


#define RIRILV4OFFSET_3_MC_MAIN_REG 0x070208E0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset4 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET4[39:26] == rank interleave 4
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt4 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 4 (used for
                               1/2/4/8-way RIR interleaving).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV4OFFSET_3_MC_MAIN_STRUCT;

/* RIRILV5OFFSET_0_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208e4)                                                      */
/*      SPRB0 (0x200208e4)                                                      */
/*      SPRHBM (0x200208e4)                                                     */
/*      SPRC0 (0x200208e4)                                                      */
/*      SPRMCC (0x200208e4)                                                     */
/*      SPRUCC (0x200208e4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv5offset, one per RIR
*/


#define RIRILV5OFFSET_0_MC_MAIN_REG 0x070208E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset5 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET5[39:26] == rank interleave 5
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt5 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 5 (used for
                               1/2/4/8-way RIR interleaving).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV5OFFSET_0_MC_MAIN_STRUCT;

/* RIRILV5OFFSET_1_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208e8)                                                      */
/*      SPRB0 (0x200208e8)                                                      */
/*      SPRHBM (0x200208e8)                                                     */
/*      SPRC0 (0x200208e8)                                                      */
/*      SPRMCC (0x200208e8)                                                     */
/*      SPRUCC (0x200208e8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv5offset, one per RIR
*/


#define RIRILV5OFFSET_1_MC_MAIN_REG 0x070208E8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset5 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET5[39:26] == rank interleave 5
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt5 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 5 (used for
                               1/2/4/8-way RIR interleaving).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV5OFFSET_1_MC_MAIN_STRUCT;

/* RIRILV5OFFSET_2_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208ec)                                                      */
/*      SPRB0 (0x200208ec)                                                      */
/*      SPRHBM (0x200208ec)                                                     */
/*      SPRC0 (0x200208ec)                                                      */
/*      SPRMCC (0x200208ec)                                                     */
/*      SPRUCC (0x200208ec)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv5offset, one per RIR
*/


#define RIRILV5OFFSET_2_MC_MAIN_REG 0x070208EC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset5 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET5[39:26] == rank interleave 5
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt5 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 5 (used for
                               1/2/4/8-way RIR interleaving).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV5OFFSET_2_MC_MAIN_STRUCT;

/* RIRILV5OFFSET_3_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208f0)                                                      */
/*      SPRB0 (0x200208f0)                                                      */
/*      SPRHBM (0x200208f0)                                                     */
/*      SPRC0 (0x200208f0)                                                      */
/*      SPRMCC (0x200208f0)                                                     */
/*      SPRUCC (0x200208f0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv5offset, one per RIR
*/


#define RIRILV5OFFSET_3_MC_MAIN_REG 0x070208F0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset5 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET5[39:26] == rank interleave 5
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt5 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 5 (used for
                               1/2/4/8-way RIR interleaving).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV5OFFSET_3_MC_MAIN_STRUCT;

/* RIRILV6OFFSET_0_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208f4)                                                      */
/*      SPRB0 (0x200208f4)                                                      */
/*      SPRHBM (0x200208f4)                                                     */
/*      SPRC0 (0x200208f4)                                                      */
/*      SPRMCC (0x200208f4)                                                     */
/*      SPRUCC (0x200208f4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv6offset, one per RIR
*/


#define RIRILV6OFFSET_0_MC_MAIN_REG 0x070208F4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset6 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET6[39:26] == rank interleave 6
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt6 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 6 (used for
                               1/2/4/8-way RIR interleaving).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV6OFFSET_0_MC_MAIN_STRUCT;

/* RIRILV6OFFSET_1_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208f8)                                                      */
/*      SPRB0 (0x200208f8)                                                      */
/*      SPRHBM (0x200208f8)                                                     */
/*      SPRC0 (0x200208f8)                                                      */
/*      SPRMCC (0x200208f8)                                                     */
/*      SPRUCC (0x200208f8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv6offset, one per RIR
*/


#define RIRILV6OFFSET_1_MC_MAIN_REG 0x070208F8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset6 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET6[39:26] == rank interleave 6
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt6 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 6 (used for
                               1/2/4/8-way RIR interleaving).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV6OFFSET_1_MC_MAIN_STRUCT;

/* RIRILV6OFFSET_2_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x200208fc)                                                      */
/*      SPRB0 (0x200208fc)                                                      */
/*      SPRHBM (0x200208fc)                                                     */
/*      SPRC0 (0x200208fc)                                                      */
/*      SPRMCC (0x200208fc)                                                     */
/*      SPRUCC (0x200208fc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv6offset, one per RIR
*/


#define RIRILV6OFFSET_2_MC_MAIN_REG 0x070208FC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset6 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET6[39:26] == rank interleave 6
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt6 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 6 (used for
                               1/2/4/8-way RIR interleaving).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV6OFFSET_2_MC_MAIN_STRUCT;

/* RIRILV6OFFSET_3_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x20020900)                                                      */
/*      SPRB0 (0x20020900)                                                      */
/*      SPRHBM (0x20020900)                                                     */
/*      SPRC0 (0x20020900)                                                      */
/*      SPRMCC (0x20020900)                                                     */
/*      SPRUCC (0x20020900)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv6offset, one per RIR
*/


#define RIRILV6OFFSET_3_MC_MAIN_REG 0x07020900

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset6 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET6[39:26] == rank interleave 6
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt6 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 6 (used for
                               1/2/4/8-way RIR interleaving).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV6OFFSET_3_MC_MAIN_STRUCT;

/* RIRILV7OFFSET_0_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x20020904)                                                      */
/*      SPRB0 (0x20020904)                                                      */
/*      SPRHBM (0x20020904)                                                     */
/*      SPRC0 (0x20020904)                                                      */
/*      SPRMCC (0x20020904)                                                     */
/*      SPRUCC (0x20020904)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv7offset, one per RIR
*/


#define RIRILV7OFFSET_0_MC_MAIN_REG 0x07020904

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset7 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET7[39:26] == rank interleave 0
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt7 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 7 (used for
                               1/2/4/8-way RIR interleaving).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV7OFFSET_0_MC_MAIN_STRUCT;

/* RIRILV7OFFSET_1_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x20020908)                                                      */
/*      SPRB0 (0x20020908)                                                      */
/*      SPRHBM (0x20020908)                                                     */
/*      SPRC0 (0x20020908)                                                      */
/*      SPRMCC (0x20020908)                                                     */
/*      SPRUCC (0x20020908)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv7offset, one per RIR
*/


#define RIRILV7OFFSET_1_MC_MAIN_REG 0x07020908

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset7 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET7[39:26] == rank interleave 0
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt7 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 7 (used for
                               1/2/4/8-way RIR interleaving).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV7OFFSET_1_MC_MAIN_STRUCT;

/* RIRILV7OFFSET_2_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x2002090c)                                                      */
/*      SPRB0 (0x2002090c)                                                      */
/*      SPRHBM (0x2002090c)                                                     */
/*      SPRC0 (0x2002090c)                                                      */
/*      SPRMCC (0x2002090c)                                                     */
/*      SPRUCC (0x2002090c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv7offset, one per RIR
*/


#define RIRILV7OFFSET_2_MC_MAIN_REG 0x0702090C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset7 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET7[39:26] == rank interleave 0
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt7 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 7 (used for
                               1/2/4/8-way RIR interleaving).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV7OFFSET_2_MC_MAIN_STRUCT;

/* RIRILV7OFFSET_3_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x20020910)                                                      */
/*      SPRB0 (0x20020910)                                                      */
/*      SPRHBM (0x20020910)                                                     */
/*      SPRC0 (0x20020910)                                                      */
/*      SPRMCC (0x20020910)                                                     */
/*      SPRUCC (0x20020910)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* Four instances of ririlv7offset, one per RIR
*/


#define RIRILV7OFFSET_3_MC_MAIN_REG 0x07020910

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_offset7 : 16;

                            /* Bits[17:2], Access Type=RW, default=0x00000000*/

                            /*
                               RIR[5:0].RANKOFFSET7[39:26] == rank interleave 0
                               offset, 64MB granularity (The processors minimum
                               rank size is 512MB. 512MB/8 interleave = 64MB
                               per 8-way interleave.)
                            */
    UINT32 rsvd_18 : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rir_rnk_tgt7 : 4;

                            /* Bits[23:20], Access Type=RW/V, default=0x00000000*/

                            /*
                               target rank ID for rank interleave 7 (used for
                               1/2/4/8-way RIR interleaving).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RIRILV7OFFSET_3_MC_MAIN_STRUCT;

/* MCDECS_CHKN_BIT_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x2002091c)                                                      */
/*      SPRB0 (0x2002091c)                                                      */
/*      SPRHBM (0x2002091c)                                                     */
/*      SPRC0 (0x2002091c)                                                      */
/*      SPRMCC (0x2002091c)                                                     */
/*      SPRUCC (0x2002091c)                                                     */
/* Register default value on SPRA0: 0x00000002                                  */
/* Register default value on SPRB0: 0x00000002                                  */
/* Register default value on SPRHBM: 0x00000002                                 */
/* Register default value on SPRC0: 0x00000002                                  */
/* Register default value on SPRMCC: 0x00000002                                 */
/* Register default value on SPRUCC: 0x00000002                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Chicken bits 
*/


#define MCDECS_CHKN_BIT_MC_MAIN_REG 0x0702091C

#if defined(SPRA0_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_mcdecs_pri_rcb_gate : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Disable RCB Clock Gate in DECS */
    UINT32 rsvd_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_clkgate_decs_cpgc : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, clock gating is disabled on
                               signals that stage CPGC address.
                            */
    UINT32 en_clkgate_mrc_done : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Enable additional clock gating on logic that
                               does not change after MRC completes programming
                               MC. BIOS should set this bit after the end of
                               MRC
                            */
    UINT32 rsvd_4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCDECS_CHKN_BIT_MC_MAIN_SPRA0_STRUCT;
#endif /* (SPRA0_HOST) */

#if defined(SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_mcdecs_pri_rcb_gate : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Disable RCB Clock Gate in DECS */
    UINT32 rsvd_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_clkgate_decs_cpgc : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, clock gating is disabled on
                               signals that stage CPGC address.
                            */
    UINT32 en_clkgate_mrc_done : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Enable additional clock gating on logic that
                               does not change after MRC completes programming
                               MC. BIOS should set this bit after the end of
                               MRC
                            */
    UINT32 rsvd_4 : 28;

                            /* Bits[31:4], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCDECS_CHKN_BIT_MC_MAIN_SPRB0_SPRHBM_SPRC0_SPRMCC_SPRUCC_STRUCT;
#endif /* (SPRB0_HOST) || defined(SPRHBM_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_mcdecs_pri_rcb_gate : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Disable RCB Clock Gate in DECS */
    UINT32 rsvd_1 : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_clkgate_decs_cpgc : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, clock gating is disabled on
                               signals that stage CPGC address.
                            */
    UINT32 en_clkgate_mrc_done : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Enable additional clock gating on logic that
                               does not change after MRC completes programming
                               MC. BIOS should set this bit after the end of
                               MRC
                            */
    UINT32 rsvd_4 : 3;

                            /* Bits[6:4], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 25;

                            /* Bits[31:7], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCDECS_CHKN_BIT_MC_MAIN_STRUCT;

/* MCDECS_CHICKEN_BITS_MC_MAIN_REG supported on:                                */
/*      SPRA0 (0x20920)                                                         */
/*      SPRB0 (0x20920)                                                         */
/*      SPRHBM (0x20920)                                                        */
/*      SPRC0 (0x20920)                                                         */
/*      SPRMCC (0x20920)                                                        */
/*      SPRUCC (0x20920)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* MCDECS_CHICKEN_BITS
*/


#define MCDECS_CHICKEN_BITS_MC_MAIN_REG 0x07000920

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 dis_ck_gate_addr_dec : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Disable clock gating addr_decode */
    UINT8 dis_isoch_wr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Reserved - unused. */
    UINT8 dis_isoch_rd : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Reserved - unused. */
    UINT8 defeature_2 : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* Reserved Unused */
    UINT8 defeature_3 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, disables fix to prevent error
                               injection on directory writes. Should be set to
                               0 to not inject on directory writes.
                            */
    UINT8 en_cpgc_adddc : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /* Reserved - unused. */
    UINT8 defeature : 2;

                            /* Bits[7:6], Access Type=RW, default=0x00000000*/

                            /*
                               Defeature bits. Bit 6 - Enable 1 cc additional
                               delay for all new request to align ADDDC and +1
                               information with other fields.
                            */

  } Bits;
  UINT8 Data;

} MCDECS_CHICKEN_BITS_MC_MAIN_STRUCT;

/* PXPENHCAP_MC_MAIN_REG supported on:                                          */
/*      SPRA0 (0x20020928)                                                      */
/*      SPRB0 (0x20020928)                                                      */
/*      SPRHBM (0x20020928)                                                     */
/*      SPRC0 (0x20020928)                                                      */
/*      SPRMCC (0x20020928)                                                     */
/*      SPRUCC (0x20020928)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This field points to the next Capability in extended configuration space.
*/


#define PXPENHCAP_MC_MAIN_REG 0x07020928

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 capability_id : 16;

                            /* Bits[15:0], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates there are no capability structures in
                               the enhanced configuration space.
                            */
    UINT32 capability_version : 4;

                            /* Bits[19:16], Access Type=RO, default=0x00000000*/

                            /*
                               Indicates there are no capability structures in
                               the enhanced configuration space.
                            */
    UINT32 next_capability_offset : 12;

                            /* Bits[31:20], Access Type=RO, default=0x00000000*/

                            /* Next capability offset. */

  } Bits;
  UINT32 Data;

} PXPENHCAP_MC_MAIN_STRUCT;

/* ECC_MODE_RANK0_MC_MAIN_REG supported on:                                     */
/*      SPRA0 (0x2092c)                                                         */
/*      SPRB0 (0x2092c)                                                         */
/*      SPRHBM (0x2092c)                                                        */
/*      SPRC0 (0x2092c)                                                         */
/*      SPRMCC (0x2092c)                                                        */
/*      SPRUCC (0x2092c)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
          This register specifies the current ECC configuration for each rank.
      
*/


#define ECC_MODE_RANK0_MC_MAIN_REG 0x0700092C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mode : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the ECC in use for this
                               rank. 0 = No failure 1 = Parity substitution.
                               EP: Detect only, EX: Single bit correction This
                               field is set by hardware at the end of a sparing
                               flow.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} ECC_MODE_RANK0_MC_MAIN_STRUCT;

/* ECC_MODE_RANK1_MC_MAIN_REG supported on:                                     */
/*      SPRA0 (0x20930)                                                         */
/*      SPRB0 (0x20930)                                                         */
/*      SPRHBM (0x20930)                                                        */
/*      SPRC0 (0x20930)                                                         */
/*      SPRMCC (0x20930)                                                        */
/*      SPRUCC (0x20930)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
          This register specifies the current ECC configuration for each rank.
      
*/


#define ECC_MODE_RANK1_MC_MAIN_REG 0x07000930

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mode : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the ECC in use for this
                               rank. 0 = No failure 1 = Parity substitution.
                               EP: Detect only, EX: Single bit correction This
                               field is set by hardware at the end of a sparing
                               flow.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} ECC_MODE_RANK1_MC_MAIN_STRUCT;

/* ECC_MODE_RANK2_MC_MAIN_REG supported on:                                     */
/*      SPRA0 (0x20934)                                                         */
/*      SPRB0 (0x20934)                                                         */
/*      SPRHBM (0x20934)                                                        */
/*      SPRC0 (0x20934)                                                         */
/*      SPRMCC (0x20934)                                                        */
/*      SPRUCC (0x20934)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
          This register specifies the current ECC configuration for each rank.
      
*/


#define ECC_MODE_RANK2_MC_MAIN_REG 0x07000934

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mode : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the ECC in use for this
                               rank. 0 = No failure 1 = Parity substitution.
                               EP: Detect only, EX: Single bit correction This
                               field is set by hardware at the end of a sparing
                               flow.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} ECC_MODE_RANK2_MC_MAIN_STRUCT;

/* ECC_MODE_RANK3_MC_MAIN_REG supported on:                                     */
/*      SPRA0 (0x20938)                                                         */
/*      SPRB0 (0x20938)                                                         */
/*      SPRHBM (0x20938)                                                        */
/*      SPRC0 (0x20938)                                                         */
/*      SPRMCC (0x20938)                                                        */
/*      SPRUCC (0x20938)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
          This register specifies the current ECC configuration for each rank.
      
*/


#define ECC_MODE_RANK3_MC_MAIN_REG 0x07000938

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mode : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the ECC in use for this
                               rank. 0 = No failure 1 = Parity substitution.
                               EP: Detect only, EX: Single bit correction This
                               field is set by hardware at the end of a sparing
                               flow.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} ECC_MODE_RANK3_MC_MAIN_STRUCT;

/* ECC_MODE_RANK4_MC_MAIN_REG supported on:                                     */
/*      SPRA0 (0x2093c)                                                         */
/*      SPRB0 (0x2093c)                                                         */
/*      SPRHBM (0x2093c)                                                        */
/*      SPRC0 (0x2093c)                                                         */
/*      SPRMCC (0x2093c)                                                        */
/*      SPRUCC (0x2093c)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
          This register specifies the current ECC configuration for each rank.
      
*/


#define ECC_MODE_RANK4_MC_MAIN_REG 0x0700093C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mode : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the ECC in use for this
                               rank. 0 = No failure 1 = Parity substitution.
                               EP: Detect only, EX: Single bit correction This
                               field is set by hardware at the end of a sparing
                               flow.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} ECC_MODE_RANK4_MC_MAIN_STRUCT;

/* ECC_MODE_RANK5_MC_MAIN_REG supported on:                                     */
/*      SPRA0 (0x20940)                                                         */
/*      SPRB0 (0x20940)                                                         */
/*      SPRHBM (0x20940)                                                        */
/*      SPRC0 (0x20940)                                                         */
/*      SPRMCC (0x20940)                                                        */
/*      SPRUCC (0x20940)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
          This register specifies the current ECC configuration for each rank.
      
*/


#define ECC_MODE_RANK5_MC_MAIN_REG 0x07000940

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mode : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the ECC in use for this
                               rank. 0 = No failure 1 = Parity substitution.
                               EP: Detect only, EX: Single bit correction This
                               field is set by hardware at the end of a sparing
                               flow.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} ECC_MODE_RANK5_MC_MAIN_STRUCT;

/* ECC_MODE_RANK6_MC_MAIN_REG supported on:                                     */
/*      SPRA0 (0x20944)                                                         */
/*      SPRB0 (0x20944)                                                         */
/*      SPRHBM (0x20944)                                                        */
/*      SPRC0 (0x20944)                                                         */
/*      SPRMCC (0x20944)                                                        */
/*      SPRUCC (0x20944)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
          This register specifies the current ECC configuration for each rank.
      
*/


#define ECC_MODE_RANK6_MC_MAIN_REG 0x07000944

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mode : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the ECC in use for this
                               rank. 0 = No failure 1 = Parity substitution.
                               EP: Detect only, EX: Single bit correction This
                               field is set by hardware at the end of a sparing
                               flow.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} ECC_MODE_RANK6_MC_MAIN_STRUCT;

/* ECC_MODE_RANK7_MC_MAIN_REG supported on:                                     */
/*      SPRA0 (0x20948)                                                         */
/*      SPRB0 (0x20948)                                                         */
/*      SPRHBM (0x20948)                                                        */
/*      SPRC0 (0x20948)                                                         */
/*      SPRMCC (0x20948)                                                        */
/*      SPRUCC (0x20948)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* 
          This register specifies the current ECC configuration for each rank.
      
*/


#define ECC_MODE_RANK7_MC_MAIN_REG 0x07000948

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 mode : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the ECC in use for this
                               rank. 0 = No failure 1 = Parity substitution.
                               EP: Detect only, EX: Single bit correction This
                               field is set by hardware at the end of a sparing
                               flow.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} ECC_MODE_RANK7_MC_MAIN_STRUCT;




/* MCDECS_ERR_LOG_MC_MAIN_REG supported on:                                     */
/*      SPRA0 (0x20020968)                                                      */
/*      SPRB0 (0x20020968)                                                      */
/*      SPRHBM (0x20020968)                                                     */
/*      SPRC0 (0x20020968)                                                      */
/*      SPRMCC (0x20020968)                                                     */
/*      SPRUCC (0x20020968)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Error information in mcdecs
*/


#define MCDECS_ERR_LOG_MC_MAIN_REG 0x07020968

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 critical_chunk_err : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Error indication when critical chunk bit is set
                               for ADDDC or PlusOne transaction
                            */
    UINT32 rsvd : 31;

                            /* Bits[31:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCDECS_ERR_LOG_MC_MAIN_STRUCT;

/* MCDDRTCFG_MC_MAIN_REG supported on:                                          */
/*      SPRA0 (0x20020970)                                                      */
/*      SPRB0 (0x20020970)                                                      */
/*      SPRHBM (0x20020970)                                                     */
/*      SPRC0 (0x20020970)                                                      */
/*      SPRMCC (0x20020970)                                                     */
/*      SPRUCC (0x20020970)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* MC DDRT Config register.
*/


#define MCDDRTCFG_MC_MAIN_REG 0x07020970

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 slot0 : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               DDR-T DIMM populated if set; otherwise,
                               unpopulated. Should be set to 0 when this slot
                               is populated with a DDR4 DIMM.
                            */
    UINT32 slot1 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               DDR-T DIMM populated if set; otherwise,
                               unpopulated. Should be set to 0 when this slot
                               is populated with a DDR4 DIMM.
                            */
    UINT32 rsvd : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCDDRTCFG_MC_MAIN_STRUCT;

/* RSP_FUNC_ADDR_MATCH_LO_MC_MAIN_REG supported on:                             */
/*      SPRA0 (0x20020990)                                                      */
/*      SPRB0 (0x20020990)                                                      */
/*      SPRHBM (0x20020990)                                                     */
/*      SPRC0 (0x20020990)                                                      */
/*      SPRMCC (0x20020990)                                                     */
/*      SPRUCC (0x20020990)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Complete address match (Addr[45:3]) and mask is supported for all M2M writes. The error injection logic uses the address match mask logic output to determine which memory writes need to get error injection. Users can program up to two x4 device masks (8-bits per chunk - 64 bits per cacheline). 
*/


#define RSP_FUNC_ADDR_MATCH_LO_MC_MAIN_REG 0x07020990

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_match_lower : 32;

                            /* Bits[31:0], Access Type=RW/P, default=0x00000000*/

                            /* Addr Match Lower: 32-bits (Match Addr[34:3]) */

  } Bits;
  UINT32 Data;

} RSP_FUNC_ADDR_MATCH_LO_MC_MAIN_STRUCT;

/* RSP_FUNC_ADDR_MATCH_HI_MC_MAIN_REG supported on:                             */
/*      SPRA0 (0x20020994)                                                      */
/*      SPRB0 (0x20020994)                                                      */
/*      SPRHBM (0x20020994)                                                     */
/*      SPRC0 (0x20020994)                                                      */
/*      SPRMCC (0x20020994)                                                     */
/*      SPRUCC (0x20020994)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Complete address match (Addr[45:3]) and mask is supported for all HA writes. The error injection logic uses the address match mask logic output to determine which memory writes need to get error injection. Users can program up to two x4 device masks (8-bits per chunk - 64 bits per cacheline). In Lockstep mode, only one device can be programmed in each lockstep channel.
*/


#define RSP_FUNC_ADDR_MATCH_HI_MC_MAIN_REG 0x07020994

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_match_higher : 17;

                            /* Bits[16:0], Access Type=RW/P, default=0x00000000*/

                            /* Addr Match Higher : 11-Bits (Match Addr[51:35]) */
    UINT32 rsp_func_addr_match_en : 1;

                            /* Bits[17:17], Access Type=RW/V/P/L, default=0x00000000*/

                            /*
                               Enabling the Address Match Response Function
                               when set.
                            */
    UINT32 rsp_func_addr_match_always : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /*
                               The enable bit RSP_FUNC_ADDR_MATCH_EN will not
                               be self cleared after match if this field is
                               set. Continuous address matching.
                            */
    UINT32 htid_match : 9;

                            /* Bits[27:19], Access Type=RW, default=0x00000000*/

                            /*
                               HTID comparison value for array dump. Note array
                               dump function is only enabled when the
                               WPQ_DUMP_CFG2.VALID or the RPQ_DUMP_CFG2.VALID
                               are enabled.
                            */
    UINT32 mirror_match : 3;

                            /* Bits[30:28], Access Type=RW/P, default=0x00000000*/

                            /*
                               Additional match configuration: Bit 0 matches
                               with Mirror field; Bit 1 matches with mirr_pri
                               (primary channel); Bit 2 matches with demand
                               scrub request
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RSP_FUNC_ADDR_MATCH_HI_MC_MAIN_STRUCT;

/* RSP_FUNC_ADDR_MASK_LO_MC_MAIN_REG supported on:                              */
/*      SPRA0 (0x20020998)                                                      */
/*      SPRB0 (0x20020998)                                                      */
/*      SPRHBM (0x20020998)                                                     */
/*      SPRC0 (0x20020998)                                                      */
/*      SPRMCC (0x20020998)                                                     */
/*      SPRUCC (0x20020998)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Complete address match (Addr[45:3]) and mask is supported for all HA writes. Error injection does not use the response logic triggers and uses the match mask logic output to determine which writes need to get error injection. Users can program up to two x4 device masks (8-bits per chunk - 64 bits per cacheline). In Lockstep mode, only one device can be programmed in each lockstep channel.
*/


#define RSP_FUNC_ADDR_MASK_LO_MC_MAIN_REG 0x07020998

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_mask_lower : 32;

                            /* Bits[31:0], Access Type=RW/P, default=0xFFFFFFFF*/

                            /*
                               Address Mask to deselect (when set) the
                               corresponding Addr[34:3] for the address match.
                            */

  } Bits;
  UINT32 Data;

} RSP_FUNC_ADDR_MASK_LO_MC_MAIN_STRUCT;

/* RSP_FUNC_ADDR_MASK_HI_MC_MAIN_REG supported on:                              */
/*      SPRA0 (0x2002099c)                                                      */
/*      SPRB0 (0x2002099c)                                                      */
/*      SPRHBM (0x2002099c)                                                     */
/*      SPRC0 (0x2002099c)                                                      */
/*      SPRMCC (0x2002099c)                                                     */
/*      SPRUCC (0x2002099c)                                                     */
/* Register default value on SPRA0: 0x1C01FFFF                                  */
/* Register default value on SPRB0: 0x1C01FFFF                                  */
/* Register default value on SPRHBM: 0x1C01FFFF                                 */
/* Register default value on SPRC0: 0x1C01FFFF                                  */
/* Register default value on SPRMCC: 0x1C01FFFF                                 */
/* Register default value on SPRUCC: 0x1C01FFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Complete address match (Addr[51:3]) and mask is supported for all HA writes. Error injection does not use the response logic triggers and uses the match mask logic output to determine which writes need to get error injection. Users can program up to two x4 device masks (8-bits per chunk - 64 bits per cacheline).
*/


#define RSP_FUNC_ADDR_MASK_HI_MC_MAIN_REG 0x0702099C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_mask_higher : 17;

                            /* Bits[16:0], Access Type=RW/P, default=0x0001FFFF*/

                            /*
                               Address Mask to deselect (when set) the
                               corresponding Addr[51:35] for the address match.
                            */
    UINT32 htid_mask : 9;

                            /* Bits[25:17], Access Type=RW, default=0x00000000*/

                            /* HTID mask comparison value for array dump */
    UINT32 mirror_mask : 3;

                            /* Bits[28:26], Access Type=RW/P, default=0x00000007*/

                            /*
                               Additional mask to deselect (when set) the
                               corresponding bits in mirror_mask field. Bit 0
                               is mask for Mirror field; Bit 1 is mask for
                               mirr_pri (primary channel); Bit 2 is mask for
                               demand scrub request
                            */
    UINT32 rsvd : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RSP_FUNC_ADDR_MASK_HI_MC_MAIN_STRUCT;

/* RSP_FUNC_RANK_BANK_MATCH_MC_MAIN_REG supported on:                           */
/*      SPRA0 (0x200209a0)                                                      */
/*      SPRB0 (0x200209a0)                                                      */
/*      SPRHBM (0x200209a0)                                                     */
/*      SPRC0 (0x200209a0)                                                      */
/*      SPRMCC (0x200209a0)                                                     */
/*      SPRUCC (0x200209a0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Enables targetting injection to a particular bank in a particular logical rank.  When enabled, programmed rank and bank will be matched, system address match will not be used.
*/


#define RSP_FUNC_RANK_BANK_MATCH_MC_MAIN_REG 0x070209A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 bank : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /* Bank to match */
    UINT32 rank : 3;

                            /* Bits[7:5], Access Type=RW, default=0x00000000*/

                            /* Rank to match */
    UINT32 bank2 : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000000*/

                            /*
                               Bank to match for second set of mask/match
                               register
                            */
    UINT32 rank2 : 3;

                            /* Bits[15:13], Access Type=RW, default=0x00000000*/

                            /*
                               Rank to match for second set of mask/match
                               register
                            */
    UINT32 rsvd : 8;

                            /* Bits[23:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dedup_use_addr_match_ddrt : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, for DDRT dedup addresses, use
                               address match for error injection instead of
                               using dedup selection input.
                            */
    UINT32 dedup_use_addr_match : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, for non-DDRT dedup addresses, use
                               address match for error injection instead of
                               using dedup selection input.
                            */
    UINT32 dis_tgr_inj2 : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Disable injection on transgress txn for second
                               set of mask/match register
                            */
    UINT32 dis_tgr_inj : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /* Disable injection on transgress txn */
    UINT32 dis_patspr2 : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Disable any injection matching on Patrol or
                               Spare transactions. This applies to rank/bank
                               match and system address match for second set of
                               mask/match register.
                            */
    UINT32 en2 : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rank and bank matching for second set of
                               mask/match register
                            */
    UINT32 dis_patspr : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Disable any injection matching on Patrol or
                               Spare transactions. This applies to rank/bank
                               match and system address match.
                            */
    UINT32 en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Enable rank and bank matching */

  } Bits;
  UINT32 Data;

} RSP_FUNC_RANK_BANK_MATCH_MC_MAIN_STRUCT;

/* RSP_FUNC_ADDR2_MATCH_LO_MC_MAIN_REG supported on:                            */
/*      SPRA0 (0x200209a4)                                                      */
/*      SPRB0 (0x200209a4)                                                      */
/*      SPRHBM (0x200209a4)                                                     */
/*      SPRC0 (0x200209a4)                                                      */
/*      SPRMCC (0x200209a4)                                                     */
/*      SPRUCC (0x200209a4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Complete address match (Addr[45:3]) and mask is supported for all M2M writes. The error injection logic uses the address match mask logic output to determine which memory writes need to get error injection. Users can program up to two x4 device masks (8-bits per chunk - 64 bits per cacheline). 
*/


#define RSP_FUNC_ADDR2_MATCH_LO_MC_MAIN_REG 0x070209A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_match_lower : 32;

                            /* Bits[31:0], Access Type=RW/P, default=0x00000000*/

                            /* Addr Match Lower: 32-bits (Match Addr[34:3]) */

  } Bits;
  UINT32 Data;

} RSP_FUNC_ADDR2_MATCH_LO_MC_MAIN_STRUCT;

/* RSP_FUNC_ADDR2_MATCH_HI_MC_MAIN_REG supported on:                            */
/*      SPRA0 (0x200209a8)                                                      */
/*      SPRB0 (0x200209a8)                                                      */
/*      SPRHBM (0x200209a8)                                                     */
/*      SPRC0 (0x200209a8)                                                      */
/*      SPRMCC (0x200209a8)                                                     */
/*      SPRUCC (0x200209a8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Complete address match (Addr[45:3]) and mask is supported for all HA writes. The error injection logic uses the address match mask logic output to determine which memory writes need to get error injection. Users can program up to two x4 device masks (8-bits per chunk - 64 bits per cacheline). In Lockstep mode, only one device can be programmed in each lockstep channel.
*/


#define RSP_FUNC_ADDR2_MATCH_HI_MC_MAIN_REG 0x070209A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_match_higher : 17;

                            /* Bits[16:0], Access Type=RW/P, default=0x00000000*/

                            /* Addr Match Higher : 11-Bits (Match Addr[51:35]) */
    UINT32 rsp_func_addr_match_en : 1;

                            /* Bits[17:17], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Enabling the Address Match Response Function
                               when set.
                            */
    UINT32 rsp_func_addr_match_always : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /*
                               The enable bit RSP_FUNC_ADDR_MATCH_EN will not
                               be self cleared after match if this field is
                               set. Continuous address matching.
                            */
    UINT32 rsvd : 9;

                            /* Bits[27:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mirror_match : 3;

                            /* Bits[30:28], Access Type=RW/P, default=0x00000000*/

                            /*
                               Additional match configuration: Bit 0 matches
                               with Mirror field; Bit 1 matches with mirr_pri
                               (primary channel); Bit 2 matches with demand
                               scrub request
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RSP_FUNC_ADDR2_MATCH_HI_MC_MAIN_STRUCT;

/* RSP_FUNC_ADDR2_MASK_LO_MC_MAIN_REG supported on:                             */
/*      SPRA0 (0x200209ac)                                                      */
/*      SPRB0 (0x200209ac)                                                      */
/*      SPRHBM (0x200209ac)                                                     */
/*      SPRC0 (0x200209ac)                                                      */
/*      SPRMCC (0x200209ac)                                                     */
/*      SPRUCC (0x200209ac)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Complete address match (Addr[45:3]) and mask is supported for all HA writes. Error injection does not use the response logic triggers and uses the match mask logic output to determine which writes need to get error injection. Users can program up to two x4 device masks (8-bits per chunk - 64 bits per cacheline). In Lockstep mode, only one device can be programmed in each lockstep channel.
*/


#define RSP_FUNC_ADDR2_MASK_LO_MC_MAIN_REG 0x070209AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_mask_lower : 32;

                            /* Bits[31:0], Access Type=RW/P, default=0xFFFFFFFF*/

                            /*
                               Address Mask to deselect (when set) the
                               corresponding Addr[34:3] for the address match.
                            */

  } Bits;
  UINT32 Data;

} RSP_FUNC_ADDR2_MASK_LO_MC_MAIN_STRUCT;

/* RSP_FUNC_ADDR2_MASK_HI_MC_MAIN_REG supported on:                             */
/*      SPRA0 (0x200209b0)                                                      */
/*      SPRB0 (0x200209b0)                                                      */
/*      SPRHBM (0x200209b0)                                                     */
/*      SPRC0 (0x200209b0)                                                      */
/*      SPRMCC (0x200209b0)                                                     */
/*      SPRUCC (0x200209b0)                                                     */
/* Register default value on SPRA0: 0x1C01FFFF                                  */
/* Register default value on SPRB0: 0x1C01FFFF                                  */
/* Register default value on SPRHBM: 0x1C01FFFF                                 */
/* Register default value on SPRC0: 0x1C01FFFF                                  */
/* Register default value on SPRMCC: 0x1C01FFFF                                 */
/* Register default value on SPRUCC: 0x1C01FFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Complete address match (Addr[51:3]) and mask is supported for all HA writes. Error injection does not use the response logic triggers and uses the match mask logic output to determine which writes need to get error injection. Users can program up to two x4 device masks (8-bits per chunk - 64 bits per cacheline).
*/


#define RSP_FUNC_ADDR2_MASK_HI_MC_MAIN_REG 0x070209B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_mask_higher : 17;

                            /* Bits[16:0], Access Type=RW/P, default=0x0001FFFF*/

                            /*
                               Address Mask to deselect (when set) the
                               corresponding Addr[51:35] for the address match.
                            */
    UINT32 rsvd : 9;

                            /* Bits[25:17], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mirror_mask : 3;

                            /* Bits[28:26], Access Type=RW/P, default=0x00000007*/

                            /*
                               Additional mask to deselect (when set) the
                               corresponding bits in mirror_mask field. Bit 0
                               is mask for Mirror field; Bit 1 is mask for
                               mirr_pri (primary channel); Bit 2 is mask for
                               demand scrub request
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RSP_FUNC_ADDR2_MASK_HI_MC_MAIN_STRUCT;

/* SCRATCHPAD2_MC_MAIN_REG supported on:                                        */
/*      SPRA0 (0x200209b8)                                                      */
/*      SPRB0 (0x200209b8)                                                      */
/*      SPRHBM (0x200209b8)                                                     */
/*      SPRC0 (0x200209b8)                                                      */
/*      SPRMCC (0x200209b8)                                                     */
/*      SPRUCC (0x200209b8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: P_U_CODE                                         */
/* SPRB0 Security PolicyGroup: P_U_CODE                                         */
/* SPRHBM Security PolicyGroup: P_U_CODE                                        */
/* SPRC0 Security PolicyGroup: P_U_CODE                                         */
/* SPRMCC Security PolicyGroup: P_U_CODE                                        */
/* SPRUCC Security PolicyGroup: P_U_CODE                                        */
/* 
          second scratch pad register in MCDECS_CSR for validation.  last one locates in mcmains and was only specific to MCDECS_CSR_CH0.  this one are channel specific.
      
*/


#define SCRATCHPAD2_MC_MAIN_REG 0x070209B8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 scratchpad2 : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* SCRATCHPAD2 */

  } Bits;
  UINT32 Data;

} SCRATCHPAD2_MC_MAIN_STRUCT;

/* MASK0_WDB_MC_MAIN_REG supported on:                                          */
/*      SPRA0 (0x200209c0)                                                      */
/*      SPRB0 (0x200209c0)                                                      */
/*      SPRHBM (0x200209c0)                                                     */
/*      SPRC0 (0x200209c0)                                                      */
/*      SPRMCC (0x200209c0)                                                     */
/*      SPRUCC (0x200209c0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* 
          This register specifies first part of WDB mask.
      
*/


#define MASK0_WDB_MC_MAIN_REG 0x070209C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wdb_mask : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set a bit to 1 in this field to prevent the WDB
                               from allocating into the entry. Each bit in the
                               32b field corresponds to one of the WDB entry in
                               entries 31 to 0 respectively. Bit 0 blocks WDB
                               entry 0 and Bit 31 masks WDB entry 31 and so on.
                            */

  } Bits;
  UINT32 Data;

} MASK0_WDB_MC_MAIN_STRUCT;

/* MASK1_WDB_MC_MAIN_REG supported on:                                          */
/*      SPRA0 (0x200209c4)                                                      */
/*      SPRB0 (0x200209c4)                                                      */
/*      SPRHBM (0x200209c4)                                                     */
/*      SPRC0 (0x200209c4)                                                      */
/*      SPRMCC (0x200209c4)                                                     */
/*      SPRUCC (0x200209c4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* 
          This register specifies second part of WDB mask.
      
*/


#define MASK1_WDB_MC_MAIN_REG 0x070209C4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wdb_mask : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set a bit to 1 in this field to prevent the WDB
                               from allocating into the entry. Each bit in the
                               32b field corresponds to one of the WDB entry in
                               entries 63 to 32 respectively. Bit 0 blocks WDB
                               entry 32 and Bit 31 masks WDB entry 63 and so
                               on.
                            */

  } Bits;
  UINT32 Data;

} MASK1_WDB_MC_MAIN_STRUCT;

/* ADDDC_REGION0_CONTROL_MC_MAIN_REG supported on:                              */
/*      SPRA0 (0x200209c8)                                                      */
/*      SPRB0 (0x200209c8)                                                      */
/*      SPRHBM (0x200209c8)                                                     */
/*      SPRC0 (0x200209c8)                                                      */
/*      SPRMCC (0x200209c8)                                                     */
/*      SPRUCC (0x200209c8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
          This register specifies the configuration for the regions using ADDDC for operation after the sparing copy is finished for the region.
      
*/


#define ADDDC_REGION0_CONTROL_MC_MAIN_REG 0x070209C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 region_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit specifies whether the ADDDC region is
                               in use. 0=ADDDC not enabled for this region
                               1=ADDDC enabled for this region This bit should
                               be set by software before the beginning of the
                               ADDDC sparing copy flow.
                            */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 region_size : 2;

                            /* Bits[3:2], Access Type=RW/V, default=0x00000000*/

                            /*
                               Granularity for this ADDDC region: 00=bank
                               01=rank 10=reserved 11=reserved
                            */
    UINT32 failed_cs : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the Chip Select (rank) to
                               match when determining if this is the failed
                               region participating in either ADDDC or Static
                               Virtual Lockstep. The value in this field is
                               encoded (Chip Selects are normally 1-hot),
                               corresponding to CS0-CS7. When the failed region
                               is a DIMM, two region registers should be
                               programmed corresponding to both Chip Selects of
                               the failed DIMM.
                            */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 failed_c : 3;

                            /* Bits[10:8], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the subrank to match when
                               determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 failed_ba : 2;

                            /* Bits[12:11], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank address to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 failed_bg : 3;

                            /* Bits[15:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank group to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 nonfailed_cs : 3;

                            /* Bits[18:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the Chip Select (rank) to
                               match when determining if this is the failed
                               region participating in either ADDDC or Static
                               Virtual Lockstep. The value in this field is
                               encoded (Chip Selects are normally 1-hot),
                               corresponding to CS0-CS7. When the failed region
                               is a DIMM, two region registers should be
                               programmed corresponding to both Chip Selects of
                               the failed DIMM.
                            */
    UINT32 rsvd_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 nonfailed_c : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the subrank to match when
                               determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 nonfailed_ba : 2;

                            /* Bits[24:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the bank address to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 nonfailed_bg : 3;

                            /* Bits[27:25], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank group to match
                               when determining if this is the failed region
                               participating in ADDDC. Only used when
                               region_size=bank.
                            */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 copy_in_progress : 1;

                            /* Bits[29:29], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies that ADDDC spare copy is
                               on-going for this region. This bit should be set
                               by BIOS before starting the ADDDC sparing copy
                               flow. This bit should be cleared by hardware at
                               the end of the sparing copy flow.
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ADDDC_REGION0_CONTROL_MC_MAIN_STRUCT;

/* ADDDC_REGION1_CONTROL_MC_MAIN_REG supported on:                              */
/*      SPRA0 (0x200209d0)                                                      */
/*      SPRB0 (0x200209d0)                                                      */
/*      SPRHBM (0x200209d0)                                                     */
/*      SPRC0 (0x200209d0)                                                      */
/*      SPRMCC (0x200209d0)                                                     */
/*      SPRUCC (0x200209d0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
          This register specifies the configuration for the regions using ADDDC for operation after the sparing copy is finished for the region.
      
*/


#define ADDDC_REGION1_CONTROL_MC_MAIN_REG 0x070209D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 region_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit specifies whether the ADDDC region is
                               in use. 0=ADDDC not enabled for this region
                               1=ADDDC enabled for this region
                            */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 region_size : 2;

                            /* Bits[3:2], Access Type=RW/V, default=0x00000000*/

                            /*
                               Granularity for this ADDDC region: 00=bank
                               01=rank 10=reserved 11=reserved
                            */
    UINT32 failed_cs : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the Chip Select (rank) to
                               match when determining if this is the failed
                               region participating in either ADDDC or Static
                               Virtual Lockstep. The value in this field is
                               encoded (Chip Selects are normally 1-hot),
                               corresponding to CS0-CS7. When the failed region
                               is a DIMM, two region registers should be
                               programmed corresponding to both Chip Selects of
                               the failed DIMM.
                            */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 failed_c : 3;

                            /* Bits[10:8], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the subrank to match when
                               determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 failed_ba : 2;

                            /* Bits[12:11], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank address to match
                               when determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 failed_bg : 3;

                            /* Bits[15:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank group to match
                               when determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 nonfailed_cs : 3;

                            /* Bits[18:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the Chip Select (rank) to
                               match when determining if this is the failed
                               region participating in either ADDDC or Static
                               Virtual Lockstep. The value in this field is
                               encoded (Chip Selects are normally 1-hot),
                               corresponding to CS0-CS7. When the failed region
                               is a DIMM, two region registers should be
                               programmed corresponding to both Chip Selects of
                               the failed DIMM.
                            */
    UINT32 rsvd_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 nonfailed_c : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the subrank to match when
                               determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 nonfailed_ba : 2;

                            /* Bits[24:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the bank address to match
                               when determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 nonfailed_bg : 3;

                            /* Bits[27:25], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank group to match
                               when determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 copy_in_progress : 1;

                            /* Bits[29:29], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies that ADDDC spare copy is
                               on-going for this region
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ADDDC_REGION1_CONTROL_MC_MAIN_STRUCT;

/* ADDDC_REGION2_CONTROL_MC_MAIN_REG supported on:                              */
/*      SPRA0 (0x200209d4)                                                      */
/*      SPRB0 (0x200209d4)                                                      */
/*      SPRHBM (0x200209d4)                                                     */
/*      SPRC0 (0x200209d4)                                                      */
/*      SPRMCC (0x200209d4)                                                     */
/*      SPRUCC (0x200209d4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
          This register specifies the configuration for the regions using ADDDC for operation after the sparing copy is finished for the region.
      
*/


#define ADDDC_REGION2_CONTROL_MC_MAIN_REG 0x070209D4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 region_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit specifies whether the ADDDC region is
                               in use. 0=ADDDC not enabled for this region
                               1=ADDDC enabled for this region
                            */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 region_size : 2;

                            /* Bits[3:2], Access Type=RW/V, default=0x00000000*/

                            /*
                               Granularity for this ADDDC region: 00=bank
                               01=rank 10=reserved 11=reserved
                            */
    UINT32 failed_cs : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the Chip Select (rank) to
                               match when determining if this is the failed
                               region participating in either ADDDC or Static
                               Virtual Lockstep. The value in this field is
                               encoded (Chip Selects are normally 1-hot),
                               corresponding to CS0-CS7. When the failed region
                               is a DIMM, two region registers should be
                               programmed corresponding to both Chip Selects of
                               the failed DIMM.
                            */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 failed_c : 3;

                            /* Bits[10:8], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the subrank to match when
                               determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 failed_ba : 2;

                            /* Bits[12:11], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank address to match
                               when determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 failed_bg : 3;

                            /* Bits[15:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank group to match
                               when determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 nonfailed_cs : 3;

                            /* Bits[18:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the Chip Select (rank) to
                               match when determining if this is the failed
                               region participating in either ADDDC or Static
                               Virtual Lockstep. The value in this field is
                               encoded (Chip Selects are normally 1-hot),
                               corresponding to CS0-CS7. When the failed region
                               is a DIMM, two region registers should be
                               programmed corresponding to both Chip Selects of
                               the failed DIMM.
                            */
    UINT32 rsvd_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 nonfailed_c : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the subrank to match when
                               determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 nonfailed_ba : 2;

                            /* Bits[24:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the bank address to match
                               when determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 nonfailed_bg : 3;

                            /* Bits[27:25], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank group to match
                               when determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 copy_in_progress : 1;

                            /* Bits[29:29], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies that ADDDC spare copy is
                               on-going for this region
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ADDDC_REGION2_CONTROL_MC_MAIN_STRUCT;

/* ADDDC_REGION3_CONTROL_MC_MAIN_REG supported on:                              */
/*      SPRA0 (0x200209d8)                                                      */
/*      SPRB0 (0x200209d8)                                                      */
/*      SPRHBM (0x200209d8)                                                     */
/*      SPRC0 (0x200209d8)                                                      */
/*      SPRMCC (0x200209d8)                                                     */
/*      SPRUCC (0x200209d8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* 
          This register specifies the configuration for the regions using ADDDC for operation after the sparing copy is finished for the region.
      
*/


#define ADDDC_REGION3_CONTROL_MC_MAIN_REG 0x070209D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 region_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit specifies whether the ADDDC region is
                               in use. 0=ADDDC not enabled for this region
                               1=ADDDC enabled for this region
                            */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 region_size : 2;

                            /* Bits[3:2], Access Type=RW/V, default=0x00000000*/

                            /*
                               Granularity for this ADDDC region: 00=bank
                               01=rank 10=reserved 11=reserved
                            */
    UINT32 failed_cs : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the Chip Select (rank) to
                               match when determining if this is the failed
                               region participating in either ADDDC or Static
                               Virtual Lockstep. The value in this field is
                               encoded (Chip Selects are normally 1-hot),
                               corresponding to CS0-CS7. When the failed region
                               is a DIMM, two region registers should be
                               programmed corresponding to both Chip Selects of
                               the failed DIMM.
                            */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 failed_c : 3;

                            /* Bits[10:8], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the subrank to match when
                               determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 failed_ba : 2;

                            /* Bits[12:11], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank address to match
                               when determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 failed_bg : 3;

                            /* Bits[15:13], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank group to match
                               when determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 nonfailed_cs : 3;

                            /* Bits[18:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the Chip Select (rank) to
                               match when determining if this is the failed
                               region participating in either ADDDC or Static
                               Virtual Lockstep. The value in this field is
                               encoded (Chip Selects are normally 1-hot),
                               corresponding to CS0-CS7. When the failed region
                               is a DIMM, two region registers should be
                               programmed corresponding to both Chip Selects of
                               the failed DIMM.
                            */
    UINT32 rsvd_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 nonfailed_c : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the subrank to match when
                               determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 nonfailed_ba : 2;

                            /* Bits[24:23], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies the bank address to match
                               when determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 nonfailed_bg : 3;

                            /* Bits[27:25], Access Type=RW, default=0x00000000*/

                            /*
                               This field specifies the bank group to match
                               when determining if this is the failed region
                               participating in either ADDDC or Static Virtual
                               Lockstep. Only used when region_size=bank.
                            */
    UINT32 rsvd_28 : 1;

                            /* Bits[28:28], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 copy_in_progress : 1;

                            /* Bits[29:29], Access Type=RW/V, default=0x00000000*/

                            /*
                               This field specifies that ADDDC spare copy is
                               on-going for this region
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} ADDDC_REGION3_CONTROL_MC_MAIN_STRUCT;





/* MCDECSVISACFG_MC_MAIN_REG supported on:                                      */
/*      SPRA0 (0x20020a00)                                                      */
/*      SPRB0 (0x20020a00)                                                      */
/*      SPRHBM (0x20020a00)                                                     */
/*      SPRC0 (0x20020a00)                                                      */
/*      SPRMCC (0x20020a00)                                                     */
/*      SPRUCC (0x20020a00)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* VISA configuration register for mc_decs. All bits are locked by mc_dfxwraps EPMCMAIN_DFX_LCK_CNTL.RSPLCK.
*/


#define MCDECSVISACFG_MC_MAIN_REG 0x07020A00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lane0sel : 6;

                            /* Bits[5:0], Access Type=RW/P/L, default=0x00000000*/

                            /* lane 0 select */
    UINT32 lane1sel : 6;

                            /* Bits[11:6], Access Type=RW/P/L, default=0x00000000*/

                            /* lane 1 select */
    UINT32 lane2sel : 6;

                            /* Bits[17:12], Access Type=RW/P/L, default=0x00000000*/

                            /* lane 2 select */
    UINT32 lane3sel : 6;

                            /* Bits[23:18], Access Type=RW/P/L, default=0x00000000*/

                            /* lane 3 select */
    UINT32 clken : 1;

                            /* Bits[24:24], Access Type=RW/P/L, default=0x00000000*/

                            /* clock enable for debug mux */
    UINT32 rsvd : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCDECSVISACFG_MC_MAIN_STRUCT;

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* PTRR_SEED0_HI_MC_MAIN_REG supported on:                                      */
/*      SPRC0 (0x20020a30)                                                      */
/*      SPRMCC (0x20020a30)                                                     */
/*      SPRUCC (0x20020a30)                                                     */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRC0 BDF: 0_0_0                                       */
/* SPRC0 Security PolicyGroup: P_U_CODE                                         */
/* SPRMCC Security PolicyGroup: P_U_CODE                                        */
/* SPRUCC Security PolicyGroup: P_U_CODE                                        */
/* Register to load the seed to hi 31 bits of LFSR0
*/

#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* PTRR_SEED0_LO_MC_MAIN_REG supported on:                                      */
/*      SPRC0 (0x20020a34)                                                      */
/*      SPRMCC (0x20020a34)                                                     */
/*      SPRUCC (0x20020a34)                                                     */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRC0 BDF: 0_0_0                                       */
/* SPRC0 Security PolicyGroup: P_U_CODE                                         */
/* SPRMCC Security PolicyGroup: P_U_CODE                                        */
/* SPRUCC Security PolicyGroup: P_U_CODE                                        */
/* Register to load the seed to low 32 bits of LFSR0
*/

#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* PTRR_SEED1_HI_MC_MAIN_REG supported on:                                      */
/*      SPRC0 (0x20020a38)                                                      */
/*      SPRMCC (0x20020a38)                                                     */
/*      SPRUCC (0x20020a38)                                                     */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRC0 BDF: 0_0_0                                       */
/* SPRC0 Security PolicyGroup: P_U_CODE                                         */
/* SPRMCC Security PolicyGroup: P_U_CODE                                        */
/* SPRUCC Security PolicyGroup: P_U_CODE                                        */
/* Register to load the seed to hi 31 bits of LFSR1
*/

#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* PTRR_CTL_THRESHOLD0_MC_MAIN_REG supported on:                                */
/*      SPRC0 (0x20020a40)                                                      */
/*      SPRMCC (0x20020a40)                                                     */
/*      SPRUCC (0x20020a40)                                                     */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRC0 BDF: 0_0_0                                       */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This is the register for match and mask capabilities to inject PTRR with LFSR0
*/


#define PTRR_CTL_THRESHOLD0_MC_MAIN_REG 0x07020A40

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the threshold match defined in this
                               register
                            */
    UINT32 cmp_match : 15;

                            /* Bits[15:1], Access Type=RW, default=0x00000000*/

                            /*
                               Value to match to determine if PTRR should be
                               injected
                            */
    UINT32 cmp_mask : 15;

                            /* Bits[30:16], Access Type=RW, default=0x00000000*/

                            /*
                               Mask for each bit in match field. If mask bit is
                               set then the corresponding match bit is ignored
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PTRR_CTL_THRESHOLD0_MC_MAIN_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* PTRR_CTL_THRESHOLD1_MC_MAIN_REG supported on:                                */
/*      SPRC0 (0x20020a44)                                                      */
/*      SPRMCC (0x20020a44)                                                     */
/*      SPRUCC (0x20020a44)                                                     */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRC0 BDF: 0_0_0                                       */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This is the register for match and mask capabilities to inject PTRR with LFSR0
*/


#define PTRR_CTL_THRESHOLD1_MC_MAIN_REG 0x07020A44

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the threshold match defined in this
                               register
                            */
    UINT32 cmp_match : 15;

                            /* Bits[15:1], Access Type=RW, default=0x00000000*/

                            /*
                               Value to match to determine if PTRR should be
                               injected
                            */
    UINT32 cmp_mask : 15;

                            /* Bits[30:16], Access Type=RW, default=0x00000000*/

                            /*
                               Mask for each bit in match field. If mask bit is
                               set then the corresponding match bit is ignored
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PTRR_CTL_THRESHOLD1_MC_MAIN_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* PTRR_CTL_THRESHOLD2_MC_MAIN_REG supported on:                                */
/*      SPRC0 (0x20020a48)                                                      */
/*      SPRMCC (0x20020a48)                                                     */
/*      SPRUCC (0x20020a48)                                                     */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRC0 BDF: 0_0_0                                       */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This is the register for match and mask capabilities to inject PTRR with LFSR1
*/


#define PTRR_CTL_THRESHOLD2_MC_MAIN_REG 0x07020A48

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the threshold match defined in this
                               register
                            */
    UINT32 cmp_match : 15;

                            /* Bits[15:1], Access Type=RW, default=0x00000000*/

                            /*
                               Value to match to determine if PTRR should be
                               injected
                            */
    UINT32 cmp_mask : 15;

                            /* Bits[30:16], Access Type=RW, default=0x00000000*/

                            /*
                               Mask for each bit in match field. If mask bit is
                               set then the corresponding match bit is ignored
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PTRR_CTL_THRESHOLD2_MC_MAIN_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* PTRR_CTL0_MC_MAIN_REG supported on:                                          */
/*      SPRC0 (0x20020a50)                                                      */
/*      SPRMCC (0x20020a50)                                                     */
/*      SPRUCC (0x20020a50)                                                     */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRC0 BDF: 0_0_0                                       */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Control Register to configure PTRR victim refreshes
*/


#define PTRR_CTL0_MC_MAIN_REG 0x07020A50

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 en_ptrr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Set this bit to 1 to enable pTRR injection */
    UINT32 reset_lfsr : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               If this bit is set to 1 then the LFSRs for pTRR
                               are reset and prevent injection of pTRR commands
                            */
    UINT32 swizzle : 2;

                            /* Bits[3:2], Access Type=RW, default=0x00000000*/

                            /*
                               Per DIMM field to enable vendor-specific address
                               swizzling. In a 2 DPC config Bit 0 controls
                               Ranks 0-3 and Bit 1 controls Ranks 4-7";
                            */
    UINT32 flush_cmd : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               If this bit is set to 1 then all the outstanding
                               pTRR commands are flushed
                            */
    UINT32 reduce_inv_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is applicable only when addr_inv_en
                               mode is turned on for a rank. If this bit is set
                               to 1, then inverted victim address is injected
                               only when the Row A[2:0] of the aggressor is 000
                               or 111.
                            */
    UINT32 dis_fifo_last_entry : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               This is a chicken bit to reduce the pTRR FIFO
                               entry by an entry
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 row_mask0 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               pTRR Victim addresses [20:13] are not updated
                               based on the values programmed in this CSR
                               field. This prevents changing row bits for
                               unused row or LRDIMM Rank select bits in the
                               pTRR victim address and the pTRR victim address
                               will retain the row bit value from the aggressor
                               Row address. Bit 0 of this field controls Row
                               address 13 and so on. This field controls Ranks
                               3-0.
                            */
    UINT32 row_mask1 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /*
                               pTRR Victim addresses [20:13] are not updated
                               based on the values programmed in this CSR
                               field. This prevents changing row bits for
                               unused row or LRDIMM Rank select bits in the
                               pTRR victim address and the pTRR victim address
                               will retain the row bit value from the aggressor
                               Row address. Bit 0 of this field controls Row
                               address 13 and so on. This field controls Ranks
                               7-4.
                            */
    UINT32 cmd_pri : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /* Priority level at scheduler of victim refreshes */
    UINT32 rsvd_26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PTRR_CTL0_MC_MAIN_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* PTRR_CTL1_MC_MAIN_REG supported on:                                          */
/*      SPRC0 (0x20020a54)                                                      */
/*      SPRMCC (0x20020a54)                                                     */
/*      SPRUCC (0x20020a54)                                                     */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRC0 BDF: 0_0_0                                       */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Control Register to configure PTRR victim refreshes
*/


#define PTRR_CTL1_MC_MAIN_REG 0x07020A54

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_inv_en : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per rank enable to turn on Address Inversion
                               during Victim address calculation for rank under
                               consideration. Inversion is done as (Row Addr
                               XOR 0xebf8).
                            */
    UINT32 addr_mirror_en : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000000*/

                            /*
                               Per rank enable to turn on address mirroring for
                               rank under consideration. Mirror operation flips
                               the following row address bits: (A4xA3),
                               (A6xA5), (A8xA7)
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PTRR_CTL1_MC_MAIN_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* PTRR_LOG0_MC_MAIN_REG supported on:                                          */
/*      SPRC0 (0x20020a58)                                                      */
/*      SPRMCC (0x20020a58)                                                     */
/*      SPRUCC (0x20020a58)                                                     */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRC0 BDF: 0_0_0                                       */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Debug register to log PTRR behavior
*/


#define PTRR_LOG0_MC_MAIN_REG 0x07020A58

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 en_log : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Per rank enable to turn on Address Inversion
                               during Victim address calculation for rank under
                               consideration. Inversion is done as (Row Addr
                               XOR 0xebf8).
                            */
    UINT32 fifo_empty : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /* PTRR Victim refresh FIFO is empty */
    UINT32 rsvd : 14;

                            /* Bits[15:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 num_drops : 16;

                            /* Bits[31:16], Access Type=RW/V, default=0x00000000*/

                            /* Number of commands dropped from the PTRR FIFO */

  } Bits;
  UINT32 Data;

} PTRR_LOG0_MC_MAIN_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#if defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* PTRR_LOG1_MC_MAIN_REG supported on:                                          */
/*      SPRC0 (0x20020a5c)                                                      */
/*      SPRMCC (0x20020a5c)                                                     */
/*      SPRUCC (0x20020a5c)                                                     */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR     */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mcdecs_crnode/MEM_MCDECS_CSR    */
/* Struct generated from SPRC0 BDF: 0_0_0                                       */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Debug register to log PTRR behavior
*/


#define PTRR_LOG1_MC_MAIN_REG 0x07020A5C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 num_injects : 16;

                            /* Bits[15:0], Access Type=RW/V, default=0x00000000*/

                            /* Number of PTRR commands injected */
    UINT32 num_between : 16;

                            /* Bits[31:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               Number of commands between successive PTRR
                               triggers
                            */

  } Bits;
  UINT32 Data;

} PTRR_LOG1_MC_MAIN_STRUCT;
#endif /* (SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

/* NM_DRAM_RULE_CFG0_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020c00)                                                      */
/*      SPRB0 (0x20020c00)                                                      */
/*      SPRHBM (0x20020c00)                                                     */
/*      SPRC0 (0x20020c00)                                                      */
/*      SPRMCC (0x20020c00)                                                     */
/*      SPRUCC (0x20020c00)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
          8 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used to generate addresses for for patrol and sparing transactions. 
      
*/


#define NM_DRAM_RULE_CFG0_N0_MC_MAIN_REG 0x07020C00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rule_enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable for this DRAM rule. */
    UINT32 limit : 26;

                            /* Bits[26:1], Access Type=RW, default=0x00000000*/

                            /*
                               This correspond to Addr[51:26] of the DRAM rule
                               top limit address. Must be strickly greater then
                               previous rule, even if this rule is disabled,
                               unless this rule and all following rules are
                               disabled. Lower limit is the previous rule (or 0
                               if this is the first rule)
                            */
    UINT32 nm_chn_ways : 3;

                            /* Bits[29:27], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnWays - Near Memory Channel Ways: used to
                               calculate ChnLID 000 = 1 way (ChnLID = 0) 001 =
                               2 ways (ChnLID = modulo 2 of System Address) 010
                               = 3 ways (ChnLID = modulo 3 of System Address)
                               011 = 8 ways (ChnLID = module 8 of System
                               Address) 100 = 4 ways (ChnLID = module 4 of
                               System Address)
                            */
    UINT32 nm_chn_gran : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnGran - Near Memory Channel Granularity:
                               000=64B, 001=256B, 010=4KB,
                               100-111=128B,512B,1KB,2KB; other reserved
                            */

  } Bits;
  UINT32 Data;

} NM_DRAM_RULE_CFG0_N0_MC_MAIN_STRUCT;

/* NM_DRAM_RULE_CFG0_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020c04)                                                      */
/*      SPRB0 (0x20020c04)                                                      */
/*      SPRHBM (0x20020c04)                                                     */
/*      SPRC0 (0x20020c04)                                                      */
/*      SPRMCC (0x20020c04)                                                     */
/*      SPRUCC (0x20020c04)                                                     */
/* Register default value on SPRA0: 0x0FAC6880                                  */
/* Register default value on SPRB0: 0x0FAC6880                                  */
/* Register default value on SPRHBM: 0x0FAC6880                                 */
/* Register default value on SPRC0: 0x0FAC6880                                  */
/* Register default value on SPRMCC: 0x0FAC6880                                 */
/* Register default value on SPRUCC: 0x0FAC6880                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
          8 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used to generate addresses for for patrol and sparing transactions. 
      
*/


#define NM_DRAM_RULE_CFG0_N1_MC_MAIN_REG 0x07020C04

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 nm_chn_gran : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnGran - Near Memory Channel Granularity:
                               000=64B, 001=256B, 010=4KB,
                               100-111=128B,512B,1KB,2KB; other reserved
                            */
    UINT32 nm_target_ways : 2;

                            /* Bits[2:1], Access Type=RW, default=0x00000000*/

                            /*
                               NmTargetWays - Near Memory Target Ways: used to
                               calculate ChnLID 00 = 1 way 01 = 2 ways 10 = 4
                               ways 11 = 8 ways
                            */
    UINT32 nm_gran_eq : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 0, indicate near memory target and
                               channel granularity are different, or target way
                               is 1.
                            */
    UINT32 nm_chn_l2pid : 24;

                            /* Bits[27:4], Access Type=RW, default=0x00FAC688*/

                            /*
                               NmChnL2PID - translation table for Logical
                               (ChnLID) to Physical ID (ChnPID) NmChnL2PID[ 2:
                               0] = mapping from ChnLID=0 to ChnPID NmChnL2PID[
                               5: 3] = mapping from ChnLID=1 to ChnPID
                               NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to
                               ChnPID NmChnL2PID[11: 9] = mapping from ChnLID=3
                               to ChnPID; only used in HBM mode
                               NmChnL2PID[14:12] = mapping from ChnLID=4 to
                               ChnPID; only used in HBM mode NmChnL2PID[17:15]
                               = mapping from ChnLID=5 to ChnPID; only used in
                               HBM mode NmChnL2PID[20:18] = mapping from
                               ChnLID=6 to ChnPID; only used in HBM mode
                               NmChnL2PID[23:21] = mapping from ChnLID=7 to
                               ChnPID; only used in HBM mode Default value maps
                               ChnLID to the same ChnPID
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} NM_DRAM_RULE_CFG0_N1_MC_MAIN_STRUCT;

/* NM_DRAM_RULE_CFG1_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020c08)                                                      */
/*      SPRB0 (0x20020c08)                                                      */
/*      SPRHBM (0x20020c08)                                                     */
/*      SPRC0 (0x20020c08)                                                      */
/*      SPRMCC (0x20020c08)                                                     */
/*      SPRUCC (0x20020c08)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
          8 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used to generate addresses for for patrol and sparing transactions. 
      
*/


#define NM_DRAM_RULE_CFG1_N0_MC_MAIN_REG 0x07020C08

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rule_enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable for this DRAM rule. */
    UINT32 limit : 26;

                            /* Bits[26:1], Access Type=RW, default=0x00000000*/

                            /*
                               This correspond to Addr[51:26] of the DRAM rule
                               top limit address. Must be strickly greater then
                               previous rule, even if this rule is disabled,
                               unless this rule and all following rules are
                               disabled. Lower limit is the previous rule (or 0
                               if this is the first rule)
                            */
    UINT32 nm_chn_ways : 3;

                            /* Bits[29:27], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnWays - Near Memory Channel Ways: used to
                               calculate ChnLID 000 = 1 way (ChnLID = 0) 001 =
                               2 ways (ChnLID = modulo 2 of System Address) 010
                               = 3 ways (ChnLID = modulo 3 of System Address)
                               011 = 8 ways (ChnLID = module 8 of System
                               Address) 100 = 4 ways (ChnLID = module 4 of
                               System Address)
                            */
    UINT32 nm_chn_gran : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnGran - Near Memory Channel Granularity:
                               000=64B, 001=256B, 010=4KB,
                               100-111=128B,512B,1KB,2KB; other reserved
                            */

  } Bits;
  UINT32 Data;

} NM_DRAM_RULE_CFG1_N0_MC_MAIN_STRUCT;

/* NM_DRAM_RULE_CFG1_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020c0c)                                                      */
/*      SPRB0 (0x20020c0c)                                                      */
/*      SPRHBM (0x20020c0c)                                                     */
/*      SPRC0 (0x20020c0c)                                                      */
/*      SPRMCC (0x20020c0c)                                                     */
/*      SPRUCC (0x20020c0c)                                                     */
/* Register default value on SPRA0: 0x0FAC6880                                  */
/* Register default value on SPRB0: 0x0FAC6880                                  */
/* Register default value on SPRHBM: 0x0FAC6880                                 */
/* Register default value on SPRC0: 0x0FAC6880                                  */
/* Register default value on SPRMCC: 0x0FAC6880                                 */
/* Register default value on SPRUCC: 0x0FAC6880                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
          8 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used to generate addresses for for patrol and sparing transactions. 
      
*/


#define NM_DRAM_RULE_CFG1_N1_MC_MAIN_REG 0x07020C0C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 nm_chn_gran : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnGran - Near Memory Channel Granularity:
                               000=64B, 001=256B, 010=4KB,
                               100-111=128B,512B,1KB,2KB; other reserved
                            */
    UINT32 nm_target_ways : 2;

                            /* Bits[2:1], Access Type=RW, default=0x00000000*/

                            /*
                               NmTargetWays - Near Memory Target Ways: used to
                               calculate ChnLID 00 = 1 way 01 = 2 ways 10 = 4
                               ways 11 = 8 ways
                            */
    UINT32 nm_gran_eq : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 0, indicate near memory target and
                               channel granularity are different, or target way
                               is 1.
                            */
    UINT32 nm_chn_l2pid : 24;

                            /* Bits[27:4], Access Type=RW, default=0x00FAC688*/

                            /*
                               NmChnL2PID - translation table for Logical
                               (ChnLID) to Physical ID (ChnPID) NmChnL2PID[ 2:
                               0] = mapping from ChnLID=0 to ChnPID NmChnL2PID[
                               5: 3] = mapping from ChnLID=1 to ChnPID
                               NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to
                               ChnPID NmChnL2PID[11: 9] = mapping from ChnLID=3
                               to ChnPID; only used in HBM mode
                               NmChnL2PID[14:12] = mapping from ChnLID=4 to
                               ChnPID; only used in HBM mode NmChnL2PID[17:15]
                               = mapping from ChnLID=5 to ChnPID; only used in
                               HBM mode NmChnL2PID[20:18] = mapping from
                               ChnLID=6 to ChnPID; only used in HBM mode
                               NmChnL2PID[23:21] = mapping from ChnLID=7 to
                               ChnPID; only used in HBM mode Default value maps
                               ChnLID to the same ChnPID
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} NM_DRAM_RULE_CFG1_N1_MC_MAIN_STRUCT;

/* NM_DRAM_RULE_CFG2_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020c10)                                                      */
/*      SPRB0 (0x20020c10)                                                      */
/*      SPRHBM (0x20020c10)                                                     */
/*      SPRC0 (0x20020c10)                                                      */
/*      SPRMCC (0x20020c10)                                                     */
/*      SPRUCC (0x20020c10)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
          8 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used to generate addresses for for patrol and sparing transactions. 
      
*/


#define NM_DRAM_RULE_CFG2_N0_MC_MAIN_REG 0x07020C10

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rule_enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable for this DRAM rule. */
    UINT32 limit : 26;

                            /* Bits[26:1], Access Type=RW, default=0x00000000*/

                            /*
                               This correspond to Addr[51:26] of the DRAM rule
                               top limit address. Must be strickly greater then
                               previous rule, even if this rule is disabled,
                               unless this rule and all following rules are
                               disabled. Lower limit is the previous rule (or 0
                               if this is the first rule)
                            */
    UINT32 nm_chn_ways : 3;

                            /* Bits[29:27], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnWays - Near Memory Channel Ways: used to
                               calculate ChnLID 000 = 1 way (ChnLID = 0) 001 =
                               2 ways (ChnLID = modulo 2 of System Address) 010
                               = 3 ways (ChnLID = modulo 3 of System Address)
                               011 = 8 ways (ChnLID = module 8 of System
                               Address) 100 = 4 ways (ChnLID = module 4 of
                               System Address)
                            */
    UINT32 nm_chn_gran : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnGran - Near Memory Channel Granularity:
                               000=64B, 001=256B, 010=4KB,
                               100-111=128B,512B,1KB,2KB; other reserved
                            */

  } Bits;
  UINT32 Data;

} NM_DRAM_RULE_CFG2_N0_MC_MAIN_STRUCT;

/* NM_DRAM_RULE_CFG2_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020c14)                                                      */
/*      SPRB0 (0x20020c14)                                                      */
/*      SPRHBM (0x20020c14)                                                     */
/*      SPRC0 (0x20020c14)                                                      */
/*      SPRMCC (0x20020c14)                                                     */
/*      SPRUCC (0x20020c14)                                                     */
/* Register default value on SPRA0: 0x0FAC6880                                  */
/* Register default value on SPRB0: 0x0FAC6880                                  */
/* Register default value on SPRHBM: 0x0FAC6880                                 */
/* Register default value on SPRC0: 0x0FAC6880                                  */
/* Register default value on SPRMCC: 0x0FAC6880                                 */
/* Register default value on SPRUCC: 0x0FAC6880                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
          8 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used to generate addresses for for patrol and sparing transactions. 
      
*/


#define NM_DRAM_RULE_CFG2_N1_MC_MAIN_REG 0x07020C14

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 nm_chn_gran : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnGran - Near Memory Channel Granularity:
                               000=64B, 001=256B, 010=4KB,
                               100-111=128B,512B,1KB,2KB; other reserved
                            */
    UINT32 nm_target_ways : 2;

                            /* Bits[2:1], Access Type=RW, default=0x00000000*/

                            /*
                               NmTargetWays - Near Memory Target Ways: used to
                               calculate ChnLID 00 = 1 way 01 = 2 ways 10 = 4
                               ways 11 = 8 ways
                            */
    UINT32 nm_gran_eq : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 0, indicate near memory target and
                               channel granularity are different, or target way
                               is 1.
                            */
    UINT32 nm_chn_l2pid : 24;

                            /* Bits[27:4], Access Type=RW, default=0x00FAC688*/

                            /*
                               NmChnL2PID - translation table for Logical
                               (ChnLID) to Physical ID (ChnPID) NmChnL2PID[ 2:
                               0] = mapping from ChnLID=0 to ChnPID NmChnL2PID[
                               5: 3] = mapping from ChnLID=1 to ChnPID
                               NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to
                               ChnPID NmChnL2PID[11: 9] = mapping from ChnLID=3
                               to ChnPID; only used in HBM mode
                               NmChnL2PID[14:12] = mapping from ChnLID=4 to
                               ChnPID; only used in HBM mode NmChnL2PID[17:15]
                               = mapping from ChnLID=5 to ChnPID; only used in
                               HBM mode NmChnL2PID[20:18] = mapping from
                               ChnLID=6 to ChnPID; only used in HBM mode
                               NmChnL2PID[23:21] = mapping from ChnLID=7 to
                               ChnPID; only used in HBM mode Default value maps
                               ChnLID to the same ChnPID
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} NM_DRAM_RULE_CFG2_N1_MC_MAIN_STRUCT;

/* NM_DRAM_RULE_CFG3_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020c18)                                                      */
/*      SPRB0 (0x20020c18)                                                      */
/*      SPRHBM (0x20020c18)                                                     */
/*      SPRC0 (0x20020c18)                                                      */
/*      SPRMCC (0x20020c18)                                                     */
/*      SPRUCC (0x20020c18)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
          8 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used to generate addresses for for patrol and sparing transactions. 
      
*/


#define NM_DRAM_RULE_CFG3_N0_MC_MAIN_REG 0x07020C18

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rule_enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable for this DRAM rule. */
    UINT32 limit : 26;

                            /* Bits[26:1], Access Type=RW, default=0x00000000*/

                            /*
                               This correspond to Addr[51:26] of the DRAM rule
                               top limit address. Must be strickly greater then
                               previous rule, even if this rule is disabled,
                               unless this rule and all following rules are
                               disabled. Lower limit is the previous rule (or 0
                               if this is the first rule)
                            */
    UINT32 nm_chn_ways : 3;

                            /* Bits[29:27], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnWays - Near Memory Channel Ways: used to
                               calculate ChnLID 000 = 1 way (ChnLID = 0) 001 =
                               2 ways (ChnLID = modulo 2 of System Address) 010
                               = 3 ways (ChnLID = modulo 3 of System Address)
                               011 = 8 ways (ChnLID = module 8 of System
                               Address) 100 = 4 ways (ChnLID = module 4 of
                               System Address)
                            */
    UINT32 nm_chn_gran : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnGran - Near Memory Channel Granularity:
                               000=64B, 001=256B, 010=4KB,
                               100-111=128B,512B,1KB,2KB; other reserved
                            */

  } Bits;
  UINT32 Data;

} NM_DRAM_RULE_CFG3_N0_MC_MAIN_STRUCT;

/* NM_DRAM_RULE_CFG3_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020c1c)                                                      */
/*      SPRB0 (0x20020c1c)                                                      */
/*      SPRHBM (0x20020c1c)                                                     */
/*      SPRC0 (0x20020c1c)                                                      */
/*      SPRMCC (0x20020c1c)                                                     */
/*      SPRUCC (0x20020c1c)                                                     */
/* Register default value on SPRA0: 0x0FAC6880                                  */
/* Register default value on SPRB0: 0x0FAC6880                                  */
/* Register default value on SPRHBM: 0x0FAC6880                                 */
/* Register default value on SPRC0: 0x0FAC6880                                  */
/* Register default value on SPRMCC: 0x0FAC6880                                 */
/* Register default value on SPRUCC: 0x0FAC6880                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
          8 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used to generate addresses for for patrol and sparing transactions. 
      
*/


#define NM_DRAM_RULE_CFG3_N1_MC_MAIN_REG 0x07020C1C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 nm_chn_gran : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnGran - Near Memory Channel Granularity:
                               000=64B, 001=256B, 010=4KB,
                               100-111=128B,512B,1KB,2KB; other reserved
                            */
    UINT32 nm_target_ways : 2;

                            /* Bits[2:1], Access Type=RW, default=0x00000000*/

                            /*
                               NmTargetWays - Near Memory Target Ways: used to
                               calculate ChnLID 00 = 1 way 01 = 2 ways 10 = 4
                               ways 11 = 8 ways
                            */
    UINT32 nm_gran_eq : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 0, indicate near memory target and
                               channel granularity are different, or target way
                               is 1.
                            */
    UINT32 nm_chn_l2pid : 24;

                            /* Bits[27:4], Access Type=RW, default=0x00FAC688*/

                            /*
                               NmChnL2PID - translation table for Logical
                               (ChnLID) to Physical ID (ChnPID) NmChnL2PID[ 2:
                               0] = mapping from ChnLID=0 to ChnPID NmChnL2PID[
                               5: 3] = mapping from ChnLID=1 to ChnPID
                               NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to
                               ChnPID NmChnL2PID[11: 9] = mapping from ChnLID=3
                               to ChnPID; only used in HBM mode
                               NmChnL2PID[14:12] = mapping from ChnLID=4 to
                               ChnPID; only used in HBM mode NmChnL2PID[17:15]
                               = mapping from ChnLID=5 to ChnPID; only used in
                               HBM mode NmChnL2PID[20:18] = mapping from
                               ChnLID=6 to ChnPID; only used in HBM mode
                               NmChnL2PID[23:21] = mapping from ChnLID=7 to
                               ChnPID; only used in HBM mode Default value maps
                               ChnLID to the same ChnPID
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} NM_DRAM_RULE_CFG3_N1_MC_MAIN_STRUCT;

/* NM_DRAM_RULE_CFG4_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020c20)                                                      */
/*      SPRB0 (0x20020c20)                                                      */
/*      SPRHBM (0x20020c20)                                                     */
/*      SPRC0 (0x20020c20)                                                      */
/*      SPRMCC (0x20020c20)                                                     */
/*      SPRUCC (0x20020c20)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
          8 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used to generate addresses for for patrol and sparing transactions. 
      
*/


#define NM_DRAM_RULE_CFG4_N0_MC_MAIN_REG 0x07020C20

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rule_enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable for this DRAM rule. */
    UINT32 limit : 26;

                            /* Bits[26:1], Access Type=RW, default=0x00000000*/

                            /*
                               This correspond to Addr[51:26] of the DRAM rule
                               top limit address. Must be strickly greater then
                               previous rule, even if this rule is disabled,
                               unless this rule and all following rules are
                               disabled. Lower limit is the previous rule (or 0
                               if this is the first rule)
                            */
    UINT32 nm_chn_ways : 3;

                            /* Bits[29:27], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnWays - Near Memory Channel Ways: used to
                               calculate ChnLID 000 = 1 way (ChnLID = 0) 001 =
                               2 ways (ChnLID = modulo 2 of System Address) 010
                               = 3 ways (ChnLID = modulo 3 of System Address)
                               011 = 8 ways (ChnLID = module 8 of System
                               Address) 100 = 4 ways (ChnLID = module 4 of
                               System Address)
                            */
    UINT32 nm_chn_gran : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnGran - Near Memory Channel Granularity:
                               000=64B, 001=256B, 010=4KB,
                               100-111=128B,512B,1KB,2KB; other reserved
                            */

  } Bits;
  UINT32 Data;

} NM_DRAM_RULE_CFG4_N0_MC_MAIN_STRUCT;

/* NM_DRAM_RULE_CFG4_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020c24)                                                      */
/*      SPRB0 (0x20020c24)                                                      */
/*      SPRHBM (0x20020c24)                                                     */
/*      SPRC0 (0x20020c24)                                                      */
/*      SPRMCC (0x20020c24)                                                     */
/*      SPRUCC (0x20020c24)                                                     */
/* Register default value on SPRA0: 0x0FAC6880                                  */
/* Register default value on SPRB0: 0x0FAC6880                                  */
/* Register default value on SPRHBM: 0x0FAC6880                                 */
/* Register default value on SPRC0: 0x0FAC6880                                  */
/* Register default value on SPRMCC: 0x0FAC6880                                 */
/* Register default value on SPRUCC: 0x0FAC6880                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
          8 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used to generate addresses for for patrol and sparing transactions. 
      
*/


#define NM_DRAM_RULE_CFG4_N1_MC_MAIN_REG 0x07020C24

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 nm_chn_gran : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnGran - Near Memory Channel Granularity:
                               000=64B, 001=256B, 010=4KB,
                               100-111=128B,512B,1KB,2KB; other reserved
                            */
    UINT32 nm_target_ways : 2;

                            /* Bits[2:1], Access Type=RW, default=0x00000000*/

                            /*
                               NmTargetWays - Near Memory Target Ways: used to
                               calculate ChnLID 00 = 1 way 01 = 2 ways 10 = 4
                               ways 11 = 8 ways
                            */
    UINT32 nm_gran_eq : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 0, indicate near memory target and
                               channel granularity are different, or target way
                               is 1.
                            */
    UINT32 nm_chn_l2pid : 24;

                            /* Bits[27:4], Access Type=RW, default=0x00FAC688*/

                            /*
                               NmChnL2PID - translation table for Logical
                               (ChnLID) to Physical ID (ChnPID) NmChnL2PID[ 2:
                               0] = mapping from ChnLID=0 to ChnPID NmChnL2PID[
                               5: 3] = mapping from ChnLID=1 to ChnPID
                               NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to
                               ChnPID NmChnL2PID[11: 9] = mapping from ChnLID=3
                               to ChnPID; only used in HBM mode
                               NmChnL2PID[14:12] = mapping from ChnLID=4 to
                               ChnPID; only used in HBM mode NmChnL2PID[17:15]
                               = mapping from ChnLID=5 to ChnPID; only used in
                               HBM mode NmChnL2PID[20:18] = mapping from
                               ChnLID=6 to ChnPID; only used in HBM mode
                               NmChnL2PID[23:21] = mapping from ChnLID=7 to
                               ChnPID; only used in HBM mode Default value maps
                               ChnLID to the same ChnPID
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} NM_DRAM_RULE_CFG4_N1_MC_MAIN_STRUCT;

/* NM_DRAM_RULE_CFG5_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020c28)                                                      */
/*      SPRB0 (0x20020c28)                                                      */
/*      SPRHBM (0x20020c28)                                                     */
/*      SPRC0 (0x20020c28)                                                      */
/*      SPRMCC (0x20020c28)                                                     */
/*      SPRUCC (0x20020c28)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
          8 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used to generate addresses for for patrol and sparing transactions. 
      
*/


#define NM_DRAM_RULE_CFG5_N0_MC_MAIN_REG 0x07020C28

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rule_enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable for this DRAM rule. */
    UINT32 limit : 26;

                            /* Bits[26:1], Access Type=RW, default=0x00000000*/

                            /*
                               This correspond to Addr[51:26] of the DRAM rule
                               top limit address. Must be strickly greater then
                               previous rule, even if this rule is disabled,
                               unless this rule and all following rules are
                               disabled. Lower limit is the previous rule (or 0
                               if this is the first rule)
                            */
    UINT32 nm_chn_ways : 3;

                            /* Bits[29:27], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnWays - Near Memory Channel Ways: used to
                               calculate ChnLID 000 = 1 way (ChnLID = 0) 001 =
                               2 ways (ChnLID = modulo 2 of System Address) 010
                               = 3 ways (ChnLID = modulo 3 of System Address)
                               011 = 8 ways (ChnLID = module 8 of System
                               Address) 100 = 4 ways (ChnLID = module 4 of
                               System Address)
                            */
    UINT32 nm_chn_gran : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnGran - Near Memory Channel Granularity:
                               000=64B, 001=256B, 010=4KB,
                               100-111=128B,512B,1KB,2KB; other reserved
                            */

  } Bits;
  UINT32 Data;

} NM_DRAM_RULE_CFG5_N0_MC_MAIN_STRUCT;

/* NM_DRAM_RULE_CFG5_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020c2c)                                                      */
/*      SPRB0 (0x20020c2c)                                                      */
/*      SPRHBM (0x20020c2c)                                                     */
/*      SPRC0 (0x20020c2c)                                                      */
/*      SPRMCC (0x20020c2c)                                                     */
/*      SPRUCC (0x20020c2c)                                                     */
/* Register default value on SPRA0: 0x0FAC6880                                  */
/* Register default value on SPRB0: 0x0FAC6880                                  */
/* Register default value on SPRHBM: 0x0FAC6880                                 */
/* Register default value on SPRC0: 0x0FAC6880                                  */
/* Register default value on SPRMCC: 0x0FAC6880                                 */
/* Register default value on SPRUCC: 0x0FAC6880                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
          8 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used to generate addresses for for patrol and sparing transactions. 
      
*/


#define NM_DRAM_RULE_CFG5_N1_MC_MAIN_REG 0x07020C2C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 nm_chn_gran : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnGran - Near Memory Channel Granularity:
                               000=64B, 001=256B, 010=4KB,
                               100-111=128B,512B,1KB,2KB; other reserved
                            */
    UINT32 nm_target_ways : 2;

                            /* Bits[2:1], Access Type=RW, default=0x00000000*/

                            /*
                               NmTargetWays - Near Memory Target Ways: used to
                               calculate ChnLID 00 = 1 way 01 = 2 ways 10 = 4
                               ways 11 = 8 ways
                            */
    UINT32 nm_gran_eq : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 0, indicate near memory target and
                               channel granularity are different, or target way
                               is 1.
                            */
    UINT32 nm_chn_l2pid : 24;

                            /* Bits[27:4], Access Type=RW, default=0x00FAC688*/

                            /*
                               NmChnL2PID - translation table for Logical
                               (ChnLID) to Physical ID (ChnPID) NmChnL2PID[ 2:
                               0] = mapping from ChnLID=0 to ChnPID NmChnL2PID[
                               5: 3] = mapping from ChnLID=1 to ChnPID
                               NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to
                               ChnPID NmChnL2PID[11: 9] = mapping from ChnLID=3
                               to ChnPID; only used in HBM mode
                               NmChnL2PID[14:12] = mapping from ChnLID=4 to
                               ChnPID; only used in HBM mode NmChnL2PID[17:15]
                               = mapping from ChnLID=5 to ChnPID; only used in
                               HBM mode NmChnL2PID[20:18] = mapping from
                               ChnLID=6 to ChnPID; only used in HBM mode
                               NmChnL2PID[23:21] = mapping from ChnLID=7 to
                               ChnPID; only used in HBM mode Default value maps
                               ChnLID to the same ChnPID
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} NM_DRAM_RULE_CFG5_N1_MC_MAIN_STRUCT;

/* NM_DRAM_RULE_CFG6_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020c30)                                                      */
/*      SPRB0 (0x20020c30)                                                      */
/*      SPRHBM (0x20020c30)                                                     */
/*      SPRC0 (0x20020c30)                                                      */
/*      SPRMCC (0x20020c30)                                                     */
/*      SPRUCC (0x20020c30)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
          8 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used to generate addresses for for patrol and sparing transactions. 
      
*/


#define NM_DRAM_RULE_CFG6_N0_MC_MAIN_REG 0x07020C30

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rule_enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable for this DRAM rule. */
    UINT32 limit : 26;

                            /* Bits[26:1], Access Type=RW, default=0x00000000*/

                            /*
                               This correspond to Addr[51:26] of the DRAM rule
                               top limit address. Must be strickly greater then
                               previous rule, even if this rule is disabled,
                               unless this rule and all following rules are
                               disabled. Lower limit is the previous rule (or 0
                               if this is the first rule)
                            */
    UINT32 nm_chn_ways : 3;

                            /* Bits[29:27], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnWays - Near Memory Channel Ways: used to
                               calculate ChnLID 000 = 1 way (ChnLID = 0) 001 =
                               2 ways (ChnLID = modulo 2 of System Address) 010
                               = 3 ways (ChnLID = modulo 3 of System Address)
                               011 = 8 ways (ChnLID = module 8 of System
                               Address) 100 = 4 ways (ChnLID = module 4 of
                               System Address)
                            */
    UINT32 nm_chn_gran : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnGran - Near Memory Channel Granularity:
                               000=64B, 001=256B, 010=4KB,
                               100-111=128B,512B,1KB,2KB; other reserved
                            */

  } Bits;
  UINT32 Data;

} NM_DRAM_RULE_CFG6_N0_MC_MAIN_STRUCT;

/* NM_DRAM_RULE_CFG6_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020c34)                                                      */
/*      SPRB0 (0x20020c34)                                                      */
/*      SPRHBM (0x20020c34)                                                     */
/*      SPRC0 (0x20020c34)                                                      */
/*      SPRMCC (0x20020c34)                                                     */
/*      SPRUCC (0x20020c34)                                                     */
/* Register default value on SPRA0: 0x0FAC6880                                  */
/* Register default value on SPRB0: 0x0FAC6880                                  */
/* Register default value on SPRHBM: 0x0FAC6880                                 */
/* Register default value on SPRC0: 0x0FAC6880                                  */
/* Register default value on SPRMCC: 0x0FAC6880                                 */
/* Register default value on SPRUCC: 0x0FAC6880                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
          8 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used to generate addresses for for patrol and sparing transactions. 
      
*/


#define NM_DRAM_RULE_CFG6_N1_MC_MAIN_REG 0x07020C34

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 nm_chn_gran : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnGran - Near Memory Channel Granularity:
                               000=64B, 001=256B, 010=4KB,
                               100-111=128B,512B,1KB,2KB; other reserved
                            */
    UINT32 nm_target_ways : 2;

                            /* Bits[2:1], Access Type=RW, default=0x00000000*/

                            /*
                               NmTargetWays - Near Memory Target Ways: used to
                               calculate ChnLID 00 = 1 way 01 = 2 ways 10 = 4
                               ways 11 = 8 ways
                            */
    UINT32 nm_gran_eq : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 0, indicate near memory target and
                               channel granularity are different, or target way
                               is 1.
                            */
    UINT32 nm_chn_l2pid : 24;

                            /* Bits[27:4], Access Type=RW, default=0x00FAC688*/

                            /*
                               NmChnL2PID - translation table for Logical
                               (ChnLID) to Physical ID (ChnPID) NmChnL2PID[ 2:
                               0] = mapping from ChnLID=0 to ChnPID NmChnL2PID[
                               5: 3] = mapping from ChnLID=1 to ChnPID
                               NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to
                               ChnPID NmChnL2PID[11: 9] = mapping from ChnLID=3
                               to ChnPID; only used in HBM mode
                               NmChnL2PID[14:12] = mapping from ChnLID=4 to
                               ChnPID; only used in HBM mode NmChnL2PID[17:15]
                               = mapping from ChnLID=5 to ChnPID; only used in
                               HBM mode NmChnL2PID[20:18] = mapping from
                               ChnLID=6 to ChnPID; only used in HBM mode
                               NmChnL2PID[23:21] = mapping from ChnLID=7 to
                               ChnPID; only used in HBM mode Default value maps
                               ChnLID to the same ChnPID
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} NM_DRAM_RULE_CFG6_N1_MC_MAIN_STRUCT;

/* NM_DRAM_RULE_CFG7_N0_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020c38)                                                      */
/*      SPRB0 (0x20020c38)                                                      */
/*      SPRHBM (0x20020c38)                                                     */
/*      SPRC0 (0x20020c38)                                                      */
/*      SPRMCC (0x20020c38)                                                     */
/*      SPRUCC (0x20020c38)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
          8 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used to generate addresses for for patrol and sparing transactions. 
      
*/


#define NM_DRAM_RULE_CFG7_N0_MC_MAIN_REG 0x07020C38

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rule_enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable for this DRAM rule. */
    UINT32 limit : 26;

                            /* Bits[26:1], Access Type=RW, default=0x00000000*/

                            /*
                               This correspond to Addr[51:26] of the DRAM rule
                               top limit address. Must be strickly greater then
                               previous rule, even if this rule is disabled,
                               unless this rule and all following rules are
                               disabled. Lower limit is the previous rule (or 0
                               if this is the first rule)
                            */
    UINT32 nm_chn_ways : 3;

                            /* Bits[29:27], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnWays - Near Memory Channel Ways: used to
                               calculate ChnLID 000 = 1 way (ChnLID = 0) 001 =
                               2 ways (ChnLID = modulo 2 of System Address) 010
                               = 3 ways (ChnLID = modulo 3 of System Address)
                               011 = 8 ways (ChnLID = module 8 of System
                               Address) 100 = 4 ways (ChnLID = module 4 of
                               System Address)
                            */
    UINT32 nm_chn_gran : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnGran - Near Memory Channel Granularity:
                               000=64B, 001=256B, 010=4KB,
                               100-111=128B,512B,1KB,2KB; other reserved
                            */

  } Bits;
  UINT32 Data;

} NM_DRAM_RULE_CFG7_N0_MC_MAIN_STRUCT;

/* NM_DRAM_RULE_CFG7_N1_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020c3c)                                                      */
/*      SPRB0 (0x20020c3c)                                                      */
/*      SPRHBM (0x20020c3c)                                                     */
/*      SPRC0 (0x20020c3c)                                                      */
/*      SPRMCC (0x20020c3c)                                                     */
/*      SPRUCC (0x20020c3c)                                                     */
/* Register default value on SPRA0: 0x0FAC6880                                  */
/* Register default value on SPRB0: 0x0FAC6880                                  */
/* Register default value on SPRHBM: 0x0FAC6880                                 */
/* Register default value on SPRC0: 0x0FAC6880                                  */
/* Register default value on SPRMCC: 0x0FAC6880                                 */
/* Register default value on SPRUCC: 0x0FAC6880                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  
          8 instances of NM_DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used to generate addresses for for patrol and sparing transactions. 
      
*/


#define NM_DRAM_RULE_CFG7_N1_MC_MAIN_REG 0x07020C3C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 nm_chn_gran : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               NmChnGran - Near Memory Channel Granularity:
                               000=64B, 001=256B, 010=4KB,
                               100-111=128B,512B,1KB,2KB; other reserved
                            */
    UINT32 nm_target_ways : 2;

                            /* Bits[2:1], Access Type=RW, default=0x00000000*/

                            /*
                               NmTargetWays - Near Memory Target Ways: used to
                               calculate ChnLID 00 = 1 way 01 = 2 ways 10 = 4
                               ways 11 = 8 ways
                            */
    UINT32 nm_gran_eq : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 0, indicate near memory target and
                               channel granularity are different, or target way
                               is 1.
                            */
    UINT32 nm_chn_l2pid : 24;

                            /* Bits[27:4], Access Type=RW, default=0x00FAC688*/

                            /*
                               NmChnL2PID - translation table for Logical
                               (ChnLID) to Physical ID (ChnPID) NmChnL2PID[ 2:
                               0] = mapping from ChnLID=0 to ChnPID NmChnL2PID[
                               5: 3] = mapping from ChnLID=1 to ChnPID
                               NmChnL2PID[ 8: 6] = mapping from ChnLID=2 to
                               ChnPID NmChnL2PID[11: 9] = mapping from ChnLID=3
                               to ChnPID; only used in HBM mode
                               NmChnL2PID[14:12] = mapping from ChnLID=4 to
                               ChnPID; only used in HBM mode NmChnL2PID[17:15]
                               = mapping from ChnLID=5 to ChnPID; only used in
                               HBM mode NmChnL2PID[20:18] = mapping from
                               ChnLID=6 to ChnPID; only used in HBM mode
                               NmChnL2PID[23:21] = mapping from ChnLID=7 to
                               ChnPID; only used in HBM mode Default value maps
                               ChnLID to the same ChnPID
                            */
    UINT32 rsvd : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} NM_DRAM_RULE_CFG7_N1_MC_MAIN_STRUCT;

/* MC_SAD2TAD_CFG0_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x20020cc4)                                                      */
/*      SPRB0 (0x20020cc4)                                                      */
/*      SPRHBM (0x20020cc4)                                                     */
/*      SPRC0 (0x20020cc4)                                                      */
/*      SPRMCC (0x20020cc4)                                                     */
/*      SPRUCC (0x20020cc4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* SAD to TAD configuration register.
*/


#define MC_SAD2TAD_CFG0_MC_MAIN_REG 0x07020CC4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sad2tad0 : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /* SAD2TAD mapping entry 0 for write through */
    UINT32 sad2tad1 : 4;

                            /* Bits[7:4], Access Type=RW, default=0x00000000*/

                            /* SAD2TAD mapping entry 1 for write through */
    UINT32 sad2tad2 : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000000*/

                            /* SAD2TAD mapping entry 2 for write through */
    UINT32 sad2tad3 : 4;

                            /* Bits[15:12], Access Type=RW, default=0x00000000*/

                            /* SAD2TAD mapping entry 3 for write through */
    UINT32 sad2tad4 : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000000*/

                            /* SAD2TAD mapping entry 4 for write through */
    UINT32 sad2tad5 : 4;

                            /* Bits[23:20], Access Type=RW, default=0x00000000*/

                            /* SAD2TAD mapping entry 5 for write through */
    UINT32 sad2tad6 : 4;

                            /* Bits[27:24], Access Type=RW, default=0x00000000*/

                            /* SAD2TAD mapping entry 6 for write through */
    UINT32 sad2tad7 : 4;

                            /* Bits[31:28], Access Type=RW, default=0x00000000*/

                            /* SAD2TAD mapping entry 7 for write through */

  } Bits;
  UINT32 Data;

} MC_SAD2TAD_CFG0_MC_MAIN_STRUCT;

/* PCOMMIT_CONTROL_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x10020cd0)                                                      */
/*      SPRB0 (0x10020cd0)                                                      */
/*      SPRHBM (0x10020cd0)                                                     */
/*      SPRC0 (0x10020cd0)                                                      */
/*      SPRMCC (0x10020cd0)                                                     */
/*      SPRUCC (0x10020cd0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register is unused.
*/


#define PCOMMIT_CONTROL_MC_MAIN_REG 0x07010CD0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 nvdimm_chn_msk : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               Unused - One bit per MC channel. When the bit is
                               set, then a Pcommit will target DDR4 on that
                               channel. When the bit is clear, then a Pcommit
                               will target DDRT on that channel.
                            */
    UINT16 rsvd : 13;

                            /* Bits[15:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} PCOMMIT_CONTROL_MC_MAIN_STRUCT;

/* DRAM_RULE_CFG0_N0_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020ce8)                                                      */
/*      SPRB0 (0x20020ce8)                                                      */
/*      SPRHBM (0x20020ce8)                                                     */
/*      SPRC0 (0x20020ce8)                                                      */
/*      SPRMCC (0x20020ce8)                                                     */
/*      SPRUCC (0x20020ce8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/*  
          8 instances of DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used for 2LM and Write-Through Fill and Evict flows.
      
*/


#define DRAM_RULE_CFG0_N0_MC_MAIN_REG 0x07020CE8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rule_enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable for this DRAM rule. */
    UINT32 limit : 26;

                            /* Bits[26:1], Access Type=RW, default=0x00000000*/

                            /*
                               This correspond to Addr[51:26] of the DRAM rule
                               top limit address. Must be strickly greater then
                               previous rule, even if this rule is disabled,
                               unless this rule and all following rules are
                               disabled. Lower limit is the previous rule (or 0
                               if this is the first rule)
                            */
    UINT32 fm_target : 2;

                            /* Bits[28:27], Access Type=RW, default=0x00000000*/

                            /*
                               FmTarget - Target Far Memory MC; Bit 0 defines
                               the half target (KNH) that all traffic go to.
                            */
    UINT32 fm_chn_ways : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               FmChnWays - Far Memory Channel Ways: used to
                               calculate ChnLID 00 = 1 way (ChnLID = 0) 01 = 2
                               ways (ChnLID = modulo 2 of System Address) 10 =
                               3 ways (ChnLID = modulo 3 of System Address) 11
                               = Reserved
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DRAM_RULE_CFG0_N0_MC_MAIN_STRUCT;

/* DRAM_RULE_CFG0_N1_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020cec)                                                      */
/*      SPRB0 (0x20020cec)                                                      */
/*      SPRHBM (0x20020cec)                                                     */
/*      SPRC0 (0x20020cec)                                                      */
/*      SPRMCC (0x20020cec)                                                     */
/*      SPRUCC (0x20020cec)                                                     */
/* Register default value on SPRA0: 0x00001200                                  */
/* Register default value on SPRB0: 0x00001200                                  */
/* Register default value on SPRHBM: 0x00001200                                 */
/* Register default value on SPRC0: 0x00001200                                  */
/* Register default value on SPRMCC: 0x00001200                                 */
/* Register default value on SPRUCC: 0x00001200                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/*  
          8 instances of DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used for 2LM and Write-Through Fill and Evict flows.
      
*/


#define DRAM_RULE_CFG0_N1_MC_MAIN_REG 0x07020CEC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fm_chn_gran : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               FmChnGran - Far Memory Channel Granularity:
                               001=256B, 010=4KB, 111=2KB, other reserved
                            */
    UINT32 fm_target_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               FmTargetWays - Far Memory Target Ways: used to
                               calculate ChnLID when fm_gran_eq = 1 000 = 1 way
                               001 = 2 ways 010 = 4 ways 011 = 8 ways 100 = 16
                               ways
                            */
    UINT32 fm_gran_eq : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 0, indicate far memory target and
                               channel granularity are different, or target way
                               is 1.
                            */
    UINT32 fm_chn_l2pid : 6;

                            /* Bits[12:7], Access Type=RW, default=0x00000024*/

                            /*
                               FmChnL2PID - translation table for Logical
                               (ChnLID) to Physical ID (ChnPID) FmChnL2PID[1:0]
                               = mapping from ChnLID=0 to ChnPID
                               FmChnL2PID[3:2] = mapping from ChnLID=1 to
                               ChnPID FmChnL2PID[5:4] = mapping from ChnLID=2
                               to ChnPID ChnPID values are 00-01-10, value 11
                               is not valid
                            */
    UINT32 rsvd : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DRAM_RULE_CFG0_N1_MC_MAIN_STRUCT;

/* DRAM_RULE_CFG1_N0_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020cf0)                                                      */
/*      SPRB0 (0x20020cf0)                                                      */
/*      SPRHBM (0x20020cf0)                                                     */
/*      SPRC0 (0x20020cf0)                                                      */
/*      SPRMCC (0x20020cf0)                                                     */
/*      SPRUCC (0x20020cf0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/*  
          8 instances of DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used for 2LM and Write-Through Fill and Evict flows.
      
*/


#define DRAM_RULE_CFG1_N0_MC_MAIN_REG 0x07020CF0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rule_enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable for this DRAM rule. */
    UINT32 limit : 26;

                            /* Bits[26:1], Access Type=RW, default=0x00000000*/

                            /*
                               This correspond to Addr[51:26] of the DRAM rule
                               top limit address. Must be strickly greater then
                               previous rule, even if this rule is disabled,
                               unless this rule and all following rules are
                               disabled. Lower limit is the previous rule (or 0
                               if this is the first rule)
                            */
    UINT32 fm_target : 2;

                            /* Bits[28:27], Access Type=RW, default=0x00000000*/

                            /*
                               FmTarget - Target Far Memory MC; Bit 0 defines
                               the half target (KNH) that all traffic go to.
                            */
    UINT32 fm_chn_ways : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               FmChnWays - Far Memory Channel Ways: used to
                               calculate ChnLID 00 = 1 way (ChnLID = 0) 01 = 2
                               ways (ChnLID = modulo 2 of System Address) 10 =
                               3 ways (ChnLID = modulo 3 of System Address) 11
                               = Reserved
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DRAM_RULE_CFG1_N0_MC_MAIN_STRUCT;

/* DRAM_RULE_CFG1_N1_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020cf4)                                                      */
/*      SPRB0 (0x20020cf4)                                                      */
/*      SPRHBM (0x20020cf4)                                                     */
/*      SPRC0 (0x20020cf4)                                                      */
/*      SPRMCC (0x20020cf4)                                                     */
/*      SPRUCC (0x20020cf4)                                                     */
/* Register default value on SPRA0: 0x00001200                                  */
/* Register default value on SPRB0: 0x00001200                                  */
/* Register default value on SPRHBM: 0x00001200                                 */
/* Register default value on SPRC0: 0x00001200                                  */
/* Register default value on SPRMCC: 0x00001200                                 */
/* Register default value on SPRUCC: 0x00001200                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/*  
          8 instances of DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used for 2LM and Write-Through Fill and Evict flows.
      
*/


#define DRAM_RULE_CFG1_N1_MC_MAIN_REG 0x07020CF4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fm_chn_gran : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               FmChnGran - Far Memory Channel Granularity:
                               001=256B, 010=4KB, 111=2KB, other reserved
                            */
    UINT32 fm_target_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               FmTargetWays - Far Memory Target Ways: used to
                               calculate ChnLID when fm_gran_eq = 1 000 = 1 way
                               001 = 2 ways 010 = 4 ways 011 = 8 ways 100 = 16
                               ways
                            */
    UINT32 fm_gran_eq : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 0, indicate far memory target and
                               channel granularity are different, or target way
                               is 1.
                            */
    UINT32 fm_chn_l2pid : 6;

                            /* Bits[12:7], Access Type=RW, default=0x00000024*/

                            /*
                               FmChnL2PID - translation table for Logical
                               (ChnLID) to Physical ID (ChnPID) FmChnL2PID[1:0]
                               = mapping from ChnLID=0 to ChnPID
                               FmChnL2PID[3:2] = mapping from ChnLID=1 to
                               ChnPID FmChnL2PID[5:4] = mapping from ChnLID=2
                               to ChnPID ChnPID values are 00-01-10, value 11
                               is not valid
                            */
    UINT32 rsvd : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DRAM_RULE_CFG1_N1_MC_MAIN_STRUCT;

/* DRAM_RULE_CFG2_N0_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020cf8)                                                      */
/*      SPRB0 (0x20020cf8)                                                      */
/*      SPRHBM (0x20020cf8)                                                     */
/*      SPRC0 (0x20020cf8)                                                      */
/*      SPRMCC (0x20020cf8)                                                     */
/*      SPRUCC (0x20020cf8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/*  
          8 instances of DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used for 2LM and Write-Through Fill and Evict flows.
      
*/


#define DRAM_RULE_CFG2_N0_MC_MAIN_REG 0x07020CF8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rule_enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable for this DRAM rule. */
    UINT32 limit : 26;

                            /* Bits[26:1], Access Type=RW, default=0x00000000*/

                            /*
                               This correspond to Addr[51:26] of the DRAM rule
                               top limit address. Must be strickly greater then
                               previous rule, even if this rule is disabled,
                               unless this rule and all following rules are
                               disabled. Lower limit is the previous rule (or 0
                               if this is the first rule)
                            */
    UINT32 fm_target : 2;

                            /* Bits[28:27], Access Type=RW, default=0x00000000*/

                            /*
                               FmTarget - Target Far Memory MC; Bit 0 defines
                               the half target (KNH) that all traffic go to.
                            */
    UINT32 fm_chn_ways : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               FmChnWays - Far Memory Channel Ways: used to
                               calculate ChnLID 00 = 1 way (ChnLID = 0) 01 = 2
                               ways (ChnLID = modulo 2 of System Address) 10 =
                               3 ways (ChnLID = modulo 3 of System Address) 11
                               = Reserved
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DRAM_RULE_CFG2_N0_MC_MAIN_STRUCT;

/* DRAM_RULE_CFG2_N1_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020cfc)                                                      */
/*      SPRB0 (0x20020cfc)                                                      */
/*      SPRHBM (0x20020cfc)                                                     */
/*      SPRC0 (0x20020cfc)                                                      */
/*      SPRMCC (0x20020cfc)                                                     */
/*      SPRUCC (0x20020cfc)                                                     */
/* Register default value on SPRA0: 0x00001200                                  */
/* Register default value on SPRB0: 0x00001200                                  */
/* Register default value on SPRHBM: 0x00001200                                 */
/* Register default value on SPRC0: 0x00001200                                  */
/* Register default value on SPRMCC: 0x00001200                                 */
/* Register default value on SPRUCC: 0x00001200                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/*  
          8 instances of DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used for 2LM and Write-Through Fill and Evict flows.
      
*/


#define DRAM_RULE_CFG2_N1_MC_MAIN_REG 0x07020CFC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fm_chn_gran : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               FmChnGran - Far Memory Channel Granularity:
                               001=256B, 010=4KB, 111=2KB, other reserved
                            */
    UINT32 fm_target_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               FmTargetWays - Far Memory Target Ways: used to
                               calculate ChnLID when fm_gran_eq = 1 000 = 1 way
                               001 = 2 ways 010 = 4 ways 011 = 8 ways 100 = 16
                               ways
                            */
    UINT32 fm_gran_eq : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 0, indicate far memory target and
                               channel granularity are different, or target way
                               is 1.
                            */
    UINT32 fm_chn_l2pid : 6;

                            /* Bits[12:7], Access Type=RW, default=0x00000024*/

                            /*
                               FmChnL2PID - translation table for Logical
                               (ChnLID) to Physical ID (ChnPID) FmChnL2PID[1:0]
                               = mapping from ChnLID=0 to ChnPID
                               FmChnL2PID[3:2] = mapping from ChnLID=1 to
                               ChnPID FmChnL2PID[5:4] = mapping from ChnLID=2
                               to ChnPID ChnPID values are 00-01-10, value 11
                               is not valid
                            */
    UINT32 rsvd : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DRAM_RULE_CFG2_N1_MC_MAIN_STRUCT;

/* DRAM_RULE_CFG3_N0_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020d00)                                                      */
/*      SPRB0 (0x20020d00)                                                      */
/*      SPRHBM (0x20020d00)                                                     */
/*      SPRC0 (0x20020d00)                                                      */
/*      SPRMCC (0x20020d00)                                                     */
/*      SPRUCC (0x20020d00)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/*  
          8 instances of DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used for 2LM and Write-Through Fill and Evict flows.
      
*/


#define DRAM_RULE_CFG3_N0_MC_MAIN_REG 0x07020D00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rule_enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable for this DRAM rule. */
    UINT32 limit : 26;

                            /* Bits[26:1], Access Type=RW, default=0x00000000*/

                            /*
                               This correspond to Addr[51:26] of the DRAM rule
                               top limit address. Must be strickly greater then
                               previous rule, even if this rule is disabled,
                               unless this rule and all following rules are
                               disabled. Lower limit is the previous rule (or 0
                               if this is the first rule)
                            */
    UINT32 fm_target : 2;

                            /* Bits[28:27], Access Type=RW, default=0x00000000*/

                            /*
                               FmTarget - Target Far Memory MC; Bit 0 defines
                               the half target (KNH) that all traffic go to.
                            */
    UINT32 fm_chn_ways : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               FmChnWays - Far Memory Channel Ways: used to
                               calculate ChnLID 00 = 1 way (ChnLID = 0) 01 = 2
                               ways (ChnLID = modulo 2 of System Address) 10 =
                               3 ways (ChnLID = modulo 3 of System Address) 11
                               = Reserved
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DRAM_RULE_CFG3_N0_MC_MAIN_STRUCT;

/* DRAM_RULE_CFG3_N1_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020d04)                                                      */
/*      SPRB0 (0x20020d04)                                                      */
/*      SPRHBM (0x20020d04)                                                     */
/*      SPRC0 (0x20020d04)                                                      */
/*      SPRMCC (0x20020d04)                                                     */
/*      SPRUCC (0x20020d04)                                                     */
/* Register default value on SPRA0: 0x00001200                                  */
/* Register default value on SPRB0: 0x00001200                                  */
/* Register default value on SPRHBM: 0x00001200                                 */
/* Register default value on SPRC0: 0x00001200                                  */
/* Register default value on SPRMCC: 0x00001200                                 */
/* Register default value on SPRUCC: 0x00001200                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/*  
          8 instances of DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used for 2LM and Write-Through Fill and Evict flows.
      
*/


#define DRAM_RULE_CFG3_N1_MC_MAIN_REG 0x07020D04

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fm_chn_gran : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               FmChnGran - Far Memory Channel Granularity:
                               001=256B, 010=4KB, 111=2KB, other reserved
                            */
    UINT32 fm_target_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               FmTargetWays - Far Memory Target Ways: used to
                               calculate ChnLID when fm_gran_eq = 1 000 = 1 way
                               001 = 2 ways 010 = 4 ways 011 = 8 ways 100 = 16
                               ways
                            */
    UINT32 fm_gran_eq : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 0, indicate far memory target and
                               channel granularity are different, or target way
                               is 1.
                            */
    UINT32 fm_chn_l2pid : 6;

                            /* Bits[12:7], Access Type=RW, default=0x00000024*/

                            /*
                               FmChnL2PID - translation table for Logical
                               (ChnLID) to Physical ID (ChnPID) FmChnL2PID[1:0]
                               = mapping from ChnLID=0 to ChnPID
                               FmChnL2PID[3:2] = mapping from ChnLID=1 to
                               ChnPID FmChnL2PID[5:4] = mapping from ChnLID=2
                               to ChnPID ChnPID values are 00-01-10, value 11
                               is not valid
                            */
    UINT32 rsvd : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DRAM_RULE_CFG3_N1_MC_MAIN_STRUCT;

/* DRAM_RULE_CFG4_N0_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020d08)                                                      */
/*      SPRB0 (0x20020d08)                                                      */
/*      SPRHBM (0x20020d08)                                                     */
/*      SPRC0 (0x20020d08)                                                      */
/*      SPRMCC (0x20020d08)                                                     */
/*      SPRUCC (0x20020d08)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/*  
          8 instances of DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used for 2LM and Write-Through Fill and Evict flows.
      
*/


#define DRAM_RULE_CFG4_N0_MC_MAIN_REG 0x07020D08

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rule_enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable for this DRAM rule. */
    UINT32 limit : 26;

                            /* Bits[26:1], Access Type=RW, default=0x00000000*/

                            /*
                               This correspond to Addr[51:26] of the DRAM rule
                               top limit address. Must be strickly greater then
                               previous rule, even if this rule is disabled,
                               unless this rule and all following rules are
                               disabled. Lower limit is the previous rule (or 0
                               if this is the first rule)
                            */
    UINT32 fm_target : 2;

                            /* Bits[28:27], Access Type=RW, default=0x00000000*/

                            /*
                               FmTarget - Target Far Memory MC; Bit 0 defines
                               the half target (KNH) that all traffic go to.
                            */
    UINT32 fm_chn_ways : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               FmChnWays - Far Memory Channel Ways: used to
                               calculate ChnLID 00 = 1 way (ChnLID = 0) 01 = 2
                               ways (ChnLID = modulo 2 of System Address) 10 =
                               3 ways (ChnLID = modulo 3 of System Address) 11
                               = Reserved
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DRAM_RULE_CFG4_N0_MC_MAIN_STRUCT;

/* DRAM_RULE_CFG4_N1_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020d0c)                                                      */
/*      SPRB0 (0x20020d0c)                                                      */
/*      SPRHBM (0x20020d0c)                                                     */
/*      SPRC0 (0x20020d0c)                                                      */
/*      SPRMCC (0x20020d0c)                                                     */
/*      SPRUCC (0x20020d0c)                                                     */
/* Register default value on SPRA0: 0x00001200                                  */
/* Register default value on SPRB0: 0x00001200                                  */
/* Register default value on SPRHBM: 0x00001200                                 */
/* Register default value on SPRC0: 0x00001200                                  */
/* Register default value on SPRMCC: 0x00001200                                 */
/* Register default value on SPRUCC: 0x00001200                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/*  
          8 instances of DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used for 2LM and Write-Through Fill and Evict flows.
      
*/


#define DRAM_RULE_CFG4_N1_MC_MAIN_REG 0x07020D0C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fm_chn_gran : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               FmChnGran - Far Memory Channel Granularity:
                               001=256B, 010=4KB, 111=2KB, other reserved
                            */
    UINT32 fm_target_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               FmTargetWays - Far Memory Target Ways: used to
                               calculate ChnLID when fm_gran_eq = 1 000 = 1 way
                               001 = 2 ways 010 = 4 ways 011 = 8 ways 100 = 16
                               ways
                            */
    UINT32 fm_gran_eq : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 0, indicate far memory target and
                               channel granularity are different, or target way
                               is 1.
                            */
    UINT32 fm_chn_l2pid : 6;

                            /* Bits[12:7], Access Type=RW, default=0x00000024*/

                            /*
                               FmChnL2PID - translation table for Logical
                               (ChnLID) to Physical ID (ChnPID) FmChnL2PID[1:0]
                               = mapping from ChnLID=0 to ChnPID
                               FmChnL2PID[3:2] = mapping from ChnLID=1 to
                               ChnPID FmChnL2PID[5:4] = mapping from ChnLID=2
                               to ChnPID ChnPID values are 00-01-10, value 11
                               is not valid
                            */
    UINT32 rsvd : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DRAM_RULE_CFG4_N1_MC_MAIN_STRUCT;

/* DRAM_RULE_CFG5_N0_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020d10)                                                      */
/*      SPRB0 (0x20020d10)                                                      */
/*      SPRHBM (0x20020d10)                                                     */
/*      SPRC0 (0x20020d10)                                                      */
/*      SPRMCC (0x20020d10)                                                     */
/*      SPRUCC (0x20020d10)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/*  
          8 instances of DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used for 2LM and Write-Through Fill and Evict flows.
      
*/


#define DRAM_RULE_CFG5_N0_MC_MAIN_REG 0x07020D10

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rule_enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable for this DRAM rule. */
    UINT32 limit : 26;

                            /* Bits[26:1], Access Type=RW, default=0x00000000*/

                            /*
                               This correspond to Addr[51:26] of the DRAM rule
                               top limit address. Must be strickly greater then
                               previous rule, even if this rule is disabled,
                               unless this rule and all following rules are
                               disabled. Lower limit is the previous rule (or 0
                               if this is the first rule)
                            */
    UINT32 fm_target : 2;

                            /* Bits[28:27], Access Type=RW, default=0x00000000*/

                            /*
                               FmTarget - Target Far Memory MC; Bit 0 defines
                               the half target (KNH) that all traffic go to.
                            */
    UINT32 fm_chn_ways : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               FmChnWays - Far Memory Channel Ways: used to
                               calculate ChnLID 00 = 1 way (ChnLID = 0) 01 = 2
                               ways (ChnLID = modulo 2 of System Address) 10 =
                               3 ways (ChnLID = modulo 3 of System Address) 11
                               = Reserved
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DRAM_RULE_CFG5_N0_MC_MAIN_STRUCT;

/* DRAM_RULE_CFG5_N1_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020d14)                                                      */
/*      SPRB0 (0x20020d14)                                                      */
/*      SPRHBM (0x20020d14)                                                     */
/*      SPRC0 (0x20020d14)                                                      */
/*      SPRMCC (0x20020d14)                                                     */
/*      SPRUCC (0x20020d14)                                                     */
/* Register default value on SPRA0: 0x00001200                                  */
/* Register default value on SPRB0: 0x00001200                                  */
/* Register default value on SPRHBM: 0x00001200                                 */
/* Register default value on SPRC0: 0x00001200                                  */
/* Register default value on SPRMCC: 0x00001200                                 */
/* Register default value on SPRUCC: 0x00001200                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/*  
          8 instances of DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used for 2LM and Write-Through Fill and Evict flows.
      
*/


#define DRAM_RULE_CFG5_N1_MC_MAIN_REG 0x07020D14

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fm_chn_gran : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               FmChnGran - Far Memory Channel Granularity:
                               001=256B, 010=4KB, 111=2KB, other reserved
                            */
    UINT32 fm_target_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               FmTargetWays - Far Memory Target Ways: used to
                               calculate ChnLID when fm_gran_eq = 1 000 = 1 way
                               001 = 2 ways 010 = 4 ways 011 = 8 ways 100 = 16
                               ways
                            */
    UINT32 fm_gran_eq : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 0, indicate far memory target and
                               channel granularity are different, or target way
                               is 1.
                            */
    UINT32 fm_chn_l2pid : 6;

                            /* Bits[12:7], Access Type=RW, default=0x00000024*/

                            /*
                               FmChnL2PID - translation table for Logical
                               (ChnLID) to Physical ID (ChnPID) FmChnL2PID[1:0]
                               = mapping from ChnLID=0 to ChnPID
                               FmChnL2PID[3:2] = mapping from ChnLID=1 to
                               ChnPID FmChnL2PID[5:4] = mapping from ChnLID=2
                               to ChnPID ChnPID values are 00-01-10, value 11
                               is not valid
                            */
    UINT32 rsvd : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DRAM_RULE_CFG5_N1_MC_MAIN_STRUCT;

/* DRAM_RULE_CFG6_N0_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020d18)                                                      */
/*      SPRB0 (0x20020d18)                                                      */
/*      SPRHBM (0x20020d18)                                                     */
/*      SPRC0 (0x20020d18)                                                      */
/*      SPRMCC (0x20020d18)                                                     */
/*      SPRUCC (0x20020d18)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/*  
          8 instances of DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used for 2LM and Write-Through Fill and Evict flows.
      
*/


#define DRAM_RULE_CFG6_N0_MC_MAIN_REG 0x07020D18

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rule_enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable for this DRAM rule. */
    UINT32 limit : 26;

                            /* Bits[26:1], Access Type=RW, default=0x00000000*/

                            /*
                               This correspond to Addr[51:26] of the DRAM rule
                               top limit address. Must be strickly greater then
                               previous rule, even if this rule is disabled,
                               unless this rule and all following rules are
                               disabled. Lower limit is the previous rule (or 0
                               if this is the first rule)
                            */
    UINT32 fm_target : 2;

                            /* Bits[28:27], Access Type=RW, default=0x00000000*/

                            /*
                               FmTarget - Target Far Memory MC; Bit 0 defines
                               the half target (KNH) that all traffic go to.
                            */
    UINT32 fm_chn_ways : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               FmChnWays - Far Memory Channel Ways: used to
                               calculate ChnLID 00 = 1 way (ChnLID = 0) 01 = 2
                               ways (ChnLID = modulo 2 of System Address) 10 =
                               3 ways (ChnLID = modulo 3 of System Address) 11
                               = Reserved
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DRAM_RULE_CFG6_N0_MC_MAIN_STRUCT;

/* DRAM_RULE_CFG6_N1_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020d1c)                                                      */
/*      SPRB0 (0x20020d1c)                                                      */
/*      SPRHBM (0x20020d1c)                                                     */
/*      SPRC0 (0x20020d1c)                                                      */
/*      SPRMCC (0x20020d1c)                                                     */
/*      SPRUCC (0x20020d1c)                                                     */
/* Register default value on SPRA0: 0x00001200                                  */
/* Register default value on SPRB0: 0x00001200                                  */
/* Register default value on SPRHBM: 0x00001200                                 */
/* Register default value on SPRC0: 0x00001200                                  */
/* Register default value on SPRMCC: 0x00001200                                 */
/* Register default value on SPRUCC: 0x00001200                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/*  
          8 instances of DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used for 2LM and Write-Through Fill and Evict flows.
      
*/


#define DRAM_RULE_CFG6_N1_MC_MAIN_REG 0x07020D1C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fm_chn_gran : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               FmChnGran - Far Memory Channel Granularity:
                               001=256B, 010=4KB, 111=2KB, other reserved
                            */
    UINT32 fm_target_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               FmTargetWays - Far Memory Target Ways: used to
                               calculate ChnLID when fm_gran_eq = 1 000 = 1 way
                               001 = 2 ways 010 = 4 ways 011 = 8 ways 100 = 16
                               ways
                            */
    UINT32 fm_gran_eq : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 0, indicate far memory target and
                               channel granularity are different, or target way
                               is 1.
                            */
    UINT32 fm_chn_l2pid : 6;

                            /* Bits[12:7], Access Type=RW, default=0x00000024*/

                            /*
                               FmChnL2PID - translation table for Logical
                               (ChnLID) to Physical ID (ChnPID) FmChnL2PID[1:0]
                               = mapping from ChnLID=0 to ChnPID
                               FmChnL2PID[3:2] = mapping from ChnLID=1 to
                               ChnPID FmChnL2PID[5:4] = mapping from ChnLID=2
                               to ChnPID ChnPID values are 00-01-10, value 11
                               is not valid
                            */
    UINT32 rsvd : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DRAM_RULE_CFG6_N1_MC_MAIN_STRUCT;

/* DRAM_RULE_CFG7_N0_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020d20)                                                      */
/*      SPRB0 (0x20020d20)                                                      */
/*      SPRHBM (0x20020d20)                                                     */
/*      SPRC0 (0x20020d20)                                                      */
/*      SPRMCC (0x20020d20)                                                     */
/*      SPRUCC (0x20020d20)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/*  
          8 instances of DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used for 2LM and Write-Through Fill and Evict flows.
      
*/


#define DRAM_RULE_CFG7_N0_MC_MAIN_REG 0x07020D20

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rule_enable : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Enable for this DRAM rule. */
    UINT32 limit : 26;

                            /* Bits[26:1], Access Type=RW, default=0x00000000*/

                            /*
                               This correspond to Addr[51:26] of the DRAM rule
                               top limit address. Must be strickly greater then
                               previous rule, even if this rule is disabled,
                               unless this rule and all following rules are
                               disabled. Lower limit is the previous rule (or 0
                               if this is the first rule)
                            */
    UINT32 fm_target : 2;

                            /* Bits[28:27], Access Type=RW, default=0x00000000*/

                            /*
                               FmTarget - Target Far Memory MC; Bit 0 defines
                               the half target (KNH) that all traffic go to.
                            */
    UINT32 fm_chn_ways : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               FmChnWays - Far Memory Channel Ways: used to
                               calculate ChnLID 00 = 1 way (ChnLID = 0) 01 = 2
                               ways (ChnLID = modulo 2 of System Address) 10 =
                               3 ways (ChnLID = modulo 3 of System Address) 11
                               = Reserved
                            */
    UINT32 rsvd : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DRAM_RULE_CFG7_N0_MC_MAIN_STRUCT;

/* DRAM_RULE_CFG7_N1_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020d24)                                                      */
/*      SPRB0 (0x20020d24)                                                      */
/*      SPRHBM (0x20020d24)                                                     */
/*      SPRC0 (0x20020d24)                                                      */
/*      SPRMCC (0x20020d24)                                                     */
/*      SPRUCC (0x20020d24)                                                     */
/* Register default value on SPRA0: 0x00001200                                  */
/* Register default value on SPRB0: 0x00001200                                  */
/* Register default value on SPRHBM: 0x00001200                                 */
/* Register default value on SPRC0: 0x00001200                                  */
/* Register default value on SPRMCC: 0x00001200                                 */
/* Register default value on SPRUCC: 0x00001200                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/*  
          8 instances of DRAM_RULE_CFG, one for each of the existing DRAM decoder 
          Used for 2LM and Write-Through Fill and Evict flows.
      
*/


#define DRAM_RULE_CFG7_N1_MC_MAIN_REG 0x07020D24

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fm_chn_gran : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               FmChnGran - Far Memory Channel Granularity:
                               001=256B, 010=4KB, 111=2KB, other reserved
                            */
    UINT32 fm_target_ways : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               FmTargetWays - Far Memory Target Ways: used to
                               calculate ChnLID when fm_gran_eq = 1 000 = 1 way
                               001 = 2 ways 010 = 4 ways 011 = 8 ways 100 = 16
                               ways
                            */
    UINT32 fm_gran_eq : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 0, indicate far memory target and
                               channel granularity are different, or target way
                               is 1.
                            */
    UINT32 fm_chn_l2pid : 6;

                            /* Bits[12:7], Access Type=RW, default=0x00000024*/

                            /*
                               FmChnL2PID - translation table for Logical
                               (ChnLID) to Physical ID (ChnPID) FmChnL2PID[1:0]
                               = mapping from ChnLID=0 to ChnPID
                               FmChnL2PID[3:2] = mapping from ChnLID=1 to
                               ChnPID FmChnL2PID[5:4] = mapping from ChnLID=2
                               to ChnPID ChnPID values are 00-01-10, value 11
                               is not valid
                            */
    UINT32 rsvd : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DRAM_RULE_CFG7_N1_MC_MAIN_STRUCT;

/* MCNMCACHINGCFG_MC_MAIN_REG supported on:                                     */
/*      SPRA0 (0x20020dac)                                                      */
/*      SPRB0 (0x20020dac)                                                      */
/*      SPRHBM (0x20020dac)                                                     */
/*      SPRC0 (0x20020dac)                                                      */
/*      SPRMCC (0x20020dac)                                                     */
/*      SPRUCC (0x20020dac)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* MC 2LM Configuration Register
*/


#define MCNMCACHINGCFG_MC_MAIN_REG 0x07020DAC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mcnmcachingenb : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Enables 2LM near memory caching of far memory if
                               set. Locked by 2LM disable uCR. This field is
                               programmed on the per iMC basis, i.e. need to
                               maintain consistency with other populated
                               channels in this iMC. A related register -
                               McNMCachingCfg2 - is per channel and is located
                               in MC2LMCNTL block.
                            */
    UINT32 mcpmemenb : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               1LM or 2LM mode but with AG2 memory enabled if
                               set. Locked by PMem disable uCR. This field is
                               programmed on the per iMC basis, i.e. need to
                               maintain consistency with other populated
                               channels in this iMC.
                            */
    UINT32 mcnmcachingpmemwt : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               For PMem transactions, write to both near and
                               far memory if set. Locked by PMem Write-Thru
                               disable uCR. This field is programmed on the per
                               iMC basis, i.e. need to maintain consistency
                               with other populated channels in this iMC.
                            */
    UINT32 wcilfoptdis : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               For WCILF if NM dir=i/s do not squash the fillrd
                               on a miss if this bit is set
                            */
    UINT32 rsvd0 : 4;

                            /* Bits[7:4], Access Type=RO, default=0x00000000*/

                            /* Reserved */
    UINT32 mcmirrormode : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Configured for mirroring - far memory is in the
                               same channel as near memory if set. Locked by
                               mirroring disable uCR. This field is programmed
                               on the per iMC basis, i.e. need to maintain
                               consistency with other populated channels in
                               this iMC.
                            */
    UINT32 nmcachingtad : 3;

                            /* Bits[11:9], Access Type=RW, default=0x00000000*/

                            /*
                               TAD index used for 2LM NM for patrol and sparing
                               address generation.
                            */
    UINT32 nmcachingtaden : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Enable for TAD index used for 2LM NM for patrol
                               and sparing address generation.
                            */
    UINT32 patforcenm : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Force all patrol transaction destination to 2LM
                               NM.
                            */
    UINT32 rsvd_14 : 1;

                            /* Bits[14:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd1 : 17;

                            /* Bits[31:15], Access Type=RO, default=0x00000000*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCNMCACHINGCFG_MC_MAIN_STRUCT;

/* TADBASE_0_MC_MAIN_REG supported on:                                          */
/*      SPRA0 (0x20020db0)                                                      */
/*      SPRB0 (0x20020db0)                                                      */
/*      SPRHBM (0x20020db0)                                                     */
/*      SPRC0 (0x20020db0)                                                      */
/*      SPRMCC (0x20020db0)                                                     */
/*      SPRUCC (0x20020db0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* There are total of 8 TAD ranges for DRAM memory.
                   This part of the TAD defines the system address Base of each range.
*/


#define TADBASE_0_MC_MAIN_REG 0x07020DB0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mirror_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Mirroring enabled on this TAD */
    UINT32 en_failover : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to indicate mirror failover happened on
                               this TAD. Patrol address to the channel
                               programmed in failed_ch for this TAD will be
                               skipped. Set to 1 for the failed channel and
                               also the channel whose mirror channel has
                               failed.
                            */
    UINT32 ign_ptrl_uc : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Downgrades patrol scrubbing uncorrectable errors
                               to correactable for this TAD range. Use for
                               partial mirroring mode.
                            */
    UINT32 base : 26;

                            /* Bits[28:3], Access Type=RW, default=0x00000000*/

                            /*
                               lowest address of the range in system address
                               space, 64MB granularity, i.e.
                               TADRANGEBASE[51:26].
                            */
    UINT32 failed_ch : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Used when en_failover bit is set for this TAD.
                               Indicates the channel that has failed.
                            */
    UINT32 dedup_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* This TAD is used for Dedup region */

  } Bits;
  UINT32 Data;

} TADBASE_0_MC_MAIN_STRUCT;

/* TADBASE_1_MC_MAIN_REG supported on:                                          */
/*      SPRA0 (0x20020db4)                                                      */
/*      SPRB0 (0x20020db4)                                                      */
/*      SPRHBM (0x20020db4)                                                     */
/*      SPRC0 (0x20020db4)                                                      */
/*      SPRMCC (0x20020db4)                                                     */
/*      SPRUCC (0x20020db4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* There are total of 8 TAD ranges for DRAM memory.
                   This part of the TAD defines the system address Base of each range.
*/


#define TADBASE_1_MC_MAIN_REG 0x07020DB4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mirror_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Mirroring enabled on this TAD */
    UINT32 en_failover : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to indicate mirror failover happened on
                               this TAD. Patrol address to the channel
                               programmed in failed_ch for this TAD will be
                               skipped. Set to 1 for the failed channel and
                               also the channel whose mirror channel has
                               failed.
                            */
    UINT32 ign_ptrl_uc : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Downgrades patrol scrubbing uncorrectable errors
                               to correactable for this TAD range. Use for
                               partial mirroring mode.
                            */
    UINT32 base : 26;

                            /* Bits[28:3], Access Type=RW, default=0x00000000*/

                            /*
                               lowest address of the range in system address
                               space, 64MB granularity, i.e.
                               TADRANGEBASE[51:26].
                            */
    UINT32 failed_ch : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Used when en_failover bit is set for this TAD.
                               Indicates the channel that has failed.
                            */
    UINT32 dedup_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* This TAD is used for Dedup region */

  } Bits;
  UINT32 Data;

} TADBASE_1_MC_MAIN_STRUCT;

/* TADBASE_2_MC_MAIN_REG supported on:                                          */
/*      SPRA0 (0x20020db8)                                                      */
/*      SPRB0 (0x20020db8)                                                      */
/*      SPRHBM (0x20020db8)                                                     */
/*      SPRC0 (0x20020db8)                                                      */
/*      SPRMCC (0x20020db8)                                                     */
/*      SPRUCC (0x20020db8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* There are total of 8 TAD ranges for DRAM memory.
                   This part of the TAD defines the system address Base of each range.
*/


#define TADBASE_2_MC_MAIN_REG 0x07020DB8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mirror_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Mirroring enabled on this TAD */
    UINT32 en_failover : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to indicate mirror failover happened on
                               this TAD. Patrol address to the channel
                               programmed in failed_ch for this TAD will be
                               skipped. Set to 1 for the failed channel and
                               also the channel whose mirror channel has
                               failed.
                            */
    UINT32 ign_ptrl_uc : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Downgrades patrol scrubbing uncorrectable errors
                               to correactable for this TAD range. Use for
                               partial mirroring mode.
                            */
    UINT32 base : 26;

                            /* Bits[28:3], Access Type=RW, default=0x00000000*/

                            /*
                               lowest address of the range in system address
                               space, 64MB granularity, i.e.
                               TADRANGEBASE[51:26].
                            */
    UINT32 failed_ch : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Used when en_failover bit is set for this TAD.
                               Indicates the channel that has failed.
                            */
    UINT32 dedup_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* This TAD is used for Dedup region */

  } Bits;
  UINT32 Data;

} TADBASE_2_MC_MAIN_STRUCT;

/* TADBASE_3_MC_MAIN_REG supported on:                                          */
/*      SPRA0 (0x20020dbc)                                                      */
/*      SPRB0 (0x20020dbc)                                                      */
/*      SPRHBM (0x20020dbc)                                                     */
/*      SPRC0 (0x20020dbc)                                                      */
/*      SPRMCC (0x20020dbc)                                                     */
/*      SPRUCC (0x20020dbc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* There are total of 8 TAD ranges for DRAM memory.
                   This part of the TAD defines the system address Base of each range.
*/


#define TADBASE_3_MC_MAIN_REG 0x07020DBC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mirror_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Mirroring enabled on this TAD */
    UINT32 en_failover : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to indicate mirror failover happened on
                               this TAD. Patrol address to the channel
                               programmed in failed_ch for this TAD will be
                               skipped. Set to 1 for the failed channel and
                               also the channel whose mirror channel has
                               failed.
                            */
    UINT32 ign_ptrl_uc : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Downgrades patrol scrubbing uncorrectable errors
                               to correactable for this TAD range. Use for
                               partial mirroring mode.
                            */
    UINT32 base : 26;

                            /* Bits[28:3], Access Type=RW, default=0x00000000*/

                            /*
                               lowest address of the range in system address
                               space, 64MB granularity, i.e.
                               TADRANGEBASE[51:26].
                            */
    UINT32 failed_ch : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Used when en_failover bit is set for this TAD.
                               Indicates the channel that has failed.
                            */
    UINT32 dedup_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* This TAD is used for Dedup region */

  } Bits;
  UINT32 Data;

} TADBASE_3_MC_MAIN_STRUCT;

/* TADBASE_4_MC_MAIN_REG supported on:                                          */
/*      SPRA0 (0x20020dc0)                                                      */
/*      SPRB0 (0x20020dc0)                                                      */
/*      SPRHBM (0x20020dc0)                                                     */
/*      SPRC0 (0x20020dc0)                                                      */
/*      SPRMCC (0x20020dc0)                                                     */
/*      SPRUCC (0x20020dc0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* There are total of 8 TAD ranges for DRAM memory.
                   This part of the TAD defines the system address Base of each range.
*/


#define TADBASE_4_MC_MAIN_REG 0x07020DC0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mirror_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Mirroring enabled on this TAD */
    UINT32 en_failover : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to indicate mirror failover happened on
                               this TAD. Patrol address to the channel
                               programmed in failed_ch for this TAD will be
                               skipped. Set to 1 for the failed channel and
                               also the channel whose mirror channel has
                               failed.
                            */
    UINT32 ign_ptrl_uc : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Downgrades patrol scrubbing uncorrectable errors
                               to correactable for this TAD range. Use for
                               partial mirroring mode.
                            */
    UINT32 base : 26;

                            /* Bits[28:3], Access Type=RW, default=0x00000000*/

                            /*
                               lowest address of the range in system address
                               space, 64MB granularity, i.e.
                               TADRANGEBASE[51:26].
                            */
    UINT32 failed_ch : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Used when en_failover bit is set for this TAD.
                               Indicates the channel that has failed.
                            */
    UINT32 dedup_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* This TAD is used for Dedup region */

  } Bits;
  UINT32 Data;

} TADBASE_4_MC_MAIN_STRUCT;

/* TADBASE_5_MC_MAIN_REG supported on:                                          */
/*      SPRA0 (0x20020dc4)                                                      */
/*      SPRB0 (0x20020dc4)                                                      */
/*      SPRHBM (0x20020dc4)                                                     */
/*      SPRC0 (0x20020dc4)                                                      */
/*      SPRMCC (0x20020dc4)                                                     */
/*      SPRUCC (0x20020dc4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* There are total of 8 TAD ranges for DRAM memory.
                   This part of the TAD defines the system address Base of each range.
*/


#define TADBASE_5_MC_MAIN_REG 0x07020DC4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mirror_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Mirroring enabled on this TAD */
    UINT32 en_failover : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to indicate mirror failover happened on
                               this TAD. Patrol address to the channel
                               programmed in failed_ch for this TAD will be
                               skipped. Set to 1 for the failed channel and
                               also the channel whose mirror channel has
                               failed.
                            */
    UINT32 ign_ptrl_uc : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Downgrades patrol scrubbing uncorrectable errors
                               to correactable for this TAD range. Use for
                               partial mirroring mode.
                            */
    UINT32 base : 26;

                            /* Bits[28:3], Access Type=RW, default=0x00000000*/

                            /*
                               lowest address of the range in system address
                               space, 64MB granularity, i.e.
                               TADRANGEBASE[51:26].
                            */
    UINT32 failed_ch : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Used when en_failover bit is set for this TAD.
                               Indicates the channel that has failed.
                            */
    UINT32 dedup_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* This TAD is used for Dedup region */

  } Bits;
  UINT32 Data;

} TADBASE_5_MC_MAIN_STRUCT;

/* TADBASE_6_MC_MAIN_REG supported on:                                          */
/*      SPRA0 (0x20020dc8)                                                      */
/*      SPRB0 (0x20020dc8)                                                      */
/*      SPRHBM (0x20020dc8)                                                     */
/*      SPRC0 (0x20020dc8)                                                      */
/*      SPRMCC (0x20020dc8)                                                     */
/*      SPRUCC (0x20020dc8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* There are total of 8 TAD ranges for DRAM memory.
                   This part of the TAD defines the system address Base of each range.
*/


#define TADBASE_6_MC_MAIN_REG 0x07020DC8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mirror_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Mirroring enabled on this TAD */
    UINT32 en_failover : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to indicate mirror failover happened on
                               this TAD. Patrol address to the channel
                               programmed in failed_ch for this TAD will be
                               skipped. Set to 1 for the failed channel and
                               also the channel whose mirror channel has
                               failed.
                            */
    UINT32 ign_ptrl_uc : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Downgrades patrol scrubbing uncorrectable errors
                               to correactable for this TAD range. Use for
                               partial mirroring mode.
                            */
    UINT32 base : 26;

                            /* Bits[28:3], Access Type=RW, default=0x00000000*/

                            /*
                               lowest address of the range in system address
                               space, 64MB granularity, i.e.
                               TADRANGEBASE[51:26].
                            */
    UINT32 failed_ch : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Used when en_failover bit is set for this TAD.
                               Indicates the channel that has failed.
                            */
    UINT32 dedup_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* This TAD is used for Dedup region */

  } Bits;
  UINT32 Data;

} TADBASE_6_MC_MAIN_STRUCT;

/* TADBASE_7_MC_MAIN_REG supported on:                                          */
/*      SPRA0 (0x20020dcc)                                                      */
/*      SPRB0 (0x20020dcc)                                                      */
/*      SPRHBM (0x20020dcc)                                                     */
/*      SPRC0 (0x20020dcc)                                                      */
/*      SPRMCC (0x20020dcc)                                                     */
/*      SPRUCC (0x20020dcc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* There are total of 8 TAD ranges for DRAM memory.
                   This part of the TAD defines the system address Base of each range.
*/


#define TADBASE_7_MC_MAIN_REG 0x07020DCC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mirror_en : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* Mirroring enabled on this TAD */
    UINT32 en_failover : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Set to 1 to indicate mirror failover happened on
                               this TAD. Patrol address to the channel
                               programmed in failed_ch for this TAD will be
                               skipped. Set to 1 for the failed channel and
                               also the channel whose mirror channel has
                               failed.
                            */
    UINT32 ign_ptrl_uc : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Downgrades patrol scrubbing uncorrectable errors
                               to correactable for this TAD range. Use for
                               partial mirroring mode.
                            */
    UINT32 base : 26;

                            /* Bits[28:3], Access Type=RW, default=0x00000000*/

                            /*
                               lowest address of the range in system address
                               space, 64MB granularity, i.e.
                               TADRANGEBASE[51:26].
                            */
    UINT32 failed_ch : 2;

                            /* Bits[30:29], Access Type=RW, default=0x00000000*/

                            /*
                               Used when en_failover bit is set for this TAD.
                               Indicates the channel that has failed.
                            */
    UINT32 dedup_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* This TAD is used for Dedup region */

  } Bits;
  UINT32 Data;

} TADBASE_7_MC_MAIN_STRUCT;

/* TADWAYNESS_0_MC_MAIN_REG supported on:                                       */
/*      SPRA0 (0x20020dd4)                                                      */
/*      SPRB0 (0x20020dd4)                                                      */
/*      SPRHBM (0x20020dd4)                                                     */
/*      SPRC0 (0x20020dd4)                                                      */
/*      SPRMCC (0x20020dd4)                                                     */
/*      SPRUCC (0x20020dd4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* There are total of 8 TAD ranges 
          Note for mirroring configuration:
          For 1-way interleave, channel 0-2 mirror pair: target list = <0,2,x,x>, TAD ways = 00
          For 1-way interleave, channel 1-3 mirror pair: target list = <1,3,x,x>, TAD ways = 00
          For 2-way interleave, 0-2 mirror pair and 1-3 mirror pair: target list = <0,1,2,3>, TAD ways = 01
          For 1-way interleave, lockstep + mirroring, target list = <0,2,x,x>, TAD ways = 00
*/


#define TADWAYNESS_0_MC_MAIN_REG 0x07020DD4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_lid : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               TargetLID: target logical ID, a.k.a.,
                               base_offset The position of the MC in the socket
                               interleave list in the SAD rule that maps to
                               this TAD rule. If 1-way interleaved to one MC,
                               base_offset is 0. If 2-way interleaved across
                               two MCs, base_offset is either 0 or 1. 4-way, 0
                               through 3. 8-way, 0 through 7.
                            */
    UINT32 chn_lid : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               ChnLID: channel logical ID. logical channel for
                               channel interleave.
                            */
    UINT32 tad_limit : 26;

                            /* Bits[31:6], Access Type=RW, default=0x00000000*/

                            /*
                               highest address of the range in system address
                               space, 64MB granularity, i.e.
                               TADRANGLIMIT[51:26]. In case of 3 channel
                               interleave, exclude the address not accessed by
                               the system, even if the address is valid in
                               memory.
                            */

  } Bits;
  UINT32 Data;

} TADWAYNESS_0_MC_MAIN_STRUCT;

/* TADWAYNESS_1_MC_MAIN_REG supported on:                                       */
/*      SPRA0 (0x20020dd8)                                                      */
/*      SPRB0 (0x20020dd8)                                                      */
/*      SPRHBM (0x20020dd8)                                                     */
/*      SPRC0 (0x20020dd8)                                                      */
/*      SPRMCC (0x20020dd8)                                                     */
/*      SPRUCC (0x20020dd8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* There are total of 8 TAD ranges 
Note for mirroring configuration:
For 1-way interleave, channel 0-2 mirror pair: target list = <0,2,x,x>, TAD ways = 00
For 1-way interleave, channel 1-3 mirror pair: target list = <1,3,x,x>, TAD ways = 00
For 2-way interleave, 0-2 mirror pair and 1-3 mirror pair: target list = <0,1,2,3>, TAD ways = 01
For 1-way interleave, lockstep + mirroring, target list = <0,2,x,x>, TAD ways = 00
*/


#define TADWAYNESS_1_MC_MAIN_REG 0x07020DD8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_lid : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               TargetLID: target logical ID, a.k.a.,
                               base_offset The position of the MC in the socket
                               interleave list in the SAD rule that maps to
                               this TAD rule. If 1-way interleaved to one MC,
                               base_offset is 0. If 2-way interleaved across
                               two MCs, base_offset is either 0 or 1. 4-way, 0
                               through 3. 8-way, 0 through 7.
                            */
    UINT32 chn_lid : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               ChnLID: channel logical ID. logical channel for
                               channel interleave.
                            */
    UINT32 tad_limit : 26;

                            /* Bits[31:6], Access Type=RW, default=0x00000000*/

                            /*
                               highest address of the range in system address
                               space, 64MB granularity, i.e.
                               TADRANGLIMIT[51:26]. In case of 3 channel
                               interleave, exclude the address not accessed by
                               the system, even if the address is valid in
                               memory.
                            */

  } Bits;
  UINT32 Data;

} TADWAYNESS_1_MC_MAIN_STRUCT;

/* TADWAYNESS_2_MC_MAIN_REG supported on:                                       */
/*      SPRA0 (0x20020ddc)                                                      */
/*      SPRB0 (0x20020ddc)                                                      */
/*      SPRHBM (0x20020ddc)                                                     */
/*      SPRC0 (0x20020ddc)                                                      */
/*      SPRMCC (0x20020ddc)                                                     */
/*      SPRUCC (0x20020ddc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* There are total of 8 TAD ranges 
Note for mirroring configuration:
For 1-way interleave, channel 0-2 mirror pair: target list = <0,2,x,x>, TAD ways = 00
For 1-way interleave, channel 1-3 mirror pair: target list = <1,3,x,x>, TAD ways = 00
For 2-way interleave, 0-2 mirror pair and 1-3 mirror pair: target list = <0,1,2,3>, TAD ways = 01
For 1-way interleave, lockstep + mirroring, target list = <0,2,x,x>, TAD ways = 00
*/


#define TADWAYNESS_2_MC_MAIN_REG 0x07020DDC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_lid : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               TargetLID: target logical ID, a.k.a.,
                               base_offset The position of the MC in the socket
                               interleave list in the SAD rule that maps to
                               this TAD rule. If 1-way interleaved to one MC,
                               base_offset is 0. If 2-way interleaved across
                               two MCs, base_offset is either 0 or 1. 4-way, 0
                               through 3. 8-way, 0 through 7.
                            */
    UINT32 chn_lid : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               ChnLID: channel logical ID. logical channel for
                               channel interleave.
                            */
    UINT32 tad_limit : 26;

                            /* Bits[31:6], Access Type=RW, default=0x00000000*/

                            /*
                               highest address of the range in system address
                               space, 64MB granularity, i.e.
                               TADRANGLIMIT[51:26]. In case of 3 channel
                               interleave, exclude the address not accessed by
                               the system, even if the address is valid in
                               memory.
                            */

  } Bits;
  UINT32 Data;

} TADWAYNESS_2_MC_MAIN_STRUCT;

/* TADWAYNESS_3_MC_MAIN_REG supported on:                                       */
/*      SPRA0 (0x20020de0)                                                      */
/*      SPRB0 (0x20020de0)                                                      */
/*      SPRHBM (0x20020de0)                                                     */
/*      SPRC0 (0x20020de0)                                                      */
/*      SPRMCC (0x20020de0)                                                     */
/*      SPRUCC (0x20020de0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* There are total of 8 TAD ranges 
Note for mirroring configuration:
For 1-way interleave, channel 0-2 mirror pair: target list = <0,2,x,x>, TAD ways = 00
For 1-way interleave, channel 1-3 mirror pair: target list = <1,3,x,x>, TAD ways = 00
For 2-way interleave, 0-2 mirror pair and 1-3 mirror pair: target list = <0,1,2,3>, TAD ways = 01
For 1-way interleave, lockstep + mirroring, target list = <0,2,x,x>, TAD ways = 00
*/


#define TADWAYNESS_3_MC_MAIN_REG 0x07020DE0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_lid : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               TargetLID: target logical ID, a.k.a.,
                               base_offset The position of the MC in the socket
                               interleave list in the SAD rule that maps to
                               this TAD rule. If 1-way interleaved to one MC,
                               base_offset is 0. If 2-way interleaved across
                               two MCs, base_offset is either 0 or 1. 4-way, 0
                               through 3. 8-way, 0 through 7.
                            */
    UINT32 chn_lid : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               ChnLID: channel logical ID. logical channel for
                               channel interleave.
                            */
    UINT32 tad_limit : 26;

                            /* Bits[31:6], Access Type=RW, default=0x00000000*/

                            /*
                               highest address of the range in system address
                               space, 64MB granularity, i.e.
                               TADRANGLIMIT[51:26]. In case of 3 channel
                               interleave, exclude the address not accessed by
                               the system, even if the address is valid in
                               memory.
                            */

  } Bits;
  UINT32 Data;

} TADWAYNESS_3_MC_MAIN_STRUCT;

/* TADWAYNESS_4_MC_MAIN_REG supported on:                                       */
/*      SPRA0 (0x20020de4)                                                      */
/*      SPRB0 (0x20020de4)                                                      */
/*      SPRHBM (0x20020de4)                                                     */
/*      SPRC0 (0x20020de4)                                                      */
/*      SPRMCC (0x20020de4)                                                     */
/*      SPRUCC (0x20020de4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* There are total of 8 TAD ranges 
Note for mirroring configuration:
For 1-way interleave, channel 0-2 mirror pair: target list = <0,2,x,x>, TAD ways = 00
For 1-way interleave, channel 1-3 mirror pair: target list = <1,3,x,x>, TAD ways = 00
For 2-way interleave, 0-2 mirror pair and 1-3 mirror pair: target list = <0,1,2,3>, TAD ways = 01
For 1-way interleave, lockstep + mirroring, target list = <0,2,x,x>, TAD ways = 00
*/


#define TADWAYNESS_4_MC_MAIN_REG 0x07020DE4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_lid : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               TargetLID: target logical ID, a.k.a.,
                               base_offset The position of the MC in the socket
                               interleave list in the SAD rule that maps to
                               this TAD rule. If 1-way interleaved to one MC,
                               base_offset is 0. If 2-way interleaved across
                               two MCs, base_offset is either 0 or 1. 4-way, 0
                               through 3. 8-way, 0 through 7.
                            */
    UINT32 chn_lid : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               ChnLID: channel logical ID. logical channel for
                               channel interleave.
                            */
    UINT32 tad_limit : 26;

                            /* Bits[31:6], Access Type=RW, default=0x00000000*/

                            /*
                               highest address of the range in system address
                               space, 64MB granularity, i.e.
                               TADRANGLIMIT[51:26]. In case of 3 channel
                               interleave, exclude the address not accessed by
                               the system, even if the address is valid in
                               memory.
                            */

  } Bits;
  UINT32 Data;

} TADWAYNESS_4_MC_MAIN_STRUCT;

/* TADWAYNESS_5_MC_MAIN_REG supported on:                                       */
/*      SPRA0 (0x20020de8)                                                      */
/*      SPRB0 (0x20020de8)                                                      */
/*      SPRHBM (0x20020de8)                                                     */
/*      SPRC0 (0x20020de8)                                                      */
/*      SPRMCC (0x20020de8)                                                     */
/*      SPRUCC (0x20020de8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* There are total of 8 TAD ranges 
Note for mirroring configuration:
For 1-way interleave, channel 0-2 mirror pair: target list = <0,2,x,x>, TAD ways = 00
For 1-way interleave, channel 1-3 mirror pair: target list = <1,3,x,x>, TAD ways = 00
For 2-way interleave, 0-2 mirror pair and 1-3 mirror pair: target list = <0,1,2,3>, TAD ways = 01
For 1-way interleave, lockstep + mirroring, target list = <0,2,x,x>, TAD ways = 00
*/


#define TADWAYNESS_5_MC_MAIN_REG 0x07020DE8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_lid : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               TargetLID: target logical ID, a.k.a.,
                               base_offset The position of the MC in the socket
                               interleave list in the SAD rule that maps to
                               this TAD rule. If 1-way interleaved to one MC,
                               base_offset is 0. If 2-way interleaved across
                               two MCs, base_offset is either 0 or 1. 4-way, 0
                               through 3. 8-way, 0 through 7.
                            */
    UINT32 chn_lid : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               ChnLID: channel logical ID. logical channel for
                               channel interleave.
                            */
    UINT32 tad_limit : 26;

                            /* Bits[31:6], Access Type=RW, default=0x00000000*/

                            /*
                               highest address of the range in system address
                               space, 64MB granularity, i.e.
                               TADRANGLIMIT[51:26]. In case of 3 channel
                               interleave, exclude the address not accessed by
                               the system, even if the address is valid in
                               memory.
                            */

  } Bits;
  UINT32 Data;

} TADWAYNESS_5_MC_MAIN_STRUCT;

/* TADWAYNESS_6_MC_MAIN_REG supported on:                                       */
/*      SPRA0 (0x20020dec)                                                      */
/*      SPRB0 (0x20020dec)                                                      */
/*      SPRHBM (0x20020dec)                                                     */
/*      SPRC0 (0x20020dec)                                                      */
/*      SPRMCC (0x20020dec)                                                     */
/*      SPRUCC (0x20020dec)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* There are total of 8 TAD ranges 
Note for mirroring configuration:
For 1-way interleave, channel 0-2 mirror pair: target list = <0,2,x,x>, TAD ways = 00
For 1-way interleave, channel 1-3 mirror pair: target list = <1,3,x,x>, TAD ways = 00
For 2-way interleave, 0-2 mirror pair and 1-3 mirror pair: target list = <0,1,2,3>, TAD ways = 01
For 1-way interleave, lockstep + mirroring, target list = <0,2,x,x>, TAD ways = 00
*/


#define TADWAYNESS_6_MC_MAIN_REG 0x07020DEC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_lid : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               TargetLID: target logical ID, a.k.a.,
                               base_offset The position of the MC in the socket
                               interleave list in the SAD rule that maps to
                               this TAD rule. If 1-way interleaved to one MC,
                               base_offset is 0. If 2-way interleaved across
                               two MCs, base_offset is either 0 or 1. 4-way, 0
                               through 3. 8-way, 0 through 7.
                            */
    UINT32 chn_lid : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               ChnLID: channel logical ID. logical channel for
                               channel interleave.
                            */
    UINT32 tad_limit : 26;

                            /* Bits[31:6], Access Type=RW, default=0x00000000*/

                            /*
                               highest address of the range in system address
                               space, 64MB granularity, i.e.
                               TADRANGLIMIT[51:26]. In case of 3 channel
                               interleave, exclude the address not accessed by
                               the system, even if the address is valid in
                               memory.
                            */

  } Bits;
  UINT32 Data;

} TADWAYNESS_6_MC_MAIN_STRUCT;

/* TADWAYNESS_7_MC_MAIN_REG supported on:                                       */
/*      SPRA0 (0x20020df0)                                                      */
/*      SPRB0 (0x20020df0)                                                      */
/*      SPRHBM (0x20020df0)                                                     */
/*      SPRC0 (0x20020df0)                                                      */
/*      SPRMCC (0x20020df0)                                                     */
/*      SPRUCC (0x20020df0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* There are total of 8 TAD ranges 
Note for mirroring configuration:
For 1-way interleave, channel 0-2 mirror pair: target list = <0,2,x,x>, TAD ways = 00
For 1-way interleave, channel 1-3 mirror pair: target list = <1,3,x,x>, TAD ways = 00
For 2-way interleave, 0-2 mirror pair and 1-3 mirror pair: target list = <0,1,2,3>, TAD ways = 01
For 1-way interleave, lockstep + mirroring, target list = <0,2,x,x>, TAD ways = 00
*/


#define TADWAYNESS_7_MC_MAIN_REG 0x07020DF0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 target_lid : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               TargetLID: target logical ID, a.k.a.,
                               base_offset The position of the MC in the socket
                               interleave list in the SAD rule that maps to
                               this TAD rule. If 1-way interleaved to one MC,
                               base_offset is 0. If 2-way interleaved across
                               two MCs, base_offset is either 0 or 1. 4-way, 0
                               through 3. 8-way, 0 through 7.
                            */
    UINT32 chn_lid : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               ChnLID: channel logical ID. logical channel for
                               channel interleave.
                            */
    UINT32 tad_limit : 26;

                            /* Bits[31:6], Access Type=RW, default=0x00000000*/

                            /*
                               highest address of the range in system address
                               space, 64MB granularity, i.e.
                               TADRANGLIMIT[51:26]. In case of 3 channel
                               interleave, exclude the address not accessed by
                               the system, even if the address is valid in
                               memory.
                            */

  } Bits;
  UINT32 Data;

} TADWAYNESS_7_MC_MAIN_STRUCT;

/* MCMTR2_MC_MAIN_REG supported on:                                             */
/*      SPRA0 (0x20020df4)                                                      */
/*      SPRB0 (0x20020df4)                                                      */
/*      SPRHBM (0x20020df4)                                                     */
/*      SPRC0 (0x20020df4)                                                      */
/*      SPRMCC (0x20020df4)                                                     */
/*      SPRUCC (0x20020df4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* MC Memory Technology Register 2
*/


#define MCMTR2_MC_MAIN_REG 0x07020DF4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 monroe_chn_force_sr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Monroe Technology software channel force
                               SRcontrol. When set, the corresponding channel
                               is ignoring the ForceSRExit. A new transaction
                               arrive at this channel will still cause the SR
                               exit.
                            */
    UINT32 rsvd : 3;

                            /* Bits[3:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 adddc_exclusive2 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is set to designate access to exclusive
                               functionality in ADDDC. Both adddc_exclusive and
                               adddc_exclusive2 need to be set for the
                               exclusive functionality to work.
                            */
    UINT32 rsvd_5 : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCMTR2_MC_MAIN_STRUCT;

/* RCOMP_TIMER_MC_MAIN_REG supported on:                                        */
/*      SPRA0 (0x20020dfc)                                                      */
/*      SPRB0 (0x20020dfc)                                                      */
/*      SPRHBM (0x20020dfc)                                                     */
/*      SPRC0 (0x20020dfc)                                                      */
/*      SPRMCC (0x20020dfc)                                                     */
/*      SPRUCC (0x20020dfc)                                                     */
/* Register default value on SPRA0: 0x0B000000                                  */
/* Register default value on SPRB0: 0x0B000000                                  */
/* Register default value on SPRHBM: 0x0B000000                                 */
/* Register default value on SPRC0: 0x0B000000                                  */
/* Register default value on SPRMCC: 0x0B000000                                 */
/* Register default value on SPRUCC: 0x0B000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Defines the time from IO starting to run RCOMP evaluation until RCOMP results are defenetly ready. This counter is added in order to keep determinism of the process if operated in different modes
The register also indicates that first RCOMP has been done - required by BIOS
*/


#define RCOMP_TIMER_MC_MAIN_REG 0x07020DFC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 count : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /*
                               Unused spare bits. There is no logic behind this
                               field
                            */
    UINT32 first_rcomp_done : 1;

                            /* Bits[16:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               This is a status bit that indicates the first
                               RCOMP has been completed. It is cleared on
                               reset, and set by MC HW when the first RCOMP is
                               completed. Bios should wait until this bit is
                               set before executing any DDR command
                            */
    UINT32 increase_rcomp : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Increase RCOMP quiet time. */
    UINT32 rsvd : 2;

                            /* Bits[19:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 no_mdll_fsm_override : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /* no mdll fsm override. */
    UINT32 ignore_mdll_locked_bit : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* ignore mdll locked bit. */
    UINT32 rcompblock : 8;

                            /* Bits[29:22], Access Type=RW, default=0x0000002C*/

                            /*
                               Count for timer to expire before asserting
                               spid_bus_quiet_time_gnt. Value = global sched
                               blocking time + roundtrip time
                            */
    UINT32 unused : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /* Unused. Intel reserved */
    UINT32 rcomp_in_progress : 1;

                            /* Bits[31:31], Access Type=RW/V, default=0x00000000*/

                            /* rcomp is in progress. */

  } Bits;
  UINT32 Data;

} RCOMP_TIMER_MC_MAIN_STRUCT;

/* IMC_FUSE_DOWNLOAD_SHADOW_MC_MAIN_REG supported on:                           */
/*      SPRA0 (0x20020e00)                                                      */
/*      SPRB0 (0x20020e00)                                                      */
/*      SPRHBM (0x20020e00)                                                     */
/*      SPRC0 (0x20020e00)                                                      */
/*      SPRMCC (0x20020e00)                                                     */
/*      SPRUCC (0x20020e00)                                                     */
/* Register default value on SPRA0: 0x00001000                                  */
/* Register default value on SPRB0: 0x00001000                                  */
/* Register default value on SPRHBM: 0x00001000                                 */
/* Register default value on SPRC0: 0x00001000                                  */
/* Register default value on SPRMCC: 0x00001000                                 */
/* Register default value on SPRUCC: 0x00001000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 19_0_0x0c8
*/


#define IMC_FUSE_DOWNLOAD_SHADOW_MC_MAIN_REG 0x07020E00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fuse_shadow_chn_disable_mc0 : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Fused channel disable control. When set, the
                               corresponding channel is disabled. Fuse download
                               may change the default value after reset de-
                               assertion. Setting to all 1 may disable msg
                               channel.
                            */
    UINT32 fuse_shadow_disable_persistent_cache : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /*
                               Fused channel disable control. When set, the
                               corresponding channel is disabled. Fuse download
                               may change the default value after reset de-
                               assertion. Setting to all 1 may disable msg
                               channel.
                            */
    UINT32 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fuse_shadow_disable_ddr4_caparity : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000000*/

                            /*
                               Force ddr4 command address parity to be zero.
                               This requires DDR4 DRAMs to be initialized to
                               disable parity checking.
                            */
    UINT32 fuse_shadow_disable_2_dpc : 1;

                            /* Bits[4:4], Access Type=RO/V, default=0x00000000*/

                            /*
                               Fused 2 DPC disable control. When set, CS
                               signals for DIMM slot 1 (i.e. slot 0 is not
                               disabled) are disabled. Note: some CS may have
                               multiplexed with address signal to support
                               extended addressing. The CS signal disabling is
                               only applicable to CS not the being multiplexed
                               with address. Fuse download may change the
                               default value after reset de-assertion.
                            */
    UINT32 fuse_shadow_disable_patrol_scrub : 1;

                            /* Bits[5:5], Access Type=RO/V, default=0x00000000*/

                            /*
                               Fused patrol scrub disable control. When set,
                               rank patrol scrub is disabled. Fuse download may
                               change the default value after reset de-
                               assertion.
                            */
    UINT32 fuse_shadow_disable_3ds : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000000*/

                            /*
                               Fused 3DS (3D stacked die) disable control. When
                               set, the C0, C1 and C2 signals will forced to
                               zero. Fuse download may change the default value
                               after reset de-assertion.
                            */
    UINT32 fuse_shadow_disable_16gbit : 1;

                            /* Bits[7:7], Access Type=RO/V, default=0x00000000*/

                            /*
                               Fused 16Gb or higher disable control for DDR4
                               and 24Gb or higher disable for DDR5. When set,
                               the address decode to the corresponding 16Gb or
                               higher (or 24Gb or higher for DDR5) mapping is
                               disabled. Note: LR-DIMMs logical device density
                               is also limited to 16Gb when this fuse is set.
                               Fuse download may change the default value after
                               reset de-assertion.
                            */
    UINT32 fuse_shadow_soc_id : 1;

                            /* Bits[8:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               We're using this bit to know if it is KNH or
                               ICX-SP. 1 = KNH. 0 = ICX-SP.
                            */
    UINT32 fuse_shadow_dis_asyncsr_adr : 1;

                            /* Bits[9:9], Access Type=RO/V, default=0x00000000*/

                            /*
                               Fused ADR disable control. When set, memory
                               ignores ADR event. Fuse download may change the
                               default value after reset de-assertion.
                            */
    UINT32 fuse_shadow_disable_ecc : 1;

                            /* Bits[10:10], Access Type=RO/V, default=0x00000000*/

                            /*
                               Fused ECC disable control. When set, ECC is
                               disabled. Fuse download may change the default
                               value after reset de-assertion.
                            */
    UINT32 fuse_shadow_disable_dir : 1;

                            /* Bits[11:11], Access Type=RO/V, default=0x00000000*/

                            /*
                               Fused DIR disable control. When set, directory
                               is disabled. Fuse download may change the
                               default value after reset de-assertion.
                            */
    UINT32 fuse_shadow_mc_mca_recovery : 1;

                            /* Bits[12:12], Access Type=RO/V, default=0x00000001*/

                            /*
                               Fuse for mc_mca_recovery. Blown to 0 for EP,
                               HEDT, ... etc, i.e. Means recovery from
                               uncorrectable Patrol scrub errors is not
                               supported. In addition, iMC hardware logs
                               uncorrectable PS errors in the MCA bank with
                               MCi_STATUS.PCC when set. When the fuse is blown
                               to 1 in in EX only, this means that when
                               poisoning is enabled, recovery from
                               uncorrectable patrol scrub errors is supported.
                               MC hardware will log uncorrectable Patrol scrub
                               errors in the MCA bank with a recoverable error
                               signature. Please refer to MCA HAS for further
                               details.
                            */
    UINT32 fuse_shadow_disable_rdimm : 1;

                            /* Bits[13:13], Access Type=RO/V, default=0x00000000*/

                            /*
                               Fused RDIMM disable control. When set, RDIMM
                               support is disabled by forcing the upper 5 bits
                               of the 13b T_STAB register to be zeros, i.e. the
                               T_STAB can only have max of 255 DCLK delay after
                               clock-stopped power down mode which is in
                               sufficient for normal RDIMM clock stablization;
                               hence, users will not be able to support self-
                               refresh with clock off mode (S3, pkg C6) if the
                               RDIMM disable fuse is blown to one. Fuse
                               download may change the default value after
                               reset de-assertion.
                            */
    UINT32 fuse_shadow_disable_adddc_high_ras : 1;

                            /* Bits[14:14], Access Type=RO/V, default=0x00000000*/

                            /*
                               If 1, disable the high RAS version of adddc (use
                               standard version of RAS for adddc).
                            */
    UINT32 fuse_shadow_disable_plus1_corr : 1;

                            /* Bits[15:15], Access Type=RO/V, default=0x00000000*/

                            /*
                               If 1, disable ECC correction for SDDC+1 or
                               ADDDC+1 mode; any error in +1 mode will be
                               uncorrectable.
                            */
    UINT32 fuse_shadow_disable_sparing : 1;

                            /* Bits[16:16], Access Type=RO/V, default=0x00000000*/

                            /*
                               Fused sparing disable control. When set, all
                               sparing modes are disabled. Fuse download may
                               change the default value after reset de-
                               assertion.
                            */
    UINT32 fuse_shadow_disable_adddc : 1;

                            /* Bits[17:17], Access Type=RO/V, default=0x00000000*/

                            /*
                               Fused ADDDC disable control. When set, all ADDDC
                               regions are disabled. Fuse download may change
                               the default value after reset de-assertion.
                            */
    UINT32 fuse_shadow_rfu_2 : 2;

                            /* Bits[19:18], Access Type=RO/V, default=0x00000000*/

                            /* Reserved for future use. */
    UINT32 fuse_shadow_disable_sddc_x4 : 1;

                            /* Bits[20:20], Access Type=RO/V, default=0x00000000*/

                            /*
                               Single device data correction fuse download.
                               When set, will disable 4-bit device SDDC.
                            */
    UINT32 fuse_shadow_disable_sddc_x8 : 1;

                            /* Bits[21:21], Access Type=RO/V, default=0x00000000*/

                            /*
                               Single device data correction fuse download.
                               When set, will disable 8-bit device SDDC.
                            */
    UINT32 fuse_shadow_disable_sddc_x4_plus1 : 1;

                            /* Bits[22:22], Access Type=RO/V, default=0x00000000*/

                            /*
                               Single device data correction fuse download.
                               When set, will disable SDDC plus one for x4 SDDC
                               mode.
                            */
    UINT32 fuse_shadow_disable_sddc_x8_plus1 : 1;

                            /* Bits[23:23], Access Type=RO/V, default=0x00000000*/

                            /*
                               Single device data correction fuse download.
                               When set, will disable SDDC plus one for x8 SDDC
                               mode.
                            */
    UINT32 fuse_shadow_disable_bist : 1;

                            /* Bits[24:24], Access Type=RO/V, default=0x00000000*/

                            /* Disable the BIST feature. */
    UINT32 fuse_shadow_disable_pcls : 1;

                            /* Bits[25:25], Access Type=RO/V, default=0x00000000*/

                            /* Disable PCLS (Partial Cache Line Sparing) */
    UINT32 fuse_shadow_disable_mee : 1;

                            /* Bits[26:26], Access Type=RO/V, default=0x00000000*/

                            /*
                               There was a recent change and now this reg does
                               nothing.
                            */
    UINT32 fuse_shadow_disable_2lm : 1;

                            /* Bits[27:27], Access Type=RO/V, default=0x00000000*/

                            /* Disable two-level memory */
    UINT32 fuse_shadow_disable_ddrt : 1;

                            /* Bits[28:28], Access Type=RO/V, default=0x00000000*/

                            /*
                               Disable the use of DDRT devices, once the fuse
                               is blown to one, iMC will not issue any DDRT
                               commands or responding DDRT bus request.
                               Internally, any request targeting DDRT port is
                               treated as programming error. System may hang.
                            */
    UINT32 fuse_shadow_disable_cr_pmem : 1;

                            /* Bits[29:29], Access Type=RO/V, default=0x00000000*/

                            /*
                               Disable use of Persistent Memory with Crystal
                               Ridge.
                            */
    UINT32 fuse_shadow_disable_cr_pmem_wt : 1;

                            /* Bits[30:30], Access Type=RO/V, default=0x00000000*/

                            /*
                               Disable use of Persistent Memory Write Through
                               with Crystal Ridge.
                            */
    UINT32 fuse_shadow_disable_mcmirrormode : 1;

                            /* Bits[31:31], Access Type=RO/V, default=0x00000000*/

                            /* Disable use of mirroring. */

  } Bits;
  UINT32 Data;

} IMC_FUSE_DOWNLOAD_SHADOW_MC_MAIN_STRUCT;

/* IMC_FUSE_DOWNLOAD2_SHADOW_MC_MAIN_REG supported on:                          */
/*      SPRA0 (0x20020e04)                                                      */
/*      SPRB0 (0x20020e04)                                                      */
/*      SPRHBM (0x20020e04)                                                     */
/*      SPRC0 (0x20020e04)                                                      */
/*      SPRMCC (0x20020e04)                                                     */
/*      SPRUCC (0x20020e04)                                                     */
/* Register default value on SPRA0: 0x555F0FFF                                  */
/* Register default value on SPRB0: 0x555F0FFF                                  */
/* Register default value on SPRHBM: 0x555F0FFF                                 */
/* Register default value on SPRC0: 0x555F0FFF                                  */
/* Register default value on SPRMCC: 0x555F0FFF                                 */
/* Register default value on SPRUCC: 0x555F0FFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 19_0_0x0cc
*/


#define IMC_FUSE_DOWNLOAD2_SHADOW_MC_MAIN_REG 0x07020E04

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fuse_shadow_spare_fuse_0 : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000001*/

                            /* Reserved for future use. */
    UINT32 fuse_shadow_spare_fuse_1 : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000001*/

                            /* Reserved for future use. */
    UINT32 fuse_shadow_spare_fuse_2 : 1;

                            /* Bits[2:2], Access Type=RO/V, default=0x00000001*/

                            /* Reserved for future use. */
    UINT32 fuse_shadow_spare_fuse_3 : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000001*/

                            /* Reserved for future use. */
    UINT32 fuse_shadow_spare_fuse_4 : 1;

                            /* Bits[4:4], Access Type=RO/V, default=0x00000001*/

                            /* Reserved for future use. */
    UINT32 fuse_shadow_spare_fuse_5 : 1;

                            /* Bits[5:5], Access Type=RO/V, default=0x00000001*/

                            /* Reserved for future use. */
    UINT32 fuse_shadow_spare_fuse_6 : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000001*/

                            /* Reserved for future use. */
    UINT32 fuse_shadow_spare_fuse_7 : 1;

                            /* Bits[7:7], Access Type=RO/V, default=0x00000001*/

                            /* Reserved for future use. */
    UINT32 fuse_shadow_spare_fuse_8 : 1;

                            /* Bits[8:8], Access Type=RO/V, default=0x00000001*/

                            /* Reserved for future use. */
    UINT32 fuse_shadow_spare_fuse_9 : 1;

                            /* Bits[9:9], Access Type=RO/V, default=0x00000001*/

                            /* Reserved for future use. */
    UINT32 fuse_shadow_spare_fuse_10 : 1;

                            /* Bits[10:10], Access Type=RO/V, default=0x00000001*/

                            /* Reserved for future use. */
    UINT32 fuse_shadow_spare_fuse_11 : 1;

                            /* Bits[11:11], Access Type=RO/V, default=0x00000001*/

                            /* Reserved for future use. */
    UINT32 fuse_shadow_speed : 4;

                            /* Bits[15:12], Access Type=RO/V, default=0x00000000*/

                            /* DDR/HBM speed. */
    UINT32 fuse_shadow_temp_fourxref : 8;

                            /* Bits[23:16], Access Type=RO/V, default=0x0000005F*/

                            /*
                               This fuse csr stores the temperature threshold
                               for the HBM 4x refresh rate. It gets set by the
                               fuse, and then BIOS reads this CSR in order to
                               know what to write to the mc_thr CSR.
                            */
    UINT32 fuse_shadow_temp_twoxref : 8;

                            /* Bits[31:24], Access Type=RO/V, default=0x00000055*/

                            /*
                               This fuse csr stores the temperature threshold
                               for the HBM 2x refresh rate. It gets set by the
                               fuse, and then BIOS reads this CSR in order to
                               know what to write to the mc_thr CSR.
                            */

  } Bits;
  UINT32 Data;

} IMC_FUSE_DOWNLOAD2_SHADOW_MC_MAIN_STRUCT;

/* MCDECVISACFG_MC_MAIN_REG supported on:                                       */
/*      SPRA0 (0x20020e0c)                                                      */
/*      SPRB0 (0x20020e0c)                                                      */
/*      SPRHBM (0x20020e0c)                                                     */
/*      SPRC0 (0x20020e0c)                                                      */
/*      SPRMCC (0x20020e0c)                                                     */
/*      SPRUCC (0x20020e0c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* VISA configuration register for mc_dec
*/


#define MCDECVISACFG_MC_MAIN_REG 0x07020E0C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lane0sel : 6;

                            /* Bits[5:0], Access Type=RW/P/L, default=0x00000000*/

                            /* lane 0 select */
    UINT32 lane1sel : 6;

                            /* Bits[11:6], Access Type=RW/P/L, default=0x00000000*/

                            /* lane 1 select */
    UINT32 lane2sel : 6;

                            /* Bits[17:12], Access Type=RW/P/L, default=0x00000000*/

                            /* lane 2 select */
    UINT32 lane3sel : 6;

                            /* Bits[23:18], Access Type=RW/P/L, default=0x00000000*/

                            /* lane 3 select */
    UINT32 clken : 1;

                            /* Bits[24:24], Access Type=RW/P/L, default=0x00000000*/

                            /* clock enable for debug mux */
    UINT32 rsvd : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCDECVISACFG_MC_MAIN_STRUCT;

/* MCMAIN_CHKN_BITS_MC_MAIN_REG supported on:                                   */
/*      SPRA0 (0x20020e14)                                                      */
/*      SPRB0 (0x20020e14)                                                      */
/*      SPRHBM (0x20020e14)                                                     */
/*      SPRC0 (0x20020e14)                                                      */
/*      SPRMCC (0x20020e14)                                                     */
/*      SPRUCC (0x20020e14)                                                     */
/* Register default value on SPRA0: 0x00000210                                  */
/* Register default value on SPRB0: 0x00000210                                  */
/* Register default value on SPRHBM: 0x00000210                                 */
/* Register default value on SPRC0: 0x00000210                                  */
/* Register default value on SPRMCC: 0x00000210                                 */
/* Register default value on SPRUCC: 0x00000210                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Chicken bit register in MCMAIN.
*/


#define MCMAIN_CHKN_BITS_MC_MAIN_REG 0x07020E14

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pat_skip_non_mirr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, non-mirrored region is only
                               scrubbed once when partial mirroring is enabled.
                               Should only be set to 1 if partial mirroring is
                               used.
                            */
    UINT32 rsvd_chkn_b1 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Disable signalling of SMI from patrol scrub
                               engine. Patrol scrub is able to signal SMI when
                               it stops on error or reaches end of address
                               range. See SCRUBCTL for details.
                            */
    UINT32 dis_spr_err_log : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Disable spare error logging */
    UINT32 frc_spr_strt : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /* Force spare start */
    UINT32 frc_spr_end : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /* Keep patrol address to continue after PkgC */
    UINT32 dis_spr_rir_updt : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /* Disable spare RIR update */
    UINT32 dis_ptrl_rty : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /* Disable patrol retry */
    UINT32 unused1 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /* Disable patrol error logging */
    UINT32 frc_sngl_ptrl : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* Reserved - unused. */
    UINT32 rsvd_chkn_b9 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000001*/

                            /* Reserved */
    UINT32 frc_sngl_mtst : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* Reserved - unused. */
    UINT32 dis_rcomp : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /* Disable rcomp */
    UINT32 unused : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /* unused */
    UINT32 dis_lcl_ck_gate_mcmain : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /* Disable local clock gating - mcmains */
    UINT32 increase_rcomp : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /* Increase RCOMP quiet time */
    UINT32 dis_msg_ch_ck_gate_mc : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /* Disable bug fix for HSX be4768490 when set to 1 */
    UINT32 dis_actual_msg_ch_ck_gate_mc : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /* Disable message channel clock gating */
    UINT32 dis_dbg_bgf_push : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /* Reserved - unused. */
    UINT32 unused2 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /* Allow patrol to stop at end of rank */
    UINT32 bgftune_lock : 1;

                            /* Bits[19:19], Access Type=RW/P, default=0x00000000*/

                            /* Reserved - unused. */
    UINT32 freq_chng_flow : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Bug fix for HSD b3123628: When set, tells MC
                               that this is a frequency_change flow. When the
                               bit is set, following changes take place 1. When
                               PmRsBlock is asserted, we block message channel
                               to M2M 2. PkgC Empty and FullEmpty will ignore
                               msgChEmpty when this bit is set
                            */
    UINT32 dis_leak_cntr : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* Disable leaky bucket counter in mc_dec */
    UINT32 dis_pma_blockack_hold : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, disables the hold logic on the
                               BlockAck going to the MC PMA, that keeps the
                               BlockAck asserted once set, until the BlockReq
                               de-asserts
                            */
    UINT32 rsvd_chkn_b24_b23 : 2;

                            /* Bits[24:23], Access Type=RW, default=0x00000000*/

                            /* Reserved */
    UINT32 frc_not_occ_0 : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               MC PMA interface override for channel when not
                               occupied. When set to 1, MCActive will de-assert
                               and InSRD will assert.
                            */
    UINT32 rsvd : 3;

                            /* Bits[28:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_ptrl_psn : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Disable patrol scrub poison line on finding
                               uncorr error
                            */
    UINT32 dis_asyncsr_habackpress : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, the MC will not backpressure the
                               M2M during an ADR sequence. When set to 0 and
                               the MC receives the AsyncSR signal from the PMA,
                               the MC will immediately backpressure the M2M,
                               stopping any new transactions from being sent to
                               the MC.
                            */
    UINT32 defeature_10 : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, rcomp request is never blocked
                               even if ZQCal is on-going.
                            */

  } Bits;
  UINT32 Data;

} MCMAIN_CHKN_BITS_MC_MAIN_STRUCT;

/* MCMAIN_CHKN_BITS2_MC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20020e18)                                                      */
/*      SPRB0 (0x20020e18)                                                      */
/*      SPRHBM (0x20020e18)                                                     */
/*      SPRC0 (0x20020e18)                                                      */
/*      SPRMCC (0x20020e18)                                                     */
/*      SPRUCC (0x20020e18)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Chicken bit register in MCMAIN.
*/


#define MCMAIN_CHKN_BITS2_MC_MAIN_REG 0x07020E18

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd_0 : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dis_pat_pkgc : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               When set 1, PkgCEmpty should check RT empty
                               including patrol transaction
                            */
    UINT32 dis_spr_ddrt_gnt_blk : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               When set 1, DDRT gnt is not blocked during
                               sparing before the first spare is issued. This
                               block is done to avoid DDRT read when the round
                               trip delay changes due to sparing (device
                               substitution enabled). Current RDB already stop
                               read from going through datapath when the delay
                               changes so this blocking is likely not needed
                               anymore.
                            */
    UINT32 evict_addr_par_inj_err : 2;

                            /* Bits[6:5], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Controls whether to inject a parity error on a
                               NM eviction in 2LM mode: 0 - no injection 1 -
                               always inject errors 2 - reserved 3 - reserved
                            */
    UINT32 defeature : 25;

                            /* Bits[31:7], Access Type=RW, default=0x00000000*/

                            /*
                               Chicken bits: Bit 7 : disable moving back to
                               idle in TXN_DONE state when patrol is disabled;
                               Bit 8 : disable fix for SKX b311323 Bit 9 : Bit
                               10 : disable fix for SKX b311569 Bit 11 : DDRT
                               PC6 clock stop will not de-assert PMA Queue Full
                               Empty if error FSM comes on. Bit 12 : DDRT PC6
                               clock stop will not de-assert PMA Pkgc Empty if
                               error FSM comes on. Bit 13 : DDRT PC6 clock stop
                               will not de-assert PMA Queue Full Empty if DDRT
                               RPQ is not empty. Bit 14 : DDRT PC6 clock stop
                               will not de-assert PMA Pkgc Empty if DDRT RPQ is
                               not empty. Bit 15 : Set to 1 to disable check
                               for SB empty during sparing flush. Bit 16: Clear
                               end signal for eADR done. Bit 30:17: reserved
                               and keep at 0 Bit 31: Disable check for retry
                               FSM idle during spare flush.
                            */

  } Bits;
  UINT32 Data;

} MCMAIN_CHKN_BITS2_MC_MAIN_STRUCT;

/* SPAREADDRESSLO_MC_MAIN_REG supported on:                                     */
/*      SPRA0 (0x20020e24)                                                      */
/*      SPRB0 (0x20020e24)                                                      */
/*      SPRHBM (0x20020e24)                                                     */
/*      SPRC0 (0x20020e24)                                                      */
/*      SPRMCC (0x20020e24)                                                     */
/*      SPRUCC (0x20020e24)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* Always points to the lower address for the next sparing operation. This register will not be affected by the M2M access to the spare source rank during the M2M window.

*/


#define SPAREADDRESSLO_MC_MAIN_REG 0x07020E24

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rankadd : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Always points to the lower address for the next
                               sparing operation. This register will not be
                               affected by the M2M access to the spare source
                               rank during the M2M window.
                            */

  } Bits;
  UINT32 Data;

} SPAREADDRESSLO_MC_MAIN_STRUCT;

/* SCRUBCTL_MC_MAIN_REG supported on:                                           */
/*      SPRA0 (0x20020e28)                                                      */
/*      SPRB0 (0x20020e28)                                                      */
/*      SPRHBM (0x20020e28)                                                     */
/*      SPRC0 (0x20020e28)                                                      */
/*      SPRMCC (0x20020e28)                                                     */
/*      SPRUCC (0x20020e28)                                                     */
/* Register default value on SPRA0: 0x005E0000                                  */
/* Register default value on SPRB0: 0x005E0000                                  */
/* Register default value on SPRHBM: 0x005E0000                                 */
/* Register default value on SPRC0: 0x005E0000                                  */
/* Register default value on SPRMCC: 0x005E0000                                 */
/* Register default value on SPRUCC: 0x005E0000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This register contains the Scrub control parameters and status.
*/


#define SCRUBCTL_MC_MAIN_REG 0x07020E28

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 17;

                            /* Bits[16:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd_17 : 5;

                            /* Bits[21:17], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 stop_on_rank : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000001*/

                            /* Reserved; keep this bit at 0. */
    UINT32 dis_ptrl_err_log : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /* Reserved; keep this bit at 0. */
    UINT32 startscrub : 1;

                            /* Bits[24:24], Access Type=RW/V, default=0x00000000*/

                            /*
                               When Set, the Patrol scrub engine will start
                               from the address in the scrub address registers.
                               Once the scrub is issued this bit is reset. For
                               rank address based patrol scrub (when
                               scrubaddresshi.ptl_sa_mode = 0), this bit should
                               be set to 1 when scrub is enabled.
                            */
    UINT32 issueonce : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               When Set, the patrol scrub engine will issue the
                               address in the scrub address registers only once
                               and stop. Software is responsible to turn off
                               periodic patrol before issuing patrol once. The
                               patrol interval in PMA should be set to 0 in
                               issue once mode. No cross product of patrol once
                               with PkgC is allowed.
                            */
    UINT32 scrubissued : 1;

                            /* Bits[26:26], Access Type=RW/V, default=0x00000000*/

                            /*
                               When Set, the scrub address registers contain
                               the last scrub address issued
                            */
    UINT32 ptl_stopped : 1;

                            /* Bits[27:27], Access Type=RW/V, default=0x00000000*/

                            /* Reserved */
    UINT32 stop_on_err : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /* Reserved; keep this bit at 0. */
    UINT32 ptl_cmpl : 1;

                            /* Bits[29:29], Access Type=RW/V, default=0x00000000*/

                            /*
                               When stop_on_cmpl is enabled, patrol will stop
                               at the end of the address range and set this
                               bit. Patrol will resume from beginning of
                               address range when this bit or stop_on_cmpl is
                               cleared by BIOS and patrol scrub is still
                               enabled by scrub_en.
                            */
    UINT32 stop_on_cmpl : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Stop patrol scrub at end of memory range. This
                               mode is meant to be used as part of memory
                               migration flow. SMI is signalled by default.
                            */
    UINT32 scrub_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /* Scrub Enable when set. */

  } Bits;
  UINT32 Data;

} SCRUBCTL_MC_MAIN_STRUCT;

/* SCRUBADDRESSLO_MC_MAIN_REG supported on:                                     */
/*      SPRA0 (0x20020e2c)                                                      */
/*      SPRB0 (0x20020e2c)                                                      */
/*      SPRHBM (0x20020e2c)                                                     */
/*      SPRC0 (0x20020e2c)                                                      */
/*      SPRMCC (0x20020e2c)                                                     */
/*      SPRUCC (0x20020e2c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This register contains part of the address of the last patrol scrub request issued. When running memtest, the failing address is logged in this register on memtest errors. Software can write the next address to be scrubbed into this register. The STARTSCRUB bit will then trigger the specified address to be scrubbed. Patrol scrubs must be disabled to reliably write this register.
*/


#define SCRUBADDRESSLO_MC_MAIN_REG 0x07020E2C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rankadd : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Contains the rank address or bits 37:6 of the
                               system address of the last scrub issued. Can be
                               written to specify the next scrub address with
                               STARTSCRUB. Base system address in
                               scrubaddress2lo/hi also need to be programmed in
                               system address mode for the programmed address
                               to work properly. In system address mode,
                               scrubaddresshi.ptl_sa_mode must be cleared to 0
                               and then set back to 1 after STARTSCRUB is set
                               for address written to take effect.
                               RESTRICTIONS: Patrol Scrubs must be disabled
                               when writing to this field. Bit 0 of this
                               register maps to bit 6 of address. When target
                               or channel XOR is enabled, address in this
                               register wouldn't / shouldn't be the true system
                               address, the system address with XOR applied.
                               Error logging on patrol scrub error will reflect
                               the true system address though.
                            */

  } Bits;
  UINT32 Data;

} SCRUBADDRESSLO_MC_MAIN_STRUCT;

/* SCRUBADDRESSHI_MC_MAIN_REG supported on:                                     */
/*      SPRA0 (0x20020e30)                                                      */
/*      SPRB0 (0x20020e30)                                                      */
/*      SPRHBM (0x20020e30)                                                     */
/*      SPRC0 (0x20020e30)                                                      */
/*      SPRMCC (0x20020e30)                                                     */
/*      SPRUCC (0x20020e30)                                                     */
/* Register default value on SPRA0: 0x80008000                                  */
/* Register default value on SPRB0: 0x80008000                                  */
/* Register default value on SPRHBM: 0x80008000                                 */
/* Register default value on SPRC0: 0x80008000                                  */
/* Register default value on SPRMCC: 0x80008000                                 */
/* Register default value on SPRUCC: 0x80008000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This register pair contains part of the address of the last patrol scrub request issued. Software can write the next address into this register. Scrubbing must be disabled to reliably read and write this register. The STARTSCRUB bit will then trigger the specified address to be scrubbed.
*/


#define SCRUBADDRESSHI_MC_MAIN_REG 0x07020E30

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rankaddhi : 15;

                            /* Bits[14:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Contains bits 52:38 of the system address of the
                               last scrub issued. Can be written to specify the
                               next scrub address with STARTSCRUB. Base system
                               address in scrubaddress2lo/hi also need to be
                               programmed in system address mode for the
                               programmed address to work properly.
                               scrubaddresshi.ptl_sa_mode must be cleared to 0
                               and then set back to 1 after STARTSCRUB is set
                               for address written to take effect.
                               RESTRICTIONS: Patrol Scrubs must be disabled
                               when writing to this field. Only used system
                               address patrol mode.
                            */
    UINT32 mirr_pri : 1;

                            /* Bits[15:15], Access Type=RW/V, default=0x00000001*/

                            /*
                               Contains the primary indication when mirroring
                               is enabled. Can be written to specify the next
                               scrub address. RESTRICTION: Patrol Scrubs must
                               be disabled when writing to this field. Only
                               used for system address patrol mode.
                            */
    UINT32 rank : 3;

                            /* Bits[18:16], Access Type=RW/V, default=0x00000000*/

                            /*
                               Contains the physical rank ID of the last scrub
                               issued. Can be written to specify the next scrub
                               address with STARTSCRUB. RESTRICTION: Patrol
                               Scrubs must be disabled when writing to this
                               field. Only used for legacy (non system address)
                               patrol mode.
                            */
    UINT32 chnl : 3;

                            /* Bits[21:19], Access Type=RW/V, default=0x00000000*/

                            /*
                               Can be written to specify the next scrub address
                               with STARTSCRUB. This register is updated with
                               channel address of the last scrub address
                               issued. RESTRICTIONS: Patrol Scrubs must be
                               disabled when writing to this field. Only used
                               for legacy (non system address) patrol mode.
                            */
    UINT32 tad_rule : 3;

                            /* Bits[24:22], Access Type=RW/V, default=0x00000000*/

                            /*
                               Contains the TAD rule of the last scrub issued.
                               Can be written to specify the next scrub address
                               with STARTSCRUB. scrubaddresshi.ptl_sa_mode must
                               be cleared to 0 and then set back to 1 after
                               STARTSCRUB is set for address written to take
                               effect. RESTRICTION: Patrol Scrubs must be
                               disabled when writing to this field. Only used
                               system address patrol mode.
                            */
    UINT32 minimum_tad_rule : 3;

                            /* Bits[27:25], Access Type=RW, default=0x00000000*/

                            /*
                               First TAD rule used for patrol address
                               generation. Set to 0 to begin generating system
                               addresses for patrol at the lowest address
                               mapped to the MC.
                            */
    UINT32 maximum_tad_rule : 3;

                            /* Bits[30:28], Access Type=RW, default=0x00000000*/

                            /*
                               Last TAD rule used for patrol address
                               generation. Set to the maximum valid TAD rule
                               number used on the MC to generate system
                               addresses for patrol up to the maximum address
                               mapped to the MC.
                            */
    UINT32 ptl_sa_mode : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000001*/

                            /*
                               Patrol runs in system address generation mode if
                               patrol is enabled. Keep this bit at 1 for proper
                               operation.
                            */

  } Bits;
  UINT32 Data;

} SCRUBADDRESSHI_MC_MAIN_STRUCT;


/* RASENABLES_MC_MAIN_REG supported on:                                         */
/*      SPRA0 (0x20020e3c)                                                      */
/*      SPRB0 (0x20020e3c)                                                      */
/*      SPRHBM (0x20020e3c)                                                     */
/*      SPRC0 (0x20020e3c)                                                      */
/*      SPRMCC (0x20020e3c)                                                     */
/*      SPRUCC (0x20020e3c)                                                     */
/* Register default value on SPRA0: 0x00000010                                  */
/* Register default value on SPRB0: 0x00000010                                  */
/* Register default value on SPRHBM: 0x00000010                                 */
/* Register default value on SPRC0: 0x00000010                                  */
/* Register default value on SPRMCC: 0x00000010                                 */
/* Register default value on SPRUCC: 0x00000010                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* RAS Enables Register
*/


#define RASENABLES_MC_MAIN_REG 0x07020E3C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mirroren : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Mirror mode enable. The channel mapping must be
                               set up before this bit will have an effect on
                               IMC operation. This changes the error policy.
                            */
    UINT32 rsvd : 3;

                            /* Bits[3:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ch0_mirror : 2;

                            /* Bits[5:4], Access Type=RW, default=0x00000001*/

                            /*
                               The secondary channel number when the primary
                               channel is channel 0 for mirroring. This is used
                               by patrol logic.
                            */
    UINT32 ch1_mirror : 2;

                            /* Bits[7:6], Access Type=RW, default=0x00000000*/

                            /*
                               The secondary channel number when the primary
                               channel is channel 1 for mirroring. This is used
                               by patrol logic.
                            */
    UINT32 ch2_mirror : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000000*/

                            /*
                               The secondary channel number when the primary
                               channel is channel 2 for mirroring. This is used
                               by patrol logic.
                            */
    UINT32 rsvd_10 : 22;

                            /* Bits[31:10], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RASENABLES_MC_MAIN_STRUCT;

/* SMISPARECTL_MC_MAIN_REG supported on:                                        */
/*      SPRA0 (0x20020e40)                                                      */
/*      SPRB0 (0x20020e40)                                                      */
/*      SPRHBM (0x20020e40)                                                     */
/*      SPRC0 (0x20020e40)                                                      */
/*      SPRMCC (0x20020e40)                                                     */
/*      SPRUCC (0x20020e40)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* System Management Interrupt and Spare control register.
*/


#define SMISPARECTL_MC_MAIN_REG 0x07020E40

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 15;

                            /* Bits[14:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 intrpt_sel_smi : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               SMI enable. Set to enable SMi signaling. Clear
                               to disable SMI signaling.
                            */
    UINT32 intrpt_sel_cmci : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               (CMCI used as a proxy for NMI signaling). Set to
                               enable NMI signaling. Clear to disable NMI
                               signaling. If both NMI and SMI enable bits are
                               set then only SMI is sent.
                            */
    UINT32 intrpt_sel_pin : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Enable pin signaling. When set the interrupt is
                               signaled via the err[0] pin to get the attention
                               of a BMC.
                            */
    UINT32 rsvd_18 : 14;

                            /* Bits[31:18], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SMISPARECTL_MC_MAIN_STRUCT;

/* LEAKY_BUCKET_CFG_MC_MAIN_REG supported on:                                   */
/*      SPRA0 (0x20020e44)                                                      */
/*      SPRB0 (0x20020e44)                                                      */
/*      SPRHBM (0x20020e44)                                                     */
/*      SPRC0 (0x20020e44)                                                      */
/*      SPRMCC (0x20020e44)                                                     */
/*      SPRUCC (0x20020e44)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 19_1_0x0b8
*/


#define LEAKY_BUCKET_CFG_MC_MAIN_REG 0x07020E44

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 leaky_bkt_cfg_lo : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               This is the lower order bit select mask of the
                               two hot encoding threshold. The value of this
                               field specify the bit position of the mask: 00h:
                               reserved 01h: LEAKY_BUCKET_CNTR_LO bit 1, i.e.
                               bit 12 of the full 53b counter ... 1Fh:
                               LEAKY_BUCKET_CNTR_LO bit 31, i.e. bit 42 of the
                               full 53b counter 20h: LEAKY_BUCKET_CNTR_HI bit
                               0, i.e. bit 43 of the full 53b counter ... 29h:
                               LEAKY_BUCKET_CNTR_HI bit 9, i.e. bit 52 of the
                               full 53b counter 2Ah - 3F: reserved When both
                               counter bits selected by the LEAKY_BKT_CFG_HI
                               and LEAKY_BKT_CFG_LO are set, the 53b leaky
                               bucket counter will be reset and the logic will
                               generate a LEAK pulse to decrement the
                               correctable error counter by 1. MRC BIOS must
                               program this register to any non-zero value
                               before switching to NORMAL mode.
                            */
    UINT32 leaky_bkt_cfg_hi : 6;

                            /* Bits[11:6], Access Type=RW, default=0x00000000*/

                            /*
                               This is the higher order bit select mask of the
                               two hot encoding threshold. The value of this
                               field specify the bit position of the mask: 00h:
                               reserved 01h: LEAKY_BUCKET_CNTR_LO bit 1, i.e.
                               bit 12 of the full 53b counter ... 1Fh:
                               LEAKY_BUCKET_CNTR_LO bit 31, i.e. bit 42 of the
                               full 53b counter 20h: LEAKY_BUCKET_CNTR_HI bit
                               0, i.e. bit 43 of the full 53b counter ... 29h:
                               LEAKY_BUCKET_CNTR_HI bit 9, i.e. bit 52 of the
                               full 53b counter 2Ah - 3F: reserved When both
                               counter bits selected by the LEAKY_BKT_CFG_HI
                               and LEAKY_BKT_CFG_LO are set, the 53b leaky
                               bucket counter will be reset and the logic will
                               generate a LEAK pulse to decrement the
                               correctable error counter by 1. MRC BIOS must
                               program this register to any non-zero value
                               before switching to NORMAL mode.
                            */
    UINT32 rsvd : 20;

                            /* Bits[31:12], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LEAKY_BUCKET_CFG_MC_MAIN_STRUCT;

/* LEAKY_BUCKET_CNTR_LO_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020e48)                                                      */
/*      SPRB0 (0x20020e48)                                                      */
/*      SPRHBM (0x20020e48)                                                     */
/*      SPRC0 (0x20020e48)                                                      */
/*      SPRMCC (0x20020e48)                                                     */
/*      SPRUCC (0x20020e48)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 19_1_0x0c0
*/


#define LEAKY_BUCKET_CNTR_LO_MC_MAIN_REG 0x07020E48

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 leaky_bkt_cntr_lo : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This is the lower half of the leaky bucket
                               counter. The full counter is actually a 53b DCLK
                               counter. There is a least significant 11b of the
                               53b counter is not captured in CSR. The carry
                               strobe from the not-shown least significant 11b
                               counter will trigger this 42b counter pair to
                               count. The 42b counter-pair is compared with the
                               two-hot encoding threshold specified by the
                               LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO
                               pair. When the counter bits specified by the
                               LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO are
                               both set, the 53b counter is reset and the leaky
                               bucket logic will generate a LEAK strobe last
                               for 1 DCLK.
                            */

  } Bits;
  UINT32 Data;

} LEAKY_BUCKET_CNTR_LO_MC_MAIN_STRUCT;

/* LEAKY_BUCKET_CNTR_HI_MC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20020e4c)                                                      */
/*      SPRB0 (0x20020e4c)                                                      */
/*      SPRHBM (0x20020e4c)                                                     */
/*      SPRC0 (0x20020e4c)                                                      */
/*      SPRMCC (0x20020e4c)                                                     */
/*      SPRUCC (0x20020e4c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* generated by critter 19_1_0x0c4
*/


#define LEAKY_BUCKET_CNTR_HI_MC_MAIN_REG 0x07020E4C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 leaky_bkt_cntr_hi : 10;

                            /* Bits[9:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This is the upper half of the leaky bucket
                               counter. The full counter is actually a 53b DCLK
                               counter. There is a least significant 11b of the
                               53b counter is not captured in CSR. The carry
                               strobe from the not-shown least significant 11b
                               counter will trigger this 42b counter pair to
                               count. The 42b counter-pair is compared with the
                               two-hot encoding threshold specified by the
                               LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO
                               pair. When the counter bits specified by the
                               LEAKY_BUCKET_CFG_HI and LEAKY_BUCKET_CFG_LO are
                               both set, the 53b counter is reset and the leaky
                               bucket logic will generate a LEAK strobe last
                               for 1 DCLK.
                            */
    UINT32 rsvd : 22;

                            /* Bits[31:10], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LEAKY_BUCKET_CNTR_HI_MC_MAIN_STRUCT;

/* SCRUBADDRESS2LO_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x20020e50)                                                      */
/*      SPRB0 (0x20020e50)                                                      */
/*      SPRHBM (0x20020e50)                                                     */
/*      SPRC0 (0x20020e50)                                                      */
/*      SPRMCC (0x20020e50)                                                     */
/*      SPRUCC (0x20020e50)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This register contains part of the address of the last patrol scrub request issued. When running memtest, the failing address is logged in this register on memtest errors. Software can write the next address to be scrubbed into this register. The STARTSCRUB bit will then trigger the specified address to be scrubbed. Patrol scrubs must be disabled to reliably write this register.
*/


#define SCRUBADDRESS2LO_MC_MAIN_REG 0x07020E50

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 baseadd : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Contains bits 37:6 of the base system address of
                               the last scrub issued. This is the base of the
                               current system address. Can be written to
                               specify the next scrub address with STARTSCRUB.
                               System address in scrubaddresslo/hi also need to
                               be programmed in system address mode for the
                               programmed address to take effect.
                               scrubaddresshi.ptl_sa_mode must be cleared to 0
                               and then set back to 1 after STARTSCRUB is set
                               for address written to take effect.
                               RESTRICTIONS: Patrol Scrubs must be disabled
                               when writing to this field. Only used system
                               address patrol mode. When target or channel XOR
                               is enabled, address in this register wouldn't /
                               shouldn't be the true system address, the system
                               address with XOR applied. Error logging on
                               patrol scrub error will reflect the true system
                               address though.
                            */

  } Bits;
  UINT32 Data;

} SCRUBADDRESS2LO_MC_MAIN_STRUCT;

/* SCRUBADDRESS2HI_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x20020e54)                                                      */
/*      SPRB0 (0x20020e54)                                                      */
/*      SPRHBM (0x20020e54)                                                     */
/*      SPRC0 (0x20020e54)                                                      */
/*      SPRMCC (0x20020e54)                                                     */
/*      SPRUCC (0x20020e54)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* This register pair contains part of the address of the last patrol scrub request issued. Software can write the next address into this register. Scrubbing must be disabled to reliably read and write this register. The STARTSCRUB bit will then trigger the specified address to be scrubbed.
*/


#define SCRUBADDRESS2HI_MC_MAIN_REG 0x07020E54

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 baseaddhi : 15;

                            /* Bits[14:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Contains bits 52:38 of the base system address
                               of the last scrub issued. This is the base of
                               the current system address. Can be written to
                               specify the next scrub address with STARTSCRUB.
                               System address in scrubaddresslo/hi also need to
                               be programmed in system address mode for the
                               programmed address to work properly.
                               scrubaddresshi.ptl_sa_mode must be cleared to 0
                               and then set back to 1 after STARTSCRUB is set
                               for address written to take effect.
                               RESTRICTIONS: Patrol Scrubs must be disabled
                               when writing to this field. Only used system
                               address patrol mode.
                            */
    UINT32 rsvd : 17;

                            /* Bits[31:15], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCRUBADDRESS2HI_MC_MAIN_STRUCT;

/* EMCALTCTL_MC_MAIN_REG supported on:                                          */
/*      SPRA0 (0x20e5c)                                                         */
/*      SPRB0 (0x20e5c)                                                         */
/*      SPRHBM (0x20e5c)                                                        */
/*      SPRC0 (0x20e5c)                                                         */
/*      SPRMCC (0x20e5c)                                                        */
/*      SPRUCC (0x20e5c)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* eMCA lite control register.
*/


#define EMCALTCTL_MC_MAIN_REG 0x07000E5C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 emcalt_sel_smi : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               SMI enable. Set to enable SMI signaling for each
                               correctable error. Clear to disable SMI
                               signaling and signal CMCI when correctable error
                               threshold is reached.
                            */
    UINT8 rsvd : 7;

                            /* Bits[7:1], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} EMCALTCTL_MC_MAIN_STRUCT;

/* LBITMAP_MC_MAIN_REG supported on:                                            */
/*      SPRA0 (0x20020e60)                                                      */
/*      SPRB0 (0x20020e60)                                                      */
/*      SPRHBM (0x20020e60)                                                     */
/*      SPRC0 (0x20020e60)                                                      */
/*      SPRMCC (0x20020e60)                                                     */
/*      SPRUCC (0x20020e60)                                                     */
/* Register default value on SPRA0: 0x00000008                                  */
/* Register default value on SPRB0: 0x00000008                                  */
/* Register default value on SPRHBM: 0x00000008                                 */
/* Register default value on SPRC0: 0x00000008                                  */
/* Register default value on SPRMCC: 0x00000008                                 */
/* Register default value on SPRUCC: 0x00000008                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register defines a position of the bitmap in the global error status. 
*/


#define LBITMAP_MC_MAIN_REG 0x07020E60

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 bit_select : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000008*/

                            /*
                               selects which bit to set in the one-hot payload
                               of the Global Error Message that iMC sends to
                               UBOX.
                            */
    UINT32 rsvd : 27;

                            /* Bits[31:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LBITMAP_MC_MAIN_STRUCT;

/* SCRUBMASK_MC_MAIN_REG supported on:                                          */
/*      SPRA0 (0x20020e6c)                                                      */
/*      SPRB0 (0x20020e6c)                                                      */
/*      SPRHBM (0x20020e6c)                                                     */
/*      SPRC0 (0x20020e6c)                                                      */
/*      SPRMCC (0x20020e6c)                                                     */
/*      SPRUCC (0x20020e6c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* This register contains fields to make channels/ranks from patrol scrub engine.
*/


#define SCRUBMASK_MC_MAIN_REG 0x07020E6C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ch_mask : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Patrol scrub channel mask. Setting this bit will
                               skip patrol scrub on that channel.
                            */
    UINT32 rsvd : 3;

                            /* Bits[3:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 all_ranks : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Reserved; keep this bit at 0. */
    UINT32 rsvd_5 : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ch0_rank : 3;

                            /* Bits[10:8], Access Type=RW, default=0x00000000*/

                            /* Reserved; keep this field at 0. */
    UINT32 rsvd_11 : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank_dec : 8;

                            /* Bits[19:12], Access Type=RW, default=0x00000000*/

                            /* Reserved; keep this field at 0. */
    UINT32 link_fail : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /* link fail. */
    UINT32 rsvd_21 : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SCRUBMASK_MC_MAIN_STRUCT;

/* SPARING_CONTROL_SOURCE_MC_MAIN_REG supported on:                             */
/*      SPRA0 (0x20020e74)                                                      */
/*      SPRB0 (0x20020e74)                                                      */
/*      SPRHBM (0x20020e74)                                                     */
/*      SPRC0 (0x20020e74)                                                      */
/*      SPRMCC (0x20020e74)                                                     */
/*      SPRUCC (0x20020e74)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/*  This register controls the source for the sparing copy operation for ADDDC, rank sparing, and SDDC.  
*/


#define SPARING_CONTROL_SOURCE_MC_MAIN_REG 0x07020E74

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 source_cs : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               The value in this field is encoded (Chip Selects
                               are normally 1-hot), corresponding to CS0-CS7.
                               For SDDC or rank sparing this field specifies
                               the source rank (Chip Select, CS0-CS7) for the
                               sparing copy. For ADDDC, this field specifies
                               the failed rank for the sparing copy.
                            */
    UINT32 rsvd : 9;

                            /* Bits[11:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 source_ba : 2;

                            /* Bits[13:12], Access Type=RW, default=0x00000000*/

                            /*
                               For ADDDC used at the bank granularity
                               (region_size=bank), this field specifies the
                               bank address (BA2-BA0) to match for the sparing
                               copy.
                            */
    UINT32 source_bg : 2;

                            /* Bits[15:14], Access Type=RW, default=0x00000000*/

                            /*
                               For ADDDC used at the bank granularity
                               (region_size=bank), this field specifies the
                               bank group (BG1-BG0) to match for the sparing
                               copy.
                            */
    UINT32 buddy_cs_en : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               The enable bit for buddy_cs field. This enable
                               bit is only set for SDDC sparing in x8 mode, or
                               SDDC sparing after ADDDC is enabled.
                            */
    UINT32 buddy_cs : 3;

                            /* Bits[19:17], Access Type=RW, default=0x00000000*/

                            /*
                               The value in this field is encoded (Chip Selects
                               are normally 1-hot), corresponding to CS0-CS7.
                               This field is only used for SDDC sparing in x8
                               mode, or SDDC sparing after ADDDC is enabled.
                               This field specifies the primary rank (Chip
                               Select, CS0-CS7) of an ADDDC transaction whose
                               buddy is in the rank represented by source_cs.
                               This field is used only if buddy_cs_en bit is
                               set to 1.
                            */
    UINT32 rsvd_20 : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SPARING_CONTROL_SOURCE_MC_MAIN_STRUCT;

/* SPARING_CONTROL_DESTINATION_MC_MAIN_REG supported on:                        */
/*      SPRA0 (0x20020e78)                                                      */
/*      SPRB0 (0x20020e78)                                                      */
/*      SPRHBM (0x20020e78)                                                     */
/*      SPRC0 (0x20020e78)                                                      */
/*      SPRMCC (0x20020e78)                                                     */
/*      SPRUCC (0x20020e78)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/*  This register controls the destination for the sparing copy operation for ADDDC, rank sparing, and SDDC.  
*/


#define SPARING_CONTROL_DESTINATION_MC_MAIN_REG 0x07020E78

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 destination_cs : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               The value in this field is encoded (Chip Selects
                               are normally 1-hot), corresponding to CS0-CS7.
                               For rank sparing this field specifies the
                               destination rank (Chip Select, CS0-CS7) for the
                               sparing copy. For all other sparing operation,
                               including ADDDC sparing, this field should have
                               the same value as
                               sparing_control_source.source_cs.
                            */
    UINT32 reserved : 13;

                            /* Bits[15:3], Access Type=RW, default=0x00000000*/

                            /* Reserved for future use. */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SPARING_CONTROL_DESTINATION_MC_MAIN_STRUCT;

/* SPARING_PATROL_STATUS_MC_MAIN_REG supported on:                              */
/*      SPRA0 (0x20020e7c)                                                      */
/*      SPRB0 (0x20020e7c)                                                      */
/*      SPRHBM (0x20020e7c)                                                     */
/*      SPRC0 (0x20020e7c)                                                      */
/*      SPRMCC (0x20020e7c)                                                     */
/*      SPRUCC (0x20020e7c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/*  This register logs the status of patrol scrub and the sparing copy operation for ADDDC, rank sparing, and SDDC.  
                        Formerly ssrstatus.
          
*/


#define SPARING_PATROL_STATUS_MC_MAIN_REG 0x07020E7C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 copy_in_progress : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               This bit indicates that the sparing copy
                               operation is in progress. This bit is set by
                               hardware once the sparing copy has started. It
                               is cleared by hardware once the copy operation
                               is complete or fails.
                            */
    UINT32 copy_complete : 1;

                            /* Bits[1:1], Access Type=RW/V, default=0x00000000*/

                            /*
                               Sparing copy operation complete. Set by hardware
                               once operation is complete. This bit is cleared
                               by hardware when a new operation is enabled.
                            */
    UINT32 patrol_complete : 1;

                            /* Bits[2:2], Access Type=RW/1C/V, default=0x00000000*/

                            /*
                               All memory has been scrubbed. Hardware sets this
                               bit each time the patrol engine steps through
                               all memory locations. If software wants to
                               monitor 0 to 1 transition after the bit has been
                               set, the software will need to clear the bit by
                               writing a one to clear this bit in order to
                               distinguish the next patrol scrub completion.
                               Clearing the bit will not affect the patrol
                               scrub operation. Note, when mirroring is
                               enabled, this bit will be set to 1 after either
                               primary or secondary address scrubbing is done.
                               If software clears this bit to observe 0 to 1
                               transition, the transition will happen twice to
                               get full address scrubbed.
                            */
    UINT32 rsvd : 29;

                            /* Bits[31:3], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SPARING_PATROL_STATUS_MC_MAIN_STRUCT;



/* SPARING_CONTROL_TAD_MC_MAIN_REG supported on:                                */
/*      SPRA0 (0x20020e88)                                                      */
/*      SPRB0 (0x20020e88)                                                      */
/*      SPRHBM (0x20020e88)                                                     */
/*      SPRC0 (0x20020e88)                                                      */
/*      SPRMCC (0x20020e88)                                                     */
/*      SPRUCC (0x20020e88)                                                     */
/* Register default value on SPRA0: 0x001F58D1                                  */
/* Register default value on SPRB0: 0x001F58D1                                  */
/* Register default value on SPRHBM: 0x001F58D1                                 */
/* Register default value on SPRC0: 0x001F58D1                                  */
/* Register default value on SPRMCC: 0x001F58D1                                 */
/* Register default value on SPRUCC: 0x001F58D1                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register controls the sparing copy operation for ADDDC and when mirroring is enabled.  
*/


#define SPARING_CONTROL_TAD_MC_MAIN_REG 0x07020E88

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 nxt_tad_0 : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000001*/

                            /*
                               This field is used only when mirr_adddc_en = 1
                               and partial_mirr_en = 1. This field contains the
                               next TAD number from TAD 0 with the same
                               mirror_en bit as TAD 0 in tadbase.
                            */
    UINT32 nxt_tad_1 : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000002*/

                            /*
                               This field is used only when mirr_adddc_en = 1
                               and partial_mirr_en = 1. This field contains the
                               next TAD number from TAD 1 with the same
                               mirror_en bit as TAD 1 in tadbase.
                            */
    UINT32 nxt_tad_2 : 3;

                            /* Bits[8:6], Access Type=RW, default=0x00000003*/

                            /*
                               This field is used only when mirr_adddc_en = 1
                               and partial_mirr_en = 1. This field contains the
                               next TAD number from TAD 2 with the same
                               mirror_en bit as TAD 2 in tadbase.
                            */
    UINT32 nxt_tad_3 : 3;

                            /* Bits[11:9], Access Type=RW, default=0x00000004*/

                            /*
                               This field is used only when mirr_adddc_en = 1
                               and partial_mirr_en = 1. This field contains the
                               next TAD number from TAD 3 with the same
                               mirror_en bit as TAD 3 in tadbase.
                            */
    UINT32 nxt_tad_4 : 3;

                            /* Bits[14:12], Access Type=RW, default=0x00000005*/

                            /*
                               This field is used only when mirr_adddc_en = 1
                               and partial_mirr_en = 1. This field contains the
                               next TAD number from TAD 4 with the same
                               mirror_en bit as TAD 4 in tadbase.
                            */
    UINT32 nxt_tad_5 : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000006*/

                            /*
                               This field is used only when mirr_adddc_en = 1
                               and partial_mirr_en = 1. This field contains the
                               next TAD number from TAD 5 with the same
                               mirror_en bit as TAD 5 in tadbase.
                            */
    UINT32 nxt_tad_6 : 3;

                            /* Bits[20:18], Access Type=RW, default=0x00000007*/

                            /*
                               This field is used only when mirr_adddc_en = 1
                               and partial_mirr_en = 1. This field contains the
                               next TAD number from TAD 6 with the same
                               mirror_en bit as TAD 6 in tadbase.
                            */
    UINT32 rsvd : 11;

                            /* Bits[31:21], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SPARING_CONTROL_TAD_MC_MAIN_STRUCT;

/* SPARE_FSM_STATE_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x20020e8c)                                                      */
/*      SPRB0 (0x20020e8c)                                                      */
/*      SPRHBM (0x20020e8c)                                                     */
/*      SPRC0 (0x20020e8c)                                                      */
/*      SPRMCC (0x20020e8c)                                                     */
/*      SPRUCC (0x20020e8c)                                                     */
/* Register default value on SPRA0: 0x0F0F1F1F                                  */
/* Register default value on SPRB0: 0x0F0F1F1F                                  */
/* Register default value on SPRHBM: 0x0F0F1F1F                                 */
/* Register default value on SPRC0: 0x0F0F1F1F                                  */
/* Register default value on SPRMCC: 0x0F0F1F1F                                 */
/* Register default value on SPRUCC: 0x0F0F1F1F                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains current and previous state of spare FSMs.  
*/


#define SPARE_FSM_STATE_MC_MAIN_REG 0x07020E8C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 spr_current_state : 5;

                            /* Bits[4:0], Access Type=RO/V, default=0x0000001F*/

                            /* Current encoded state of spare copy FSM */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 spr_previous_state : 5;

                            /* Bits[12:8], Access Type=RO/V, default=0x0000001F*/

                            /* Previous encoded state of spare copy FSM */
    UINT32 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ssa_current_state : 4;

                            /* Bits[19:16], Access Type=RO/V, default=0x0000000F*/

                            /*
                               Current encoded state of system address FSM for
                               spare copy
                            */
    UINT32 rsvd_20 : 4;

                            /* Bits[23:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ssa_previous_state : 4;

                            /* Bits[27:24], Access Type=RO/V, default=0x0000000F*/

                            /*
                               Previous encoded state of system address FSM for
                               spare copy
                            */
    UINT32 rsvd_28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SPARE_FSM_STATE_MC_MAIN_STRUCT;

/* PATROL_FSM_STATE_MC_MAIN_REG supported on:                                   */
/*      SPRA0 (0x20020e90)                                                      */
/*      SPRB0 (0x20020e90)                                                      */
/*      SPRHBM (0x20020e90)                                                     */
/*      SPRC0 (0x20020e90)                                                      */
/*      SPRMCC (0x20020e90)                                                     */
/*      SPRUCC (0x20020e90)                                                     */
/* Register default value on SPRA0: 0x0F0F1F1F                                  */
/* Register default value on SPRB0: 0x0F0F1F1F                                  */
/* Register default value on SPRHBM: 0x0F0F1F1F                                 */
/* Register default value on SPRC0: 0x0F0F1F1F                                  */
/* Register default value on SPRMCC: 0x0F0F1F1F                                 */
/* Register default value on SPRUCC: 0x0F0F1F1F                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains current and previous state of patrol FSMs.  
*/


#define PATROL_FSM_STATE_MC_MAIN_REG 0x07020E90

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pat_current_state : 5;

                            /* Bits[4:0], Access Type=RO/V, default=0x0000001F*/

                            /* Current encoded state of patrol scrub FSM */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 pat_previous_state : 5;

                            /* Bits[12:8], Access Type=RO/V, default=0x0000001F*/

                            /* Previous encoded state of patrol scrub FSM */
    UINT32 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 psa_current_state : 4;

                            /* Bits[19:16], Access Type=RO/V, default=0x0000000F*/

                            /*
                               Current encoded state of system address FSM for
                               patrol scrub
                            */
    UINT32 rsvd_20 : 4;

                            /* Bits[23:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 psa_previous_state : 4;

                            /* Bits[27:24], Access Type=RO/V, default=0x0000000F*/

                            /*
                               Previous encoded state of system address FSM for
                               patrol scrub
                            */
    UINT32 rsvd_28 : 4;

                            /* Bits[31:28], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} PATROL_FSM_STATE_MC_MAIN_STRUCT;

/* FINAL_TRIG_CTL_MC_MAIN_REG supported on:                                     */
/*      SPRA0 (0x20020e9c)                                                      */
/*      SPRB0 (0x20020e9c)                                                      */
/*      SPRHBM (0x20020e9c)                                                     */
/*      SPRC0 (0x20020e9c)                                                      */
/*      SPRMCC (0x20020e9c)                                                     */
/*      SPRUCC (0x20020e9c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/*  
     This register contains triggers for DDRT logic. CSR bit en_ddrt_dfd_clk must be
     enabled to use this register   
    
*/


#define FINAL_TRIG_CTL_MC_MAIN_REG 0x07020E9C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 trig_select0 : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               Final MC_TRIGGER0 select: 0: SPID command filter
                               1: DDR-T Debug 2: VERR state machine 3: DDR-T
                               FNV drain 4: CPGC global start 5: CPGC error 6:
                               CPGC done
                            */
    UINT32 trig_select1 : 4;

                            /* Bits[7:4], Access Type=RW, default=0x00000000*/

                            /*
                               Final MC_TRIGGER1 select: 0: SPID command filter
                               1: DDR-T Debug 2: VERR state machine 3: DDR-T
                               FNV drain 4: CPGC global start 5: CPGC error 6:
                               CPGC done
                            */
    UINT32 trig_select2 : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000000*/

                            /*
                               Final MC_TRIGGER2 select: 0: SPID command filter
                               1: DDR-T Debug 2: VERR state machine 3: DDR-T
                               FNV drain 4: CPGC global start 5: CPGC error 6:
                               CPGC done
                            */
    UINT32 trig_select3 : 4;

                            /* Bits[15:12], Access Type=RW, default=0x00000000*/

                            /*
                               Final MC_TRIGGER3 select: 0: SPID command filter
                               1: DDR-T Debug 2: VERR state machine 3: DDR-T
                               FNV drain 4: CPGC global start 5: CPGC error 6:
                               CPGC done
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} FINAL_TRIG_CTL_MC_MAIN_STRUCT;

/* VIRALCTL_MC_MAIN_REG supported on:                                           */
/*      SPRA0 (0x20eb0)                                                         */
/*      SPRB0 (0x20eb0)                                                         */
/*      SPRHBM (0x20eb0)                                                        */
/*      SPRC0 (0x20eb0)                                                         */
/*      SPRMCC (0x20eb0)                                                        */
/*      SPRUCC (0x20eb0)                                                        */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Viral control register (EX only). SKX - Need to update description 
*/


#define VIRALCTL_MC_MAIN_REG 0x07000EB0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 viral_clear : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               When set to 1, clears viral level signal in MC.
                               Clear to 0 to allow viral signal to be set
                               again.
                            */
    UINT8 rsvd : 3;

                            /* Bits[3:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 viral_ch0 : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* Viral test bit for current channel. */
    UINT8 rsvd_5 : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} VIRALCTL_MC_MAIN_STRUCT;

/* SPARING_CONTROL_THRESH_MC_MAIN_REG supported on:                             */
/*      SPRA0 (0x20020ec8)                                                      */
/*      SPRB0 (0x20020ec8)                                                      */
/*      SPRHBM (0x20020ec8)                                                     */
/*      SPRC0 (0x20020ec8)                                                      */
/*      SPRMCC (0x20020ec8)                                                     */
/*      SPRUCC (0x20020ec8)                                                     */
/* Register default value on SPRA0: 0x00000100                                  */
/* Register default value on SPRB0: 0x00000100                                  */
/* Register default value on SPRHBM: 0x00000100                                 */
/* Register default value on SPRC0: 0x00000100                                  */
/* Register default value on SPRMCC: 0x00000100                                 */
/* Register default value on SPRUCC: 0x00000100                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register controls the sparing copy operation.  
*/


#define SPARING_CONTROL_THRESH_MC_MAIN_REG 0x07020EC8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 addr_skip : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000100*/

                            /*
                               Threshold to exit spare window when number of
                               skipped addresses reaches this value. The value
                               shouldn't be programmed to 0 even if
                               addr_skip_en = 0.
                            */
    UINT32 addr_skip_en : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Enable exiting spare window when number of
                               skipped addresses reaches threshold (addr_skip).
                            */
    UINT32 rsvd : 15;

                            /* Bits[31:17], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SPARING_CONTROL_THRESH_MC_MAIN_STRUCT;



/* RETRY_RD_ERR_LOG_ADDRESS3_N0_MC_MAIN_REG supported on:                       */
/*      SPRA0 (0x20020ed8)                                                      */
/*      SPRB0 (0x20020ed8)                                                      */
/*      SPRHBM (0x20020ed8)                                                     */
/*      SPRC0 (0x20020ed8)                                                      */
/*      SPRMCC (0x20020ed8)                                                     */
/*      SPRUCC (0x20020ed8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG.
            This register holds the system address.
      
*/


#define RETRY_RD_ERR_LOG_ADDRESS3_N0_MC_MAIN_REG 0x07020ED8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sysaddress : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /* System address for last retry */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_LOG_ADDRESS3_N0_MC_MAIN_STRUCT;

/* RETRY_RD_ERR_LOG_ADDRESS3_N1_MC_MAIN_REG supported on:                       */
/*      SPRA0 (0x20020edc)                                                      */
/*      SPRB0 (0x20020edc)                                                      */
/*      SPRHBM (0x20020edc)                                                     */
/*      SPRC0 (0x20020edc)                                                      */
/*      SPRMCC (0x20020edc)                                                     */
/*      SPRUCC (0x20020edc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG.
            This register holds the system address.
      
*/


#define RETRY_RD_ERR_LOG_ADDRESS3_N1_MC_MAIN_REG 0x07020EDC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sysaddress : 20;

                            /* Bits[19:0], Access Type=RW/V/P, default=0x00000000*/

                            /* System address for last retry */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_LOG_ADDRESS3_N1_MC_MAIN_STRUCT;

/* RETRY_RD_ERR_SET2_LOG_ADDRESS3_N0_MC_MAIN_REG supported on:                  */
/*      SPRA0 (0x20020ee0)                                                      */
/*      SPRB0 (0x20020ee0)                                                      */
/*      SPRHBM (0x20020ee0)                                                     */
/*      SPRC0 (0x20020ee0)                                                      */
/*      SPRMCC (0x20020ee0)                                                     */
/*      SPRUCC (0x20020ee0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG.
            This register holds the system address.
      
*/


#define RETRY_RD_ERR_SET2_LOG_ADDRESS3_N0_MC_MAIN_REG 0x07020EE0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sysaddress : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /* System address for last retry */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET2_LOG_ADDRESS3_N0_MC_MAIN_STRUCT;

/* RETRY_RD_ERR_SET2_LOG_ADDRESS3_N1_MC_MAIN_REG supported on:                  */
/*      SPRA0 (0x20020ee4)                                                      */
/*      SPRB0 (0x20020ee4)                                                      */
/*      SPRHBM (0x20020ee4)                                                     */
/*      SPRC0 (0x20020ee4)                                                      */
/*      SPRMCC (0x20020ee4)                                                     */
/*      SPRUCC (0x20020ee4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG.
            This register holds the system address.
      
*/


#define RETRY_RD_ERR_SET2_LOG_ADDRESS3_N1_MC_MAIN_REG 0x07020EE4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sysaddress : 20;

                            /* Bits[19:0], Access Type=RW/V/P, default=0x00000000*/

                            /* System address for last retry */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET2_LOG_ADDRESS3_N1_MC_MAIN_STRUCT;

/* MC_INIT_STATE_G_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x20020ee8)                                                      */
/*      SPRB0 (0x20020ee8)                                                      */
/*      SPRHBM (0x20020ee8)                                                     */
/*      SPRC0 (0x20020ee8)                                                      */
/*      SPRMCC (0x20020ee8)                                                     */
/*      SPRUCC (0x20020ee8)                                                     */
/* Register default value on SPRA0: 0x00000122                                  */
/* Register default value on SPRB0: 0x00000122                                  */
/* Register default value on SPRHBM: 0x00000122                                 */
/* Register default value on SPRC0: 0x00000122                                  */
/* Register default value on SPRMCC: 0x00000122                                 */
/* Register default value on SPRUCC: 0x00000122                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* This register defines the high-level behavior in CPGC mode. It defines the DDR reset pin value, DCLK enable, refresh enable and bits indicating the MRC status
*/


#define MC_INIT_STATE_G_MC_MAIN_REG 0x07020EE8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pu_mrc_done : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               This bit should be set to 1 by bios as soon as
                               the MRC has successfully completed and all
                               required information (e.g. - training) is in the
                               Bios flash. It indicates that first MRC has been
                               completed
                            */
    UINT32 ddr_reset : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000001*/

                            /* Reserved - unused. */
    UINT32 dclk_enable : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /* Reserved - unused. */
    UINT32 rsvd : 2;

                            /* Bits[4:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 reset_io : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*
                               DDR IO reset In order to reset the IO this bit
                               has to be set for 20 DCLKs and then cleared.
                               Setting this bit will reset the DDRIO receive
                               FIFO registers only. It is required in some of
                               the training steps.
                            */
    UINT32 rsvd_6 : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mrc_done : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /* MRC done. */
    UINT32 safe_sr : 1;

                            /* Bits[8:8], Access Type=RW/P, default=0x00000001*/

                            /*
                               This bit indicates if it is safe to keep the MC
                               in SR during MC-reset. If it is clear when reset
                               occurs, it means that the reset is without
                               warning and the DDR-reset should be asserted. If
                               set when reset occurs, it indicates that DDR is
                               already in SR and it can keep it this way. This
                               bit can also indicate MRC if reset without
                               warning has occured, and if it has, cold-reset
                               flow should be selected Note to MRC BIOS: clear
                               this bit at MRC entry.
                            */
    UINT32 cs_oe_en : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /* Reserved - unused. */
    UINT32 rsvd_10 : 22;

                            /* Bits[31:10], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MC_INIT_STATE_G_MC_MAIN_STRUCT;

/* SPAREINTERVAL_MC_MAIN_REG supported on:                                      */
/*      SPRA0 (0x20020ef0)                                                      */
/*      SPRB0 (0x20020ef0)                                                      */
/*      SPRHBM (0x20020ef0)                                                     */
/*      SPRC0 (0x20020ef0)                                                      */
/*      SPRMCC (0x20020ef0)                                                     */
/*      SPRUCC (0x20020ef0)                                                     */
/* Register default value on SPRA0: 0x03200C80                                  */
/* Register default value on SPRB0: 0x03200C80                                  */
/* Register default value on SPRHBM: 0x03200C80                                 */
/* Register default value on SPRC0: 0x03200C80                                  */
/* Register default value on SPRMCC: 0x03200C80                                 */
/* Register default value on SPRUCC: 0x03200C80                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* Defines the interval between normal and sparing operations. Interval is defined in dclk.
*/


#define SPAREINTERVAL_MC_MAIN_REG 0x07020EF0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 normopdur : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000C80*/

                            /*
                               Normal operation duration. System requests will
                               be serviced during this interval.
                            */
    UINT32 numspare : 13;

                            /* Bits[28:16], Access Type=RW, default=0x00000320*/

                            /*
                               Sparing operation duration. System requests will
                               be blocked during this interval and only sparing
                               copy operations will be serviced. This needs to
                               be an even number is ADDDC sparing mode. The
                               value needs to be 32 or less in rank sparing
                               mode.
                            */
    UINT32 rsvd : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SPAREINTERVAL_MC_MAIN_STRUCT;

/* MCMTR_MC_MAIN_REG supported on:                                              */
/*      SPRA0 (0x20020ef8)                                                      */
/*      SPRB0 (0x20020ef8)                                                      */
/*      SPRHBM (0x20020ef8)                                                     */
/*      SPRC0 (0x20020ef8)                                                      */
/*      SPRMCC (0x20020ef8)                                                     */
/*      SPRUCC (0x20020ef8)                                                     */
/* Register default value on SPRA0: 0x00000010                                  */
/* Register default value on SPRB0: 0x00000010                                  */
/* Register default value on SPRHBM: 0x00000010                                 */
/* Register default value on SPRC0: 0x00000010                                  */
/* Register default value on SPRMCC: 0x00000010                                 */
/* Register default value on SPRUCC: 0x00000010                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/* generated by critter 19_0_0x07c
*/


#define MCMTR_MC_MAIN_REG 0x07020EF8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 close_pg : 1;

                            /* Bits[0:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               Use close page address mapping if set;
                               otherwise, open page.
                            */
    UINT32 rsvd : 1;

                            /* Bits[1:1], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ecc_en : 1;

                            /* Bits[2:2], Access Type=RW/V/P, default=0x00000000*/

                            /* ECC enable. */
    UINT32 dir_en : 1;

                            /* Bits[3:3], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               Directory Enable. Read-Only (RO) with 0 value if
                               not supported. This bit is not used by the
                               design. M2M controls directory enable behavior.
                            */
    UINT32 read_dbi_en : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000001*/

                            /*
                               HBM Only. Enable DBI for memory reads. This bit
                               is not used in DDR mode.
                            */
    UINT32 write_dbi_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               HBM Only. Enable DBI for memory writes. This bit
                               is not used in DDR mode.
                            */
    UINT32 read_parity_en : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               HBM Only. Enable parity for memory reads. This
                               bit is not used in DDR mode.
                            */
    UINT32 write_parity_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               HBM Only. Enable parity for memory writes. This
                               bit is not used in DDR mode.
                            */
    UINT32 normal : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /* 0: Training mode 1: Normal Mode */
    UINT32 bank_xor_enable : 1;

                            /* Bits[9:9], Access Type=RW/P, default=0x00000000*/

                            /*
                               When set, this bit will enable bank XORing. This
                               is targeted at workloads that bank thrashing
                               caused by certain stride or page mappings. If
                               one detects unexpectedly poor page hit rates,
                               one can attempt to flip this bit to see if it
                               helps. [0]: Our base configuration. Bank
                               selection is done using rank address bits
                               12:17:18 for open page mapping and bits 6:7:8
                               for close page mapping. [1]: Bank XORing
                               enabled. Bank selection is done using rank
                               address bits: (1219):(1720):(1821) for open page
                               mapping (619):(720):(821) for close page mapping
                            */
    UINT32 trng_mode : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /*
                               00: reserved 01: Native CPGC Mode. (mcmtr.normal
                               must be zero for this mode) 10: reserved 11:
                               Normal Mode (mcmtr.normal is a dont care for
                               this mode)
                            */
    UINT32 ddr5_9x4_en : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               This bit is used to enable DDR5 9x4 mode. 0 -
                               DDR5 10x4 1 - DDR5 9x4
                            */
    UINT32 dimm_xor_enable : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               XOR hash enable for Dimm Select of the Rank
                               Target (Bit [2] of 3 bit target rank) This bit
                               should be set only when the channel has 2 DDR5
                               DIMMs. Both DIMMs need to be identical. This bit
                               cannot be set for a DDR4 channel or for a 1 DPC
                               DDR5 channel.
                            */
    UINT32 rsvd_14 : 4;

                            /* Bits[17:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 chn_disable : 1;

                            /* Bits[18:18], Access Type=RW/P, default=0x00000000*/

                            /*
                               Channel disable control. When set, the channel
                               is disabled. Note: Message Channel may not work
                               if all channels are set to disable in this
                               field.
                            */
    UINT32 pch_xor_enable : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               XOR hash enable for pseudo channel or sub-
                               channel.
                            */
    UINT32 channel_xor_enable : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /* XOR hash enable for 2 or 4 or 8 channels. */
    UINT32 cluster_xor_enable : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /* XOR hash enable for 2 or 4 clusters. */
    UINT32 ch23cmd_ctl_delay : 1;

                            /* Bits[22:22], Access Type=RW/P, default=0x00000000*/

                            /* unused on 10nm */
    UINT32 rank_xor_enable : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               XOR hash enable for Rank Select of the Rank
                               Target (Bit [1] of 3 bit target rank) This bit
                               should be set only when the channel has DDR5
                               dual-rank DIMMs. In a 2DPC configuration, both
                               DIMMs need to be identical. This bit cannot be
                               set for a DDR4 channel or if the channel has a
                               single rank DIMM.
                            */
    UINT32 sid_xor_enable : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /* XOR hash enable for subrank bits. */
    UINT32 trng_target : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Per channel based target. 0 = CPGC transactions
                               go to DRAM scheduler. 1 = CPGC transactions go
                               to DDRT scheduler.
                            */
    UINT32 num_cluster : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Number of cluster indication: 0 = hemi (or 2
                               clusters); 1 = quad (or 4 clusters)
                            */
    UINT32 rsvd_27 : 2;

                            /* Bits[28:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 hbm_mc_mode : 1;

                            /* Bits[29:29], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit specifies which kind of MC this is, HBM
                               or DDR. When 1, the MC is an HBM MC. When 0, it
                               is a DDR MC (this includes both DDR4 and DDRT).
                            */
    UINT32 cpgc_active : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               This bit allows CPGC to drive traffic (CMI Mux
                               and Address Decode) while in normal mode.
                               Training Mode implications are not observed by
                               the MC while in this mode. This bit has no
                               effect when normal_mode=0.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCMTR_MC_MAIN_STRUCT;

/* SPARING_CONTROL_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x20020efc)                                                      */
/*      SPRB0 (0x20020efc)                                                      */
/*      SPRHBM (0x20020efc)                                                     */
/*      SPRC0 (0x20020efc)                                                      */
/*      SPRMCC (0x20020efc)                                                     */
/*      SPRUCC (0x20020efc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRB0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRHBM Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRC0 Security PolicyGroup: LB_MCHECK_W                                      */
/* SPRMCC Security PolicyGroup: LB_MCHECK_W                                     */
/* SPRUCC Security PolicyGroup: LB_MCHECK_W                                     */
/*  This register controls the sparing copy operation for ADDDC, rank sparing, and SDDC.  
*/


#define SPARING_CONTROL_MC_MAIN_REG 0x07020EFC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 spare_enable : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Spare enable when set to 1. Hardware clears this
                               bit after the sparing completion.
                            */
    UINT32 spare_reverse : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will cause sparing engine to be
                               run in reverse (move from virtual lockstep back
                               to independent) when sparing has been started
                               via the spare_enable bit. Expected usage models
                               are upgrading a region failure from bank to rank
                               and post-silicon testing
                            */
    UINT32 rank_sparing : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               This bit causes the sparing copy to be rank
                               sparing when sparing copy has been started via
                               the spare_enable bit. This bit is mutually
                               exclusive with the adddc_sparing and
                               sddc_sparing bits. This register is locked by
                               the DISABLE_RANK_SPARING bit from
                               IMC_FUSE_DOWNLOAD register.
                            */
    UINT32 adddc_sparing : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This bit causes the sparing copy to be ADDDC
                               sparing when sparing copy has been started via
                               the spare_enable bit. This bit is mutually
                               exclusive with the rank_sparing and sddc_sparing
                               bits. This register is locked by the
                               DISABLE_ADDDC_SPARING bit from IMC_FUSE_DOWNLOAD
                               register.
                            */
    UINT32 sddc_sparing : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               This bit causes the sparing copy to transition
                               ECC to the SDDC state when sparing copy has been
                               started via the spare_enable bit. This bit is
                               mutually exclusive with the adddc_sparing and
                               rank_sparing bits. This register is locked by
                               the DISABLE_SDDC bit from IMC_FUSE_DOWNLOAD
                               register.
                            */
    UINT32 rsvd : 2;

                            /* Bits[6:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 region_size : 2;

                            /* Bits[8:7], Access Type=RW, default=0x00000000*/

                            /*
                               This field selects the granularity for the
                               sparing copy operation: 00=Bank 01=Rank
                               1X=Reserved
                            */
    UINT32 rsvd_9 : 1;

                            /* Bits[9:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 bank_sparing : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /* This bit indicates bank sparing is enabled */
    UINT32 rsvd_11 : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 minimum_tad_rule : 3;

                            /* Bits[14:12], Access Type=RW, default=0x00000000*/

                            /*
                               First TAD rule used for spare address
                               generation. Set to 0 to begin generating system
                               addresses for sparing at the lowest address
                               mapped to the MC. When mirr_adddc_en = 1 and
                               partial_mirr_en = 1, this represent the first
                               TAD rule with mirror_en = 1.
                            */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 maximum_tad_rule : 3;

                            /* Bits[18:16], Access Type=RW, default=0x00000000*/

                            /*
                               Last TAD rule used for spare address generation.
                               Set to the maximum valid TAD rule number used on
                               the MC to generate system addresses for sparing
                               up to the maximum address mapped to the MC. When
                               mirr_adddc_en = 1 and partial_mirr_en = 1, this
                               represent the last TAD rule with mirror_en = 1.
                            */
    UINT32 rsvd_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mirr_adddc_en : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Enabling special spare copy mode for ADDDC and
                               mirroring enable. In this mode, system addresses
                               will be gone through 3 times, with first pass
                               for non-mirror addresses, second pass for mirror
                               primary addresses, and third pass for mirror
                               secondary addresses. For this function to work,
                               amap.mirr_adddc_en needs to be set to 1 in the
                               channel spare copy is done.
                            */
    UINT32 partial_mirr_en : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Only used when mirr_adddc_en = 1. When set to 1,
                               indicates partial mirroring is enabled and
                               system addresses will be generated 3 times. If
                               set to 0, only full mirroring is enabled and
                               first pass system address will be skipped.
                            */
    UINT32 rsvd_22 : 2;

                            /* Bits[23:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 minimum_tad_rule_nonmirr : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /*
                               First TAD rule for non-mirror region used for
                               spare address generation. Set to minimum valid
                               TAD rule number with mirror_en = 0 to begin
                               generating system addresses for sparing at the
                               lowest non-mirror address mapped to the MC. This
                               field is used only when mirr_adddc_en = 1 and
                               partial_mirr_en = 1.
                            */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 maximum_tad_rule_nonmirr : 3;

                            /* Bits[30:28], Access Type=RW, default=0x00000000*/

                            /*
                               Last TAD rule for non-mirror region used for
                               spare address generation. Set to the maximum
                               valid TAD rule number with mirror_en = 0 used on
                               the MC to generate system addresses for sparing
                               up to the maximum non-mirror address mapped to
                               the MC. This field is used only when
                               mirr_adddc_en = 1 and partial_mirr_en = 1.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} SPARING_CONTROL_MC_MAIN_STRUCT;

/* MCMAINDBGPRESEL0_MC_MAIN_REG supported on:                                   */
/*      SPRA0 (0x20020f00)                                                      */
/*      SPRB0 (0x20020f00)                                                      */
/*      SPRHBM (0x20020f00)                                                     */
/*      SPRC0 (0x20020f00)                                                      */
/*      SPRMCC (0x20020f00)                                                     */
/*      SPRUCC (0x20020f00)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Each event set is 32 bits wide. Debug event set 0 covers debug signal bus bit 0 ~ 31bit. Debug event set 31 covers debug signal bus bit 982 ~ 1023.
Each debug bus length is varied in MC clusters.
Total lanes are 8 lanes. Each lane cover 4 bit wide debug signals in MC. By each setting, maximum 32 bits can be brought out to the debug bus at a time.
Below lists which set of 4 bits signals will be driven on lane i of the debug bus.
This register is contolled by lock bit DBGBUSLCK in EPMCMAIN_DFX_LCK_CNTL register. The register may be readable with teh lock bit set but no writes will take effect unless the lock bit is set to 0.
*/


#define MCMAINDBGPRESEL0_MC_MAIN_REG 0x07020F00

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ln0dbgevsel : 5;

                            /* Bits[4:0], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This selects which set of signals will be driven
                               on lane 0 of the debug bus: For Lane i of
                               Ln[i]DbgEvSel, where i={0-7} and for each
                               register field value of j where the 5-bit
                               j={0-31}: j: nibble lane i (bit [i*4+3 : i*4])
                               of event set j, which select debug bus
                               bit[j*32+i*4+3 : j*32+i*4]
                            */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ln1dbgevsel : 5;

                            /* Bits[12:8], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This selects which set of signals will be driven
                               on lane 1 of the debug bus: For Lane i of
                               Ln[i]DbgEvSel, where i={0-7} and for each
                               register field value of j where the 5-bit
                               j={0-31}: j: nibble lane i (bit [i*4+3 : i*4])
                               of event set j, which select debug bus
                               bit[j*32+i*4+3 : j*32+i*4]
                            */
    UINT32 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ln2dbgevsel : 5;

                            /* Bits[20:16], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This selects which set of signals will be driven
                               on lane 2 of the debug bus: For Lane i of
                               Ln[i]DbgEvSel, where i={0-7} and for each
                               register field value of j where the 5-bit
                               j={0-31}: j: nibble lane i (bit [i*4+3 : i*4])
                               of event set j, which select debug bus
                               bit[j*32+i*4+3 : j*32+i*4]
                            */
    UINT32 rsvd_21 : 3;

                            /* Bits[23:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ln3dbgevsel : 5;

                            /* Bits[28:24], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This selects which set of signals will be driven
                               on lane 3 of the debug bus: For Lane i of
                               Ln[i]DbgEvSel, where i={0-7} and for each
                               register field value of j where the 5-bit
                               j={0-31}: j: nibble lane i (bit [i*4+3 : i*4])
                               of event set j, which select debug bus
                               bit[j*32+i*4+3 : j*32+i*4]
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCMAINDBGPRESEL0_MC_MAIN_STRUCT;

/* MCMAINDBGPRESEL1_MC_MAIN_REG supported on:                                   */
/*      SPRA0 (0x20020f04)                                                      */
/*      SPRB0 (0x20020f04)                                                      */
/*      SPRHBM (0x20020f04)                                                     */
/*      SPRC0 (0x20020f04)                                                      */
/*      SPRMCC (0x20020f04)                                                     */
/*      SPRUCC (0x20020f04)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* Each event set is 32 bits wide. Debug event set 0 covers debug signal bus bit 0 ~ 31bit. Debug event set 31 covers debug signal bus bit 982 ~ 1023.
Each debug bus length is varied in MC clusters.
Total lanes are 8 lanes. Each lane cover 4 bit wide debug signals in MC. By each setting, maximum 32 bits can be brought out to the debug bus at a time.
Below lists which set of 4 bits signals will be driven on lane i of the debug bus.
This register is contolled by lock bit DBGBUSLCK in EPMCMAIN_DFX_LCK_CNTL register. The register may be readable with teh lock bit set but no writes will take effect unless the lock bit is set to 0.
*/


#define MCMAINDBGPRESEL1_MC_MAIN_REG 0x07020F04

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ln4dbgevsel : 5;

                            /* Bits[4:0], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This selects which set of signals will be driven
                               on lane 4 of the debug bus: For Lane i of
                               Ln[i]DbgEvSel, where i={0-7} and for each
                               register field value of j where the 5-bit
                               j={0-31}: j: nibble lane i (bit [i*4+3 : i*4])
                               of event set j, which select debug bus
                               bit[j*32+i*4+3 : j*32+i*4]
                            */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ln5dbgevsel : 5;

                            /* Bits[12:8], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This selects which set of signals will be driven
                               on lane 5 of the debug bus: For Lane i of
                               Ln[i]DbgEvSel, where i={0-7} and for each
                               register field value of j where the 5-bit
                               j={0-31}: j: nibble lane i (bit [i*4+3 : i*4])
                               of event set j, which select debug bus
                               bit[j*32+i*4+3 : j*32+i*4]
                            */
    UINT32 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ln6dbgevsel : 5;

                            /* Bits[20:16], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This selects which set of signals will be driven
                               on lane 6 of the debug bus: For Lane i of
                               Ln[i]DbgEvSel, where i={0-7} and for each
                               register field value of j where the 5-bit
                               j={0-31}: j: nibble lane i (bit [i*4+3 : i*4])
                               of event set j, which select debug bus
                               bit[j*32+i*4+3 : j*32+i*4]
                            */
    UINT32 rsvd_21 : 3;

                            /* Bits[23:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ln7dbgevsel : 5;

                            /* Bits[28:24], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This selects which set of signals will be driven
                               on lane 7 of the debug bus: For Lane i of
                               Ln[i]DbgEvSel, where i={0-7} and for each
                               register field value of j where the 5-bit
                               j={0-31}: j: nibble lane i (bit [i*4+3 : i*4])
                               of event set j, which select debug bus
                               bit[j*32+i*4+3 : j*32+i*4]
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCMAINDBGPRESEL1_MC_MAIN_STRUCT;

/* MCMAINDBGSEL_MC_MAIN_REG supported on:                                       */
/*      SPRA0 (0x20020f08)                                                      */
/*      SPRB0 (0x20020f08)                                                      */
/*      SPRHBM (0x20020f08)                                                     */
/*      SPRC0 (0x20020f08)                                                      */
/*      SPRMCC (0x20020f08)                                                     */
/*      SPRUCC (0x20020f08)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is contolled by lock bit DBGBUSLCK in EPMCMAIN_DFX_LCK_CNTL register. The register may be readable with teh lock bit set but no writes will take effect unless the lock bit is set to 0.
*/


#define MCMAINDBGSEL_MC_MAIN_REG 0x07020F08

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lane0sel : 6;

                            /* Bits[5:0], Access Type=RW/P/L, default=0x00000000*/

                            /* lane 0 select */
    UINT32 lane1sel : 6;

                            /* Bits[11:6], Access Type=RW/P/L, default=0x00000000*/

                            /* lane 1 select */
    UINT32 lane2sel : 6;

                            /* Bits[17:12], Access Type=RW/P/L, default=0x00000000*/

                            /* lane 2 select */
    UINT32 lane3sel : 6;

                            /* Bits[23:18], Access Type=RW/P/L, default=0x00000000*/

                            /* lane 3 select */
    UINT32 clken : 1;

                            /* Bits[24:24], Access Type=RW/P/L, default=0x00000000*/

                            /* clock enable for debug mux */
    UINT32 rsvd : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCMAINDBGSEL_MC_MAIN_STRUCT;

/* RETRY_RD_ERR_SET3_LOG_ADDRESS3_N0_MC_MAIN_REG supported on:                  */
/*      SPRA0 (0x20020f10)                                                      */
/*      SPRB0 (0x20020f10)                                                      */
/*      SPRHBM (0x20020f10)                                                     */
/*      SPRC0 (0x20020f10)                                                      */
/*      SPRMCC (0x20020f10)                                                     */
/*      SPRUCC (0x20020f10)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG.
            This register holds the system address.
      
*/


#define RETRY_RD_ERR_SET3_LOG_ADDRESS3_N0_MC_MAIN_REG 0x07020F10

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sysaddress : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /* System address for last retry */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET3_LOG_ADDRESS3_N0_MC_MAIN_STRUCT;

/* RETRY_RD_ERR_SET3_LOG_ADDRESS3_N1_MC_MAIN_REG supported on:                  */
/*      SPRA0 (0x20020f14)                                                      */
/*      SPRB0 (0x20020f14)                                                      */
/*      SPRHBM (0x20020f14)                                                     */
/*      SPRC0 (0x20020f14)                                                      */
/*      SPRMCC (0x20020f14)                                                     */
/*      SPRUCC (0x20020f14)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: COR_CNT                                          */
/* SPRB0 Security PolicyGroup: COR_CNT                                          */
/* SPRHBM Security PolicyGroup: COR_CNT                                         */
/* SPRC0 Security PolicyGroup: COR_CNT                                          */
/* SPRMCC Security PolicyGroup: COR_CNT                                         */
/* SPRUCC Security PolicyGroup: COR_CNT                                         */
/* Logs info on retried reads.  The contents of this register are valid with RETRY_RD_ERR_LOG.
            This register holds the system address.
      
*/


#define RETRY_RD_ERR_SET3_LOG_ADDRESS3_N1_MC_MAIN_REG 0x07020F14

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 sysaddress : 20;

                            /* Bits[19:0], Access Type=RW/V/P, default=0x00000000*/

                            /* System address for last retry */
    UINT32 rsvd : 12;

                            /* Bits[31:20], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} RETRY_RD_ERR_SET3_LOG_ADDRESS3_N1_MC_MAIN_STRUCT;

/* MCDBGBUSCNTRL1_MC_MAIN_REG supported on:                                     */
/*      SPRA0 (0x10020f18)                                                      */
/*      SPRB0 (0x10020f18)                                                      */
/*      SPRHBM (0x10020f18)                                                     */
/*      SPRC0 (0x10020f18)                                                      */
/*      SPRMCC (0x10020f18)                                                     */
/*      SPRUCC (0x10020f18)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is controlled by lock bit DBGBUSLCK in EPMCMAIN_DFX_LCK_CNTL register. The register may be readable with the lock bit set but no writes will take effect unless the lock bit is set to 0.
*/


#define MCDBGBUSCNTRL1_MC_MAIN_REG 0x07010F18

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rsvd : 15;

                            /* Bits[14:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 dbgbusen : 1;

                            /* Bits[15:15], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This will enable the debug bus. Can be used to
                               gate clocks for all Debug flops. This should
                               really be RWS-L but the tool is not allowing me
                               to do that.
                            */

  } Bits;
  UINT16 Data;

} MCDBGBUSCNTRL1_MC_MAIN_STRUCT;

/* SCRATCHPAD_MC_MAIN_REG supported on:                                         */
/*      SPRA0 (0x20020f20)                                                      */
/*      SPRB0 (0x20020f20)                                                      */
/*      SPRHBM (0x20020f20)                                                     */
/*      SPRC0 (0x20020f20)                                                      */
/*      SPRMCC (0x20020f20)                                                     */
/*      SPRUCC (0x20020f20)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: LB_W                                             */
/* SPRB0 Security PolicyGroup: LB_W                                             */
/* SPRHBM Security PolicyGroup: LB_W                                            */
/* SPRC0 Security PolicyGroup: LB_W                                             */
/* SPRMCC Security PolicyGroup: LB_W                                            */
/* SPRUCC Security PolicyGroup: LB_W                                            */
/* generated by critter 19_0_0x1fc
*/


#define SCRATCHPAD_MC_MAIN_REG 0x07020F20

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 scratchpad : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /* SCRATCHPAD */

  } Bits;
  UINT32 Data;

} SCRATCHPAD_MC_MAIN_STRUCT;

/* MCGLBRSPCNTL_MC_MAIN_REG supported on:                                       */
/*      SPRA0 (0x20020f28)                                                      */
/*      SPRB0 (0x20020f28)                                                      */
/*      SPRHBM (0x20020f28)                                                     */
/*      SPRC0 (0x20020f28)                                                      */
/*      SPRMCC (0x20020f28)                                                     */
/*      SPRUCC (0x20020f28)                                                     */
/* Register default value on SPRA0: 0x00070707                                  */
/* Register default value on SPRB0: 0x00070707                                  */
/* Register default value on SPRHBM: 0x00070707                                 */
/* Register default value on SPRC0: 0x00070707                                  */
/* Register default value on SPRMCC: 0x00070707                                 */
/* Register default value on SPRUCC: 0x00070707                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/* All register fields are locked by EPMCCTRL_DFX_LCK_CNTL.RSPLCK.
*/


#define MCGLBRSPCNTL_MC_MAIN_REG 0x07020F28

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 glbrsp0starttrigsel : 3;

                            /* Bits[2:0], Access Type=RW/P/L, default=0x00000007*/

                            /*
                               This selects which trigger will be driven out.
                               000: MBP_OUT[0] 001: MBP_OUT[1] 010: ASC[0]
                               output 011: ASC[1] output 100: CTS trigger out
                               101: Do it forever 110: Always 1 111: Never
                               assert output
                            */
    UINT32 glbrsp0stopsel : 3;

                            /* Bits[5:3], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This selects the event that will cause the
                               output to be deasserted. 000: MBP[0] 001: MBP[1]
                               010: ASC[0] 011: ASC[1] 100: CTS Trigger out
                               101: Stop 1 cycle after start 110: Do it forever
                               111: Stop when start is false
                            */
    UINT32 rsvd_6 : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 glbrsp1starttrigsel : 3;

                            /* Bits[10:8], Access Type=RW/P/L, default=0x00000007*/

                            /*
                               This selects which trigger will be driven out.
                               000: MBP_OUT[0] 001: MBP_OUT[1] 010: ASC[0]
                               output 011: ASC[1] output 100: CTS trigger out
                               101: Do it forever 110: Always 1 111: Never
                               assert output
                            */
    UINT32 glbrsp1stopsel : 3;

                            /* Bits[13:11], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This selects the event that will cause the
                               output to be deasserted. 000: MBP[0] 001: MBP[1]
                               010: ASC[0] 011: ASC[1] 100: CTS Trigger out
                               101: Stop 1 cycle after start 110: Do it forever
                               111: Stop when start is false
                            */
    UINT32 rsvd_14 : 1;

                            /* Bits[14:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 glbrsp2starttrigsel : 3;

                            /* Bits[18:16], Access Type=RW/P/L, default=0x00000007*/

                            /*
                               This selects which trigger will be driven out.
                               000: MBP_OUT[0] 001: MBP_OUT[1] 010: ASC[0]
                               output 011: ASC[1] output 100: CTS trigger out
                               101: Reserved 110: Always 1 111: Never assert
                               output
                            */
    UINT32 glbrsp2stopsel : 3;

                            /* Bits[21:19], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This selects the event that will cause the
                               output to be deasserted. 000: MBP[0] 001: MBP[1]
                               010: ASC[0] 011: ASC[1] 100: CTS Trigger out
                               101: Stop 1 cycle after start 110: Do it forever
                               111: Stop when start is false
                            */
    UINT32 rsvd_22 : 1;

                            /* Bits[22:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd_23 : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCGLBRSPCNTL_MC_MAIN_STRUCT;

/* MCNOASEL_MC_MAIN_REG supported on:                                           */
/*      SPRA0 (0x20020f48)                                                      */
/*      SPRB0 (0x20020f48)                                                      */
/*      SPRHBM (0x20020f48)                                                     */
/*      SPRC0 (0x20020f48)                                                      */
/*      SPRMCC (0x20020f48)                                                     */
/*      SPRUCC (0x20020f48)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is contolled by lock bit NOALCK in EPMCMAIN_DFX_LCK_CNTL register. The register may be readable with the lock bit set but no writes will take effect unless the lock bit is set to 0.
*/


#define MCNOASEL_MC_MAIN_REG 0x07020F48

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 12;

                            /* Bits[11:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 muxsel2 : 1;

                            /* Bits[12:12], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This level of muxing will be used for taking
                               only 8 bits of data instead of 16 to reduce the
                               data rate on the NOA bus. The 8 bits selected
                               will be accumulated for 2 cycles and sent as one
                               16 bit value at half the rate. Output8[7:0]: 0
                               selects output16[7:0]; 1 selects output16[15:8]
                            */
    UINT32 rsvd_13 : 1;

                            /* Bits[13:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 noaoutsel : 1;

                            /* Bits[14:14], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Selects if the full rate or the half rate data
                               should be sent out on the NOA bus. 0: Select
                               full speed data 1: Select half rate data.
                            */
    UINT32 noaen : 1;

                            /* Bits[15:15], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               This bit enables the NOA logic. No output is
                               sent out on the NOA bus from iMC if this bit is
                               not set. 0: Disable NOA output from MC 1: Enable
                               NOA output from iMC.
                            */
    UINT32 rsvd_16 : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MCNOASEL_MC_MAIN_STRUCT;

/* VISA_CTL_DATA_MC_MAIN_REG supported on:                                      */
/*      SPRA0 (0x20020f50)                                                      */
/*      SPRB0 (0x20020f50)                                                      */
/*      SPRHBM (0x20020f50)                                                     */
/*      SPRC0 (0x20020f50)                                                      */
/*      SPRMCC (0x20020f50)                                                     */
/*      SPRUCC (0x20020f50)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is the data register for VISA controller within MC MAINS
*/


#define VISA_CTL_DATA_MC_MAIN_REG 0x07020F50

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 visactldata : 32;

                            /* Bits[31:0], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Read/Write data for VISA controller data
                               registers
                            */

  } Bits;
  UINT32 Data;

} VISA_CTL_DATA_MC_MAIN_STRUCT;

/* MCDFXBGFCONTROL_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x20020f58)                                                      */
/*      SPRB0 (0x20020f58)                                                      */
/*      SPRHBM (0x20020f58)                                                     */
/*      SPRC0 (0x20020f58)                                                      */
/*      SPRMCC (0x20020f58)                                                     */
/*      SPRUCC (0x20020f58)                                                     */
/* Register default value on SPRA0: 0x00000012                                  */
/* Register default value on SPRB0: 0x00000012                                  */
/* Register default value on SPRHBM: 0x00000012                                 */
/* Register default value on SPRC0: 0x00000012                                  */
/* Register default value on SPRMCC: 0x00000012                                 */
/* Register default value on SPRUCC: 0x00000012                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: DFX                                              */
/* SPRB0 Security PolicyGroup: DFX                                              */
/* SPRHBM Security PolicyGroup: DFX                                             */
/* SPRC0 Security PolicyGroup: DFX                                              */
/* SPRMCC Security PolicyGroup: DFX                                             */
/* SPRUCC Security PolicyGroup: DFX                                             */
/* Control for the DFX BGF
*/


#define MCDFXBGFCONTROL_MC_MAIN_REG 0x07020F58

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 bgfstopovrd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               BGF Stop Override (BgfStopOvrd): The DFx BGF is
                               primarily controlled by the BgfRun signal of
                               primary, functional BGFs in DFx BGFs
                               neighborhood. Setting this field to 1, however,
                               forces the DFx BGF to stop. While the BGF is
                               stopped, the pattern generator, pattern checker
                               and error counter are not running. When the BGF
                               is restarted (i.e. when this field is cleared to
                               0), the error counter (i.e. the ErrorCount
                               field) is reset. If the BGFs configuration is
                               changed while it is running, spurious errors
                               will be logged. To change configuration (pattern
                               mode, read delay, read back borrow, pointer
                               separation offset), the standard procedure is to
                               stop the BGF (i.e. set this field 1), change the
                               configuration, and restart the BGF (set this
                               field back to 0). All the other writable fields
                               should be sticky through reset. This field is
                               the exception; it should clear during reset.
                            */
    UINT32 patternmode : 1;

                            /* Bits[1:1], Access Type=RW/P, default=0x00000001*/

                            /*
                               Pattern Mode (PatternMode): This field controls
                               the type of test pattern that runs through the
                               DFx FIFO: 0 = toggle pattern, 1 = pseudo-random
                               bit sequence. (This setting should not be
                               changed while the BGF is running. See Bgf
                               StopOvrd.) Path from register to pattern
                               generator and checker may be multi-cycle.
                            */
    UINT32 enrddelay : 1;

                            /* Bits[2:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               Enable Read Delay (EnRdDelay): While this field
                               (and EnRdBkBrw) is set to 0, BGF read timing
                               follows standard BGF behavior. If this field is
                               set to 1, all reads are delayed by one cycle.
                               This setting may be combined with EnRdBkBrw.
                               (This setting should not be changed while the
                               BGF is running. See BgfStopOvrd.) Path from
                               register to pattern checker may be multi-cycle.
                            */
    UINT32 enrdbkbrw : 1;

                            /* Bits[3:3], Access Type=RW/P, default=0x00000000*/

                            /*
                               Pointer Separation Offset (EnRdBkBrw): While
                               this field (and EnRdDelay) is set to 0, BGF read
                               timing follows standard BGF behavior. If this
                               field is set to 1, read data is sampled half a
                               read clock earlier. This setting may be combined
                               with EnRdDelay. (This setting should not be
                               changed while the BGF is running. See
                               BgfStopOvrd.) Path from register to pattern
                               checker may be multi-cycle.
                            */
    UINT32 ptrsepoffset : 3;

                            /* Bits[6:4], Access Type=RW/P, default=0x00000001*/

                            /*
                               Pointer Separation Offset (PtrSepOffset): This
                               field specifies the offset between the pointer
                               separation of nearby primary, functional BGFs to
                               the pointer separation of the DFx BGF. The DFx
                               BGFs pointer separation is the primary BGFs
                               pointer separation minus this offset. (This
                               setting should not be changed while the BGF is
                               running. See bgfstopovrd.) Path from register to
                               DFx BGFs pointer separation calculation logic
                               may be multi-cycle.
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ptrsepeff : 3;

                            /* Bits[10:8], Access Type=RO/V, default=0x00000000*/

                            /*
                               Effective Pointer Separation (PtrSepEff): This
                               field shows the effective pointer separation
                               applied to the DFx BGF (i.e. it is the primary
                               BGF pointer separation minus PtrSepOffset). Note
                               that this value is actually the program value;
                               the conceptual pointer separation is the program
                               value plus two. Shouldnt need any flip-flops at
                               register. Value may flow through from logic that
                               computes the effective pointer separation. Path
                               to register may be multi-cycle.
                            */
    UINT32 rsvd_11 : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 errorcount : 20;

                            /* Bits[31:12], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This field shows the number of errors
                               accumulated since the DFx BGF was last started.
                               The error count saturates at its maximum value.
                               It may be cleared (write 1 to clear) while the
                               BGF is running. (Clearing this field does not
                               reset the pattern generator, BGF or pattern
                               checker; they keep running.) Shouldnt need any
                               flip-flops at register. Value may flow through
                               from error counter. Path from error counter to
                               register may be multi-cycle. If path is multi-
                               cycle, then BGF should be stopped (see
                               BgfStopOvrd) to read a, reliable, stable error
                               count value. When a 1 is written to this field,
                               send a two-cycle long clear signal to the error
                               counter logic. The clear signal may be multi-
                               cycle.
                            */

  } Bits;
  UINT32 Data;

} MCDFXBGFCONTROL_MC_MAIN_STRUCT;

/* VISA_CTL_ADDR_MC_MAIN_REG supported on:                                      */
/*      SPRA0 (0x20020f60)                                                      */
/*      SPRB0 (0x20020f60)                                                      */
/*      SPRHBM (0x20020f60)                                                     */
/*      SPRC0 (0x20020f60)                                                      */
/*      SPRMCC (0x20020f60)                                                     */
/*      SPRUCC (0x20020f60)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: OS_W                                             */
/* SPRB0 Security PolicyGroup: OS_W                                             */
/* SPRHBM Security PolicyGroup: OS_W                                            */
/* SPRC0 Security PolicyGroup: OS_W                                             */
/* SPRMCC Security PolicyGroup: OS_W                                            */
/* SPRUCC Security PolicyGroup: OS_W                                            */
/* This register is the address register for VISA controller within MC MAINS
*/


#define VISA_CTL_ADDR_MC_MAIN_REG 0x07020F60

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 visactladdr : 32;

                            /* Bits[31:0], Access Type=RW/P/L, default=0x00000000*/

                            /*
                               Read/Write addr for VISA controller addr
                               registers
                            */

  } Bits;
  UINT32 Data;

} VISA_CTL_ADDR_MC_MAIN_STRUCT;

/* LT_CPGC_CONTROL_MC_MAIN_REG supported on:                                    */
/*      SPRA0 (0x20020f68)                                                      */
/*      SPRB0 (0x20020f68)                                                      */
/*      SPRHBM (0x20020f68)                                                     */
/*      SPRC0 (0x20020f68)                                                      */
/*      SPRMCC (0x20020f68)                                                     */
/*      SPRUCC (0x20020f68)                                                     */
/* Register default value on SPRA0: 0x00000003                                  */
/* Register default value on SPRB0: 0x00000003                                  */
/* Register default value on SPRHBM: 0x00000003                                 */
/* Register default value on SPRC0: 0x00000003                                  */
/* Register default value on SPRMCC: 0x00000003                                 */
/* Register default value on SPRUCC: 0x00000003                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* generated by critter CR__0x202d0
*/


#define LT_CPGC_CONTROL_MC_MAIN_REG 0x07020F68

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 res_lock : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000003*/

                            /*
                               CPGC engine lock control from UCODE. This
                               register controls write access to all cpgc
                               registers with the excpetion of cpgc_pda_shadow,
                               cpgc_pda,cpgc_patwdbclmux,cpgc_patwdb,cpgc_patwd
                               bcl, cpgc_patwdb_wr0/cpgc_patwdb_wr1 registers.
                               00: CPGC is fully unlocked in non_normal mode
                               (training). In normal mode, determined by
                               MCMTR.normal and MCMTR.trng_mode, this setting
                               operates the same as 10 setting. margining (MRS
                               issue from CADB) are unlocked. 01: Reserved.
                               CPGC is locked. Nothing can be issued by CPGC
                               engine. mc_init_state_g is locked. 10: Only
                               parts of CPGC engine necessary for Vref
                               margining (MRS issue from CADB) is unlocked
                               (regardless of value of normal mode);
                               mc_init_state_g is locked. The register fields
                               which are unlocked in this mode are: cpgc_seqctl
                               *.global_control,cpgc_seqctl*.local_start_test,
                               all fields of cpgc_patcadbmrs_mrs,all fields of
                               cr_cpgc_patcadbprog*,
                               cpgc_patcadbwrpntr.write_pointer .
                               cr_cpgc_seqctl*.initialization_mode is
                               restricted to MRS mode. 11: CPGC is locked.
                               Nothing can be issued by CPGC engine.
                               mc_init_state_g is locked.
                            */
    UINT32 rsvd : 30;

                            /* Bits[31:2], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} LT_CPGC_CONTROL_MC_MAIN_STRUCT;

/* INTERNAL_ERROR_2LMMISC_N0_MC_MAIN_REG supported on:                          */
/*      SPRA0 (0x20020f70)                                                      */
/*      SPRB0 (0x20020f70)                                                      */
/*      SPRHBM (0x20020f70)                                                     */
/*      SPRC0 (0x20020f70)                                                      */
/*      SPRMCC (0x20020f70)                                                     */
/*      SPRUCC (0x20020f70)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains internal errors from mc2lmmisc
*/


#define INTERNAL_ERROR_2LMMISC_N0_MC_MAIN_REG 0x07020F70

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pat_illegal_init_addr : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Programmed scrub starting base address above TAD
                               limit
                            */
    UINT32 pat_illegal_init_addr2 : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /*
                               Programmed scrub starting address above TAD
                               limit
                            */
    UINT32 pat_illegal_ack_inc : 1;

                            /* Bits[2:2], Access Type=RO/V, default=0x00000000*/

                            /* Patrol error */
    UINT32 spr_sparesissued_underflow : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000000*/

                            /* Sparing error */
    UINT32 spr_m2m_conflict : 1;

                            /* Bits[4:4], Access Type=RO/V, default=0x00000000*/

                            /* Sparing error */
    UINT32 com_pkgc_pkgs_err : 1;

                            /* Bits[5:5], Access Type=RO/V, default=0x00000000*/

                            /* PkgC error */
    UINT32 ddrt2_reads_linkfail : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000000*/

                            /* DDRT error */
    UINT32 ddrt_wpq_valid_pwr_not_found : 1;

                            /* Bits[7:7], Access Type=RO/V, default=0x00000000*/

                            /* DDRT error */
    UINT32 mc2lm_unexp_intlv : 1;

                            /* Bits[8:8], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_bad_ddr4_attr : 1;

                            /* Bits[9:9], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_nm_mirr_bit_set : 1;

                            /* Bits[10:10], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_reuse_valid_sbentry : 1;

                            /* Bits[11:11], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_bad_sbentry_patrol : 1;

                            /* Bits[12:12], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_bad_sbentry_nonpatrol : 1;

                            /* Bits[13:13], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_nmfill_wr_camvec_none : 1;

                            /* Bits[14:14], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_unexp_wrflush_done : 1;

                            /* Bits[15:15], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_unexp_wrflush : 1;

                            /* Bits[16:16], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_erid_cmpl_err : 1;

                            /* Bits[17:17], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_bad_ddr4_wrt_cmpl0 : 1;

                            /* Bits[18:18], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_bad_ddr4_wrt_cmpl1 : 1;

                            /* Bits[19:19], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_bad_ddrt0_wrt_cmpl : 1;

                            /* Bits[20:20], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_bad_ddrt1_wrt_cmpl : 1;

                            /* Bits[21:21], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_ddr4_read_cpl_should_hit_sb : 1;

                            /* Bits[22:22], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_ddrt_read_cpl_should_hit_sb : 1;

                            /* Bits[23:23], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_invalid_retry_htid : 1;

                            /* Bits[24:24], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_patrol_overflow : 1;

                            /* Bits[25:25], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_sb_tag_arr_rden : 1;

                            /* Bits[26:26], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 mc2lm_sb_index_arr_rden : 1;

                            /* Bits[27:27], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 decs_bad_accept : 1;

                            /* Bits[28:28], Access Type=RO/V, default=0x00000000*/

                            /* Decoder error */
    UINT32 decs_sys2chn_dec_err : 1;

                            /* Bits[29:29], Access Type=RO/V, default=0x00000000*/

                            /* Decoder error */
    UINT32 decs_chn2rir_dec_err : 1;

                            /* Bits[30:30], Access Type=RO/V, default=0x00000000*/

                            /* Decoder error */
    UINT32 decs_ddrt_specread : 1;

                            /* Bits[31:31], Access Type=RO/V, default=0x00000000*/

                            /* Decoder error */

  } Bits;
  UINT32 Data;

} INTERNAL_ERROR_2LMMISC_N0_MC_MAIN_STRUCT;

/* INTERNAL_ERROR_2LMMISC_N1_MC_MAIN_REG supported on:                          */
/*      SPRA0 (0x20020f74)                                                      */
/*      SPRB0 (0x20020f74)                                                      */
/*      SPRHBM (0x20020f74)                                                     */
/*      SPRC0 (0x20020f74)                                                      */
/*      SPRMCC (0x20020f74)                                                     */
/*      SPRUCC (0x20020f74)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains internal errors from mc2lmmisc
*/


#define INTERNAL_ERROR_2LMMISC_N1_MC_MAIN_REG 0x07020F74

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 decs_patrol_retry_confl : 1;

                            /* Bits[0:0], Access Type=RO/V, default=0x00000000*/

                            /* Decoder error */
    UINT32 cmi_cpl_fifo_uf : 1;

                            /* Bits[1:1], Access Type=RO/V, default=0x00000000*/

                            /* CMI error */
    UINT32 cmi_cpl_fifo_of : 1;

                            /* Bits[2:2], Access Type=RO/V, default=0x00000000*/

                            /* CMI error */
    UINT32 cmi_cpl_cmd_fifo_uf : 1;

                            /* Bits[3:3], Access Type=RO/V, default=0x00000000*/

                            /* CMI error */
    UINT32 cmi_cpl_cmd_fifo_of : 1;

                            /* Bits[4:4], Access Type=RO/V, default=0x00000000*/

                            /* CMI error */
    UINT32 cmi_cpl_late_viol : 1;

                            /* Bits[5:5], Access Type=RO/V, default=0x00000000*/

                            /* CMI error */
    UINT32 cmi_cpl_late_viol_2 : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000000*/

                            /* CMI error */
    UINT32 cmi_cpl_late_viol_3 : 1;

                            /* Bits[7:7], Access Type=RO/V, default=0x00000000*/

                            /* CMI error */
    UINT32 cmi_cpl_data_viol : 1;

                            /* Bits[8:8], Access Type=RO/V, default=0x00000000*/

                            /* CMI error */
    UINT32 cmi_cpl_data_viol_2 : 1;

                            /* Bits[9:9], Access Type=RO/V, default=0x00000000*/

                            /* CMI error */
    UINT32 cmi_req_viol : 1;

                            /* Bits[10:10], Access Type=RO/V, default=0x00000000*/

                            /* CMI error */
    UINT32 cmi_rsp_viol_1 : 1;

                            /* Bits[11:11], Access Type=RO/V, default=0x00000000*/

                            /* CMI error */
    UINT32 cmi_rsp_viol_2 : 1;

                            /* Bits[12:12], Access Type=RO/V, default=0x00000000*/

                            /* CMI error */
    UINT32 cmi_rsp_viol_3 : 1;

                            /* Bits[13:13], Access Type=RO/V, default=0x00000000*/

                            /* CMI error */
    UINT32 mc2lm_sb_overflow : 1;

                            /* Bits[14:14], Access Type=RO/V, default=0x00000000*/

                            /* 2LM controller error */
    UINT32 decs_wrong_spr_rank : 1;

                            /* Bits[15:15], Access Type=RO/V, default=0x00000000*/

                            /* Decoder error */
    UINT32 ddrt_rpq_valid_idle : 1;

                            /* Bits[16:16], Access Type=RO/V, default=0x00000000*/

                            /* DDRT error */
    UINT32 ddrt_wpq_valid_idle : 1;

                            /* Bits[17:17], Access Type=RO/V, default=0x00000000*/

                            /* DDRT error */
    UINT32 ddrt2_wrcrdt_starvation : 1;

                            /* Bits[18:18], Access Type=RO/V, default=0x00000000*/

                            /* DDRT error */
    UINT32 ddrt2_tgr_starvation : 1;

                            /* Bits[19:19], Access Type=RO/V, default=0x00000000*/

                            /* DDRT error */
    UINT32 ddrt2_illegal_conditions : 1;

                            /* Bits[20:20], Access Type=RO/V, default=0x00000000*/

                            /*
                               DDRT error - combined illegal conditions (
                               invalid req pulse width, info/interrupt packet
                               received on secondary subchannel, read data came
                               on different subchannel etc)
                            */
    UINT32 mc2lm_sbtag_fifo_overflow : 1;

                            /* Bits[21:21], Access Type=RO/V, default=0x00000000*/

                            /* 2LM internal error */
    UINT32 mc2lm_sbtag_fifo_underflow : 1;

                            /* Bits[22:22], Access Type=RO/V, default=0x00000000*/

                            /* 2LM internal error */
    UINT32 rsvd : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} INTERNAL_ERROR_2LMMISC_N1_MC_MAIN_STRUCT;

/* DIS_INTERNAL_ERROR_2LMMISC_N0_MC_MAIN_REG supported on:                      */
/*      SPRA0 (0x20020f78)                                                      */
/*      SPRB0 (0x20020f78)                                                      */
/*      SPRHBM (0x20020f78)                                                     */
/*      SPRC0 (0x20020f78)                                                      */
/*      SPRMCC (0x20020f78)                                                     */
/*      SPRUCC (0x20020f78)                                                     */
/* Register default value on SPRA0: 0x00000020                                  */
/* Register default value on SPRB0: 0x00000020                                  */
/* Register default value on SPRHBM: 0x00000020                                 */
/* Register default value on SPRC0: 0x00000020                                  */
/* Register default value on SPRMCC: 0x00000020                                 */
/* Register default value on SPRUCC: 0x00000020                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains disable bits for internal errors from mc2lmmisc
*/


#define DIS_INTERNAL_ERROR_2LMMISC_N0_MC_MAIN_REG 0x07020F78

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_pat_illegal_init_addr : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by programmed scrub
                               starting base address above TAD limit
                            */
    UINT32 dis_pat_illegal_init_addr2 : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Disable error caused by programmed scrub
                               starting address above TAD limit
                            */
    UINT32 dis_pat_illegal_ack_inc : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_spr_sparesissued_underflow : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_spr_m2m_conflict : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_com_pkgc_pkgs_err : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000001*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_ddrt2_reads_linkfail : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_ddrt_wpq_valid_pwr_not_found : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_unexp_intlv : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_bad_ddr4_attr : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_nm_mirr_bit_set : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_reuse_valid_sbentry : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_bad_sbentry_patrol : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_bad_sbentry_nonpatrol : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_nmfill_wr_camvec_none : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_unexp_wrflush_done : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_unexp_wrflush : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_erid_cmpl_err : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_bad_ddr4_wrt_cmpl0 : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_bad_ddr4_wrt_cmpl : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_bad_ddrt0_wrt_cmpl : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_bad_ddrt1_wrt_cmpl : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_ddr4_read_cpl_should_hit_sb : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_ddrt_read_cpl_should_hit_sb : 1;

                            /* Bits[23:23], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_invalid_retry_htid : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_patrol_overflow : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_sb_tag_arr_rden : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_sb_index_arr_rden : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_decs_bad_accept : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_decs_sys2chn_dec_err : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_decs_chn2rir_dec_err : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_decs_ddrt_specread : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */

  } Bits;
  UINT32 Data;

} DIS_INTERNAL_ERROR_2LMMISC_N0_MC_MAIN_STRUCT;

/* DIS_INTERNAL_ERROR_2LMMISC_N1_MC_MAIN_REG supported on:                      */
/*      SPRA0 (0x20020f7c)                                                      */
/*      SPRB0 (0x20020f7c)                                                      */
/*      SPRHBM (0x20020f7c)                                                     */
/*      SPRC0 (0x20020f7c)                                                      */
/*      SPRMCC (0x20020f7c)                                                     */
/*      SPRUCC (0x20020f7c)                                                     */
/* Register default value on SPRA0: 0x001F0000                                  */
/* Register default value on SPRB0: 0x001F0000                                  */
/* Register default value on SPRHBM: 0x001F0000                                 */
/* Register default value on SPRC0: 0x001F0000                                  */
/* Register default value on SPRMCC: 0x001F0000                                 */
/* Register default value on SPRUCC: 0x001F0000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: BIOS_W                                           */
/* SPRB0 Security PolicyGroup: BIOS_W                                           */
/* SPRHBM Security PolicyGroup: BIOS_W                                          */
/* SPRC0 Security PolicyGroup: BIOS_W                                           */
/* SPRMCC Security PolicyGroup: BIOS_W                                          */
/* SPRUCC Security PolicyGroup: BIOS_W                                          */
/*  This register contains disable bits for internal errors from mc2lmmisc
*/


#define DIS_INTERNAL_ERROR_2LMMISC_N1_MC_MAIN_REG 0x07020F7C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dis_decs_patrol_retry_confl : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_cmi_cpl_fifo_uf : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_cmi_cpl_fifo_of : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_cmi_cpl_cmd_fifo_uf : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_cmi_cpl_cmd_fifo_of : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_cmi_cpl_late_viol : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_cmi_cpl_late_viol_2 : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_cmi_cpl_late_viol_3 : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_cmi_cpl_data_viol : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_cmi_cpl_data_viol_2 : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_cmi_req_viol : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_cmi_rsp_viol_1 : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_cmi_rsp_viol_2 : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_cmi_rsp_viol_3 : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_sb_overflow : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_decs_wrong_spr_rank : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_ddrt_rpq_valid_idle : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000001*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_ddrt_wpq_valid_idle : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000001*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_ddrt2_wrcrdt_starvation : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000001*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_ddrt2_tgr_starvation : 1;

                            /* Bits[19:19], Access Type=RW, default=0x00000001*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 ddrt2_illegal_conditions : 1;

                            /* Bits[20:20], Access Type=RW, default=0x00000001*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_sbtag_fifo_overflow : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 dis_mc2lm_sbtag_fifo_underflow : 1;

                            /* Bits[22:22], Access Type=RW, default=0x00000000*/

                            /*
                               Disable corresponding error in
                               internal_error_2lmmisc register
                            */
    UINT32 rsvd : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} DIS_INTERNAL_ERROR_2LMMISC_N1_MC_MAIN_STRUCT;

/* MC_CPGC_CTL_MC_MAIN_REG supported on:                                        */
/*      SPRA0 (0x20020f80)                                                      */
/*      SPRB0 (0x20020f80)                                                      */
/*      SPRHBM (0x20020f80)                                                     */
/*      SPRC0 (0x20020f80)                                                      */
/*      SPRMCC (0x20020f80)                                                     */
/*      SPRUCC (0x20020f80)                                                     */
/* Register default value on SPRA0: 0x00030000                                  */
/* Register default value on SPRB0: 0x00030000                                  */
/* Register default value on SPRHBM: 0x00030000                                 */
/* Register default value on SPRC0: 0x00030000                                  */
/* Register default value on SPRMCC: 0x00030000                                 */
/* Register default value on SPRUCC: 0x00030000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* MC Controls for the CPGC SubIP
*/


#define MC_CPGC_CTL_MC_MAIN_REG 0x07020F80

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 cpgc_safe_mode : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               0x0 = Clock gating operates as usual 0x1 = CPGC
                               clock forced to enabled
                            */
    UINT32 cpgc_reset : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               0x0 = No manual reset asserted from this CR, 0x1
                               = Manual warm reset asserted (bios needs to
                               clear this bit after setting it)
                            */
    UINT32 cpgc_htid_replace : 2;

                            /* Bits[3:2], Access Type=RW, default=0x00000000*/

                            /*
                               0x0 = Replace HTID with contiguous sequenc
                               (0,1,2..) 0x1 = Replace HTID with even sequenc
                               (0,2,4..) 0x2 = Replace HTID with oddsequenc
                               (1,3,5..) 0x3 = Use HTID that came over CMI from
                               CPGC,
                            */
    UINT32 cpgc_htid_reset : 1;

                            /* Bits[4:4], Access Type=RW/V, default=0x00000000*/

                            /*
                               Self clearing CR where HTID replacement values
                               are cleared
                            */
    UINT32 cpgc_reqlen_replace : 2;

                            /* Bits[6:5], Access Type=RW, default=0x00000000*/

                            /*
                               0x0 = No Replace 0x1 = No Replace 0x2 = Replace
                               CPGC ReqLen with 0 0x3 = Replace CPGC ReqLen
                               with 1
                            */
    UINT32 cpgc_disable_sb_wakeup : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               0x0 = CRNode Request Addr bit 0 wakes up CPGC
                               0x1 = CRNode Request Addr bit 0 doesn't wake up
                               CPGC
                            */
    UINT32 cpgc_nocs_rank_en : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               If set, MC will supress traffic CS to the rank
                               specified in cpgc_nocs_rank_match
                            */
    UINT32 cpgc_nocs_rank_match : 3;

                            /* Bits[11:9], Access Type=RW, default=0x00000000*/

                            /*
                               MC will supress traffic CS to the rank specified
                               by this value if cpgc_nocs_rank_en is set
                            */
    UINT32 cpgc_mixed_ddrt_rank_en : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               If set, MC will send traffic to DDRT for rank
                               specified in cpgc_mixed_ddrt_rank_match
                            */
    UINT32 cpgc_mixed_ddrt_rank_match : 3;

                            /* Bits[15:13], Access Type=RW, default=0x00000000*/

                            /*
                               MC will send traffic to DDRT for the rank
                               specified by this value if
                               cpgc_mixed_ddrt_rank_en is set
                            */
    UINT32 cpgc_bank_map : 1;

                            /* Bits[16:16], Access Type=RW, default=0x00000001*/

                            /*
                               0x0 = BG[1:0] and BA[1:0] are swapped (like
                               normal functional traffic bank) 0x1 = CPGC Bank
                               outputed from the CPGC is 1:1 mapped to the
                               scheduler
                            */
    UINT32 cpgc_use_chan_id : 1;

                            /* Bits[17:17], Access Type=RW, default=0x00000001*/

                            /*
                               0x0 = CPGC Rank is Sched Rank (rank bit 0 =
                               pseudochan) 0x1 = Sched Rank bit 0 is fixed to
                               pseudochan strap, sched rank bit 1 is cpgc rank
                               bit 0
                            */
    UINT32 cpgc_use_critical_bit : 1;

                            /* Bits[18:18], Access Type=RW, default=0x00000000*/

                            /*
                               0x0 = DDR5-only - shifts column to have cpgc lsb
                               at CA4 0x1 = Disables the shift and has cpgc lsb
                               at CA3 (like ddr4)
                            */
    UINT32 rsvd : 13;

                            /* Bits[31:19], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MC_CPGC_CTL_MC_MAIN_STRUCT;

/* MC_CPGC_RANK_MAP_MC_MAIN_REG supported on:                                   */
/*      SPRA0 (0x20020f84)                                                      */
/*      SPRB0 (0x20020f84)                                                      */
/*      SPRHBM (0x20020f84)                                                     */
/*      SPRC0 (0x20020f84)                                                      */
/*      SPRMCC (0x20020f84)                                                     */
/*      SPRUCC (0x20020f84)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* CPGC Logical to Physical Rank Lookup Table -
This CR is used to program the Logical to Physical Rank Mapping.
The user must define what Physical Ranks are associated with each Logical Rank, and that only valid physical ranks are programmed into this register.
*/


#define MC_CPGC_RANK_MAP_MC_MAIN_REG 0x07020F84

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rank0_mapping : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               Defines what Physical Rank Address (Memory
                               controller Rank Mapping) is mapped to this
                               logical Rank Address-0 (Sequence Address logic
                               doamin). It is possible to use more
                               Logical_to_Physical_Rank#_Mapping fileds than
                               actual Physical Ranks which is useful for more
                               complex tests where non linear Physical Rank
                               Sequences are needed.
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank1_mapping : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* Rank Address-1 mapping */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank2_mapping : 3;

                            /* Bits[10:8], Access Type=RW, default=0x00000000*/

                            /* Rank Address-2 mapping */
    UINT32 rsvd_11 : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank3_mapping : 3;

                            /* Bits[14:12], Access Type=RW, default=0x00000000*/

                            /* Rank Address-3 mapping */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank4_mapping : 3;

                            /* Bits[18:16], Access Type=RW, default=0x00000000*/

                            /* Rank Address-4 mapping */
    UINT32 rsvd_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank5_mapping : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /* Rank Address-5 mapping */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank6_mapping : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* Rank Address-6 mapping */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank7_mapping : 3;

                            /* Bits[30:28], Access Type=RW, default=0x00000000*/

                            /* Rank Address-7 mapping */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MC_CPGC_RANK_MAP_MC_MAIN_STRUCT;

/* MC_CPGC_SUBRANK_MAP_MC_MAIN_REG supported on:                                */
/*      SPRA0 (0x20020f90)                                                      */
/*      SPRB0 (0x20020f90)                                                      */
/*      SPRHBM (0x20020f90)                                                     */
/*      SPRC0 (0x20020f90)                                                      */
/*      SPRMCC (0x20020f90)                                                     */
/*      SPRUCC (0x20020f90)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRB0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRHBM Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRC0 Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR    */
/* SPRMCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* SPRUCC Register File:    sprsp_top/mc_reg[0]/mc_dec_crnode/MEM_MCMAINS_CSR   */
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC                                             */
/* SPRB0 Security PolicyGroup: CPGC                                             */
/* SPRHBM Security PolicyGroup: CPGC                                            */
/* SPRC0 Security PolicyGroup: CPGC                                             */
/* SPRMCC Security PolicyGroup: CPGC                                            */
/* SPRUCC Security PolicyGroup: CPGC                                            */
/* CPGC Logical to Physical SubRank Lookup Table -
This CR is used to program the Logical to Physical SubRank Mapping.
The user must define what Physical SubRanks are associated with each Logical Rank, and that only valid physical ranks are programmed into this register.
*/


#define MC_CPGC_SUBRANK_MAP_MC_MAIN_REG 0x07020F90

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rank0_mapping : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               Defines what Physical Rank Address (Memory
                               controller Rank Mapping) is mapped to this
                               logical Rank Address-0 (Sequence Address logic
                               doamin). It is possible to use more
                               Logical_to_Physical_Rank#_Mapping fileds than
                               actual Physical Ranks which is useful for more
                               complex tests where non linear Physical Rank
                               Sequences are needed.
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank1_mapping : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /* Rank Address-1 mapping */
    UINT32 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank2_mapping : 3;

                            /* Bits[10:8], Access Type=RW, default=0x00000000*/

                            /* Rank Address-2 mapping */
    UINT32 rsvd_11 : 1;

                            /* Bits[11:11], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank3_mapping : 3;

                            /* Bits[14:12], Access Type=RW, default=0x00000000*/

                            /* Rank Address-3 mapping */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank4_mapping : 3;

                            /* Bits[18:16], Access Type=RW, default=0x00000000*/

                            /* Rank Address-4 mapping */
    UINT32 rsvd_19 : 1;

                            /* Bits[19:19], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank5_mapping : 3;

                            /* Bits[22:20], Access Type=RW, default=0x00000000*/

                            /* Rank Address-5 mapping */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank6_mapping : 3;

                            /* Bits[26:24], Access Type=RW, default=0x00000000*/

                            /* Rank Address-6 mapping */
    UINT32 rsvd_27 : 1;

                            /* Bits[27:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank7_mapping : 3;

                            /* Bits[30:28], Access Type=RW, default=0x00000000*/

                            /* Rank Address-7 mapping */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} MC_CPGC_SUBRANK_MAP_MC_MAIN_STRUCT;
#endif /* _MC_MAIN_h */
