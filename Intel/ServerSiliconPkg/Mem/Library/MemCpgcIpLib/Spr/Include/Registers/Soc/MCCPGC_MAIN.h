
/** @file
  MCCPGC_MAIN.h

  @copyright
  INTEL CONFIDENTIAL
  Copyright 2007 - 2020 Intel Corporation. <BR>
  
  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.
  
  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.
  
  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
  
  This file contains Silicon register definitions.
  
  This is a generated file; please do not modify it directly.
  
**/

/* The following security policy groups are used by registers in this file:     */

/* SPRA0 Security Policy Groups:                                                */
/* CPGC_PROTECTED                                                               */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRB0 Security Policy Groups:                                                */
/* CPGC_PROTECTED                                                               */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRHBM Security Policy Groups:                                               */
/* CPGC_PROTECTED                                                               */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRC0 Security Policy Groups:                                                */
/* CPGC_PROTECTED                                                               */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRMCC Security Policy Groups:                                               */
/* CPGC_PROTECTED                                                               */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */

/* SPRUCC Security Policy Groups:                                               */
/* CPGC_PROTECTED                                                               */
/*  Security_Read_CP_Secured:                                                   */
/*    0                                                                         */


#ifndef _MCCPGC_MAIN_h
#define _MCCPGC_MAIN_h
#include <Base.h>









/* CPGC2_STG_CHICKEN_N0_MCCPGC_MAIN_REG supported on:                           */
/*      SPRA0 (0x20009020)                                                      */
/*      SPRB0 (0x20009020)                                                      */
/*      SPRHBM (0x20009020)                                                     */
/*      SPRC0 (0x20009020)                                                      */
/*      SPRMCC (0x20009020)                                                     */
/*      SPRUCC (0x20009020)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Storage utilization Configuration and Status
*/


#define CPGC2_STG_CHICKEN_N0_MCCPGC_MAIN_REG 0x28029020

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rtn_wtrmrk : 16;

                            /* Bits[15:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               This indicates the utilization (WaterMark) of
                               the upper 4 Cache Lines of the Read Return
                               Buffer, with a resolution for each section. [br]
                               Bits [3 : 0] : Section 0, upper 4 buffer
                               locations[br] Bits [7 : 4] : Section 1, upper 4
                               buffer locations[br] Bits [11 : 8] : Section 2,
                               upper 4 buffer locations[br] Bits [15 : 12]:
                               Section 3, upper 4 buffer locations[br] If the
                               number of sections are lesser than 4, then the
                               relevant bits start from 0, upto 4 *
                               NUM_SECTIONS
                            */
    UINT32 stg_wtrmrk : 16;

                            /* Bits[31:16], Access Type=RO/V, default=0x00000000*/

                            /*
                               This indicates the utilization (WaterMark) of
                               the upper 4 Cache Lines of the Write Storage
                               Buffer, with a resolution for each section. [br]
                               Bits [3 : 0] : Section 0, upper 4 buffer
                               locations[br] Bits [7 : 4] : Section 1, upper 4
                               buffer locations[br] Bits [11 : 8] : Section 2,
                               upper 4 buffer locations[br] Bits [15 : 12]:
                               Section 3, upper 4 buffer locations[br] If the
                               number of sections are lesser than 4, then the
                               relevant bits start from 0, upto 4 *
                               NUM_SECTIONS
                            */

  } Bits;
  UINT32 Data;

} CPGC2_STG_CHICKEN_N0_MCCPGC_MAIN_STRUCT;

/* CPGC2_STG_CHICKEN_N1_MCCPGC_MAIN_REG supported on:                           */
/*      SPRA0 (0x20009024)                                                      */
/*      SPRB0 (0x20009024)                                                      */
/*      SPRHBM (0x20009024)                                                     */
/*      SPRC0 (0x20009024)                                                      */
/*      SPRMCC (0x20009024)                                                     */
/*      SPRUCC (0x20009024)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Storage utilization Configuration and Status
*/


#define CPGC2_STG_CHICKEN_N1_MCCPGC_MAIN_REG 0x28029024

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rtn_preload : 16;

                            /* Bits[15:0], Access Type=RW/P, default=0x00000000*/

                            /*
                               The first 4 entries in the read return buffer
                               can be preloaded, to not utilize them during the
                               test.[br] Each section's preload can be set
                               individually.[br] Bits [3 : 0] : Section 0,
                               lower 4 buffer locations[br] Bits [7 : 4] :
                               Section 1, lower 4 buffer locations[br] Bits [11
                               : 8] : Section 2, lower 4 buffer locations[br]
                               Bits [15 : 12]: Section 3, lower 4 buffer
                               locations[br] If the number of sections are
                               lesser than 4, then the relevant bits start from
                               0, upto 4 * NUM_SECTIONS
                            */
    UINT32 stg_preload : 16;

                            /* Bits[31:16], Access Type=RW/P, default=0x00000000*/

                            /*
                               The first 4 entries in the write storage buffer
                               can be preloaded, to not utilize them during the
                               test.[br] Each section's preload can be set
                               individually.[br] Bits [3 : 0] : Section 0,
                               lower 4 buffer locations[br] Bits [7 : 4] :
                               Section 1, lower 4 buffer locations[br] Bits [11
                               : 8] : Section 2, lower 4 buffer locations[br]
                               Bits [15 : 12]: Section 3, lower 4 buffer
                               locations[br] If the number of sections are
                               lesser than 4, then the relevant bits start from
                               0, upto 4 * NUM_SECTIONS
                            */

  } Bits;
  UINT32 Data;

} CPGC2_STG_CHICKEN_N1_MCCPGC_MAIN_STRUCT;

/* CPGC2_CREDIT_MCCPGC_MAIN_REG supported on:                                   */
/*      SPRA0 (0x20009028)                                                      */
/*      SPRB0 (0x20009028)                                                      */
/*      SPRHBM (0x20009028)                                                     */
/*      SPRC0 (0x20009028)                                                      */
/*      SPRMCC (0x20009028)                                                     */
/*      SPRUCC (0x20009028)                                                     */
/* Register default value on SPRA0: 0x00000408                                  */
/* Register default value on SPRB0: 0x00000408                                  */
/* Register default value on SPRHBM: 0x00000408                                 */
/* Register default value on SPRC0: 0x00000408                                  */
/* Register default value on SPRMCC: 0x00000408                                 */
/* Register default value on SPRUCC: 0x00000408                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Used to configure initial credits before enabling.
*/


#define CPGC2_CREDIT_MCCPGC_MAIN_REG 0x28029028

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rd_cpl_credits_init : 8;

                            /* Bits[7:0], Access Type=RW/P, default=0x00000008*/

                            /*
                               This gives the number of read completion credits
                               that CPGC will advertise at negotiation. This is
                               the only source of this value. This field must
                               be set before the Credits Configuration Done
                               bit. Reset value is controlled by top level IP
                               parameter CPGC_RDRTN_SIZE.
                            */
    UINT32 rsp_credits_init : 8;

                            /* Bits[15:8], Access Type=RW/P, default=0x00000004*/

                            /*
                               This gives the number of response credits that
                               CPGC will advertise at negotiation. This is the
                               only source for this value. This field must be
                               set before the Credits Configuration Done bit.
                               Reset value is controlled by top level IP
                               parameter CPGC_RSPQ_SIZE.
                            */
    UINT32 rsvd : 8;

                            /* Bits[23:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 credits_config_done : 1;

                            /* Bits[24:24], Access Type=RW/P, default=0x00000000*/

                            /*
                               This bit must be set once the desired number of
                               credits have been placed in the CREDIT_CFG
                               register, and before any CPGC traffic. Also
                               never clear this bit unless you intend on doing
                               a Warm Reset immediately following.
                            */
    UINT32 rsvd_25 : 1;

                            /* Bits[25:25], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd_26 : 1;

                            /* Bits[26:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rsvd_27 : 3;

                            /* Bits[29:27], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ism_idle : 1;

                            /* Bits[30:30], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit will be set when the credit ISM is in
                               the ISM_IDLE state, normally only if all
                               channels are not in the BUSY state(s). This can
                               be used to confirm that it is safe to switch the
                               memory interface back to the system path. The
                               FORCE_ISM_ACTIVE bit would prevent this bit from
                               returning to a 1, so that bit must be cleared if
                               the ISM is shared between the modes.
                            */
    UINT32 credits_initialized : 1;

                            /* Bits[31:31], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit will be set when the credit negotiation
                               process is complete. (This bit is replicated to
                               each request generator CPGC_SEQ_STATUS for
                               convenience)
                            */

  } Bits;
  UINT32 Data;

} CPGC2_CREDIT_MCCPGC_MAIN_STRUCT;

/* CPGC2_V_CHICKEN_MCCPGC_MAIN_REG supported on:                                */
/*      SPRA0 (0x2000902c)                                                      */
/*      SPRB0 (0x2000902c)                                                      */
/*      SPRHBM (0x2000902c)                                                     */
/*      SPRC0 (0x2000902c)                                                      */
/*      SPRMCC (0x2000902c)                                                     */
/*      SPRUCC (0x2000902c)                                                     */
/* Register default value on SPRA0: 0x00000808                                  */
/* Register default value on SPRB0: 0x00000808                                  */
/* Register default value on SPRHBM: 0x00000808                                 */
/* Register default value on SPRC0: 0x00000808                                  */
/* Register default value on SPRMCC: 0x00000808                                 */
/* Register default value on SPRUCC: 0x00000808                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_shared/cpgc_v/cpgc_v_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Chicken Internal Credit Config
*/


#define CPGC2_V_CHICKEN_MCCPGC_MAIN_REG 0x2802902C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 xpq_ch_credit : 6;

                            /* Bits[5:0], Access Type=RW/P, default=0x00000008*/

                            /*
                               This gives the desired overridden value for the
                               XPQ credits per channel in max channel case.
                               Should be from localparam of XPQ_SIZE /
                               NUM_CHANNELS if no pooled entries. Actual Reset
                               value is hardware dependent based on IP resource
                               definitions for the storage size.
                            */
    UINT32 rsvd : 1;

                            /* Bits[6:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 xpq_ch_override : 1;

                            /* Bits[7:7], Access Type=RW/P, default=0x00000000*/

                            /* Override the number of XPQ credits per channel. */
    UINT32 stg_ch_credit : 6;

                            /* Bits[13:8], Access Type=RW/P, default=0x00000008*/

                            /*
                               This sets the desired overridden value for the
                               number of storage credits for each channel in
                               the max channel case. Should be from localparam
                               of (4 * STG_SIZE / NUM_CHANNELS) if no pooled
                               entries. Actual Reset value is hardware
                               dependent based on IP resource definitions for
                               the storage size.
                            */
    UINT32 rsvd_14 : 1;

                            /* Bits[14:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 stg_ch_override : 1;

                            /* Bits[15:15], Access Type=RW/P, default=0x00000000*/

                            /*
                               Override the number of STG credits per channel.
                               Measured in minimum Dpat size units.
                            */
    UINT32 rtn_bypass_disable : 1;

                            /* Bits[16:16], Access Type=RW/P, default=0x00000000*/

                            /*
                               This disables the Bypass of the Read Rtn during
                               completions. This is effective only in a config
                               with atleast 1 channel requiring Return storage.
                            */
    UINT32 axi_order_mode : 1;

                            /* Bits[17:17], Access Type=RW/P, default=0x00000000*/

                            /*
                               This enables the overriding of the TIDs on
                               outbound data to all 0's so that AXI will keep
                               transactions in-order. The default value of this
                               field is determined by whether the AXI interface
                               has been instantiated.
                            */
    UINT32 rsvd_18 : 6;

                            /* Bits[23:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 mpr_test_req_dblr : 1;

                            /* Bits[24:24], Access Type=RW/P, default=0x00000000*/

                            /*
                               This turns a read request into two at the memory
                               interface, dummying up the TID, and combines two
                               returns into the same TID. Used only for x16
                               interface where MPR/MPC/MRR is BL16 instead of
                               the native BL32 and the IP does not have 32Byte
                               Support.
                            */
    UINT32 rsvd_25 : 6;

                            /* Bits[30:25], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 internal_err : 1;

                            /* Bits[31:31], Access Type=RO/V, default=0x00000000*/

                            /*
                               If this bit is set, an internal error has
                               occurred (fifo/queue overflow etc). The only way
                               to recover is to give a warm reset. This bit is
                               replicated to each request generator
                               CPGC_SEQ_STATUS for convenience.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_V_CHICKEN_MCCPGC_MAIN_STRUCT;

/* CPGC2_ADDRESS_CONTROL_MCCPGC_MAIN_REG supported on:                          */
/*      SPRA0 (0x20009030)                                                      */
/*      SPRB0 (0x20009030)                                                      */
/*      SPRHBM (0x20009030)                                                     */
/*      SPRC0 (0x20009030)                                                      */
/*      SPRMCC (0x20009030)                                                     */
/*      SPRUCC (0x20009030)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Address Control register controlling Address_Decode_Repeats and Address Based Address Inversion enables.
*/


#define CPGC2_ADDRESS_CONTROL_MCCPGC_MAIN_REG 0x28029030

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 address_decode_rotate_repeats : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               Number of times the current Address_Instruction
                               will repeat if Address_Decode_Enable is set. As
                               N-1. (0=1 time.)[br] If Address_Decode_Enable is
                               set for the current Address_Instruction,
                               then:[br] At the start of that
                               Address_Instruction, initialize the
                               XOR_Address_Pattern to a single 1 in the LSB of
                               lowest Address field (given the Address
                               instructions Address Order and Address
                               Direction). Otherwise it is initialized to all
                               zeros.[br] For
                               (Address_Decode_Rotate_Repeat_Current = 0;
                               Current_ Address_Decode_Rotate_Repeat_Current <=
                               Address_Decode_Rotate_Repeat;
                               Address_Decode_Rotate_Repeat_Current ++)[br]
                               Execute the entire Algorithm (Block Traversal,
                               Algorithm_Instruction, Commands) with the
                               following behavior:[br] At the end of each
                               complete Block Traversal, rotate the XOR Address
                               Pattern 1 bit position from Address LSB to MSB
                               (passing through any 0-length address fields)
                               again based on the Address Order and
                               Direction.[br] The number of bits in each
                               Address field are defined based on the
                               Region_Size settings.[br] Region_Size.Max_Bank
                               and Region_Size.Max_Rank numbers are converted
                               to the equivalent number of address bits to
                               cover their range (ceil(log2(Max+1))) and should
                               be programmed to a power of 2 value (minus 1):
                               0,1,3,7,15 or 31.
                            */
    UINT32 rsvd : 10;

                            /* Bits[15:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 fasty_address_order : 3;

                            /* Bits[18:16], Access Type=RW, default=0x00000000*/

                            /*
                               FastY version of Address Order.[br] Has same
                               definition as Address Instruction register
                               Address Order field.[br] Takes effect when
                               CPGC2_ALGORITHM_INSTRUCTION_CTRL.FastY_Init is
                               set.
                            */
    UINT32 fasty_address_direction : 3;

                            /* Bits[21:19], Access Type=RW, default=0x00000000*/

                            /*
                               FastY version of Address Direction.[br] Has same
                               definition as Address Instruction register
                               Address Direction field.[br] Takes effect when
                               CPGC2_ALGORITHM_INSTRUCTION_CTRL.FastY_Init is
                               set.
                            */
    UINT32 rsvd_22 : 2;

                            /* Bits[23:22], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 column_addr_invert_select : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               Selection of enable signal for inverting the
                               entire Column address.[br] 00 = No Inversion[br]
                               01 = Colum Address[0][br] 10 = Row Address
                               [0][br] 11 = Bank Address [0][br] If using the
                               Column Address, the Col[0] will always appear to
                               be '0' and would commonly be eliminated within
                               the Swizzle settings.
                            */
    UINT32 row_addr_invert_select : 2;

                            /* Bits[27:26], Access Type=RW, default=0x00000000*/

                            /*
                               Selection of enable signal for inverting the
                               entire Row address.[br] 00 = No Inversion[br] 01
                               = Colum Address[0][br] 10 = Row Address [0][br]
                               11 = Bank Address [0][br] If using the Row
                               Address, the Row[0] will always appear to be '0'
                               and would commonly be eliminated within the
                               Swizzle settings.
                            */
    UINT32 bank_addr_invert_select : 2;

                            /* Bits[29:28], Access Type=RW, default=0x00000000*/

                            /*
                               Selection of enable signal for inverting the
                               entire Bank address.[br] 00 = No Inversion[br]
                               01 = Colum Address[0][br] 10 = Row Address
                               [0][br] 11 = Bank Address [0][br] If using the
                               Bank Address, the Bank[0] will always appear to
                               be '0' and would commonly be eliminated within
                               the Swizzle settings.
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC2_ADDRESS_CONTROL_MCCPGC_MAIN_STRUCT;

/* CPGC2_ADDRESS_INSTRUCTION_0_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x9034)                                                          */
/*      SPRB0 (0x9034)                                                          */
/*      SPRHBM (0x9034)                                                         */
/*      SPRC0 (0x9034)                                                          */
/*      SPRMCC (0x9034)                                                         */
/*      SPRUCC (0x9034)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Address Instruction controlling Address_Order and Address_Direction reversal and decode rotation/loop.
*/


#define CPGC2_ADDRESS_INSTRUCTION_0_MCCPGC_MAIN_REG 0x28009034

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 address_order : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               Controls the fastest changing address field, and
                               how that carries into higher order fields.[br]
                               000 - Rank <- Bank <- Row/Col[br] 001 - Rank <-
                               Row/Col <- Bank[br] 010 - Bank <- Rank <-
                               Row/Col[br] 011 - Bank <- Row/Col <- Rank[br]
                               100 - Row/Col <- Rank <- Bank[br] 101 - Row/Col
                               <- Bank <- Rank[br] 110 - Row/Col (Used for
                               Offset) Rank and Bank are unchanged.[br] 111 -
                               Row or Col (Used for Stripe Offset) No Carry
                               from any field to another.[br] Carry Order
                               between Row and Column is dependent on the
                               Address_Direction field.
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] Incrementing
                               fields start at 0, and Decrementing fields start
                               at 2^(field_block_size)-2^(field_increment)= top
                               of block.[br] Initial field values are shown as
                               (Ra,Ba,Ro,Co) with L being 0 and H being
                               max.[br] [br] (0)(00) FastY - North[br]
                               Increment Column and Carry Increment Row.[br]
                               (L,L,L,L) (Row <+ Column++)[br] (1)(00)
                               Inv(FastY) - South[br] Decrement Column and
                               Carry Decrement Row.[br] (H,H,H,H) (Row <-
                               Column--)[br] (0)(01) Diagonal North East[br]
                               Increment Column and Row together and Carry
                               Increment Row.[br] (L,L,L,L) (Row++ <+
                               Column++)[br] (1)(01) Inv(Diagonal) South
                               West[br] Decrement Column and Row together and
                               Carry Decrement Row.[br] (H,H,H,H) (Row-- <-
                               Column--)[br] (0)(10) Diagonal2 South East[br]
                               Decrement Column and Increment Row together and
                               Carry Increment Row.[br] (H,H,L,H) (Row++ <+
                               Column--)[br] (1)(10) Inv(Diagonal2) - North
                               West[br] Increment Column and Decrement Row
                               together and Carry Decrement Row.[br] (L,L,H,L)
                               (Row-- <- Column++)[br] (0)(11) FastX - East[br]
                               Increment Row and Carry Increment Column.[br]
                               (L,L,L,L) (Column <+ Row++)[br] (1)(11)
                               Inv(FastX) West [br] Decrement Row and Carry
                               Decrement Column.[br] (L,L,L,L) (Column <-
                               Row--)[br] [br] Notes:[br] Bank and Rank Address
                               direction follows the same as the Column
                               (Increment or Decrement).[br] Diagonal direction
                               Carry results in twice the normal
                               Increment/Decrement of the Row field.[br] East
                               and West are the only directions where Row is
                               Lower in Address Order.[br] Incrementing fields
                               start at (L) = 0[br] Decrementing fields start
                               at (H) =
                               2^(field_block_size)-2^(field_increment). One
                               Increment shy of 0.
                            */
    UINT8 address_decode_enable : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits. Used in
                               concert with the Address_Decode_Enable field in
                               the Command_Instruction list.[br] This bit
                               enables repeating of the current
                               Address_Instruction for
                               Address_Decode_Rotate_Repeats times.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set, then this is the last Address
                               Instruction and the test will terminate
                               following full execution of this instruction. If
                               there are no Last bits set in the Address
                               Instruction list, then the test will not stop
                               due to a completion of the test, but will be an
                               Infinite Test.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ADDRESS_INSTRUCTION_0_MCCPGC_MAIN_STRUCT;

/* CPGC2_ADDRESS_INSTRUCTION_1_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x9035)                                                          */
/*      SPRB0 (0x9035)                                                          */
/*      SPRHBM (0x9035)                                                         */
/*      SPRC0 (0x9035)                                                          */
/*      SPRMCC (0x9035)                                                         */
/*      SPRUCC (0x9035)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Address Instruction controlling Address_Order and Address_Direction reversal and decode rotation/loop.
*/


#define CPGC2_ADDRESS_INSTRUCTION_1_MCCPGC_MAIN_REG 0x28009035

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 address_order : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               Controls the fastest changing address field, and
                               how that carries into higher order fields.[br]
                               000 - Rank <- Bank <- Row/Col[br] 001 - Rank <-
                               Row/Col <- Bank[br] 010 - Bank <- Rank <-
                               Row/Col[br] 011 - Bank <- Row/Col <- Rank[br]
                               100 - Row/Col <- Rank <- Bank[br] 101 - Row/Col
                               <- Bank <- Rank[br] 110 - Row/Col (Used for
                               Offset) Rank and Bank are unchanged.[br] 111 -
                               Row or Col (Used for Stripe Offset) No Carry
                               from any field to another.[br] Carry Order
                               between Row and Column is dependent on the
                               Address_Direction field.
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] Incrementing
                               fields start at 0, and Decrementing fields start
                               at 2^(field_block_size)-2^(field_increment)= top
                               of block.[br] Initial field values are shown as
                               (Ra,Ba,Ro,Co) with L being 0 and H being
                               max.[br] [br] (0)(00) FastY - North[br]
                               Increment Column and Carry Increment Row.[br]
                               (L,L,L,L) (Row <+ Column++)[br] (1)(00)
                               Inv(FastY) - South[br] Decrement Column and
                               Carry Decrement Row.[br] (H,H,H,H) (Row <-
                               Column--)[br] (0)(01) Diagonal North East[br]
                               Increment Column and Row together and Carry
                               Increment Row.[br] (L,L,L,L) (Row++ <+
                               Column++)[br] (1)(01) Inv(Diagonal) South
                               West[br] Decrement Column and Row together and
                               Carry Decrement Row.[br] (H,H,H,H) (Row-- <-
                               Column--)[br] (0)(10) Diagonal2 South East[br]
                               Decrement Column and Increment Row together and
                               Carry Increment Row.[br] (H,H,L,H) (Row++ <+
                               Column--)[br] (1)(10) Inv(Diagonal2) - North
                               West[br] Increment Column and Decrement Row
                               together and Carry Decrement Row.[br] (L,L,H,L)
                               (Row-- <- Column++)[br] (0)(11) FastX - East[br]
                               Increment Row and Carry Increment Column.[br]
                               (L,L,L,L) (Column <+ Row++)[br] (1)(11)
                               Inv(FastX) West [br] Decrement Row and Carry
                               Decrement Column.[br] (L,L,L,L) (Column <-
                               Row--)[br] [br] Notes:[br] Bank and Rank Address
                               direction follows the same as the Column
                               (Increment or Decrement).[br] Diagonal direction
                               Carry results in twice the normal
                               Increment/Decrement of the Row field.[br] East
                               and West are the only directions where Row is
                               Lower in Address Order.[br] Incrementing fields
                               start at (L) = 0[br] Decrementing fields start
                               at (H) =
                               2^(field_block_size)-2^(field_increment). One
                               Increment shy of 0.
                            */
    UINT8 address_decode_enable : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits. Used in
                               concert with the Address_Decode_Enable field in
                               the Command_Instruction list.[br] This bit
                               enables repeating of the current
                               Address_Instruction for
                               Address_Decode_Rotate_Repeats times.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set, then this is the last Address
                               Instruction and the test will terminate
                               following full execution of this instruction. If
                               there are no Last bits set in the Address
                               Instruction list, then the test will not stop
                               due to a completion of the test, but will be an
                               Infinite Test.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ADDRESS_INSTRUCTION_1_MCCPGC_MAIN_STRUCT;

/* CPGC2_ADDRESS_INSTRUCTION_2_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x9036)                                                          */
/*      SPRB0 (0x9036)                                                          */
/*      SPRHBM (0x9036)                                                         */
/*      SPRC0 (0x9036)                                                          */
/*      SPRMCC (0x9036)                                                         */
/*      SPRUCC (0x9036)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Address Instruction controlling Address_Order and Address_Direction reversal and decode rotation/loop.
*/


#define CPGC2_ADDRESS_INSTRUCTION_2_MCCPGC_MAIN_REG 0x28009036

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 address_order : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               Controls the fastest changing address field, and
                               how that carries into higher order fields.[br]
                               000 - Rank <- Bank <- Row/Col[br] 001 - Rank <-
                               Row/Col <- Bank[br] 010 - Bank <- Rank <-
                               Row/Col[br] 011 - Bank <- Row/Col <- Rank[br]
                               100 - Row/Col <- Rank <- Bank[br] 101 - Row/Col
                               <- Bank <- Rank[br] 110 - Row/Col (Used for
                               Offset) Rank and Bank are unchanged.[br] 111 -
                               Row or Col (Used for Stripe Offset) No Carry
                               from any field to another.[br] Carry Order
                               between Row and Column is dependent on the
                               Address_Direction field.
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] Incrementing
                               fields start at 0, and Decrementing fields start
                               at 2^(field_block_size)-2^(field_increment)= top
                               of block.[br] Initial field values are shown as
                               (Ra,Ba,Ro,Co) with L being 0 and H being
                               max.[br] [br] (0)(00) FastY - North[br]
                               Increment Column and Carry Increment Row.[br]
                               (L,L,L,L) (Row <+ Column++)[br] (1)(00)
                               Inv(FastY) - South[br] Decrement Column and
                               Carry Decrement Row.[br] (H,H,H,H) (Row <-
                               Column--)[br] (0)(01) Diagonal North East[br]
                               Increment Column and Row together and Carry
                               Increment Row.[br] (L,L,L,L) (Row++ <+
                               Column++)[br] (1)(01) Inv(Diagonal) South
                               West[br] Decrement Column and Row together and
                               Carry Decrement Row.[br] (H,H,H,H) (Row-- <-
                               Column--)[br] (0)(10) Diagonal2 South East[br]
                               Decrement Column and Increment Row together and
                               Carry Increment Row.[br] (H,H,L,H) (Row++ <+
                               Column--)[br] (1)(10) Inv(Diagonal2) - North
                               West[br] Increment Column and Decrement Row
                               together and Carry Decrement Row.[br] (L,L,H,L)
                               (Row-- <- Column++)[br] (0)(11) FastX - East[br]
                               Increment Row and Carry Increment Column.[br]
                               (L,L,L,L) (Column <+ Row++)[br] (1)(11)
                               Inv(FastX) West [br] Decrement Row and Carry
                               Decrement Column.[br] (L,L,L,L) (Column <-
                               Row--)[br] [br] Notes:[br] Bank and Rank Address
                               direction follows the same as the Column
                               (Increment or Decrement).[br] Diagonal direction
                               Carry results in twice the normal
                               Increment/Decrement of the Row field.[br] East
                               and West are the only directions where Row is
                               Lower in Address Order.[br] Incrementing fields
                               start at (L) = 0[br] Decrementing fields start
                               at (H) =
                               2^(field_block_size)-2^(field_increment). One
                               Increment shy of 0.
                            */
    UINT8 address_decode_enable : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits. Used in
                               concert with the Address_Decode_Enable field in
                               the Command_Instruction list.[br] This bit
                               enables repeating of the current
                               Address_Instruction for
                               Address_Decode_Rotate_Repeats times.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set, then this is the last Address
                               Instruction and the test will terminate
                               following full execution of this instruction. If
                               there are no Last bits set in the Address
                               Instruction list, then the test will not stop
                               due to a completion of the test, but will be an
                               Infinite Test.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ADDRESS_INSTRUCTION_2_MCCPGC_MAIN_STRUCT;

/* CPGC2_ADDRESS_INSTRUCTION_3_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x9037)                                                          */
/*      SPRB0 (0x9037)                                                          */
/*      SPRHBM (0x9037)                                                         */
/*      SPRC0 (0x9037)                                                          */
/*      SPRMCC (0x9037)                                                         */
/*      SPRUCC (0x9037)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Address Instruction controlling Address_Order and Address_Direction reversal and decode rotation/loop.
*/


#define CPGC2_ADDRESS_INSTRUCTION_3_MCCPGC_MAIN_REG 0x28009037

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 address_order : 3;

                            /* Bits[2:0], Access Type=RW, default=0x00000000*/

                            /*
                               Controls the fastest changing address field, and
                               how that carries into higher order fields.[br]
                               000 - Rank <- Bank <- Row/Col[br] 001 - Rank <-
                               Row/Col <- Bank[br] 010 - Bank <- Rank <-
                               Row/Col[br] 011 - Bank <- Row/Col <- Rank[br]
                               100 - Row/Col <- Rank <- Bank[br] 101 - Row/Col
                               <- Bank <- Rank[br] 110 - Row/Col (Used for
                               Offset) Rank and Bank are unchanged.[br] 111 -
                               Row or Col (Used for Stripe Offset) No Carry
                               from any field to another.[br] Carry Order
                               between Row and Column is dependent on the
                               Address_Direction field.
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] Incrementing
                               fields start at 0, and Decrementing fields start
                               at 2^(field_block_size)-2^(field_increment)= top
                               of block.[br] Initial field values are shown as
                               (Ra,Ba,Ro,Co) with L being 0 and H being
                               max.[br] [br] (0)(00) FastY - North[br]
                               Increment Column and Carry Increment Row.[br]
                               (L,L,L,L) (Row <+ Column++)[br] (1)(00)
                               Inv(FastY) - South[br] Decrement Column and
                               Carry Decrement Row.[br] (H,H,H,H) (Row <-
                               Column--)[br] (0)(01) Diagonal North East[br]
                               Increment Column and Row together and Carry
                               Increment Row.[br] (L,L,L,L) (Row++ <+
                               Column++)[br] (1)(01) Inv(Diagonal) South
                               West[br] Decrement Column and Row together and
                               Carry Decrement Row.[br] (H,H,H,H) (Row-- <-
                               Column--)[br] (0)(10) Diagonal2 South East[br]
                               Decrement Column and Increment Row together and
                               Carry Increment Row.[br] (H,H,L,H) (Row++ <+
                               Column--)[br] (1)(10) Inv(Diagonal2) - North
                               West[br] Increment Column and Decrement Row
                               together and Carry Decrement Row.[br] (L,L,H,L)
                               (Row-- <- Column++)[br] (0)(11) FastX - East[br]
                               Increment Row and Carry Increment Column.[br]
                               (L,L,L,L) (Column <+ Row++)[br] (1)(11)
                               Inv(FastX) West [br] Decrement Row and Carry
                               Decrement Column.[br] (L,L,L,L) (Column <-
                               Row--)[br] [br] Notes:[br] Bank and Rank Address
                               direction follows the same as the Column
                               (Increment or Decrement).[br] Diagonal direction
                               Carry results in twice the normal
                               Increment/Decrement of the Row field.[br] East
                               and West are the only directions where Row is
                               Lower in Address Order.[br] Incrementing fields
                               start at (L) = 0[br] Decrementing fields start
                               at (H) =
                               2^(field_block_size)-2^(field_increment). One
                               Increment shy of 0.
                            */
    UINT8 address_decode_enable : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits. Used in
                               concert with the Address_Decode_Enable field in
                               the Command_Instruction list.[br] This bit
                               enables repeating of the current
                               Address_Instruction for
                               Address_Decode_Rotate_Repeats times.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set, then this is the last Address
                               Instruction and the test will terminate
                               following full execution of this instruction. If
                               there are no Last bits set in the Address
                               Instruction list, then the test will not stop
                               due to a completion of the test, but will be an
                               Infinite Test.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ADDRESS_INSTRUCTION_3_MCCPGC_MAIN_STRUCT;

/* CPGC2_DATA_CONTROL_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x20009038)                                                      */
/*      SPRB0 (0x20009038)                                                      */
/*      SPRHBM (0x20009038)                                                     */
/*      SPRC0 (0x20009038)                                                      */
/*      SPRMCC (0x20009038)                                                     */
/*      SPRUCC (0x20009038)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Number of times an enabled Data_Instruction will be repeated.
*/


#define CPGC2_DATA_CONTROL_MCCPGC_MAIN_REG 0x28029038

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_select_rotation_repeats : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               Any Data_Instruction with
                               Data_Select_Rotation_Enable will repeat this
                               many times. As N-1. (0=1 time).
                            */
    UINT32 rsvd : 24;

                            /* Bits[31:8], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC2_DATA_CONTROL_MCCPGC_MAIN_STRUCT;

/* CPGC2_DATA_INSTRUCTION_0_MCCPGC_MAIN_REG supported on:                       */
/*      SPRA0 (0x903c)                                                          */
/*      SPRB0 (0x903c)                                                          */
/*      SPRHBM (0x903c)                                                         */
/*      SPRC0 (0x903c)                                                          */
/*      SPRMCC (0x903c)                                                         */
/*      SPRUCC (0x903c)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Data Instruction controlling Alternate Data rotation, Background inversion pattern and Data Inversion.
*/


#define CPGC2_DATA_INSTRUCTION_0_MCCPGC_MAIN_REG 0x2800903C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 data_background : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               Examples:[br] If (Background_Mode == 0)[br]
                               Background - Entire transaction data inversion -
                               examples:[br] 0000 - Solid[br] 0001 - Column
                               Stripes (Column[0])[br] 0010 - Row Stripes
                               (Row[0])[br] 0011 - Checkerboard (Column[0] ^
                               Row[0])[br] 0100 - Double Column Stripes
                               (Column[1])[br] 1000 - Double Row Stripes
                               (Row[1])[br] Any combination of the above are
                               valid and 'combine'.[br] [br] if
                               (Background_Mode == 1)[br] Background - Chunk
                               Inversion mask [max:0] - examples:[br] 0000 - no
                               inversion[br] 1000 - 1111111100000000 (Invert
                               chunks 8-15)[br] 0100 - 1111000011110000 (Invert
                               chunks 15-12, 8-4)[br] 0010 - 1100110011001100
                               (Invert pairs of chunks)[br] 0001 -
                               1010101010101010 (Invert odd chunks)[br] Any
                               combination of the above are valid and
                               'combine'.[br] ex: 0110 - 0011110000111100[br]
                               The actual number of chunks is dependent on the
                               Data DQ width and the length of the transaction
                               and the Critical Chunk address bit as these
                               chunk numbers are always Cache Line address
                               aligned.
                            */
    UINT8 background_mode : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Set the interpretation of the Data_Background
                               field.[br] 0 = Invert the entire data based on
                               the selected combination of Column[1:0] and
                               Row[1:0]. Such as Row or Column stripes, or
                               Double Row or Column stripes.[br] 1 = Chunk
                               inversion based on the logical chunk number.
                            */
    UINT8 alt_data_rotate_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating Alternate Pattern Data.[br] This
                               bit enables repeating of the current
                               Data_Instruction for Data_Select_Rotation_Repeat
                               times.[br] Data generated using the Alternate
                               Pattern generation will rotate by one data bit
                               (LSB toward MSB) for each
                               Data_Select_Rotation_Repeat.[br] For the purpose
                               of this shift, the order follows the
                               Address_Instruction Address_Order and the
                               Address_Instruction[0] Address_Direction.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Globally Invert all data. Combined with the
                               Algorithm_Instruction Invert_Data field, and the
                               Command_Instruction or
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Data_Instruction indication, execution is
                               continued at Data_Instruction[0] if the test
                               does not otherwise terminate. This bit is
                               implied to be set for Data_Instruction[3].
                            */

  } Bits;
  UINT8 Data;

} CPGC2_DATA_INSTRUCTION_0_MCCPGC_MAIN_STRUCT;

/* CPGC2_DATA_INSTRUCTION_1_MCCPGC_MAIN_REG supported on:                       */
/*      SPRA0 (0x903d)                                                          */
/*      SPRB0 (0x903d)                                                          */
/*      SPRHBM (0x903d)                                                         */
/*      SPRC0 (0x903d)                                                          */
/*      SPRMCC (0x903d)                                                         */
/*      SPRUCC (0x903d)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Data Instruction controlling Alternate Data rotation, Background inversion pattern and Data Inversion.
*/


#define CPGC2_DATA_INSTRUCTION_1_MCCPGC_MAIN_REG 0x2800903D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 data_background : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               Examples:[br] If (Background_Mode == 0)[br]
                               Background - Entire transaction data inversion -
                               examples:[br] 0000 - Solid[br] 0001 - Column
                               Stripes (Column[0])[br] 0010 - Row Stripes
                               (Row[0])[br] 0011 - Checkerboard (Column[0] ^
                               Row[0])[br] 0100 - Double Column Stripes
                               (Column[1])[br] 1000 - Double Row Stripes
                               (Row[1])[br] Any combination of the above are
                               valid and 'combine'.[br] [br] if
                               (Background_Mode == 1)[br] Background - Chunk
                               Inversion mask [max:0] - examples:[br] 0000 - no
                               inversion[br] 1000 - 1111111100000000 (Invert
                               chunks 8-15)[br] 0100 - 1111000011110000 (Invert
                               chunks 15-12, 8-4)[br] 0010 - 1100110011001100
                               (Invert pairs of chunks)[br] 0001 -
                               1010101010101010 (Invert odd chunks)[br] Any
                               combination of the above are valid and
                               'combine'.[br] ex: 0110 - 0011110000111100[br]
                               The actual number of chunks is dependent on the
                               Data DQ width and the length of the transaction
                               and the Critical Chunk address bit as these
                               chunk numbers are always Cache Line address
                               aligned.
                            */
    UINT8 background_mode : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Set the interpretation of the Data_Background
                               field.[br] 0 = Invert the entire data based on
                               the selected combination of Column[1:0] and
                               Row[1:0]. Such as Row or Column stripes, or
                               Double Row or Column stripes.[br] 1 = Chunk
                               inversion based on the logical chunk number.
                            */
    UINT8 alt_data_rotate_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating Alternate Pattern Data.[br] This
                               bit enables repeating of the current
                               Data_Instruction for Data_Select_Rotation_Repeat
                               times.[br] Data generated using the Alternate
                               Pattern generation will rotate by one data bit
                               (LSB toward MSB) for each
                               Data_Select_Rotation_Repeat.[br] For the purpose
                               of this shift, the order follows the
                               Address_Instruction Address_Order and the
                               Address_Instruction[0] Address_Direction.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Globally Invert all data. Combined with the
                               Algorithm_Instruction Invert_Data field, and the
                               Command_Instruction or
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Data_Instruction indication, execution is
                               continued at Data_Instruction[0] if the test
                               does not otherwise terminate. This bit is
                               implied to be set for Data_Instruction[3].
                            */

  } Bits;
  UINT8 Data;

} CPGC2_DATA_INSTRUCTION_1_MCCPGC_MAIN_STRUCT;

/* CPGC2_DATA_INSTRUCTION_2_MCCPGC_MAIN_REG supported on:                       */
/*      SPRA0 (0x903e)                                                          */
/*      SPRB0 (0x903e)                                                          */
/*      SPRHBM (0x903e)                                                         */
/*      SPRC0 (0x903e)                                                          */
/*      SPRMCC (0x903e)                                                         */
/*      SPRUCC (0x903e)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Data Instruction controlling Alternate Data rotation, Background inversion pattern and Data Inversion.
*/


#define CPGC2_DATA_INSTRUCTION_2_MCCPGC_MAIN_REG 0x2800903E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 data_background : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               Examples:[br] If (Background_Mode == 0)[br]
                               Background - Entire transaction data inversion -
                               examples:[br] 0000 - Solid[br] 0001 - Column
                               Stripes (Column[0])[br] 0010 - Row Stripes
                               (Row[0])[br] 0011 - Checkerboard (Column[0] ^
                               Row[0])[br] 0100 - Double Column Stripes
                               (Column[1])[br] 1000 - Double Row Stripes
                               (Row[1])[br] Any combination of the above are
                               valid and 'combine'.[br] [br] if
                               (Background_Mode == 1)[br] Background - Chunk
                               Inversion mask [max:0] - examples:[br] 0000 - no
                               inversion[br] 1000 - 1111111100000000 (Invert
                               chunks 8-15)[br] 0100 - 1111000011110000 (Invert
                               chunks 15-12, 8-4)[br] 0010 - 1100110011001100
                               (Invert pairs of chunks)[br] 0001 -
                               1010101010101010 (Invert odd chunks)[br] Any
                               combination of the above are valid and
                               'combine'.[br] ex: 0110 - 0011110000111100[br]
                               The actual number of chunks is dependent on the
                               Data DQ width and the length of the transaction
                               and the Critical Chunk address bit as these
                               chunk numbers are always Cache Line address
                               aligned.
                            */
    UINT8 background_mode : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Set the interpretation of the Data_Background
                               field.[br] 0 = Invert the entire data based on
                               the selected combination of Column[1:0] and
                               Row[1:0]. Such as Row or Column stripes, or
                               Double Row or Column stripes.[br] 1 = Chunk
                               inversion based on the logical chunk number.
                            */
    UINT8 alt_data_rotate_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating Alternate Pattern Data.[br] This
                               bit enables repeating of the current
                               Data_Instruction for Data_Select_Rotation_Repeat
                               times.[br] Data generated using the Alternate
                               Pattern generation will rotate by one data bit
                               (LSB toward MSB) for each
                               Data_Select_Rotation_Repeat.[br] For the purpose
                               of this shift, the order follows the
                               Address_Instruction Address_Order and the
                               Address_Instruction[0] Address_Direction.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Globally Invert all data. Combined with the
                               Algorithm_Instruction Invert_Data field, and the
                               Command_Instruction or
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Data_Instruction indication, execution is
                               continued at Data_Instruction[0] if the test
                               does not otherwise terminate. This bit is
                               implied to be set for Data_Instruction[3].
                            */

  } Bits;
  UINT8 Data;

} CPGC2_DATA_INSTRUCTION_2_MCCPGC_MAIN_STRUCT;

/* CPGC2_DATA_INSTRUCTION_3_MCCPGC_MAIN_REG supported on:                       */
/*      SPRA0 (0x903f)                                                          */
/*      SPRB0 (0x903f)                                                          */
/*      SPRHBM (0x903f)                                                         */
/*      SPRC0 (0x903f)                                                          */
/*      SPRMCC (0x903f)                                                         */
/*      SPRUCC (0x903f)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Data Instruction controlling Alternate Data rotation, Background inversion pattern and Data Inversion.
*/


#define CPGC2_DATA_INSTRUCTION_3_MCCPGC_MAIN_REG 0x2800903F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 data_background : 4;

                            /* Bits[3:0], Access Type=RW, default=0x00000000*/

                            /*
                               Examples:[br] If (Background_Mode == 0)[br]
                               Background - Entire transaction data inversion -
                               examples:[br] 0000 - Solid[br] 0001 - Column
                               Stripes (Column[0])[br] 0010 - Row Stripes
                               (Row[0])[br] 0011 - Checkerboard (Column[0] ^
                               Row[0])[br] 0100 - Double Column Stripes
                               (Column[1])[br] 1000 - Double Row Stripes
                               (Row[1])[br] Any combination of the above are
                               valid and 'combine'.[br] [br] if
                               (Background_Mode == 1)[br] Background - Chunk
                               Inversion mask [max:0] - examples:[br] 0000 - no
                               inversion[br] 1000 - 1111111100000000 (Invert
                               chunks 8-15)[br] 0100 - 1111000011110000 (Invert
                               chunks 15-12, 8-4)[br] 0010 - 1100110011001100
                               (Invert pairs of chunks)[br] 0001 -
                               1010101010101010 (Invert odd chunks)[br] Any
                               combination of the above are valid and
                               'combine'.[br] ex: 0110 - 0011110000111100[br]
                               The actual number of chunks is dependent on the
                               Data DQ width and the length of the transaction
                               and the Critical Chunk address bit as these
                               chunk numbers are always Cache Line address
                               aligned.
                            */
    UINT8 background_mode : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Set the interpretation of the Data_Background
                               field.[br] 0 = Invert the entire data based on
                               the selected combination of Column[1:0] and
                               Row[1:0]. Such as Row or Column stripes, or
                               Double Row or Column stripes.[br] 1 = Chunk
                               inversion based on the logical chunk number.
                            */
    UINT8 alt_data_rotate_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating Alternate Pattern Data.[br] This
                               bit enables repeating of the current
                               Data_Instruction for Data_Select_Rotation_Repeat
                               times.[br] Data generated using the Alternate
                               Pattern generation will rotate by one data bit
                               (LSB toward MSB) for each
                               Data_Select_Rotation_Repeat.[br] For the purpose
                               of this shift, the order follows the
                               Address_Instruction Address_Order and the
                               Address_Instruction[0] Address_Direction.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Globally Invert all data. Combined with the
                               Algorithm_Instruction Invert_Data field, and the
                               Command_Instruction or
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Data_Instruction indication, execution is
                               continued at Data_Instruction[0] if the test
                               does not otherwise terminate. This bit is
                               implied to be set for Data_Instruction[3].
                            */

  } Bits;
  UINT8 Data;

} CPGC2_DATA_INSTRUCTION_3_MCCPGC_MAIN_STRUCT;

/* CPGC2_ADDRESS_DATA_STATUS_MCCPGC_MAIN_REG supported on:                      */
/*      SPRA0 (0x20009040)                                                      */
/*      SPRB0 (0x20009040)                                                      */
/*      SPRHBM (0x20009040)                                                     */
/*      SPRC0 (0x20009040)                                                      */
/*      SPRMCC (0x20009040)                                                     */
/*      SPRUCC (0x20009040)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Current number of remaining repeats for Data and Address Repeats loops.
*/


#define CPGC2_ADDRESS_DATA_STATUS_MCCPGC_MAIN_REG 0x28029040

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 address_decode_rotate_repeats_current : 6;

                            /* Bits[5:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Current state of Address_Decode_Rotate_Repeats
                               loop (down count).
                            */
    UINT32 rsvd : 10;

                            /* Bits[15:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 data_select_rotation_repeats_current : 8;

                            /* Bits[23:16], Access Type=RO/V, default=0x00000000*/

                            /*
                               Current state of Data_Select_Rotation_Repeats
                               loop (down count).
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC2_ADDRESS_DATA_STATUS_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_INSTRUCTION_0_MCCPGC_MAIN_REG supported on:                  */
/*      SPRA0 (0x9044)                                                          */
/*      SPRB0 (0x9044)                                                          */
/*      SPRHBM (0x9044)                                                         */
/*      SPRC0 (0x9044)                                                          */
/*      SPRMCC (0x9044)                                                         */
/*      SPRUCC (0x9044)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Algorithm Instruction controlling the starting Command_Instruction and data and address direction reversal.
*/


#define CPGC2_ALGORITHM_INSTRUCTION_0_MCCPGC_MAIN_REG 0x28009044

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 command_start_pointer : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Starting Command_Instruction for execution of
                               this Algorithm_Instruction. The
                               Command_Instruction_Current cycles from
                               Command_Start_Pointer, incrementing until a
                               Command_Instruction contains the Last bit set,
                               and then repeats for each Base_Address,
                               Base_Repeats.[br] Pointer to which one of the 24
                               command list to start with.
                            */
    UINT8 inverse_direction : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the direction as set in the current
                               Address_Instruction for the duration of this
                               Algorithm_Instruction.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this Algorithm_Instruction.
                               Combined with the Data_Instruction Invert_Data
                               field, and the Command_Instruction and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Algorithm instruction,
                               and the memory block is moved at its completion.
                               Execution continues at the first
                               Algorithm_Instruction until the test is
                               complete. Algorithm_Instruction[7] has this bit
                               set implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ALGORITHM_INSTRUCTION_0_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_INSTRUCTION_1_MCCPGC_MAIN_REG supported on:                  */
/*      SPRA0 (0x9045)                                                          */
/*      SPRB0 (0x9045)                                                          */
/*      SPRHBM (0x9045)                                                         */
/*      SPRC0 (0x9045)                                                          */
/*      SPRMCC (0x9045)                                                         */
/*      SPRUCC (0x9045)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Algorithm Instruction controlling the starting Command_Instruction and data and address direction reversal.
*/


#define CPGC2_ALGORITHM_INSTRUCTION_1_MCCPGC_MAIN_REG 0x28009045

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 command_start_pointer : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Starting Command_Instruction for execution of
                               this Algorithm_Instruction. The
                               Command_Instruction_Current cycles from
                               Command_Start_Pointer, incrementing until a
                               Command_Instruction contains the Last bit set,
                               and then repeats for each Base_Address,
                               Base_Repeats.[br] Pointer to which one of the 24
                               command list to start with.
                            */
    UINT8 inverse_direction : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the direction as set in the current
                               Address_Instruction for the duration of this
                               Algorithm_Instruction.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this Algorithm_Instruction.
                               Combined with the Data_Instruction Invert_Data
                               field, and the Command_Instruction and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Algorithm instruction,
                               and the memory block is moved at its completion.
                               Execution continues at the first
                               Algorithm_Instruction until the test is
                               complete. Algorithm_Instruction[7] has this bit
                               set implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ALGORITHM_INSTRUCTION_1_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_INSTRUCTION_2_MCCPGC_MAIN_REG supported on:                  */
/*      SPRA0 (0x9046)                                                          */
/*      SPRB0 (0x9046)                                                          */
/*      SPRHBM (0x9046)                                                         */
/*      SPRC0 (0x9046)                                                          */
/*      SPRMCC (0x9046)                                                         */
/*      SPRUCC (0x9046)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Algorithm Instruction controlling the starting Command_Instruction and data and address direction reversal.
*/


#define CPGC2_ALGORITHM_INSTRUCTION_2_MCCPGC_MAIN_REG 0x28009046

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 command_start_pointer : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Starting Command_Instruction for execution of
                               this Algorithm_Instruction. The
                               Command_Instruction_Current cycles from
                               Command_Start_Pointer, incrementing until a
                               Command_Instruction contains the Last bit set,
                               and then repeats for each Base_Address,
                               Base_Repeats.[br] Pointer to which one of the 24
                               command list to start with.
                            */
    UINT8 inverse_direction : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the direction as set in the current
                               Address_Instruction for the duration of this
                               Algorithm_Instruction.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this Algorithm_Instruction.
                               Combined with the Data_Instruction Invert_Data
                               field, and the Command_Instruction and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Algorithm instruction,
                               and the memory block is moved at its completion.
                               Execution continues at the first
                               Algorithm_Instruction until the test is
                               complete. Algorithm_Instruction[7] has this bit
                               set implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ALGORITHM_INSTRUCTION_2_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_INSTRUCTION_3_MCCPGC_MAIN_REG supported on:                  */
/*      SPRA0 (0x9047)                                                          */
/*      SPRB0 (0x9047)                                                          */
/*      SPRHBM (0x9047)                                                         */
/*      SPRC0 (0x9047)                                                          */
/*      SPRMCC (0x9047)                                                         */
/*      SPRUCC (0x9047)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Algorithm Instruction controlling the starting Command_Instruction and data and address direction reversal.
*/


#define CPGC2_ALGORITHM_INSTRUCTION_3_MCCPGC_MAIN_REG 0x28009047

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 command_start_pointer : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Starting Command_Instruction for execution of
                               this Algorithm_Instruction. The
                               Command_Instruction_Current cycles from
                               Command_Start_Pointer, incrementing until a
                               Command_Instruction contains the Last bit set,
                               and then repeats for each Base_Address,
                               Base_Repeats.[br] Pointer to which one of the 24
                               command list to start with.
                            */
    UINT8 inverse_direction : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the direction as set in the current
                               Address_Instruction for the duration of this
                               Algorithm_Instruction.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this Algorithm_Instruction.
                               Combined with the Data_Instruction Invert_Data
                               field, and the Command_Instruction and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Algorithm instruction,
                               and the memory block is moved at its completion.
                               Execution continues at the first
                               Algorithm_Instruction until the test is
                               complete. Algorithm_Instruction[7] has this bit
                               set implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ALGORITHM_INSTRUCTION_3_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_INSTRUCTION_4_MCCPGC_MAIN_REG supported on:                  */
/*      SPRA0 (0x9048)                                                          */
/*      SPRB0 (0x9048)                                                          */
/*      SPRHBM (0x9048)                                                         */
/*      SPRC0 (0x9048)                                                          */
/*      SPRMCC (0x9048)                                                         */
/*      SPRUCC (0x9048)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Algorithm Instruction controlling the starting Command_Instruction and data and address direction reversal.
*/


#define CPGC2_ALGORITHM_INSTRUCTION_4_MCCPGC_MAIN_REG 0x28009048

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 command_start_pointer : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Starting Command_Instruction for execution of
                               this Algorithm_Instruction. The
                               Command_Instruction_Current cycles from
                               Command_Start_Pointer, incrementing until a
                               Command_Instruction contains the Last bit set,
                               and then repeats for each Base_Address,
                               Base_Repeats.[br] Pointer to which one of the 24
                               command list to start with.
                            */
    UINT8 inverse_direction : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the direction as set in the current
                               Address_Instruction for the duration of this
                               Algorithm_Instruction.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this Algorithm_Instruction.
                               Combined with the Data_Instruction Invert_Data
                               field, and the Command_Instruction and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Algorithm instruction,
                               and the memory block is moved at its completion.
                               Execution continues at the first
                               Algorithm_Instruction until the test is
                               complete. Algorithm_Instruction[7] has this bit
                               set implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ALGORITHM_INSTRUCTION_4_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_INSTRUCTION_5_MCCPGC_MAIN_REG supported on:                  */
/*      SPRA0 (0x9049)                                                          */
/*      SPRB0 (0x9049)                                                          */
/*      SPRHBM (0x9049)                                                         */
/*      SPRC0 (0x9049)                                                          */
/*      SPRMCC (0x9049)                                                         */
/*      SPRUCC (0x9049)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Algorithm Instruction controlling the starting Command_Instruction and data and address direction reversal.
*/


#define CPGC2_ALGORITHM_INSTRUCTION_5_MCCPGC_MAIN_REG 0x28009049

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 command_start_pointer : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Starting Command_Instruction for execution of
                               this Algorithm_Instruction. The
                               Command_Instruction_Current cycles from
                               Command_Start_Pointer, incrementing until a
                               Command_Instruction contains the Last bit set,
                               and then repeats for each Base_Address,
                               Base_Repeats.[br] Pointer to which one of the 24
                               command list to start with.
                            */
    UINT8 inverse_direction : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the direction as set in the current
                               Address_Instruction for the duration of this
                               Algorithm_Instruction.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this Algorithm_Instruction.
                               Combined with the Data_Instruction Invert_Data
                               field, and the Command_Instruction and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Algorithm instruction,
                               and the memory block is moved at its completion.
                               Execution continues at the first
                               Algorithm_Instruction until the test is
                               complete. Algorithm_Instruction[7] has this bit
                               set implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ALGORITHM_INSTRUCTION_5_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_INSTRUCTION_6_MCCPGC_MAIN_REG supported on:                  */
/*      SPRA0 (0x904a)                                                          */
/*      SPRB0 (0x904a)                                                          */
/*      SPRHBM (0x904a)                                                         */
/*      SPRC0 (0x904a)                                                          */
/*      SPRMCC (0x904a)                                                         */
/*      SPRUCC (0x904a)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Algorithm Instruction controlling the starting Command_Instruction and data and address direction reversal.
*/


#define CPGC2_ALGORITHM_INSTRUCTION_6_MCCPGC_MAIN_REG 0x2800904A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 command_start_pointer : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Starting Command_Instruction for execution of
                               this Algorithm_Instruction. The
                               Command_Instruction_Current cycles from
                               Command_Start_Pointer, incrementing until a
                               Command_Instruction contains the Last bit set,
                               and then repeats for each Base_Address,
                               Base_Repeats.[br] Pointer to which one of the 24
                               command list to start with.
                            */
    UINT8 inverse_direction : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the direction as set in the current
                               Address_Instruction for the duration of this
                               Algorithm_Instruction.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this Algorithm_Instruction.
                               Combined with the Data_Instruction Invert_Data
                               field, and the Command_Instruction and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Algorithm instruction,
                               and the memory block is moved at its completion.
                               Execution continues at the first
                               Algorithm_Instruction until the test is
                               complete. Algorithm_Instruction[7] has this bit
                               set implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ALGORITHM_INSTRUCTION_6_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_INSTRUCTION_7_MCCPGC_MAIN_REG supported on:                  */
/*      SPRA0 (0x904b)                                                          */
/*      SPRB0 (0x904b)                                                          */
/*      SPRHBM (0x904b)                                                         */
/*      SPRC0 (0x904b)                                                          */
/*      SPRMCC (0x904b)                                                         */
/*      SPRUCC (0x904b)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Algorithm Instruction controlling the starting Command_Instruction and data and address direction reversal.
*/


#define CPGC2_ALGORITHM_INSTRUCTION_7_MCCPGC_MAIN_REG 0x2800904B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 command_start_pointer : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Starting Command_Instruction for execution of
                               this Algorithm_Instruction. The
                               Command_Instruction_Current cycles from
                               Command_Start_Pointer, incrementing until a
                               Command_Instruction contains the Last bit set,
                               and then repeats for each Base_Address,
                               Base_Repeats.[br] Pointer to which one of the 24
                               command list to start with.
                            */
    UINT8 inverse_direction : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the direction as set in the current
                               Address_Instruction for the duration of this
                               Algorithm_Instruction.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this Algorithm_Instruction.
                               Combined with the Data_Instruction Invert_Data
                               field, and the Command_Instruction and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Algorithm instruction,
                               and the memory block is moved at its completion.
                               Execution continues at the first
                               Algorithm_Instruction until the test is
                               complete. Algorithm_Instruction[7] has this bit
                               set implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ALGORITHM_INSTRUCTION_7_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_INSTRUCTION_CTRL_0_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x904c)                                                          */
/*      SPRB0 (0x904c)                                                          */
/*      SPRHBM (0x904c)                                                         */
/*      SPRC0 (0x904c)                                                          */
/*      SPRMCC (0x904c)                                                         */
/*      SPRUCC (0x904c)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Control portion of each Algorithm_Instruction.
*/


#define CPGC2_ALGORITHM_INSTRUCTION_CTRL_0_MCCPGC_MAIN_REG 0x2800904C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 fasty_init : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               FastY_Init is used to allow a background write
                               initialization type algorithm to use FastY with
                               Columns as the LSB address field to ensure the
                               fastest initialization possible.[br] ^(wD1) is a
                               the most typical background Init function.[br]
                               MEMTEL uses the keyword INIT() to reference this
                               feature.[br] FastY_Init enables the current
                               Algorithm_Instruction to override the current
                               Address_Instruction[].Address_Direction and
                               Address_Order.[br] If set, then use the
                               Address_Direction=000 (FastY) and
                               Address_Order=000 (Rank, Bank, Row/Col), else
                               use the settings defined in the current
                               Address_Instruction.[br] The actual override
                               Order/Direction can be set within the
                               CPGC2_ADDRESS_CONTROL register to something
                               other than FastY for some testing requirements.
                            */
    UINT8 base_range_row : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Instead of using the Base_Repeats setting, use
                               Base_Col_Repeats setting for the size of the
                               block for this instruction as the size of the
                               block. This may be used for a rapid short test
                               hitting all banks to open pages etc, or to
                               initialize a row worth of data.
                            */
    UINT8 wait_count_clear : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Reset the Wait Timer at the start of this
                               Algorithm Instruction.
                            */
    UINT8 wait_count_start : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Wait_Count_Start and Wait_Time are used to
                               synchronize a specific time an Algorithm should
                               start. [br] Wait_Time is commonly used for Pause
                               Refresh test where the read to a particular
                               address needs to be a specific time away from
                               when the write to an address occurs.[br] If
                               Wait_Count_Start = 0 then the start of the
                               Algorithm_Instruction is not stalled.[br] If
                               Wait_Count_Start = 1 then the start of the
                               Algorithm_Instruction is stalled until the
                               Wait_Time_Current is equal to the Wait_Time.[br]
                               Wait_Time_Current represent the current count
                               value from when it was last reset either by a
                               Test starting or Wait_Count_Clear.[br]
                               Wait_Time_Current is a free running counter that
                               accurately reflects the time from when it was
                               last reset by using the following formula.[br]
                               Time elapsed = Wait_Timer_Current *
                               (1/(frequency selected by
                               Count_Value_Frequency).[br] If Wait_Count_Clear
                               = 1 then prior to starting the current
                               Algorithm_Instruction, Wait_Time_Current is
                               reset to zero.[br] Wait_Time_Current is frozen
                               if a Test encounters any stop condition.[br]
                               Wait_Time_Current is reset to zero when a test
                               starts (Start_Test is asserted).[br]
                               Wait_Time_Current rolls over at the maximum
                               value back to zero.[br]
                               Wait_Clock_Frequency(1:0) set the frequency that
                               increment Current_Repeat_Value. The possible
                               frequencies that can be selected are the
                               following.[br] Wait_Clock_Frequency = 00 = 1GHz
                               (time = 1ns).[br] Wait_Clock_Frequency = 01 =
                               1MHZ (time = 1us).[br] Wait_Clock_Frequency = 10
                               = 1KHZ (time = 1ms).[br] Wait_Clock_Frequency =
                               11 = DUNIT clock.
                            */
    UINT8 wait_event_start : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Wait_Event_Start causes the delay in beginning
                               the current Algorithm_Instruction until the
                               Event indicated by Select_Event has been
                               acknowledged to have occurred.[br] The
                               Select_Event is acknowledged to be in
                               progress.[br] The latency between the event and
                               the acknowledgement must be a known fixed value
                               (preventing a hang situation).[br] The
                               Current_Repeat_Value is reset to zero.
                            */
    UINT8 deselect_on : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the CADB will be able to issue
                               harassment patterns into the command and address
                               bus during non Chip Select (deselect) cycles.
                            */
    UINT8 select_on : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the CADB will be able to issue
                               harassment patterns into the command and address
                               bus during Chip Select cycles.
                            */
    UINT8 be_train_err_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the BE Training Error Detection feature
                               for individual Algorithm Instructions. If the
                               BE_TRAIN_ERR_ENABLE bit is set in CPGC_ERR_CTL,
                               this bit if 0, forces BE bits to be '1 for all
                               writes. If the BE_TRAIN_ERR_ENABLE bit is not
                               set, this bit if 1, forces BE bits to be '0 for
                               an MWrPCmt transaction. Please see documentation
                               for further clarification on use.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ALGORITHM_INSTRUCTION_CTRL_0_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_INSTRUCTION_CTRL_1_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x904d)                                                          */
/*      SPRB0 (0x904d)                                                          */
/*      SPRHBM (0x904d)                                                         */
/*      SPRC0 (0x904d)                                                          */
/*      SPRMCC (0x904d)                                                         */
/*      SPRUCC (0x904d)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Control portion of each Algorithm_Instruction.
*/


#define CPGC2_ALGORITHM_INSTRUCTION_CTRL_1_MCCPGC_MAIN_REG 0x2800904D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 fasty_init : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               FastY_Init is used to allow a background write
                               initialization type algorithm to use FastY with
                               Columns as the LSB address field to ensure the
                               fastest initialization possible.[br] ^(wD1) is a
                               the most typical background Init function.[br]
                               MEMTEL uses the keyword INIT() to reference this
                               feature.[br] FastY_Init enables the current
                               Algorithm_Instruction to override the current
                               Address_Instruction[].Address_Direction and
                               Address_Order.[br] If set, then use the
                               Address_Direction=000 (FastY) and
                               Address_Order=000 (Rank, Bank, Row/Col), else
                               use the settings defined in the current
                               Address_Instruction.[br] The actual override
                               Order/Direction can be set within the
                               CPGC2_ADDRESS_CONTROL register to something
                               other than FastY for some testing requirements.
                            */
    UINT8 base_range_row : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Instead of using the Base_Repeats setting, use
                               Base_Col_Repeats setting for the size of the
                               block for this instruction as the size of the
                               block. This may be used for a rapid short test
                               hitting all banks to open pages etc, or to
                               initialize a row worth of data.
                            */
    UINT8 wait_count_clear : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Reset the Wait Timer at the start of this
                               Algorithm Instruction.
                            */
    UINT8 wait_count_start : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Wait_Count_Start and Wait_Time are used to
                               synchronize a specific time an Algorithm should
                               start. [br] Wait_Time is commonly used for Pause
                               Refresh test where the read to a particular
                               address needs to be a specific time away from
                               when the write to an address occurs.[br] If
                               Wait_Count_Start = 0 then the start of the
                               Algorithm_Instruction is not stalled.[br] If
                               Wait_Count_Start = 1 then the start of the
                               Algorithm_Instruction is stalled until the
                               Wait_Time_Current is equal to the Wait_Time.[br]
                               Wait_Time_Current represent the current count
                               value from when it was last reset either by a
                               Test starting or Wait_Count_Clear.[br]
                               Wait_Time_Current is a free running counter that
                               accurately reflects the time from when it was
                               last reset by using the following formula.[br]
                               Time elapsed = Wait_Timer_Current *
                               (1/(frequency selected by
                               Count_Value_Frequency).[br] If Wait_Count_Clear
                               = 1 then prior to starting the current
                               Algorithm_Instruction, Wait_Time_Current is
                               reset to zero.[br] Wait_Time_Current is frozen
                               if a Test encounters any stop condition.[br]
                               Wait_Time_Current is reset to zero when a test
                               starts (Start_Test is asserted).[br]
                               Wait_Time_Current rolls over at the maximum
                               value back to zero.[br]
                               Wait_Clock_Frequency(1:0) set the frequency that
                               increment Current_Repeat_Value. The possible
                               frequencies that can be selected are the
                               following.[br] Wait_Clock_Frequency = 00 = 1GHz
                               (time = 1ns).[br] Wait_Clock_Frequency = 01 =
                               1MHZ (time = 1us).[br] Wait_Clock_Frequency = 10
                               = 1KHZ (time = 1ms).[br] Wait_Clock_Frequency =
                               11 = DUNIT clock.
                            */
    UINT8 wait_event_start : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Wait_Event_Start causes the delay in beginning
                               the current Algorithm_Instruction until the
                               Event indicated by Select_Event has been
                               acknowledged to have occurred.[br] The
                               Select_Event is acknowledged to be in
                               progress.[br] The latency between the event and
                               the acknowledgement must be a known fixed value
                               (preventing a hang situation).[br] The
                               Current_Repeat_Value is reset to zero.
                            */
    UINT8 deselect_on : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the CADB will be able to issue
                               harassment patterns into the command and address
                               bus during non Chip Select (deselect) cycles.
                            */
    UINT8 select_on : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the CADB will be able to issue
                               harassment patterns into the command and address
                               bus during Chip Select cycles.
                            */
    UINT8 be_train_err_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the BE Training Error Detection feature
                               for individual Algorithm Instructions. If the
                               BE_TRAIN_ERR_ENABLE bit is set in CPGC_ERR_CTL,
                               this bit if 0, forces BE bits to be '1 for all
                               writes. If the BE_TRAIN_ERR_ENABLE bit is not
                               set, this bit if 1, forces BE bits to be '0 for
                               an MWrPCmt transaction. Please see documentation
                               for further clarification on use.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ALGORITHM_INSTRUCTION_CTRL_1_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_INSTRUCTION_CTRL_2_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x904e)                                                          */
/*      SPRB0 (0x904e)                                                          */
/*      SPRHBM (0x904e)                                                         */
/*      SPRC0 (0x904e)                                                          */
/*      SPRMCC (0x904e)                                                         */
/*      SPRUCC (0x904e)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Control portion of each Algorithm_Instruction.
*/


#define CPGC2_ALGORITHM_INSTRUCTION_CTRL_2_MCCPGC_MAIN_REG 0x2800904E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 fasty_init : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               FastY_Init is used to allow a background write
                               initialization type algorithm to use FastY with
                               Columns as the LSB address field to ensure the
                               fastest initialization possible.[br] ^(wD1) is a
                               the most typical background Init function.[br]
                               MEMTEL uses the keyword INIT() to reference this
                               feature.[br] FastY_Init enables the current
                               Algorithm_Instruction to override the current
                               Address_Instruction[].Address_Direction and
                               Address_Order.[br] If set, then use the
                               Address_Direction=000 (FastY) and
                               Address_Order=000 (Rank, Bank, Row/Col), else
                               use the settings defined in the current
                               Address_Instruction.[br] The actual override
                               Order/Direction can be set within the
                               CPGC2_ADDRESS_CONTROL register to something
                               other than FastY for some testing requirements.
                            */
    UINT8 base_range_row : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Instead of using the Base_Repeats setting, use
                               Base_Col_Repeats setting for the size of the
                               block for this instruction as the size of the
                               block. This may be used for a rapid short test
                               hitting all banks to open pages etc, or to
                               initialize a row worth of data.
                            */
    UINT8 wait_count_clear : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Reset the Wait Timer at the start of this
                               Algorithm Instruction.
                            */
    UINT8 wait_count_start : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Wait_Count_Start and Wait_Time are used to
                               synchronize a specific time an Algorithm should
                               start. [br] Wait_Time is commonly used for Pause
                               Refresh test where the read to a particular
                               address needs to be a specific time away from
                               when the write to an address occurs.[br] If
                               Wait_Count_Start = 0 then the start of the
                               Algorithm_Instruction is not stalled.[br] If
                               Wait_Count_Start = 1 then the start of the
                               Algorithm_Instruction is stalled until the
                               Wait_Time_Current is equal to the Wait_Time.[br]
                               Wait_Time_Current represent the current count
                               value from when it was last reset either by a
                               Test starting or Wait_Count_Clear.[br]
                               Wait_Time_Current is a free running counter that
                               accurately reflects the time from when it was
                               last reset by using the following formula.[br]
                               Time elapsed = Wait_Timer_Current *
                               (1/(frequency selected by
                               Count_Value_Frequency).[br] If Wait_Count_Clear
                               = 1 then prior to starting the current
                               Algorithm_Instruction, Wait_Time_Current is
                               reset to zero.[br] Wait_Time_Current is frozen
                               if a Test encounters any stop condition.[br]
                               Wait_Time_Current is reset to zero when a test
                               starts (Start_Test is asserted).[br]
                               Wait_Time_Current rolls over at the maximum
                               value back to zero.[br]
                               Wait_Clock_Frequency(1:0) set the frequency that
                               increment Current_Repeat_Value. The possible
                               frequencies that can be selected are the
                               following.[br] Wait_Clock_Frequency = 00 = 1GHz
                               (time = 1ns).[br] Wait_Clock_Frequency = 01 =
                               1MHZ (time = 1us).[br] Wait_Clock_Frequency = 10
                               = 1KHZ (time = 1ms).[br] Wait_Clock_Frequency =
                               11 = DUNIT clock.
                            */
    UINT8 wait_event_start : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Wait_Event_Start causes the delay in beginning
                               the current Algorithm_Instruction until the
                               Event indicated by Select_Event has been
                               acknowledged to have occurred.[br] The
                               Select_Event is acknowledged to be in
                               progress.[br] The latency between the event and
                               the acknowledgement must be a known fixed value
                               (preventing a hang situation).[br] The
                               Current_Repeat_Value is reset to zero.
                            */
    UINT8 deselect_on : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the CADB will be able to issue
                               harassment patterns into the command and address
                               bus during non Chip Select (deselect) cycles.
                            */
    UINT8 select_on : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the CADB will be able to issue
                               harassment patterns into the command and address
                               bus during Chip Select cycles.
                            */
    UINT8 be_train_err_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the BE Training Error Detection feature
                               for individual Algorithm Instructions. If the
                               BE_TRAIN_ERR_ENABLE bit is set in CPGC_ERR_CTL,
                               this bit if 0, forces BE bits to be '1 for all
                               writes. If the BE_TRAIN_ERR_ENABLE bit is not
                               set, this bit if 1, forces BE bits to be '0 for
                               an MWrPCmt transaction. Please see documentation
                               for further clarification on use.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ALGORITHM_INSTRUCTION_CTRL_2_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_INSTRUCTION_CTRL_3_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x904f)                                                          */
/*      SPRB0 (0x904f)                                                          */
/*      SPRHBM (0x904f)                                                         */
/*      SPRC0 (0x904f)                                                          */
/*      SPRMCC (0x904f)                                                         */
/*      SPRUCC (0x904f)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Control portion of each Algorithm_Instruction.
*/


#define CPGC2_ALGORITHM_INSTRUCTION_CTRL_3_MCCPGC_MAIN_REG 0x2800904F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 fasty_init : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               FastY_Init is used to allow a background write
                               initialization type algorithm to use FastY with
                               Columns as the LSB address field to ensure the
                               fastest initialization possible.[br] ^(wD1) is a
                               the most typical background Init function.[br]
                               MEMTEL uses the keyword INIT() to reference this
                               feature.[br] FastY_Init enables the current
                               Algorithm_Instruction to override the current
                               Address_Instruction[].Address_Direction and
                               Address_Order.[br] If set, then use the
                               Address_Direction=000 (FastY) and
                               Address_Order=000 (Rank, Bank, Row/Col), else
                               use the settings defined in the current
                               Address_Instruction.[br] The actual override
                               Order/Direction can be set within the
                               CPGC2_ADDRESS_CONTROL register to something
                               other than FastY for some testing requirements.
                            */
    UINT8 base_range_row : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Instead of using the Base_Repeats setting, use
                               Base_Col_Repeats setting for the size of the
                               block for this instruction as the size of the
                               block. This may be used for a rapid short test
                               hitting all banks to open pages etc, or to
                               initialize a row worth of data.
                            */
    UINT8 wait_count_clear : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Reset the Wait Timer at the start of this
                               Algorithm Instruction.
                            */
    UINT8 wait_count_start : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Wait_Count_Start and Wait_Time are used to
                               synchronize a specific time an Algorithm should
                               start. [br] Wait_Time is commonly used for Pause
                               Refresh test where the read to a particular
                               address needs to be a specific time away from
                               when the write to an address occurs.[br] If
                               Wait_Count_Start = 0 then the start of the
                               Algorithm_Instruction is not stalled.[br] If
                               Wait_Count_Start = 1 then the start of the
                               Algorithm_Instruction is stalled until the
                               Wait_Time_Current is equal to the Wait_Time.[br]
                               Wait_Time_Current represent the current count
                               value from when it was last reset either by a
                               Test starting or Wait_Count_Clear.[br]
                               Wait_Time_Current is a free running counter that
                               accurately reflects the time from when it was
                               last reset by using the following formula.[br]
                               Time elapsed = Wait_Timer_Current *
                               (1/(frequency selected by
                               Count_Value_Frequency).[br] If Wait_Count_Clear
                               = 1 then prior to starting the current
                               Algorithm_Instruction, Wait_Time_Current is
                               reset to zero.[br] Wait_Time_Current is frozen
                               if a Test encounters any stop condition.[br]
                               Wait_Time_Current is reset to zero when a test
                               starts (Start_Test is asserted).[br]
                               Wait_Time_Current rolls over at the maximum
                               value back to zero.[br]
                               Wait_Clock_Frequency(1:0) set the frequency that
                               increment Current_Repeat_Value. The possible
                               frequencies that can be selected are the
                               following.[br] Wait_Clock_Frequency = 00 = 1GHz
                               (time = 1ns).[br] Wait_Clock_Frequency = 01 =
                               1MHZ (time = 1us).[br] Wait_Clock_Frequency = 10
                               = 1KHZ (time = 1ms).[br] Wait_Clock_Frequency =
                               11 = DUNIT clock.
                            */
    UINT8 wait_event_start : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Wait_Event_Start causes the delay in beginning
                               the current Algorithm_Instruction until the
                               Event indicated by Select_Event has been
                               acknowledged to have occurred.[br] The
                               Select_Event is acknowledged to be in
                               progress.[br] The latency between the event and
                               the acknowledgement must be a known fixed value
                               (preventing a hang situation).[br] The
                               Current_Repeat_Value is reset to zero.
                            */
    UINT8 deselect_on : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the CADB will be able to issue
                               harassment patterns into the command and address
                               bus during non Chip Select (deselect) cycles.
                            */
    UINT8 select_on : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the CADB will be able to issue
                               harassment patterns into the command and address
                               bus during Chip Select cycles.
                            */
    UINT8 be_train_err_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the BE Training Error Detection feature
                               for individual Algorithm Instructions. If the
                               BE_TRAIN_ERR_ENABLE bit is set in CPGC_ERR_CTL,
                               this bit if 0, forces BE bits to be '1 for all
                               writes. If the BE_TRAIN_ERR_ENABLE bit is not
                               set, this bit if 1, forces BE bits to be '0 for
                               an MWrPCmt transaction. Please see documentation
                               for further clarification on use.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ALGORITHM_INSTRUCTION_CTRL_3_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_INSTRUCTION_CTRL_4_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x9050)                                                          */
/*      SPRB0 (0x9050)                                                          */
/*      SPRHBM (0x9050)                                                         */
/*      SPRC0 (0x9050)                                                          */
/*      SPRMCC (0x9050)                                                         */
/*      SPRUCC (0x9050)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Control portion of each Algorithm_Instruction.
*/


#define CPGC2_ALGORITHM_INSTRUCTION_CTRL_4_MCCPGC_MAIN_REG 0x28009050

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 fasty_init : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               FastY_Init is used to allow a background write
                               initialization type algorithm to use FastY with
                               Columns as the LSB address field to ensure the
                               fastest initialization possible.[br] ^(wD1) is a
                               the most typical background Init function.[br]
                               MEMTEL uses the keyword INIT() to reference this
                               feature.[br] FastY_Init enables the current
                               Algorithm_Instruction to override the current
                               Address_Instruction[].Address_Direction and
                               Address_Order.[br] If set, then use the
                               Address_Direction=000 (FastY) and
                               Address_Order=000 (Rank, Bank, Row/Col), else
                               use the settings defined in the current
                               Address_Instruction.[br] The actual override
                               Order/Direction can be set within the
                               CPGC2_ADDRESS_CONTROL register to something
                               other than FastY for some testing requirements.
                            */
    UINT8 base_range_row : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Instead of using the Base_Repeats setting, use
                               Base_Col_Repeats setting for the size of the
                               block for this instruction as the size of the
                               block. This may be used for a rapid short test
                               hitting all banks to open pages etc, or to
                               initialize a row worth of data.
                            */
    UINT8 wait_count_clear : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Reset the Wait Timer at the start of this
                               Algorithm Instruction.
                            */
    UINT8 wait_count_start : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Wait_Count_Start and Wait_Time are used to
                               synchronize a specific time an Algorithm should
                               start. [br] Wait_Time is commonly used for Pause
                               Refresh test where the read to a particular
                               address needs to be a specific time away from
                               when the write to an address occurs.[br] If
                               Wait_Count_Start = 0 then the start of the
                               Algorithm_Instruction is not stalled.[br] If
                               Wait_Count_Start = 1 then the start of the
                               Algorithm_Instruction is stalled until the
                               Wait_Time_Current is equal to the Wait_Time.[br]
                               Wait_Time_Current represent the current count
                               value from when it was last reset either by a
                               Test starting or Wait_Count_Clear.[br]
                               Wait_Time_Current is a free running counter that
                               accurately reflects the time from when it was
                               last reset by using the following formula.[br]
                               Time elapsed = Wait_Timer_Current *
                               (1/(frequency selected by
                               Count_Value_Frequency).[br] If Wait_Count_Clear
                               = 1 then prior to starting the current
                               Algorithm_Instruction, Wait_Time_Current is
                               reset to zero.[br] Wait_Time_Current is frozen
                               if a Test encounters any stop condition.[br]
                               Wait_Time_Current is reset to zero when a test
                               starts (Start_Test is asserted).[br]
                               Wait_Time_Current rolls over at the maximum
                               value back to zero.[br]
                               Wait_Clock_Frequency(1:0) set the frequency that
                               increment Current_Repeat_Value. The possible
                               frequencies that can be selected are the
                               following.[br] Wait_Clock_Frequency = 00 = 1GHz
                               (time = 1ns).[br] Wait_Clock_Frequency = 01 =
                               1MHZ (time = 1us).[br] Wait_Clock_Frequency = 10
                               = 1KHZ (time = 1ms).[br] Wait_Clock_Frequency =
                               11 = DUNIT clock.
                            */
    UINT8 wait_event_start : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Wait_Event_Start causes the delay in beginning
                               the current Algorithm_Instruction until the
                               Event indicated by Select_Event has been
                               acknowledged to have occurred.[br] The
                               Select_Event is acknowledged to be in
                               progress.[br] The latency between the event and
                               the acknowledgement must be a known fixed value
                               (preventing a hang situation).[br] The
                               Current_Repeat_Value is reset to zero.
                            */
    UINT8 deselect_on : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the CADB will be able to issue
                               harassment patterns into the command and address
                               bus during non Chip Select (deselect) cycles.
                            */
    UINT8 select_on : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the CADB will be able to issue
                               harassment patterns into the command and address
                               bus during Chip Select cycles.
                            */
    UINT8 be_train_err_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the BE Training Error Detection feature
                               for individual Algorithm Instructions. If the
                               BE_TRAIN_ERR_ENABLE bit is set in CPGC_ERR_CTL,
                               this bit if 0, forces BE bits to be '1 for all
                               writes. If the BE_TRAIN_ERR_ENABLE bit is not
                               set, this bit if 1, forces BE bits to be '0 for
                               an MWrPCmt transaction. Please see documentation
                               for further clarification on use.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ALGORITHM_INSTRUCTION_CTRL_4_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_INSTRUCTION_CTRL_5_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x9051)                                                          */
/*      SPRB0 (0x9051)                                                          */
/*      SPRHBM (0x9051)                                                         */
/*      SPRC0 (0x9051)                                                          */
/*      SPRMCC (0x9051)                                                         */
/*      SPRUCC (0x9051)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Control portion of each Algorithm_Instruction.
*/


#define CPGC2_ALGORITHM_INSTRUCTION_CTRL_5_MCCPGC_MAIN_REG 0x28009051

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 fasty_init : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               FastY_Init is used to allow a background write
                               initialization type algorithm to use FastY with
                               Columns as the LSB address field to ensure the
                               fastest initialization possible.[br] ^(wD1) is a
                               the most typical background Init function.[br]
                               MEMTEL uses the keyword INIT() to reference this
                               feature.[br] FastY_Init enables the current
                               Algorithm_Instruction to override the current
                               Address_Instruction[].Address_Direction and
                               Address_Order.[br] If set, then use the
                               Address_Direction=000 (FastY) and
                               Address_Order=000 (Rank, Bank, Row/Col), else
                               use the settings defined in the current
                               Address_Instruction.[br] The actual override
                               Order/Direction can be set within the
                               CPGC2_ADDRESS_CONTROL register to something
                               other than FastY for some testing requirements.
                            */
    UINT8 base_range_row : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Instead of using the Base_Repeats setting, use
                               Base_Col_Repeats setting for the size of the
                               block for this instruction as the size of the
                               block. This may be used for a rapid short test
                               hitting all banks to open pages etc, or to
                               initialize a row worth of data.
                            */
    UINT8 wait_count_clear : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Reset the Wait Timer at the start of this
                               Algorithm Instruction.
                            */
    UINT8 wait_count_start : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Wait_Count_Start and Wait_Time are used to
                               synchronize a specific time an Algorithm should
                               start. [br] Wait_Time is commonly used for Pause
                               Refresh test where the read to a particular
                               address needs to be a specific time away from
                               when the write to an address occurs.[br] If
                               Wait_Count_Start = 0 then the start of the
                               Algorithm_Instruction is not stalled.[br] If
                               Wait_Count_Start = 1 then the start of the
                               Algorithm_Instruction is stalled until the
                               Wait_Time_Current is equal to the Wait_Time.[br]
                               Wait_Time_Current represent the current count
                               value from when it was last reset either by a
                               Test starting or Wait_Count_Clear.[br]
                               Wait_Time_Current is a free running counter that
                               accurately reflects the time from when it was
                               last reset by using the following formula.[br]
                               Time elapsed = Wait_Timer_Current *
                               (1/(frequency selected by
                               Count_Value_Frequency).[br] If Wait_Count_Clear
                               = 1 then prior to starting the current
                               Algorithm_Instruction, Wait_Time_Current is
                               reset to zero.[br] Wait_Time_Current is frozen
                               if a Test encounters any stop condition.[br]
                               Wait_Time_Current is reset to zero when a test
                               starts (Start_Test is asserted).[br]
                               Wait_Time_Current rolls over at the maximum
                               value back to zero.[br]
                               Wait_Clock_Frequency(1:0) set the frequency that
                               increment Current_Repeat_Value. The possible
                               frequencies that can be selected are the
                               following.[br] Wait_Clock_Frequency = 00 = 1GHz
                               (time = 1ns).[br] Wait_Clock_Frequency = 01 =
                               1MHZ (time = 1us).[br] Wait_Clock_Frequency = 10
                               = 1KHZ (time = 1ms).[br] Wait_Clock_Frequency =
                               11 = DUNIT clock.
                            */
    UINT8 wait_event_start : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Wait_Event_Start causes the delay in beginning
                               the current Algorithm_Instruction until the
                               Event indicated by Select_Event has been
                               acknowledged to have occurred.[br] The
                               Select_Event is acknowledged to be in
                               progress.[br] The latency between the event and
                               the acknowledgement must be a known fixed value
                               (preventing a hang situation).[br] The
                               Current_Repeat_Value is reset to zero.
                            */
    UINT8 deselect_on : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the CADB will be able to issue
                               harassment patterns into the command and address
                               bus during non Chip Select (deselect) cycles.
                            */
    UINT8 select_on : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the CADB will be able to issue
                               harassment patterns into the command and address
                               bus during Chip Select cycles.
                            */
    UINT8 be_train_err_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the BE Training Error Detection feature
                               for individual Algorithm Instructions. If the
                               BE_TRAIN_ERR_ENABLE bit is set in CPGC_ERR_CTL,
                               this bit if 0, forces BE bits to be '1 for all
                               writes. If the BE_TRAIN_ERR_ENABLE bit is not
                               set, this bit if 1, forces BE bits to be '0 for
                               an MWrPCmt transaction. Please see documentation
                               for further clarification on use.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ALGORITHM_INSTRUCTION_CTRL_5_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_INSTRUCTION_CTRL_6_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x9052)                                                          */
/*      SPRB0 (0x9052)                                                          */
/*      SPRHBM (0x9052)                                                         */
/*      SPRC0 (0x9052)                                                          */
/*      SPRMCC (0x9052)                                                         */
/*      SPRUCC (0x9052)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Control portion of each Algorithm_Instruction.
*/


#define CPGC2_ALGORITHM_INSTRUCTION_CTRL_6_MCCPGC_MAIN_REG 0x28009052

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 fasty_init : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               FastY_Init is used to allow a background write
                               initialization type algorithm to use FastY with
                               Columns as the LSB address field to ensure the
                               fastest initialization possible.[br] ^(wD1) is a
                               the most typical background Init function.[br]
                               MEMTEL uses the keyword INIT() to reference this
                               feature.[br] FastY_Init enables the current
                               Algorithm_Instruction to override the current
                               Address_Instruction[].Address_Direction and
                               Address_Order.[br] If set, then use the
                               Address_Direction=000 (FastY) and
                               Address_Order=000 (Rank, Bank, Row/Col), else
                               use the settings defined in the current
                               Address_Instruction.[br] The actual override
                               Order/Direction can be set within the
                               CPGC2_ADDRESS_CONTROL register to something
                               other than FastY for some testing requirements.
                            */
    UINT8 base_range_row : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Instead of using the Base_Repeats setting, use
                               Base_Col_Repeats setting for the size of the
                               block for this instruction as the size of the
                               block. This may be used for a rapid short test
                               hitting all banks to open pages etc, or to
                               initialize a row worth of data.
                            */
    UINT8 wait_count_clear : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Reset the Wait Timer at the start of this
                               Algorithm Instruction.
                            */
    UINT8 wait_count_start : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Wait_Count_Start and Wait_Time are used to
                               synchronize a specific time an Algorithm should
                               start. [br] Wait_Time is commonly used for Pause
                               Refresh test where the read to a particular
                               address needs to be a specific time away from
                               when the write to an address occurs.[br] If
                               Wait_Count_Start = 0 then the start of the
                               Algorithm_Instruction is not stalled.[br] If
                               Wait_Count_Start = 1 then the start of the
                               Algorithm_Instruction is stalled until the
                               Wait_Time_Current is equal to the Wait_Time.[br]
                               Wait_Time_Current represent the current count
                               value from when it was last reset either by a
                               Test starting or Wait_Count_Clear.[br]
                               Wait_Time_Current is a free running counter that
                               accurately reflects the time from when it was
                               last reset by using the following formula.[br]
                               Time elapsed = Wait_Timer_Current *
                               (1/(frequency selected by
                               Count_Value_Frequency).[br] If Wait_Count_Clear
                               = 1 then prior to starting the current
                               Algorithm_Instruction, Wait_Time_Current is
                               reset to zero.[br] Wait_Time_Current is frozen
                               if a Test encounters any stop condition.[br]
                               Wait_Time_Current is reset to zero when a test
                               starts (Start_Test is asserted).[br]
                               Wait_Time_Current rolls over at the maximum
                               value back to zero.[br]
                               Wait_Clock_Frequency(1:0) set the frequency that
                               increment Current_Repeat_Value. The possible
                               frequencies that can be selected are the
                               following.[br] Wait_Clock_Frequency = 00 = 1GHz
                               (time = 1ns).[br] Wait_Clock_Frequency = 01 =
                               1MHZ (time = 1us).[br] Wait_Clock_Frequency = 10
                               = 1KHZ (time = 1ms).[br] Wait_Clock_Frequency =
                               11 = DUNIT clock.
                            */
    UINT8 wait_event_start : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Wait_Event_Start causes the delay in beginning
                               the current Algorithm_Instruction until the
                               Event indicated by Select_Event has been
                               acknowledged to have occurred.[br] The
                               Select_Event is acknowledged to be in
                               progress.[br] The latency between the event and
                               the acknowledgement must be a known fixed value
                               (preventing a hang situation).[br] The
                               Current_Repeat_Value is reset to zero.
                            */
    UINT8 deselect_on : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the CADB will be able to issue
                               harassment patterns into the command and address
                               bus during non Chip Select (deselect) cycles.
                            */
    UINT8 select_on : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the CADB will be able to issue
                               harassment patterns into the command and address
                               bus during Chip Select cycles.
                            */
    UINT8 be_train_err_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the BE Training Error Detection feature
                               for individual Algorithm Instructions. If the
                               BE_TRAIN_ERR_ENABLE bit is set in CPGC_ERR_CTL,
                               this bit if 0, forces BE bits to be '1 for all
                               writes. If the BE_TRAIN_ERR_ENABLE bit is not
                               set, this bit if 1, forces BE bits to be '0 for
                               an MWrPCmt transaction. Please see documentation
                               for further clarification on use.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ALGORITHM_INSTRUCTION_CTRL_6_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_INSTRUCTION_CTRL_7_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x9053)                                                          */
/*      SPRB0 (0x9053)                                                          */
/*      SPRHBM (0x9053)                                                         */
/*      SPRC0 (0x9053)                                                          */
/*      SPRMCC (0x9053)                                                         */
/*      SPRUCC (0x9053)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Control portion of each Algorithm_Instruction.
*/


#define CPGC2_ALGORITHM_INSTRUCTION_CTRL_7_MCCPGC_MAIN_REG 0x28009053

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 fasty_init : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               FastY_Init is used to allow a background write
                               initialization type algorithm to use FastY with
                               Columns as the LSB address field to ensure the
                               fastest initialization possible.[br] ^(wD1) is a
                               the most typical background Init function.[br]
                               MEMTEL uses the keyword INIT() to reference this
                               feature.[br] FastY_Init enables the current
                               Algorithm_Instruction to override the current
                               Address_Instruction[].Address_Direction and
                               Address_Order.[br] If set, then use the
                               Address_Direction=000 (FastY) and
                               Address_Order=000 (Rank, Bank, Row/Col), else
                               use the settings defined in the current
                               Address_Instruction.[br] The actual override
                               Order/Direction can be set within the
                               CPGC2_ADDRESS_CONTROL register to something
                               other than FastY for some testing requirements.
                            */
    UINT8 base_range_row : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Instead of using the Base_Repeats setting, use
                               Base_Col_Repeats setting for the size of the
                               block for this instruction as the size of the
                               block. This may be used for a rapid short test
                               hitting all banks to open pages etc, or to
                               initialize a row worth of data.
                            */
    UINT8 wait_count_clear : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Reset the Wait Timer at the start of this
                               Algorithm Instruction.
                            */
    UINT8 wait_count_start : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               Wait_Count_Start and Wait_Time are used to
                               synchronize a specific time an Algorithm should
                               start. [br] Wait_Time is commonly used for Pause
                               Refresh test where the read to a particular
                               address needs to be a specific time away from
                               when the write to an address occurs.[br] If
                               Wait_Count_Start = 0 then the start of the
                               Algorithm_Instruction is not stalled.[br] If
                               Wait_Count_Start = 1 then the start of the
                               Algorithm_Instruction is stalled until the
                               Wait_Time_Current is equal to the Wait_Time.[br]
                               Wait_Time_Current represent the current count
                               value from when it was last reset either by a
                               Test starting or Wait_Count_Clear.[br]
                               Wait_Time_Current is a free running counter that
                               accurately reflects the time from when it was
                               last reset by using the following formula.[br]
                               Time elapsed = Wait_Timer_Current *
                               (1/(frequency selected by
                               Count_Value_Frequency).[br] If Wait_Count_Clear
                               = 1 then prior to starting the current
                               Algorithm_Instruction, Wait_Time_Current is
                               reset to zero.[br] Wait_Time_Current is frozen
                               if a Test encounters any stop condition.[br]
                               Wait_Time_Current is reset to zero when a test
                               starts (Start_Test is asserted).[br]
                               Wait_Time_Current rolls over at the maximum
                               value back to zero.[br]
                               Wait_Clock_Frequency(1:0) set the frequency that
                               increment Current_Repeat_Value. The possible
                               frequencies that can be selected are the
                               following.[br] Wait_Clock_Frequency = 00 = 1GHz
                               (time = 1ns).[br] Wait_Clock_Frequency = 01 =
                               1MHZ (time = 1us).[br] Wait_Clock_Frequency = 10
                               = 1KHZ (time = 1ms).[br] Wait_Clock_Frequency =
                               11 = DUNIT clock.
                            */
    UINT8 wait_event_start : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Wait_Event_Start causes the delay in beginning
                               the current Algorithm_Instruction until the
                               Event indicated by Select_Event has been
                               acknowledged to have occurred.[br] The
                               Select_Event is acknowledged to be in
                               progress.[br] The latency between the event and
                               the acknowledgement must be a known fixed value
                               (preventing a hang situation).[br] The
                               Current_Repeat_Value is reset to zero.
                            */
    UINT8 deselect_on : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the CADB will be able to issue
                               harassment patterns into the command and address
                               bus during non Chip Select (deselect) cycles.
                            */
    UINT8 select_on : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the CADB will be able to issue
                               harassment patterns into the command and address
                               bus during Chip Select cycles.
                            */
    UINT8 be_train_err_en : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Enable the BE Training Error Detection feature
                               for individual Algorithm Instructions. If the
                               BE_TRAIN_ERR_ENABLE bit is set in CPGC_ERR_CTL,
                               this bit if 0, forces BE bits to be '1 for all
                               writes. If the BE_TRAIN_ERR_ENABLE bit is not
                               set, this bit if 1, forces BE bits to be '0 for
                               an MWrPCmt transaction. Please see documentation
                               for further clarification on use.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_ALGORITHM_INSTRUCTION_CTRL_7_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_WAIT_COUNT_CURRENT_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x20009054)                                                      */
/*      SPRB0 (0x20009054)                                                      */
/*      SPRHBM (0x20009054)                                                     */
/*      SPRC0 (0x20009054)                                                      */
/*      SPRMCC (0x20009054)                                                     */
/*      SPRUCC (0x20009054)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Current wait timer value.
*/


#define CPGC2_ALGORITHM_WAIT_COUNT_CURRENT_MCCPGC_MAIN_REG 0x28029054

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wait_timer_current : 16;

                            /* Bits[15:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Current wait timer value. See Wait_Time
                               description (down count).[br] The counter is
                               cleared on starting an Algorithm_Instruction
                               with Wait Count Clear, or Wait Event Start.
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC2_ALGORITHM_WAIT_COUNT_CURRENT_MCCPGC_MAIN_STRUCT;

/* CPGC2_ALGORITHM_WAIT_EVENT_CONTROL_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x20009058)                                                      */
/*      SPRB0 (0x20009058)                                                      */
/*      SPRHBM (0x20009058)                                                     */
/*      SPRC0 (0x20009058)                                                      */
/*      SPRMCC (0x20009058)                                                     */
/*      SPRUCC (0x20009058)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Algorithm wait event control.
*/


#define CPGC2_ALGORITHM_WAIT_EVENT_CONTROL_MCCPGC_MAIN_REG 0x28029058

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 wait_time : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /*
                               Number of clocks at Wait_Clock_Frequency to wait
                               (since the last/current Wait_Event or
                               Wait_Count_Clear) before starting current
                               Algorithm_Instruction if Wait_Count_Start = 1.
                            */
    UINT32 rsvd : 4;

                            /* Bits[19:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 timer : 4;

                            /* Bits[23:20], Access Type=RW, default=0x00000000*/

                            /*
                               Exponential timer (timer value calculated as
                               2^Timer). If WaitEventStart is set in the
                               currently executing Algorithm Instruction, this
                               timer is used as a watchdog and dynamically
                               replaces the current Wait_Time counter
                               immediately at the start of waiting on the
                               Select_Event occurring (such as SelfRefresh or
                               PowerDown), to add a fixed timeout for the
                               Select_Event condition to occur. When the
                               Select_Event occurs (such as SelfRefresh or
                               PowerDown), Wait_Time is started (as if
                               Wait_Count_Clear were set) to allow the
                               Select_Event condition to remain before CPGC
                               activity resumes. Timer Value = 4'hF disables
                               the Event Wait Timer.
                            */
    UINT32 wait_clock_frequency : 2;

                            /* Bits[25:24], Access Type=RW, default=0x00000000*/

                            /*
                               00 - 1GHz[br] 01 - 1MHz[br] 10 - 1KHz[br] 11 -
                               Native CPGC clock[br] (CPGC typically operates
                               at 1/4 the DDR frequency)
                            */
    UINT32 rsvd_26 : 4;

                            /* Bits[29:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 select_event : 2;

                            /* Bits[31:30], Access Type=RW, default=0x00000000*/

                            /*
                               Select_Event is decoded in the following
                               ways.[br] Select_Event = 00 = Read/Write Pending
                               CAS cue is empty[br] Select_Event = 01 = CKE
                               Power Down[br] Select_Event = 10 = Refresh[br]
                               Select_Event = 11 = Self Refresh
                            */

  } Bits;
  UINT32 Data;

} CPGC2_ALGORITHM_WAIT_EVENT_CONTROL_MCCPGC_MAIN_STRUCT;

/* CPGC2_BASE_REPEATS_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x2000905c)                                                      */
/*      SPRB0 (0x2000905c)                                                      */
/*      SPRHBM (0x2000905c)                                                     */
/*      SPRC0 (0x2000905c)                                                      */
/*      SPRMCC (0x2000905c)                                                     */
/*      SPRUCC (0x2000905c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Base Address Loopcount
*/


#define CPGC2_BASE_REPEATS_MCCPGC_MAIN_REG 0x2802905C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 base_repeats : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               Base Address Loopcount - Typically the number of
                               Base Addresses within the Block
                               (Row*Col*Bank*Rank). As N-1. (0=1 time.)[br]
                               This is the number of times the current
                               Algorithm Instruction will be executed when the
                               current CPGC2_ALGORITHM_INSTRUCTION_CTRL
                               Base_Range_Row = 0.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_BASE_REPEATS_MCCPGC_MAIN_STRUCT;

/* CPGC2_BASE_REPEATS_CURRENT_MCCPGC_MAIN_REG supported on:                     */
/*      SPRA0 (0x20009060)                                                      */
/*      SPRB0 (0x20009060)                                                      */
/*      SPRHBM (0x20009060)                                                     */
/*      SPRC0 (0x20009060)                                                      */
/*      SPRMCC (0x20009060)                                                     */
/*      SPRUCC (0x20009060)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Current Base Address Loopcount
*/


#define CPGC2_BASE_REPEATS_CURRENT_MCCPGC_MAIN_REG 0x28029060

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 base_repeats_current : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Current remaining Base Address loops (down
                               count).
                            */

  } Bits;
  UINT32 Data;

} CPGC2_BASE_REPEATS_CURRENT_MCCPGC_MAIN_STRUCT;

/* CPGC2_BASE_COL_REPEATS_MCCPGC_MAIN_REG supported on:                         */
/*      SPRA0 (0x20009064)                                                      */
/*      SPRB0 (0x20009064)                                                      */
/*      SPRHBM (0x20009064)                                                     */
/*      SPRC0 (0x20009064)                                                      */
/*      SPRMCC (0x20009064)                                                     */
/*      SPRUCC (0x20009064)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Base Address Loopcount - Alternate
*/


#define CPGC2_BASE_COL_REPEATS_MCCPGC_MAIN_REG 0x28029064

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 base_col_repeats : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               Alternate Base_Address_Loopcount. Often used to
                               initialize a Row or Column worth of data. As
                               N-1. (0=1 time.)[br] This is the number of times
                               the current Algorithm Instruction will be
                               executed when the current
                               CPGC2_ALGORITHM_INSTRUCTION_CTRL Base_Range_Row
                               = 1.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_BASE_COL_REPEATS_MCCPGC_MAIN_STRUCT;

/* CPGC2_BLOCK_REPEATS_MCCPGC_MAIN_REG supported on:                            */
/*      SPRA0 (0x20009068)                                                      */
/*      SPRB0 (0x20009068)                                                      */
/*      SPRHBM (0x20009068)                                                     */
/*      SPRC0 (0x20009068)                                                      */
/*      SPRMCC (0x20009068)                                                     */
/*      SPRUCC (0x20009068)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Block Loopcount for outer loop around all March Elements.
*/


#define CPGC2_BLOCK_REPEATS_MCCPGC_MAIN_REG 0x28029068

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 block_repeats : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               Block Loopcount. Typically the number of Blocks
                               to be tested to traverse the entire Tested
                               Region. (2^region_size/2^block_size -1). As N-1.
                               (0=1 time.)[br] This is the number of times the
                               entire list of Algorithm Instructions will be
                               executed.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_BLOCK_REPEATS_MCCPGC_MAIN_STRUCT;

/* CPGC2_BLOCK_REPEATS_CURRENT_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x2000906c)                                                      */
/*      SPRB0 (0x2000906c)                                                      */
/*      SPRHBM (0x2000906c)                                                     */
/*      SPRC0 (0x2000906c)                                                      */
/*      SPRMCC (0x2000906c)                                                     */
/*      SPRUCC (0x2000906c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Current Block Loopcount
*/


#define CPGC2_BLOCK_REPEATS_CURRENT_MCCPGC_MAIN_REG 0x2802906C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 block_repeats_current : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /* Current Block Loopcount (down count). */

  } Bits;
  UINT32 Data;

} CPGC2_BLOCK_REPEATS_CURRENT_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_0_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x9070)                                                          */
/*      SPRB0 (0x9070)                                                          */
/*      SPRHBM (0x9070)                                                         */
/*      SPRC0 (0x9070)                                                          */
/*      SPRMCC (0x9070)                                                         */
/*      SPRUCC (0x9070)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_0_MCCPGC_MAIN_REG 0x28009070

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_0_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_1_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x9071)                                                          */
/*      SPRB0 (0x9071)                                                          */
/*      SPRHBM (0x9071)                                                         */
/*      SPRC0 (0x9071)                                                          */
/*      SPRMCC (0x9071)                                                         */
/*      SPRUCC (0x9071)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_1_MCCPGC_MAIN_REG 0x28009071

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_1_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_2_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x9072)                                                          */
/*      SPRB0 (0x9072)                                                          */
/*      SPRHBM (0x9072)                                                         */
/*      SPRC0 (0x9072)                                                          */
/*      SPRMCC (0x9072)                                                         */
/*      SPRUCC (0x9072)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_2_MCCPGC_MAIN_REG 0x28009072

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_2_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_3_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x9073)                                                          */
/*      SPRB0 (0x9073)                                                          */
/*      SPRHBM (0x9073)                                                         */
/*      SPRC0 (0x9073)                                                          */
/*      SPRMCC (0x9073)                                                         */
/*      SPRUCC (0x9073)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_3_MCCPGC_MAIN_REG 0x28009073

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_3_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_4_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x9074)                                                          */
/*      SPRB0 (0x9074)                                                          */
/*      SPRHBM (0x9074)                                                         */
/*      SPRC0 (0x9074)                                                          */
/*      SPRMCC (0x9074)                                                         */
/*      SPRUCC (0x9074)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_4_MCCPGC_MAIN_REG 0x28009074

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_4_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_5_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x9075)                                                          */
/*      SPRB0 (0x9075)                                                          */
/*      SPRHBM (0x9075)                                                         */
/*      SPRC0 (0x9075)                                                          */
/*      SPRMCC (0x9075)                                                         */
/*      SPRUCC (0x9075)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_5_MCCPGC_MAIN_REG 0x28009075

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_5_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_6_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x9076)                                                          */
/*      SPRB0 (0x9076)                                                          */
/*      SPRHBM (0x9076)                                                         */
/*      SPRC0 (0x9076)                                                          */
/*      SPRMCC (0x9076)                                                         */
/*      SPRUCC (0x9076)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_6_MCCPGC_MAIN_REG 0x28009076

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_6_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_7_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x9077)                                                          */
/*      SPRB0 (0x9077)                                                          */
/*      SPRHBM (0x9077)                                                         */
/*      SPRC0 (0x9077)                                                          */
/*      SPRMCC (0x9077)                                                         */
/*      SPRUCC (0x9077)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_7_MCCPGC_MAIN_REG 0x28009077

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_7_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_8_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x9078)                                                          */
/*      SPRB0 (0x9078)                                                          */
/*      SPRHBM (0x9078)                                                         */
/*      SPRC0 (0x9078)                                                          */
/*      SPRMCC (0x9078)                                                         */
/*      SPRUCC (0x9078)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_8_MCCPGC_MAIN_REG 0x28009078

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_8_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_9_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x9079)                                                          */
/*      SPRB0 (0x9079)                                                          */
/*      SPRHBM (0x9079)                                                         */
/*      SPRC0 (0x9079)                                                          */
/*      SPRMCC (0x9079)                                                         */
/*      SPRUCC (0x9079)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_9_MCCPGC_MAIN_REG 0x28009079

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_9_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_10_MCCPGC_MAIN_REG supported on:                   */
/*      SPRA0 (0x907a)                                                          */
/*      SPRB0 (0x907a)                                                          */
/*      SPRHBM (0x907a)                                                         */
/*      SPRC0 (0x907a)                                                          */
/*      SPRMCC (0x907a)                                                         */
/*      SPRUCC (0x907a)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_10_MCCPGC_MAIN_REG 0x2800907A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_10_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_11_MCCPGC_MAIN_REG supported on:                   */
/*      SPRA0 (0x907b)                                                          */
/*      SPRB0 (0x907b)                                                          */
/*      SPRHBM (0x907b)                                                         */
/*      SPRC0 (0x907b)                                                          */
/*      SPRMCC (0x907b)                                                         */
/*      SPRUCC (0x907b)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_11_MCCPGC_MAIN_REG 0x2800907B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_11_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_12_MCCPGC_MAIN_REG supported on:                   */
/*      SPRA0 (0x907c)                                                          */
/*      SPRB0 (0x907c)                                                          */
/*      SPRHBM (0x907c)                                                         */
/*      SPRC0 (0x907c)                                                          */
/*      SPRMCC (0x907c)                                                         */
/*      SPRUCC (0x907c)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_12_MCCPGC_MAIN_REG 0x2800907C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_12_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_13_MCCPGC_MAIN_REG supported on:                   */
/*      SPRA0 (0x907d)                                                          */
/*      SPRB0 (0x907d)                                                          */
/*      SPRHBM (0x907d)                                                         */
/*      SPRC0 (0x907d)                                                          */
/*      SPRMCC (0x907d)                                                         */
/*      SPRUCC (0x907d)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_13_MCCPGC_MAIN_REG 0x2800907D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_13_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_14_MCCPGC_MAIN_REG supported on:                   */
/*      SPRA0 (0x907e)                                                          */
/*      SPRB0 (0x907e)                                                          */
/*      SPRHBM (0x907e)                                                         */
/*      SPRC0 (0x907e)                                                          */
/*      SPRMCC (0x907e)                                                         */
/*      SPRUCC (0x907e)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_14_MCCPGC_MAIN_REG 0x2800907E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_14_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_15_MCCPGC_MAIN_REG supported on:                   */
/*      SPRA0 (0x907f)                                                          */
/*      SPRB0 (0x907f)                                                          */
/*      SPRHBM (0x907f)                                                         */
/*      SPRC0 (0x907f)                                                          */
/*      SPRMCC (0x907f)                                                         */
/*      SPRUCC (0x907f)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_15_MCCPGC_MAIN_REG 0x2800907F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_15_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_16_MCCPGC_MAIN_REG supported on:                   */
/*      SPRA0 (0x9080)                                                          */
/*      SPRB0 (0x9080)                                                          */
/*      SPRHBM (0x9080)                                                         */
/*      SPRC0 (0x9080)                                                          */
/*      SPRMCC (0x9080)                                                         */
/*      SPRUCC (0x9080)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_16_MCCPGC_MAIN_REG 0x28009080

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_16_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_17_MCCPGC_MAIN_REG supported on:                   */
/*      SPRA0 (0x9081)                                                          */
/*      SPRB0 (0x9081)                                                          */
/*      SPRHBM (0x9081)                                                         */
/*      SPRC0 (0x9081)                                                          */
/*      SPRMCC (0x9081)                                                         */
/*      SPRUCC (0x9081)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_17_MCCPGC_MAIN_REG 0x28009081

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_17_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_18_MCCPGC_MAIN_REG supported on:                   */
/*      SPRA0 (0x9082)                                                          */
/*      SPRB0 (0x9082)                                                          */
/*      SPRHBM (0x9082)                                                         */
/*      SPRC0 (0x9082)                                                          */
/*      SPRMCC (0x9082)                                                         */
/*      SPRUCC (0x9082)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_18_MCCPGC_MAIN_REG 0x28009082

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_18_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_19_MCCPGC_MAIN_REG supported on:                   */
/*      SPRA0 (0x9083)                                                          */
/*      SPRB0 (0x9083)                                                          */
/*      SPRHBM (0x9083)                                                         */
/*      SPRC0 (0x9083)                                                          */
/*      SPRMCC (0x9083)                                                         */
/*      SPRUCC (0x9083)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_19_MCCPGC_MAIN_REG 0x28009083

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_19_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_20_MCCPGC_MAIN_REG supported on:                   */
/*      SPRA0 (0x9084)                                                          */
/*      SPRB0 (0x9084)                                                          */
/*      SPRHBM (0x9084)                                                         */
/*      SPRC0 (0x9084)                                                          */
/*      SPRMCC (0x9084)                                                         */
/*      SPRUCC (0x9084)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_20_MCCPGC_MAIN_REG 0x28009084

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_20_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_21_MCCPGC_MAIN_REG supported on:                   */
/*      SPRA0 (0x9085)                                                          */
/*      SPRB0 (0x9085)                                                          */
/*      SPRHBM (0x9085)                                                         */
/*      SPRC0 (0x9085)                                                          */
/*      SPRMCC (0x9085)                                                         */
/*      SPRUCC (0x9085)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_21_MCCPGC_MAIN_REG 0x28009085

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_21_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_22_MCCPGC_MAIN_REG supported on:                   */
/*      SPRA0 (0x9086)                                                          */
/*      SPRB0 (0x9086)                                                          */
/*      SPRHBM (0x9086)                                                         */
/*      SPRC0 (0x9086)                                                          */
/*      SPRMCC (0x9086)                                                         */
/*      SPRUCC (0x9086)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_22_MCCPGC_MAIN_REG 0x28009086

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_22_MCCPGC_MAIN_STRUCT;

/* CPGC2_COMMAND_INSTRUCTION_23_MCCPGC_MAIN_REG supported on:                   */
/*      SPRA0 (0x9087)                                                          */
/*      SPRB0 (0x9087)                                                          */
/*      SPRHBM (0x9087)                                                         */
/*      SPRC0 (0x9087)                                                          */
/*      SPRMCC (0x9087)                                                         */
/*      SPRUCC (0x9087)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Command Instruction controlling access type, data polarity, and offset sequence selection.
*/


#define CPGC2_COMMAND_INSTRUCTION_23_MCCPGC_MAIN_REG 0x28009087

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Base Write operation will be
                               performed. For an Offset operation, this field
                               will invert all WriteCmd bits for the given
                               Offset_Group when it is executed.
                            */
    UINT8 offset_group_srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Selects which Offset_Group will be used if
                               Offset field is set. If Offset field is not set,
                               then Request to Send Response for this
                               transaction.
                            */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If set, Alternate_Data_Select and
                               Address_Decode_Enable fields determine the
                               nature of this instruction.[br] If set and
                               Alternate_Data_Select is a 0, this is an Offset
                               operation, and the selected Offset_Group will be
                               executed in its place. In this case the Hammer
                               field is ignored.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 0, this is a Dummy
                               command; and if Address_Order0_Inc_Rate =1 the
                               Base Address is advanced.[br] If set and
                               Alternate_Data_Select is a 1, and
                               Address_Decode_Enable is a 1, this is a reserved
                               command and should not be programmed.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Base command will be repeated
                               Hammer_Repeats times. If both
                               Address_Order0_Inc_Rate is set and
                               Hammer_Increment_Rate are set, then the address
                               will be advanced for each access.
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 address_decode_or_prbs_en : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Enable rotating XOR of address bits or PRBS
                               address generation. If the Address_Decode_Enable
                               field in the Address_Instruction list is active,
                               and Address Decode or PRBS Enable is also
                               active, then for the access of this
                               Command_Instruction, the address will be XOR
                               with the XOR_Address_Pattern.[br] If the
                               Address_Decode_Enable field in the
                               Address_Instruction list is inactive (0), and
                               Address Decode or PRBS Enable is also active,
                               then the desired address fields will be replaced
                               with the PRBS generated value.
                            */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert the data used for this command. This is
                               combined with the Algorithm_Instruction and
                               Data_Instruction Invert_Data bits for Base
                               accesses. For Offset accesses, it is further
                               combined with the Offset_Command Invert_Data
                               bit.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               If set this is the last Command Instruction for
                               this Algorithm Command Sequence.
                               Command_Instruction[23] has this bit set
                               implicitly.[br] Execution continues at the
                               Command_Instruction pointed to by the
                               Algorithm_Instruction's Command_Start_Pointer
                               until the end of the Algorithm_Instruction.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_COMMAND_INSTRUCTION_23_MCCPGC_MAIN_STRUCT;

/* CPGC2_HAMMER_REPEATS_MCCPGC_MAIN_REG supported on:                           */
/*      SPRA0 (0x20009088)                                                      */
/*      SPRB0 (0x20009088)                                                      */
/*      SPRHBM (0x20009088)                                                     */
/*      SPRC0 (0x20009088)                                                      */
/*      SPRMCC (0x20009088)                                                     */
/*      SPRUCC (0x20009088)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Hammer Loopcount for repeating a command at the same location.
*/


#define CPGC2_HAMMER_REPEATS_MCCPGC_MAIN_REG 0x28029088

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hammer_repeats : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               Hammer_Repeats is the number of times any
                               command is repeated at the same address when the
                               Hammer control bit is set in the
                               Command_Instruction (if not an offset command).
                               As N-1. (0=1 time.)
                            */

  } Bits;
  UINT32 Data;

} CPGC2_HAMMER_REPEATS_MCCPGC_MAIN_STRUCT;

/* CPGC2_HAMMER_REPEATS_CURRENT_MCCPGC_MAIN_REG supported on:                   */
/*      SPRA0 (0x2000908c)                                                      */
/*      SPRB0 (0x2000908c)                                                      */
/*      SPRHBM (0x2000908c)                                                     */
/*      SPRC0 (0x2000908c)                                                      */
/*      SPRMCC (0x2000908c)                                                     */
/*      SPRUCC (0x2000908c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Current Hammer Loopcount
*/


#define CPGC2_HAMMER_REPEATS_CURRENT_MCCPGC_MAIN_REG 0x2802908C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 hammer_repeats_current : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /* Current Hammer Loopcount (down count). */

  } Bits;
  UINT32 Data;

} CPGC2_HAMMER_REPEATS_CURRENT_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_ADDRESS_INSTRUCTION_0_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x9090)                                                          */
/*      SPRB0 (0x9090)                                                          */
/*      SPRHBM (0x9090)                                                         */
/*      SPRC0 (0x9090)                                                          */
/*      SPRMCC (0x9090)                                                         */
/*      SPRUCC (0x9090)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Address Direction Instructions.  Note that these registers are grouped as two sets of 8 Offset_Address registers and their associated set of 6 Offset_Command registers. Thus we have two Offset_Groups.  Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][7:0]
*/


#define CPGC2_OFFSET_ADDRESS_INSTRUCTION_0_MCCPGC_MAIN_REG 0x28009090

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 periodic_data_inv_adj : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Reduce or increase the inversion interval by
                               -1,0,1 based on the value in this field.[br] 00
                               - no adjust[br] 01 - interval is increased by
                               1[br] 11 - interval is decreased by 1[br] 10 -
                               reserved
                            */
    UINT8 periodic_data_inv_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enabled periodic data inversion - based on
                               Address_Direction (OrderX field) -normally
                               invert every 2^Block_Size_Bits_Row/Col, modified
                               based on Periodic_Data_Inversion_Adjustment
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] (0)(00) FastY
                               -North[br] Increment Column and Carry Increment
                               into Row.[br] (1)(00) Inv(FastY) - South[br]
                               Decrement Column and Carry Decrement into
                               Row.[br] (0)(01) Diagonal - North East[br]
                               Increment Row and Column together and Carry
                               Increment Column into Row.[br] (1)(01)
                               Inv(Diagonal) - South West[br] Decrement Row and
                               Column together and Carry Decrement Column into
                               Row.[br] (0)(10) FastX - East[br] Increment Row
                               and Carry Increment into Column.[br] (1)(10)
                               Inv(FastX) - West[br] Decrement Row and Carry
                               Decrement into Column.[br] (0)(11) Diagonal2 -
                               South East[br] Decrement Column and Increment
                               Row and Carry Increment Column into Row.[br]
                               (1)(11) Inv(Diagonal2) - North West [br]
                               Increment Column and Decrement Row and Carry
                               Decrement Column into Row.[br] [br] Offset
                               accesses begin one 'step' in the given direction
                               from the current Base_Address.
                            */
    UINT8 stripe : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Normal Offsets use Address_Order=110[br] This
                               allows full traversal of the entire Block by and
                               offset.[br] If Stripe is active, then there is
                               no carry between Row and Column. This will keep
                               the offset address within the same Row, or the
                               same Column or on the same diagonal.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Address_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[7] and
                               Offset_Address_Instruction[15] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_ADDRESS_INSTRUCTION_0_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_ADDRESS_INSTRUCTION_1_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x9091)                                                          */
/*      SPRB0 (0x9091)                                                          */
/*      SPRHBM (0x9091)                                                         */
/*      SPRC0 (0x9091)                                                          */
/*      SPRMCC (0x9091)                                                         */
/*      SPRUCC (0x9091)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Address Direction Instructions.  Note that these registers are grouped as two sets of 8 Offset_Address registers and their associated set of 6 Offset_Command registers. Thus we have two Offset_Groups.  Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][7:0]
*/


#define CPGC2_OFFSET_ADDRESS_INSTRUCTION_1_MCCPGC_MAIN_REG 0x28009091

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 periodic_data_inv_adj : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Reduce or increase the inversion interval by
                               -1,0,1 based on the value in this field.[br] 00
                               - no adjust[br] 01 - interval is increased by
                               1[br] 11 - interval is decreased by 1[br] 10 -
                               reserved
                            */
    UINT8 periodic_data_inv_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enabled periodic data inversion - based on
                               Address_Direction (OrderX field) -normally
                               invert every 2^Block_Size_Bits_Row/Col, modified
                               based on Periodic_Data_Inversion_Adjustment
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] (0)(00) FastY
                               -North[br] Increment Column and Carry Increment
                               into Row.[br] (1)(00) Inv(FastY) - South[br]
                               Decrement Column and Carry Decrement into
                               Row.[br] (0)(01) Diagonal - North East[br]
                               Increment Row and Column together and Carry
                               Increment Column into Row.[br] (1)(01)
                               Inv(Diagonal) - South West[br] Decrement Row and
                               Column together and Carry Decrement Column into
                               Row.[br] (0)(10) FastX - East[br] Increment Row
                               and Carry Increment into Column.[br] (1)(10)
                               Inv(FastX) - West[br] Decrement Row and Carry
                               Decrement into Column.[br] (0)(11) Diagonal2 -
                               South East[br] Decrement Column and Increment
                               Row and Carry Increment Column into Row.[br]
                               (1)(11) Inv(Diagonal2) - North West [br]
                               Increment Column and Decrement Row and Carry
                               Decrement Column into Row.[br] [br] Offset
                               accesses begin one 'step' in the given direction
                               from the current Base_Address.
                            */
    UINT8 stripe : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Normal Offsets use Address_Order=110[br] This
                               allows full traversal of the entire Block by and
                               offset.[br] If Stripe is active, then there is
                               no carry between Row and Column. This will keep
                               the offset address within the same Row, or the
                               same Column or on the same diagonal.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Address_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[7] and
                               Offset_Address_Instruction[15] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_ADDRESS_INSTRUCTION_1_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_ADDRESS_INSTRUCTION_2_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x9092)                                                          */
/*      SPRB0 (0x9092)                                                          */
/*      SPRHBM (0x9092)                                                         */
/*      SPRC0 (0x9092)                                                          */
/*      SPRMCC (0x9092)                                                         */
/*      SPRUCC (0x9092)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Address Direction Instructions.  Note that these registers are grouped as two sets of 8 Offset_Address registers and their associated set of 6 Offset_Command registers. Thus we have two Offset_Groups.  Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][7:0]
*/


#define CPGC2_OFFSET_ADDRESS_INSTRUCTION_2_MCCPGC_MAIN_REG 0x28009092

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 periodic_data_inv_adj : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Reduce or increase the inversion interval by
                               -1,0,1 based on the value in this field.[br] 00
                               - no adjust[br] 01 - interval is increased by
                               1[br] 11 - interval is decreased by 1[br] 10 -
                               reserved
                            */
    UINT8 periodic_data_inv_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enabled periodic data inversion - based on
                               Address_Direction (OrderX field) -normally
                               invert every 2^Block_Size_Bits_Row/Col, modified
                               based on Periodic_Data_Inversion_Adjustment
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] (0)(00) FastY
                               -North[br] Increment Column and Carry Increment
                               into Row.[br] (1)(00) Inv(FastY) - South[br]
                               Decrement Column and Carry Decrement into
                               Row.[br] (0)(01) Diagonal - North East[br]
                               Increment Row and Column together and Carry
                               Increment Column into Row.[br] (1)(01)
                               Inv(Diagonal) - South West[br] Decrement Row and
                               Column together and Carry Decrement Column into
                               Row.[br] (0)(10) FastX - East[br] Increment Row
                               and Carry Increment into Column.[br] (1)(10)
                               Inv(FastX) - West[br] Decrement Row and Carry
                               Decrement into Column.[br] (0)(11) Diagonal2 -
                               South East[br] Decrement Column and Increment
                               Row and Carry Increment Column into Row.[br]
                               (1)(11) Inv(Diagonal2) - North West [br]
                               Increment Column and Decrement Row and Carry
                               Decrement Column into Row.[br] [br] Offset
                               accesses begin one 'step' in the given direction
                               from the current Base_Address.
                            */
    UINT8 stripe : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Normal Offsets use Address_Order=110[br] This
                               allows full traversal of the entire Block by and
                               offset.[br] If Stripe is active, then there is
                               no carry between Row and Column. This will keep
                               the offset address within the same Row, or the
                               same Column or on the same diagonal.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Address_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[7] and
                               Offset_Address_Instruction[15] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_ADDRESS_INSTRUCTION_2_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_ADDRESS_INSTRUCTION_3_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x9093)                                                          */
/*      SPRB0 (0x9093)                                                          */
/*      SPRHBM (0x9093)                                                         */
/*      SPRC0 (0x9093)                                                          */
/*      SPRMCC (0x9093)                                                         */
/*      SPRUCC (0x9093)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Address Direction Instructions.  Note that these registers are grouped as two sets of 8 Offset_Address registers and their associated set of 6 Offset_Command registers. Thus we have two Offset_Groups.  Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][7:0]
*/


#define CPGC2_OFFSET_ADDRESS_INSTRUCTION_3_MCCPGC_MAIN_REG 0x28009093

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 periodic_data_inv_adj : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Reduce or increase the inversion interval by
                               -1,0,1 based on the value in this field.[br] 00
                               - no adjust[br] 01 - interval is increased by
                               1[br] 11 - interval is decreased by 1[br] 10 -
                               reserved
                            */
    UINT8 periodic_data_inv_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enabled periodic data inversion - based on
                               Address_Direction (OrderX field) -normally
                               invert every 2^Block_Size_Bits_Row/Col, modified
                               based on Periodic_Data_Inversion_Adjustment
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] (0)(00) FastY
                               -North[br] Increment Column and Carry Increment
                               into Row.[br] (1)(00) Inv(FastY) - South[br]
                               Decrement Column and Carry Decrement into
                               Row.[br] (0)(01) Diagonal - North East[br]
                               Increment Row and Column together and Carry
                               Increment Column into Row.[br] (1)(01)
                               Inv(Diagonal) - South West[br] Decrement Row and
                               Column together and Carry Decrement Column into
                               Row.[br] (0)(10) FastX - East[br] Increment Row
                               and Carry Increment into Column.[br] (1)(10)
                               Inv(FastX) - West[br] Decrement Row and Carry
                               Decrement into Column.[br] (0)(11) Diagonal2 -
                               South East[br] Decrement Column and Increment
                               Row and Carry Increment Column into Row.[br]
                               (1)(11) Inv(Diagonal2) - North West [br]
                               Increment Column and Decrement Row and Carry
                               Decrement Column into Row.[br] [br] Offset
                               accesses begin one 'step' in the given direction
                               from the current Base_Address.
                            */
    UINT8 stripe : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Normal Offsets use Address_Order=110[br] This
                               allows full traversal of the entire Block by and
                               offset.[br] If Stripe is active, then there is
                               no carry between Row and Column. This will keep
                               the offset address within the same Row, or the
                               same Column or on the same diagonal.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Address_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[7] and
                               Offset_Address_Instruction[15] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_ADDRESS_INSTRUCTION_3_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_ADDRESS_INSTRUCTION_4_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x9094)                                                          */
/*      SPRB0 (0x9094)                                                          */
/*      SPRHBM (0x9094)                                                         */
/*      SPRC0 (0x9094)                                                          */
/*      SPRMCC (0x9094)                                                         */
/*      SPRUCC (0x9094)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Address Direction Instructions.  Note that these registers are grouped as two sets of 8 Offset_Address registers and their associated set of 6 Offset_Command registers. Thus we have two Offset_Groups.  Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][7:0]
*/


#define CPGC2_OFFSET_ADDRESS_INSTRUCTION_4_MCCPGC_MAIN_REG 0x28009094

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 periodic_data_inv_adj : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Reduce or increase the inversion interval by
                               -1,0,1 based on the value in this field.[br] 00
                               - no adjust[br] 01 - interval is increased by
                               1[br] 11 - interval is decreased by 1[br] 10 -
                               reserved
                            */
    UINT8 periodic_data_inv_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enabled periodic data inversion - based on
                               Address_Direction (OrderX field) -normally
                               invert every 2^Block_Size_Bits_Row/Col, modified
                               based on Periodic_Data_Inversion_Adjustment
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] (0)(00) FastY
                               -North[br] Increment Column and Carry Increment
                               into Row.[br] (1)(00) Inv(FastY) - South[br]
                               Decrement Column and Carry Decrement into
                               Row.[br] (0)(01) Diagonal - North East[br]
                               Increment Row and Column together and Carry
                               Increment Column into Row.[br] (1)(01)
                               Inv(Diagonal) - South West[br] Decrement Row and
                               Column together and Carry Decrement Column into
                               Row.[br] (0)(10) FastX - East[br] Increment Row
                               and Carry Increment into Column.[br] (1)(10)
                               Inv(FastX) - West[br] Decrement Row and Carry
                               Decrement into Column.[br] (0)(11) Diagonal2 -
                               South East[br] Decrement Column and Increment
                               Row and Carry Increment Column into Row.[br]
                               (1)(11) Inv(Diagonal2) - North West [br]
                               Increment Column and Decrement Row and Carry
                               Decrement Column into Row.[br] [br] Offset
                               accesses begin one 'step' in the given direction
                               from the current Base_Address.
                            */
    UINT8 stripe : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Normal Offsets use Address_Order=110[br] This
                               allows full traversal of the entire Block by and
                               offset.[br] If Stripe is active, then there is
                               no carry between Row and Column. This will keep
                               the offset address within the same Row, or the
                               same Column or on the same diagonal.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Address_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[7] and
                               Offset_Address_Instruction[15] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_ADDRESS_INSTRUCTION_4_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_ADDRESS_INSTRUCTION_5_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x9095)                                                          */
/*      SPRB0 (0x9095)                                                          */
/*      SPRHBM (0x9095)                                                         */
/*      SPRC0 (0x9095)                                                          */
/*      SPRMCC (0x9095)                                                         */
/*      SPRUCC (0x9095)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Address Direction Instructions.  Note that these registers are grouped as two sets of 8 Offset_Address registers and their associated set of 6 Offset_Command registers. Thus we have two Offset_Groups.  Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][7:0]
*/


#define CPGC2_OFFSET_ADDRESS_INSTRUCTION_5_MCCPGC_MAIN_REG 0x28009095

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 periodic_data_inv_adj : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Reduce or increase the inversion interval by
                               -1,0,1 based on the value in this field.[br] 00
                               - no adjust[br] 01 - interval is increased by
                               1[br] 11 - interval is decreased by 1[br] 10 -
                               reserved
                            */
    UINT8 periodic_data_inv_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enabled periodic data inversion - based on
                               Address_Direction (OrderX field) -normally
                               invert every 2^Block_Size_Bits_Row/Col, modified
                               based on Periodic_Data_Inversion_Adjustment
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] (0)(00) FastY
                               -North[br] Increment Column and Carry Increment
                               into Row.[br] (1)(00) Inv(FastY) - South[br]
                               Decrement Column and Carry Decrement into
                               Row.[br] (0)(01) Diagonal - North East[br]
                               Increment Row and Column together and Carry
                               Increment Column into Row.[br] (1)(01)
                               Inv(Diagonal) - South West[br] Decrement Row and
                               Column together and Carry Decrement Column into
                               Row.[br] (0)(10) FastX - East[br] Increment Row
                               and Carry Increment into Column.[br] (1)(10)
                               Inv(FastX) - West[br] Decrement Row and Carry
                               Decrement into Column.[br] (0)(11) Diagonal2 -
                               South East[br] Decrement Column and Increment
                               Row and Carry Increment Column into Row.[br]
                               (1)(11) Inv(Diagonal2) - North West [br]
                               Increment Column and Decrement Row and Carry
                               Decrement Column into Row.[br] [br] Offset
                               accesses begin one 'step' in the given direction
                               from the current Base_Address.
                            */
    UINT8 stripe : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Normal Offsets use Address_Order=110[br] This
                               allows full traversal of the entire Block by and
                               offset.[br] If Stripe is active, then there is
                               no carry between Row and Column. This will keep
                               the offset address within the same Row, or the
                               same Column or on the same diagonal.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Address_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[7] and
                               Offset_Address_Instruction[15] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_ADDRESS_INSTRUCTION_5_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_ADDRESS_INSTRUCTION_6_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x9096)                                                          */
/*      SPRB0 (0x9096)                                                          */
/*      SPRHBM (0x9096)                                                         */
/*      SPRC0 (0x9096)                                                          */
/*      SPRMCC (0x9096)                                                         */
/*      SPRUCC (0x9096)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Address Direction Instructions.  Note that these registers are grouped as two sets of 8 Offset_Address registers and their associated set of 6 Offset_Command registers. Thus we have two Offset_Groups.  Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][7:0]
*/


#define CPGC2_OFFSET_ADDRESS_INSTRUCTION_6_MCCPGC_MAIN_REG 0x28009096

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 periodic_data_inv_adj : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Reduce or increase the inversion interval by
                               -1,0,1 based on the value in this field.[br] 00
                               - no adjust[br] 01 - interval is increased by
                               1[br] 11 - interval is decreased by 1[br] 10 -
                               reserved
                            */
    UINT8 periodic_data_inv_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enabled periodic data inversion - based on
                               Address_Direction (OrderX field) -normally
                               invert every 2^Block_Size_Bits_Row/Col, modified
                               based on Periodic_Data_Inversion_Adjustment
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] (0)(00) FastY
                               -North[br] Increment Column and Carry Increment
                               into Row.[br] (1)(00) Inv(FastY) - South[br]
                               Decrement Column and Carry Decrement into
                               Row.[br] (0)(01) Diagonal - North East[br]
                               Increment Row and Column together and Carry
                               Increment Column into Row.[br] (1)(01)
                               Inv(Diagonal) - South West[br] Decrement Row and
                               Column together and Carry Decrement Column into
                               Row.[br] (0)(10) FastX - East[br] Increment Row
                               and Carry Increment into Column.[br] (1)(10)
                               Inv(FastX) - West[br] Decrement Row and Carry
                               Decrement into Column.[br] (0)(11) Diagonal2 -
                               South East[br] Decrement Column and Increment
                               Row and Carry Increment Column into Row.[br]
                               (1)(11) Inv(Diagonal2) - North West [br]
                               Increment Column and Decrement Row and Carry
                               Decrement Column into Row.[br] [br] Offset
                               accesses begin one 'step' in the given direction
                               from the current Base_Address.
                            */
    UINT8 stripe : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Normal Offsets use Address_Order=110[br] This
                               allows full traversal of the entire Block by and
                               offset.[br] If Stripe is active, then there is
                               no carry between Row and Column. This will keep
                               the offset address within the same Row, or the
                               same Column or on the same diagonal.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Address_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[7] and
                               Offset_Address_Instruction[15] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_ADDRESS_INSTRUCTION_6_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_ADDRESS_INSTRUCTION_7_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x9097)                                                          */
/*      SPRB0 (0x9097)                                                          */
/*      SPRHBM (0x9097)                                                         */
/*      SPRC0 (0x9097)                                                          */
/*      SPRMCC (0x9097)                                                         */
/*      SPRUCC (0x9097)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Address Direction Instructions.  Note that these registers are grouped as two sets of 8 Offset_Address registers and their associated set of 6 Offset_Command registers. Thus we have two Offset_Groups.  Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][7:0]
*/


#define CPGC2_OFFSET_ADDRESS_INSTRUCTION_7_MCCPGC_MAIN_REG 0x28009097

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 periodic_data_inv_adj : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Reduce or increase the inversion interval by
                               -1,0,1 based on the value in this field.[br] 00
                               - no adjust[br] 01 - interval is increased by
                               1[br] 11 - interval is decreased by 1[br] 10 -
                               reserved
                            */
    UINT8 periodic_data_inv_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enabled periodic data inversion - based on
                               Address_Direction (OrderX field) -normally
                               invert every 2^Block_Size_Bits_Row/Col, modified
                               based on Periodic_Data_Inversion_Adjustment
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] (0)(00) FastY
                               -North[br] Increment Column and Carry Increment
                               into Row.[br] (1)(00) Inv(FastY) - South[br]
                               Decrement Column and Carry Decrement into
                               Row.[br] (0)(01) Diagonal - North East[br]
                               Increment Row and Column together and Carry
                               Increment Column into Row.[br] (1)(01)
                               Inv(Diagonal) - South West[br] Decrement Row and
                               Column together and Carry Decrement Column into
                               Row.[br] (0)(10) FastX - East[br] Increment Row
                               and Carry Increment into Column.[br] (1)(10)
                               Inv(FastX) - West[br] Decrement Row and Carry
                               Decrement into Column.[br] (0)(11) Diagonal2 -
                               South East[br] Decrement Column and Increment
                               Row and Carry Increment Column into Row.[br]
                               (1)(11) Inv(Diagonal2) - North West [br]
                               Increment Column and Decrement Row and Carry
                               Decrement Column into Row.[br] [br] Offset
                               accesses begin one 'step' in the given direction
                               from the current Base_Address.
                            */
    UINT8 stripe : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Normal Offsets use Address_Order=110[br] This
                               allows full traversal of the entire Block by and
                               offset.[br] If Stripe is active, then there is
                               no carry between Row and Column. This will keep
                               the offset address within the same Row, or the
                               same Column or on the same diagonal.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Address_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[7] and
                               Offset_Address_Instruction[15] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_ADDRESS_INSTRUCTION_7_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_ADDRESS_INSTRUCTION_8_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x9098)                                                          */
/*      SPRB0 (0x9098)                                                          */
/*      SPRHBM (0x9098)                                                         */
/*      SPRC0 (0x9098)                                                          */
/*      SPRMCC (0x9098)                                                         */
/*      SPRUCC (0x9098)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Address Direction Instructions.  Note that these registers are grouped as two sets of 8 Offset_Address registers and their associated set of 6 Offset_Command registers. Thus we have two Offset_Groups.  Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][7:0]
*/


#define CPGC2_OFFSET_ADDRESS_INSTRUCTION_8_MCCPGC_MAIN_REG 0x28009098

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 periodic_data_inv_adj : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Reduce or increase the inversion interval by
                               -1,0,1 based on the value in this field.[br] 00
                               - no adjust[br] 01 - interval is increased by
                               1[br] 11 - interval is decreased by 1[br] 10 -
                               reserved
                            */
    UINT8 periodic_data_inv_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enabled periodic data inversion - based on
                               Address_Direction (OrderX field) -normally
                               invert every 2^Block_Size_Bits_Row/Col, modified
                               based on Periodic_Data_Inversion_Adjustment
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] (0)(00) FastY
                               -North[br] Increment Column and Carry Increment
                               into Row.[br] (1)(00) Inv(FastY) - South[br]
                               Decrement Column and Carry Decrement into
                               Row.[br] (0)(01) Diagonal - North East[br]
                               Increment Row and Column together and Carry
                               Increment Column into Row.[br] (1)(01)
                               Inv(Diagonal) - South West[br] Decrement Row and
                               Column together and Carry Decrement Column into
                               Row.[br] (0)(10) FastX - East[br] Increment Row
                               and Carry Increment into Column.[br] (1)(10)
                               Inv(FastX) - West[br] Decrement Row and Carry
                               Decrement into Column.[br] (0)(11) Diagonal2 -
                               South East[br] Decrement Column and Increment
                               Row and Carry Increment Column into Row.[br]
                               (1)(11) Inv(Diagonal2) - North West [br]
                               Increment Column and Decrement Row and Carry
                               Decrement Column into Row.[br] [br] Offset
                               accesses begin one 'step' in the given direction
                               from the current Base_Address.
                            */
    UINT8 stripe : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Normal Offsets use Address_Order=110[br] This
                               allows full traversal of the entire Block by and
                               offset.[br] If Stripe is active, then there is
                               no carry between Row and Column. This will keep
                               the offset address within the same Row, or the
                               same Column or on the same diagonal.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Address_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[7] and
                               Offset_Address_Instruction[15] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_ADDRESS_INSTRUCTION_8_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_ADDRESS_INSTRUCTION_9_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x9099)                                                          */
/*      SPRB0 (0x9099)                                                          */
/*      SPRHBM (0x9099)                                                         */
/*      SPRC0 (0x9099)                                                          */
/*      SPRMCC (0x9099)                                                         */
/*      SPRUCC (0x9099)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Address Direction Instructions.  Note that these registers are grouped as two sets of 8 Offset_Address registers and their associated set of 6 Offset_Command registers. Thus we have two Offset_Groups.  Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][7:0]
*/


#define CPGC2_OFFSET_ADDRESS_INSTRUCTION_9_MCCPGC_MAIN_REG 0x28009099

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 periodic_data_inv_adj : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Reduce or increase the inversion interval by
                               -1,0,1 based on the value in this field.[br] 00
                               - no adjust[br] 01 - interval is increased by
                               1[br] 11 - interval is decreased by 1[br] 10 -
                               reserved
                            */
    UINT8 periodic_data_inv_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enabled periodic data inversion - based on
                               Address_Direction (OrderX field) -normally
                               invert every 2^Block_Size_Bits_Row/Col, modified
                               based on Periodic_Data_Inversion_Adjustment
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] (0)(00) FastY
                               -North[br] Increment Column and Carry Increment
                               into Row.[br] (1)(00) Inv(FastY) - South[br]
                               Decrement Column and Carry Decrement into
                               Row.[br] (0)(01) Diagonal - North East[br]
                               Increment Row and Column together and Carry
                               Increment Column into Row.[br] (1)(01)
                               Inv(Diagonal) - South West[br] Decrement Row and
                               Column together and Carry Decrement Column into
                               Row.[br] (0)(10) FastX - East[br] Increment Row
                               and Carry Increment into Column.[br] (1)(10)
                               Inv(FastX) - West[br] Decrement Row and Carry
                               Decrement into Column.[br] (0)(11) Diagonal2 -
                               South East[br] Decrement Column and Increment
                               Row and Carry Increment Column into Row.[br]
                               (1)(11) Inv(Diagonal2) - North West [br]
                               Increment Column and Decrement Row and Carry
                               Decrement Column into Row.[br] [br] Offset
                               accesses begin one 'step' in the given direction
                               from the current Base_Address.
                            */
    UINT8 stripe : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Normal Offsets use Address_Order=110[br] This
                               allows full traversal of the entire Block by and
                               offset.[br] If Stripe is active, then there is
                               no carry between Row and Column. This will keep
                               the offset address within the same Row, or the
                               same Column or on the same diagonal.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Address_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[7] and
                               Offset_Address_Instruction[15] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_ADDRESS_INSTRUCTION_9_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_ADDRESS_INSTRUCTION_10_MCCPGC_MAIN_REG supported on:            */
/*      SPRA0 (0x909a)                                                          */
/*      SPRB0 (0x909a)                                                          */
/*      SPRHBM (0x909a)                                                         */
/*      SPRC0 (0x909a)                                                          */
/*      SPRMCC (0x909a)                                                         */
/*      SPRUCC (0x909a)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Address Direction Instructions.  Note that these registers are grouped as two sets of 8 Offset_Address registers and their associated set of 6 Offset_Command registers. Thus we have two Offset_Groups.  Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][7:0]
*/


#define CPGC2_OFFSET_ADDRESS_INSTRUCTION_10_MCCPGC_MAIN_REG 0x2800909A

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 periodic_data_inv_adj : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Reduce or increase the inversion interval by
                               -1,0,1 based on the value in this field.[br] 00
                               - no adjust[br] 01 - interval is increased by
                               1[br] 11 - interval is decreased by 1[br] 10 -
                               reserved
                            */
    UINT8 periodic_data_inv_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enabled periodic data inversion - based on
                               Address_Direction (OrderX field) -normally
                               invert every 2^Block_Size_Bits_Row/Col, modified
                               based on Periodic_Data_Inversion_Adjustment
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] (0)(00) FastY
                               -North[br] Increment Column and Carry Increment
                               into Row.[br] (1)(00) Inv(FastY) - South[br]
                               Decrement Column and Carry Decrement into
                               Row.[br] (0)(01) Diagonal - North East[br]
                               Increment Row and Column together and Carry
                               Increment Column into Row.[br] (1)(01)
                               Inv(Diagonal) - South West[br] Decrement Row and
                               Column together and Carry Decrement Column into
                               Row.[br] (0)(10) FastX - East[br] Increment Row
                               and Carry Increment into Column.[br] (1)(10)
                               Inv(FastX) - West[br] Decrement Row and Carry
                               Decrement into Column.[br] (0)(11) Diagonal2 -
                               South East[br] Decrement Column and Increment
                               Row and Carry Increment Column into Row.[br]
                               (1)(11) Inv(Diagonal2) - North West [br]
                               Increment Column and Decrement Row and Carry
                               Decrement Column into Row.[br] [br] Offset
                               accesses begin one 'step' in the given direction
                               from the current Base_Address.
                            */
    UINT8 stripe : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Normal Offsets use Address_Order=110[br] This
                               allows full traversal of the entire Block by and
                               offset.[br] If Stripe is active, then there is
                               no carry between Row and Column. This will keep
                               the offset address within the same Row, or the
                               same Column or on the same diagonal.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Address_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[7] and
                               Offset_Address_Instruction[15] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_ADDRESS_INSTRUCTION_10_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_ADDRESS_INSTRUCTION_11_MCCPGC_MAIN_REG supported on:            */
/*      SPRA0 (0x909b)                                                          */
/*      SPRB0 (0x909b)                                                          */
/*      SPRHBM (0x909b)                                                         */
/*      SPRC0 (0x909b)                                                          */
/*      SPRMCC (0x909b)                                                         */
/*      SPRUCC (0x909b)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Address Direction Instructions.  Note that these registers are grouped as two sets of 8 Offset_Address registers and their associated set of 6 Offset_Command registers. Thus we have two Offset_Groups.  Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][7:0]
*/


#define CPGC2_OFFSET_ADDRESS_INSTRUCTION_11_MCCPGC_MAIN_REG 0x2800909B

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 periodic_data_inv_adj : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Reduce or increase the inversion interval by
                               -1,0,1 based on the value in this field.[br] 00
                               - no adjust[br] 01 - interval is increased by
                               1[br] 11 - interval is decreased by 1[br] 10 -
                               reserved
                            */
    UINT8 periodic_data_inv_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enabled periodic data inversion - based on
                               Address_Direction (OrderX field) -normally
                               invert every 2^Block_Size_Bits_Row/Col, modified
                               based on Periodic_Data_Inversion_Adjustment
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] (0)(00) FastY
                               -North[br] Increment Column and Carry Increment
                               into Row.[br] (1)(00) Inv(FastY) - South[br]
                               Decrement Column and Carry Decrement into
                               Row.[br] (0)(01) Diagonal - North East[br]
                               Increment Row and Column together and Carry
                               Increment Column into Row.[br] (1)(01)
                               Inv(Diagonal) - South West[br] Decrement Row and
                               Column together and Carry Decrement Column into
                               Row.[br] (0)(10) FastX - East[br] Increment Row
                               and Carry Increment into Column.[br] (1)(10)
                               Inv(FastX) - West[br] Decrement Row and Carry
                               Decrement into Column.[br] (0)(11) Diagonal2 -
                               South East[br] Decrement Column and Increment
                               Row and Carry Increment Column into Row.[br]
                               (1)(11) Inv(Diagonal2) - North West [br]
                               Increment Column and Decrement Row and Carry
                               Decrement Column into Row.[br] [br] Offset
                               accesses begin one 'step' in the given direction
                               from the current Base_Address.
                            */
    UINT8 stripe : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Normal Offsets use Address_Order=110[br] This
                               allows full traversal of the entire Block by and
                               offset.[br] If Stripe is active, then there is
                               no carry between Row and Column. This will keep
                               the offset address within the same Row, or the
                               same Column or on the same diagonal.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Address_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[7] and
                               Offset_Address_Instruction[15] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_ADDRESS_INSTRUCTION_11_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_ADDRESS_INSTRUCTION_12_MCCPGC_MAIN_REG supported on:            */
/*      SPRA0 (0x909c)                                                          */
/*      SPRB0 (0x909c)                                                          */
/*      SPRHBM (0x909c)                                                         */
/*      SPRC0 (0x909c)                                                          */
/*      SPRMCC (0x909c)                                                         */
/*      SPRUCC (0x909c)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Address Direction Instructions.  Note that these registers are grouped as two sets of 8 Offset_Address registers and their associated set of 6 Offset_Command registers. Thus we have two Offset_Groups.  Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][7:0]
*/


#define CPGC2_OFFSET_ADDRESS_INSTRUCTION_12_MCCPGC_MAIN_REG 0x2800909C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 periodic_data_inv_adj : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Reduce or increase the inversion interval by
                               -1,0,1 based on the value in this field.[br] 00
                               - no adjust[br] 01 - interval is increased by
                               1[br] 11 - interval is decreased by 1[br] 10 -
                               reserved
                            */
    UINT8 periodic_data_inv_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enabled periodic data inversion - based on
                               Address_Direction (OrderX field) -normally
                               invert every 2^Block_Size_Bits_Row/Col, modified
                               based on Periodic_Data_Inversion_Adjustment
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] (0)(00) FastY
                               -North[br] Increment Column and Carry Increment
                               into Row.[br] (1)(00) Inv(FastY) - South[br]
                               Decrement Column and Carry Decrement into
                               Row.[br] (0)(01) Diagonal - North East[br]
                               Increment Row and Column together and Carry
                               Increment Column into Row.[br] (1)(01)
                               Inv(Diagonal) - South West[br] Decrement Row and
                               Column together and Carry Decrement Column into
                               Row.[br] (0)(10) FastX - East[br] Increment Row
                               and Carry Increment into Column.[br] (1)(10)
                               Inv(FastX) - West[br] Decrement Row and Carry
                               Decrement into Column.[br] (0)(11) Diagonal2 -
                               South East[br] Decrement Column and Increment
                               Row and Carry Increment Column into Row.[br]
                               (1)(11) Inv(Diagonal2) - North West [br]
                               Increment Column and Decrement Row and Carry
                               Decrement Column into Row.[br] [br] Offset
                               accesses begin one 'step' in the given direction
                               from the current Base_Address.
                            */
    UINT8 stripe : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Normal Offsets use Address_Order=110[br] This
                               allows full traversal of the entire Block by and
                               offset.[br] If Stripe is active, then there is
                               no carry between Row and Column. This will keep
                               the offset address within the same Row, or the
                               same Column or on the same diagonal.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Address_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[7] and
                               Offset_Address_Instruction[15] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_ADDRESS_INSTRUCTION_12_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_ADDRESS_INSTRUCTION_13_MCCPGC_MAIN_REG supported on:            */
/*      SPRA0 (0x909d)                                                          */
/*      SPRB0 (0x909d)                                                          */
/*      SPRHBM (0x909d)                                                         */
/*      SPRC0 (0x909d)                                                          */
/*      SPRMCC (0x909d)                                                         */
/*      SPRUCC (0x909d)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Address Direction Instructions.  Note that these registers are grouped as two sets of 8 Offset_Address registers and their associated set of 6 Offset_Command registers. Thus we have two Offset_Groups.  Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][7:0]
*/


#define CPGC2_OFFSET_ADDRESS_INSTRUCTION_13_MCCPGC_MAIN_REG 0x2800909D

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 periodic_data_inv_adj : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Reduce or increase the inversion interval by
                               -1,0,1 based on the value in this field.[br] 00
                               - no adjust[br] 01 - interval is increased by
                               1[br] 11 - interval is decreased by 1[br] 10 -
                               reserved
                            */
    UINT8 periodic_data_inv_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enabled periodic data inversion - based on
                               Address_Direction (OrderX field) -normally
                               invert every 2^Block_Size_Bits_Row/Col, modified
                               based on Periodic_Data_Inversion_Adjustment
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] (0)(00) FastY
                               -North[br] Increment Column and Carry Increment
                               into Row.[br] (1)(00) Inv(FastY) - South[br]
                               Decrement Column and Carry Decrement into
                               Row.[br] (0)(01) Diagonal - North East[br]
                               Increment Row and Column together and Carry
                               Increment Column into Row.[br] (1)(01)
                               Inv(Diagonal) - South West[br] Decrement Row and
                               Column together and Carry Decrement Column into
                               Row.[br] (0)(10) FastX - East[br] Increment Row
                               and Carry Increment into Column.[br] (1)(10)
                               Inv(FastX) - West[br] Decrement Row and Carry
                               Decrement into Column.[br] (0)(11) Diagonal2 -
                               South East[br] Decrement Column and Increment
                               Row and Carry Increment Column into Row.[br]
                               (1)(11) Inv(Diagonal2) - North West [br]
                               Increment Column and Decrement Row and Carry
                               Decrement Column into Row.[br] [br] Offset
                               accesses begin one 'step' in the given direction
                               from the current Base_Address.
                            */
    UINT8 stripe : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Normal Offsets use Address_Order=110[br] This
                               allows full traversal of the entire Block by and
                               offset.[br] If Stripe is active, then there is
                               no carry between Row and Column. This will keep
                               the offset address within the same Row, or the
                               same Column or on the same diagonal.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Address_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[7] and
                               Offset_Address_Instruction[15] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_ADDRESS_INSTRUCTION_13_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_ADDRESS_INSTRUCTION_14_MCCPGC_MAIN_REG supported on:            */
/*      SPRA0 (0x909e)                                                          */
/*      SPRB0 (0x909e)                                                          */
/*      SPRHBM (0x909e)                                                         */
/*      SPRC0 (0x909e)                                                          */
/*      SPRMCC (0x909e)                                                         */
/*      SPRUCC (0x909e)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Address Direction Instructions.  Note that these registers are grouped as two sets of 8 Offset_Address registers and their associated set of 6 Offset_Command registers. Thus we have two Offset_Groups.  Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][7:0]
*/


#define CPGC2_OFFSET_ADDRESS_INSTRUCTION_14_MCCPGC_MAIN_REG 0x2800909E

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 periodic_data_inv_adj : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Reduce or increase the inversion interval by
                               -1,0,1 based on the value in this field.[br] 00
                               - no adjust[br] 01 - interval is increased by
                               1[br] 11 - interval is decreased by 1[br] 10 -
                               reserved
                            */
    UINT8 periodic_data_inv_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enabled periodic data inversion - based on
                               Address_Direction (OrderX field) -normally
                               invert every 2^Block_Size_Bits_Row/Col, modified
                               based on Periodic_Data_Inversion_Adjustment
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] (0)(00) FastY
                               -North[br] Increment Column and Carry Increment
                               into Row.[br] (1)(00) Inv(FastY) - South[br]
                               Decrement Column and Carry Decrement into
                               Row.[br] (0)(01) Diagonal - North East[br]
                               Increment Row and Column together and Carry
                               Increment Column into Row.[br] (1)(01)
                               Inv(Diagonal) - South West[br] Decrement Row and
                               Column together and Carry Decrement Column into
                               Row.[br] (0)(10) FastX - East[br] Increment Row
                               and Carry Increment into Column.[br] (1)(10)
                               Inv(FastX) - West[br] Decrement Row and Carry
                               Decrement into Column.[br] (0)(11) Diagonal2 -
                               South East[br] Decrement Column and Increment
                               Row and Carry Increment Column into Row.[br]
                               (1)(11) Inv(Diagonal2) - North West [br]
                               Increment Column and Decrement Row and Carry
                               Decrement Column into Row.[br] [br] Offset
                               accesses begin one 'step' in the given direction
                               from the current Base_Address.
                            */
    UINT8 stripe : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Normal Offsets use Address_Order=110[br] This
                               allows full traversal of the entire Block by and
                               offset.[br] If Stripe is active, then there is
                               no carry between Row and Column. This will keep
                               the offset address within the same Row, or the
                               same Column or on the same diagonal.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Address_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[7] and
                               Offset_Address_Instruction[15] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_ADDRESS_INSTRUCTION_14_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_ADDRESS_INSTRUCTION_15_MCCPGC_MAIN_REG supported on:            */
/*      SPRA0 (0x909f)                                                          */
/*      SPRB0 (0x909f)                                                          */
/*      SPRHBM (0x909f)                                                         */
/*      SPRC0 (0x909f)                                                          */
/*      SPRMCC (0x909f)                                                         */
/*      SPRUCC (0x909f)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Address Direction Instructions.  Note that these registers are grouped as two sets of 8 Offset_Address registers and their associated set of 6 Offset_Command registers. Thus we have two Offset_Groups.  Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][7:0]
*/


#define CPGC2_OFFSET_ADDRESS_INSTRUCTION_15_MCCPGC_MAIN_REG 0x2800909F

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 periodic_data_inv_adj : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Reduce or increase the inversion interval by
                               -1,0,1 based on the value in this field.[br] 00
                               - no adjust[br] 01 - interval is increased by
                               1[br] 11 - interval is decreased by 1[br] 10 -
                               reserved
                            */
    UINT8 periodic_data_inv_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Enabled periodic data inversion - based on
                               Address_Direction (OrderX field) -normally
                               invert every 2^Block_Size_Bits_Row/Col, modified
                               based on Periodic_Data_Inversion_Adjustment
                            */
    UINT8 address_direction : 3;

                            /* Bits[5:3], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Direction[br] There are 4 basic address
                               directions and their inverse for a total of
                               8.[br] We will denote this as a combination of a
                               1-bit field and a 2-bit field.[br] (0)(00) FastY
                               -North[br] Increment Column and Carry Increment
                               into Row.[br] (1)(00) Inv(FastY) - South[br]
                               Decrement Column and Carry Decrement into
                               Row.[br] (0)(01) Diagonal - North East[br]
                               Increment Row and Column together and Carry
                               Increment Column into Row.[br] (1)(01)
                               Inv(Diagonal) - South West[br] Decrement Row and
                               Column together and Carry Decrement Column into
                               Row.[br] (0)(10) FastX - East[br] Increment Row
                               and Carry Increment into Column.[br] (1)(10)
                               Inv(FastX) - West[br] Decrement Row and Carry
                               Decrement into Column.[br] (0)(11) Diagonal2 -
                               South East[br] Decrement Column and Increment
                               Row and Carry Increment Column into Row.[br]
                               (1)(11) Inv(Diagonal2) - North West [br]
                               Increment Column and Decrement Row and Carry
                               Decrement Column into Row.[br] [br] Offset
                               accesses begin one 'step' in the given direction
                               from the current Base_Address.
                            */
    UINT8 stripe : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Normal Offsets use Address_Order=110[br] This
                               allows full traversal of the entire Block by and
                               offset.[br] If Stripe is active, then there is
                               no carry between Row and Column. This will keep
                               the offset address within the same Row, or the
                               same Column or on the same diagonal.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Address_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[7] and
                               Offset_Address_Instruction[15] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_ADDRESS_INSTRUCTION_15_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_COMMAND_INSTRUCTION_0_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x90a0)                                                          */
/*      SPRB0 (0x90a0)                                                          */
/*      SPRHBM (0x90a0)                                                         */
/*      SPRC0 (0x90a0)                                                          */
/*      SPRMCC (0x90a0)                                                         */
/*      SPRUCC (0x90a0)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Command Instructions. Note that these registers are grouped as two sets of 6 Offset_Command registers and their associated set of 8 Offset_Address registers. Thus we have two Offset_Groups.   Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][5:0].
*/


#define CPGC2_OFFSET_COMMAND_INSTRUCTION_0_MCCPGC_MAIN_REG 0x280090A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Write operation will be
                               performed at the Offset (or Base if the Offset
                               field = 0) Address.[br] If the initiating
                               Command_Instruction has its associated WriteCmd
                               bit set, then this bit is inverted (Writes
                               become Reads, Reads become Writes) allowing the
                               same offset sequence to be used to write and
                               verify.
                            */
    UINT8 srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Request to Send Response for this transaction. */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Used to re-visit the Base address during an
                               Offset Command sequence.[br] 0=Use Base
                               Address.[br] 1=Normal Offset Address.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Offset command will be repeated
                               Hammer_Repeats times
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate Zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this
                               Offset_Command_Instruction. Combine the
                               Data_Instruction Invert_Data field, the
                               Algorithm_Instruction Invert_Data field,
                               Command_Instruction Invert_Data field and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Command_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[5] and
                               Offset_Address_Instruction[11] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_COMMAND_INSTRUCTION_0_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_COMMAND_INSTRUCTION_1_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x90a1)                                                          */
/*      SPRB0 (0x90a1)                                                          */
/*      SPRHBM (0x90a1)                                                         */
/*      SPRC0 (0x90a1)                                                          */
/*      SPRMCC (0x90a1)                                                         */
/*      SPRUCC (0x90a1)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Command Instructions. Note that these registers are grouped as two sets of 6 Offset_Command registers and their associated set of 8 Offset_Address registers. Thus we have two Offset_Groups.   Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][5:0].
*/


#define CPGC2_OFFSET_COMMAND_INSTRUCTION_1_MCCPGC_MAIN_REG 0x280090A1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Write operation will be
                               performed at the Offset (or Base if the Offset
                               field = 0) Address.[br] If the initiating
                               Command_Instruction has its associated WriteCmd
                               bit set, then this bit is inverted (Writes
                               become Reads, Reads become Writes) allowing the
                               same offset sequence to be used to write and
                               verify.
                            */
    UINT8 srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Request to Send Response for this transaction. */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Used to re-visit the Base address during an
                               Offset Command sequence.[br] 0=Use Base
                               Address.[br] 1=Normal Offset Address.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Offset command will be repeated
                               Hammer_Repeats times
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate Zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this
                               Offset_Command_Instruction. Combine the
                               Data_Instruction Invert_Data field, the
                               Algorithm_Instruction Invert_Data field,
                               Command_Instruction Invert_Data field and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Command_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[5] and
                               Offset_Address_Instruction[11] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_COMMAND_INSTRUCTION_1_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_COMMAND_INSTRUCTION_2_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x90a2)                                                          */
/*      SPRB0 (0x90a2)                                                          */
/*      SPRHBM (0x90a2)                                                         */
/*      SPRC0 (0x90a2)                                                          */
/*      SPRMCC (0x90a2)                                                         */
/*      SPRUCC (0x90a2)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Command Instructions. Note that these registers are grouped as two sets of 6 Offset_Command registers and their associated set of 8 Offset_Address registers. Thus we have two Offset_Groups.   Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][5:0].
*/


#define CPGC2_OFFSET_COMMAND_INSTRUCTION_2_MCCPGC_MAIN_REG 0x280090A2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Write operation will be
                               performed at the Offset (or Base if the Offset
                               field = 0) Address.[br] If the initiating
                               Command_Instruction has its associated WriteCmd
                               bit set, then this bit is inverted (Writes
                               become Reads, Reads become Writes) allowing the
                               same offset sequence to be used to write and
                               verify.
                            */
    UINT8 srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Request to Send Response for this transaction. */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Used to re-visit the Base address during an
                               Offset Command sequence.[br] 0=Use Base
                               Address.[br] 1=Normal Offset Address.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Offset command will be repeated
                               Hammer_Repeats times
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate Zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this
                               Offset_Command_Instruction. Combine the
                               Data_Instruction Invert_Data field, the
                               Algorithm_Instruction Invert_Data field,
                               Command_Instruction Invert_Data field and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Command_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[5] and
                               Offset_Address_Instruction[11] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_COMMAND_INSTRUCTION_2_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_COMMAND_INSTRUCTION_3_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x90a3)                                                          */
/*      SPRB0 (0x90a3)                                                          */
/*      SPRHBM (0x90a3)                                                         */
/*      SPRC0 (0x90a3)                                                          */
/*      SPRMCC (0x90a3)                                                         */
/*      SPRUCC (0x90a3)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Command Instructions. Note that these registers are grouped as two sets of 6 Offset_Command registers and their associated set of 8 Offset_Address registers. Thus we have two Offset_Groups.   Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][5:0].
*/


#define CPGC2_OFFSET_COMMAND_INSTRUCTION_3_MCCPGC_MAIN_REG 0x280090A3

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Write operation will be
                               performed at the Offset (or Base if the Offset
                               field = 0) Address.[br] If the initiating
                               Command_Instruction has its associated WriteCmd
                               bit set, then this bit is inverted (Writes
                               become Reads, Reads become Writes) allowing the
                               same offset sequence to be used to write and
                               verify.
                            */
    UINT8 srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Request to Send Response for this transaction. */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Used to re-visit the Base address during an
                               Offset Command sequence.[br] 0=Use Base
                               Address.[br] 1=Normal Offset Address.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Offset command will be repeated
                               Hammer_Repeats times
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate Zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this
                               Offset_Command_Instruction. Combine the
                               Data_Instruction Invert_Data field, the
                               Algorithm_Instruction Invert_Data field,
                               Command_Instruction Invert_Data field and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Command_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[5] and
                               Offset_Address_Instruction[11] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_COMMAND_INSTRUCTION_3_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_COMMAND_INSTRUCTION_4_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x90a4)                                                          */
/*      SPRB0 (0x90a4)                                                          */
/*      SPRHBM (0x90a4)                                                         */
/*      SPRC0 (0x90a4)                                                          */
/*      SPRMCC (0x90a4)                                                         */
/*      SPRUCC (0x90a4)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Command Instructions. Note that these registers are grouped as two sets of 6 Offset_Command registers and their associated set of 8 Offset_Address registers. Thus we have two Offset_Groups.   Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][5:0].
*/


#define CPGC2_OFFSET_COMMAND_INSTRUCTION_4_MCCPGC_MAIN_REG 0x280090A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Write operation will be
                               performed at the Offset (or Base if the Offset
                               field = 0) Address.[br] If the initiating
                               Command_Instruction has its associated WriteCmd
                               bit set, then this bit is inverted (Writes
                               become Reads, Reads become Writes) allowing the
                               same offset sequence to be used to write and
                               verify.
                            */
    UINT8 srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Request to Send Response for this transaction. */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Used to re-visit the Base address during an
                               Offset Command sequence.[br] 0=Use Base
                               Address.[br] 1=Normal Offset Address.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Offset command will be repeated
                               Hammer_Repeats times
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate Zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this
                               Offset_Command_Instruction. Combine the
                               Data_Instruction Invert_Data field, the
                               Algorithm_Instruction Invert_Data field,
                               Command_Instruction Invert_Data field and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Command_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[5] and
                               Offset_Address_Instruction[11] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_COMMAND_INSTRUCTION_4_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_COMMAND_INSTRUCTION_5_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x90a5)                                                          */
/*      SPRB0 (0x90a5)                                                          */
/*      SPRHBM (0x90a5)                                                         */
/*      SPRC0 (0x90a5)                                                          */
/*      SPRMCC (0x90a5)                                                         */
/*      SPRUCC (0x90a5)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Command Instructions. Note that these registers are grouped as two sets of 6 Offset_Command registers and their associated set of 8 Offset_Address registers. Thus we have two Offset_Groups.   Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][5:0].
*/


#define CPGC2_OFFSET_COMMAND_INSTRUCTION_5_MCCPGC_MAIN_REG 0x280090A5

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Write operation will be
                               performed at the Offset (or Base if the Offset
                               field = 0) Address.[br] If the initiating
                               Command_Instruction has its associated WriteCmd
                               bit set, then this bit is inverted (Writes
                               become Reads, Reads become Writes) allowing the
                               same offset sequence to be used to write and
                               verify.
                            */
    UINT8 srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Request to Send Response for this transaction. */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Used to re-visit the Base address during an
                               Offset Command sequence.[br] 0=Use Base
                               Address.[br] 1=Normal Offset Address.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Offset command will be repeated
                               Hammer_Repeats times
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate Zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this
                               Offset_Command_Instruction. Combine the
                               Data_Instruction Invert_Data field, the
                               Algorithm_Instruction Invert_Data field,
                               Command_Instruction Invert_Data field and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Command_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[5] and
                               Offset_Address_Instruction[11] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_COMMAND_INSTRUCTION_5_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_COMMAND_INSTRUCTION_6_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x90a6)                                                          */
/*      SPRB0 (0x90a6)                                                          */
/*      SPRHBM (0x90a6)                                                         */
/*      SPRC0 (0x90a6)                                                          */
/*      SPRMCC (0x90a6)                                                         */
/*      SPRUCC (0x90a6)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Command Instructions. Note that these registers are grouped as two sets of 6 Offset_Command registers and their associated set of 8 Offset_Address registers. Thus we have two Offset_Groups.   Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][5:0].
*/


#define CPGC2_OFFSET_COMMAND_INSTRUCTION_6_MCCPGC_MAIN_REG 0x280090A6

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Write operation will be
                               performed at the Offset (or Base if the Offset
                               field = 0) Address.[br] If the initiating
                               Command_Instruction has its associated WriteCmd
                               bit set, then this bit is inverted (Writes
                               become Reads, Reads become Writes) allowing the
                               same offset sequence to be used to write and
                               verify.
                            */
    UINT8 srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Request to Send Response for this transaction. */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Used to re-visit the Base address during an
                               Offset Command sequence.[br] 0=Use Base
                               Address.[br] 1=Normal Offset Address.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Offset command will be repeated
                               Hammer_Repeats times
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate Zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this
                               Offset_Command_Instruction. Combine the
                               Data_Instruction Invert_Data field, the
                               Algorithm_Instruction Invert_Data field,
                               Command_Instruction Invert_Data field and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Command_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[5] and
                               Offset_Address_Instruction[11] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_COMMAND_INSTRUCTION_6_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_COMMAND_INSTRUCTION_7_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x90a7)                                                          */
/*      SPRB0 (0x90a7)                                                          */
/*      SPRHBM (0x90a7)                                                         */
/*      SPRC0 (0x90a7)                                                          */
/*      SPRMCC (0x90a7)                                                         */
/*      SPRUCC (0x90a7)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Command Instructions. Note that these registers are grouped as two sets of 6 Offset_Command registers and their associated set of 8 Offset_Address registers. Thus we have two Offset_Groups.   Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][5:0].
*/


#define CPGC2_OFFSET_COMMAND_INSTRUCTION_7_MCCPGC_MAIN_REG 0x280090A7

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Write operation will be
                               performed at the Offset (or Base if the Offset
                               field = 0) Address.[br] If the initiating
                               Command_Instruction has its associated WriteCmd
                               bit set, then this bit is inverted (Writes
                               become Reads, Reads become Writes) allowing the
                               same offset sequence to be used to write and
                               verify.
                            */
    UINT8 srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Request to Send Response for this transaction. */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Used to re-visit the Base address during an
                               Offset Command sequence.[br] 0=Use Base
                               Address.[br] 1=Normal Offset Address.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Offset command will be repeated
                               Hammer_Repeats times
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate Zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this
                               Offset_Command_Instruction. Combine the
                               Data_Instruction Invert_Data field, the
                               Algorithm_Instruction Invert_Data field,
                               Command_Instruction Invert_Data field and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Command_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[5] and
                               Offset_Address_Instruction[11] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_COMMAND_INSTRUCTION_7_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_COMMAND_INSTRUCTION_8_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x90a8)                                                          */
/*      SPRB0 (0x90a8)                                                          */
/*      SPRHBM (0x90a8)                                                         */
/*      SPRC0 (0x90a8)                                                          */
/*      SPRMCC (0x90a8)                                                         */
/*      SPRUCC (0x90a8)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Command Instructions. Note that these registers are grouped as two sets of 6 Offset_Command registers and their associated set of 8 Offset_Address registers. Thus we have two Offset_Groups.   Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][5:0].
*/


#define CPGC2_OFFSET_COMMAND_INSTRUCTION_8_MCCPGC_MAIN_REG 0x280090A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Write operation will be
                               performed at the Offset (or Base if the Offset
                               field = 0) Address.[br] If the initiating
                               Command_Instruction has its associated WriteCmd
                               bit set, then this bit is inverted (Writes
                               become Reads, Reads become Writes) allowing the
                               same offset sequence to be used to write and
                               verify.
                            */
    UINT8 srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Request to Send Response for this transaction. */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Used to re-visit the Base address during an
                               Offset Command sequence.[br] 0=Use Base
                               Address.[br] 1=Normal Offset Address.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Offset command will be repeated
                               Hammer_Repeats times
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate Zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this
                               Offset_Command_Instruction. Combine the
                               Data_Instruction Invert_Data field, the
                               Algorithm_Instruction Invert_Data field,
                               Command_Instruction Invert_Data field and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Command_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[5] and
                               Offset_Address_Instruction[11] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_COMMAND_INSTRUCTION_8_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_COMMAND_INSTRUCTION_9_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x90a9)                                                          */
/*      SPRB0 (0x90a9)                                                          */
/*      SPRHBM (0x90a9)                                                         */
/*      SPRC0 (0x90a9)                                                          */
/*      SPRMCC (0x90a9)                                                         */
/*      SPRUCC (0x90a9)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Command Instructions. Note that these registers are grouped as two sets of 6 Offset_Command registers and their associated set of 8 Offset_Address registers. Thus we have two Offset_Groups.   Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][5:0].
*/


#define CPGC2_OFFSET_COMMAND_INSTRUCTION_9_MCCPGC_MAIN_REG 0x280090A9

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Write operation will be
                               performed at the Offset (or Base if the Offset
                               field = 0) Address.[br] If the initiating
                               Command_Instruction has its associated WriteCmd
                               bit set, then this bit is inverted (Writes
                               become Reads, Reads become Writes) allowing the
                               same offset sequence to be used to write and
                               verify.
                            */
    UINT8 srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Request to Send Response for this transaction. */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Used to re-visit the Base address during an
                               Offset Command sequence.[br] 0=Use Base
                               Address.[br] 1=Normal Offset Address.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Offset command will be repeated
                               Hammer_Repeats times
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate Zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this
                               Offset_Command_Instruction. Combine the
                               Data_Instruction Invert_Data field, the
                               Algorithm_Instruction Invert_Data field,
                               Command_Instruction Invert_Data field and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Command_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[5] and
                               Offset_Address_Instruction[11] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_COMMAND_INSTRUCTION_9_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_COMMAND_INSTRUCTION_10_MCCPGC_MAIN_REG supported on:            */
/*      SPRA0 (0x90aa)                                                          */
/*      SPRB0 (0x90aa)                                                          */
/*      SPRHBM (0x90aa)                                                         */
/*      SPRC0 (0x90aa)                                                          */
/*      SPRMCC (0x90aa)                                                         */
/*      SPRUCC (0x90aa)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Command Instructions. Note that these registers are grouped as two sets of 6 Offset_Command registers and their associated set of 8 Offset_Address registers. Thus we have two Offset_Groups.   Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][5:0].
*/


#define CPGC2_OFFSET_COMMAND_INSTRUCTION_10_MCCPGC_MAIN_REG 0x280090AA

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Write operation will be
                               performed at the Offset (or Base if the Offset
                               field = 0) Address.[br] If the initiating
                               Command_Instruction has its associated WriteCmd
                               bit set, then this bit is inverted (Writes
                               become Reads, Reads become Writes) allowing the
                               same offset sequence to be used to write and
                               verify.
                            */
    UINT8 srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Request to Send Response for this transaction. */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Used to re-visit the Base address during an
                               Offset Command sequence.[br] 0=Use Base
                               Address.[br] 1=Normal Offset Address.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Offset command will be repeated
                               Hammer_Repeats times
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate Zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this
                               Offset_Command_Instruction. Combine the
                               Data_Instruction Invert_Data field, the
                               Algorithm_Instruction Invert_Data field,
                               Command_Instruction Invert_Data field and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Command_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[5] and
                               Offset_Address_Instruction[11] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_COMMAND_INSTRUCTION_10_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_COMMAND_INSTRUCTION_11_MCCPGC_MAIN_REG supported on:            */
/*      SPRA0 (0x90ab)                                                          */
/*      SPRB0 (0x90ab)                                                          */
/*      SPRHBM (0x90ab)                                                         */
/*      SPRC0 (0x90ab)                                                          */
/*      SPRMCC (0x90ab)                                                         */
/*      SPRUCC (0x90ab)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Offset Command Instructions. Note that these registers are grouped as two sets of 6 Offset_Command registers and their associated set of 8 Offset_Address registers. Thus we have two Offset_Groups.   Selected by Command_Instruction.Offset_Group bit. i.e. an array [1:0][5:0].
*/


#define CPGC2_OFFSET_COMMAND_INSTRUCTION_11_MCCPGC_MAIN_REG 0x280090AB

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 writecmd : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               1= Write, 0=Read. A Write operation will be
                               performed at the Offset (or Base if the Offset
                               field = 0) Address.[br] If the initiating
                               Command_Instruction has its associated WriteCmd
                               bit set, then this bit is inverted (Writes
                               become Reads, Reads become Writes) allowing the
                               same offset sequence to be used to write and
                               verify.
                            */
    UINT8 srsp : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /* Request to Send Response for this transaction. */
    UINT8 offset : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Used to re-visit the Base address during an
                               Offset Command sequence.[br] 0=Use Base
                               Address.[br] 1=Normal Offset Address.
                            */
    UINT8 hammer : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               This Offset command will be repeated
                               Hammer_Repeats times
                            */
    UINT8 alternate_data : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /*
                               Use the alternate Zero data source instead of
                               the UniSequencers and Pattern_Select.
                            */
    UINT8 rsvd : 1;

                            /* Bits[5:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 invert_data : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Invert all data for this
                               Offset_Command_Instruction. Combine the
                               Data_Instruction Invert_Data field, the
                               Algorithm_Instruction Invert_Data field,
                               Command_Instruction Invert_Data field and
                               Offset_Command_Instruction Invert_Data field to
                               determine the final data polarity.
                            */
    UINT8 last : 1;

                            /* Bits[7:7], Access Type=RW, default=0x00000000*/

                            /*
                               Last Offset_Command_Instruction. The offset
                               instruction is complete after all
                               Offset_Address, Offset_Repeats, and
                               Offset_Commands have finished.[br]
                               Offset_Address_Instruction[5] and
                               Offset_Address_Instruction[11] have this bit set
                               implicitly.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_OFFSET_COMMAND_INSTRUCTION_11_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_REPEATS_CURRENT_MCCPGC_MAIN_REG supported on:                   */
/*      SPRA0 (0x200090ac)                                                      */
/*      SPRB0 (0x200090ac)                                                      */
/*      SPRHBM (0x200090ac)                                                     */
/*      SPRC0 (0x200090ac)                                                      */
/*      SPRMCC (0x200090ac)                                                     */
/*      SPRUCC (0x200090ac)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Current Offset Loopcount (down count).
*/


#define CPGC2_OFFSET_REPEATS_CURRENT_MCCPGC_MAIN_REG 0x280290AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 offset_repeats_current : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /* Current Offset Loopcount (down count). */

  } Bits;
  UINT32 Data;

} CPGC2_OFFSET_REPEATS_CURRENT_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_REPEATS_0_MCCPGC_MAIN_REG supported on:                         */
/*      SPRA0 (0x200090b0)                                                      */
/*      SPRB0 (0x200090b0)                                                      */
/*      SPRHBM (0x200090b0)                                                     */
/*      SPRC0 (0x200090b0)                                                      */
/*      SPRMCC (0x200090b0)                                                     */
/*      SPRUCC (0x200090b0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Set the loopcount for Offset (Distance from Base). Selected by Command_Instruction.Offset_Group bit.
*/


#define CPGC2_OFFSET_REPEATS_0_MCCPGC_MAIN_REG 0x280290B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 offset_repeats : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set the loopcount for Offset (Distance from
                               Base). The entire list of Offset Commands are
                               executed for each loop. As N-1. (0=1 time.)
                            */

  } Bits;
  UINT32 Data;

} CPGC2_OFFSET_REPEATS_0_MCCPGC_MAIN_STRUCT;

/* CPGC2_OFFSET_REPEATS_1_MCCPGC_MAIN_REG supported on:                         */
/*      SPRA0 (0x200090b4)                                                      */
/*      SPRB0 (0x200090b4)                                                      */
/*      SPRHBM (0x200090b4)                                                     */
/*      SPRC0 (0x200090b4)                                                      */
/*      SPRMCC (0x200090b4)                                                     */
/*      SPRUCC (0x200090b4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Set the loopcount for Offset (Distance from Base). Selected by Command_Instruction.Offset_Group bit.
*/


#define CPGC2_OFFSET_REPEATS_1_MCCPGC_MAIN_REG 0x280290B4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 offset_repeats : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set the loopcount for Offset (Distance from
                               Base). The entire list of Offset Commands are
                               executed for each loop. As N-1. (0=1 time.)
                            */

  } Bits;
  UINT32 Data;

} CPGC2_OFFSET_REPEATS_1_MCCPGC_MAIN_STRUCT;

/* CPGC2_REGION_LOW_N0_MCCPGC_MAIN_REG supported on:                            */
/*      SPRA0 (0x200090b8)                                                      */
/*      SPRB0 (0x200090b8)                                                      */
/*      SPRHBM (0x200090b8)                                                     */
/*      SPRC0 (0x200090b8)                                                      */
/*      SPRMCC (0x200090b8)                                                     */
/*      SPRUCC (0x200090b8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Region Low Address.
*/


#define CPGC2_REGION_LOW_N0_MCCPGC_MAIN_REG 0x280290B8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 low_col : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set the lowest Column for the physical memory
                               being tested. This value is added to all Region
                               Column Addresses computed.
                            */
    UINT32 rsvd : 8;

                            /* Bits[23:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 low_rank : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000000*/

                            /*
                               Set the lowest Rank for the physical memory
                               being tested. This value is added to all Region
                               Rank Addresses computed.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC2_REGION_LOW_N0_MCCPGC_MAIN_STRUCT;

/* CPGC2_REGION_LOW_N1_MCCPGC_MAIN_REG supported on:                            */
/*      SPRA0 (0x200090bc)                                                      */
/*      SPRB0 (0x200090bc)                                                      */
/*      SPRHBM (0x200090bc)                                                     */
/*      SPRC0 (0x200090bc)                                                      */
/*      SPRMCC (0x200090bc)                                                     */
/*      SPRUCC (0x200090bc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Region Low Address.
*/


#define CPGC2_REGION_LOW_N1_MCCPGC_MAIN_REG 0x280290BC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 low_row : 18;

                            /* Bits[17:0], Access Type=RW, default=0x00000000*/

                            /*
                               Set the bottom Row for the physical memory being
                               tested. This value is added to all Region Row
                               Addresses computed.
                            */
    UINT32 rsvd : 6;

                            /* Bits[23:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 low_bank : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000000*/

                            /*
                               Set the bottom Bank for the physical memory
                               being tested. This value is added to all Region
                               Bank Addresses computed.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC2_REGION_LOW_N1_MCCPGC_MAIN_STRUCT;

/* CPGC2_ADDRESS_SIZE_N0_MCCPGC_MAIN_REG supported on:                          */
/*      SPRA0 (0x200090d8)                                                      */
/*      SPRB0 (0x200090d8)                                                      */
/*      SPRHBM (0x200090d8)                                                     */
/*      SPRC0 (0x200090d8)                                                      */
/*      SPRMCC (0x200090d8)                                                     */
/*      SPRUCC (0x200090d8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Set the size of the Region and Block.
*/


#define CPGC2_ADDRESS_SIZE_N0_MCCPGC_MAIN_REG 0x280290D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 block_size_bits_col : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               2^Block_Size_Bits_Col is the number of columns
                               for a Block. These are the number of Column bits
                               used to select the current Cache Line (or half
                               Cache Line depending on Request_Data_Size) and
                               do not include any burst-order or byte address
                               bits. If Column Block Traversal is used, then
                               this must be at least 4 columns (=2). Minimum
                               value is 1 if Address_Decode_Enable =1.
                            */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 block_size_bits_row : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000000*/

                            /*
                               2^Block_Size_Bits_Row is the number of rows for
                               a Block. If Row Block Traversal is used, then
                               this must be at least 4 rows (=2). Minimum value
                               is 1 if Address_Decode_Enable =1.
                            */
    UINT32 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 block_size_max_bank : 5;

                            /* Bits[20:16], Access Type=RW, default=0x00000000*/

                            /*
                               Block_Size_Max_Bank+1 is the number of Banks to
                               test for a Block (value = top bank number).[br]
                               All Bank Address values go through the Bank
                               Address Lookup table.[br] Minimum value is 1 (2
                               Banks) if Address_Decode_Enable =1.[br] 0 mens
                               only 1 Bank is tested in the Block.
                            */
    UINT32 rsvd_21 : 3;

                            /* Bits[23:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 block_size_max_rank : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000000*/

                            /*
                               Block_Size_Max_Rank+1 is the number of Ranks to
                               test for a Block (value = top rank number).[br]
                               All Rank Addresses go through the Rank Address
                               Lookup table.[br] Minimum value is 0 (1 Rank) if
                               Address_Decode_Enable =1 in which case Rank will
                               not participate.[br] 0 means only 1 Rank is
                               tested in the Block.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC2_ADDRESS_SIZE_N0_MCCPGC_MAIN_STRUCT;

/* CPGC2_ADDRESS_SIZE_N1_MCCPGC_MAIN_REG supported on:                          */
/*      SPRA0 (0x200090dc)                                                      */
/*      SPRB0 (0x200090dc)                                                      */
/*      SPRHBM (0x200090dc)                                                     */
/*      SPRC0 (0x200090dc)                                                      */
/*      SPRMCC (0x200090dc)                                                     */
/*      SPRUCC (0x200090dc)                                                     */
/* Register default value on SPRA0: 0x40000000                                  */
/* Register default value on SPRB0: 0x40000000                                  */
/* Register default value on SPRHBM: 0x40000000                                 */
/* Register default value on SPRC0: 0x40000000                                  */
/* Register default value on SPRMCC: 0x40000000                                 */
/* Register default value on SPRUCC: 0x40000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Set the size of the Region and Block.
*/


#define CPGC2_ADDRESS_SIZE_N1_MCCPGC_MAIN_REG 0x280290DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 region_size_bits_col : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               2^Region_Size_Bits_Col is the number of columns
                               in the testing region. It is also used as the
                               Block_Size_Bits_Col value to set the size of the
                               block. Minimum value is 1 if
                               Address_Decode_Enable =1. , so this normally
                               needs to be set to the number of Column bits of
                               the memory.
                            */
    UINT32 rsvd : 3;

                            /* Bits[7:5], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 region_size_bits_row : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000000*/

                            /*
                               2^Region_Size_Bits_Row is the number of rows in
                               the testing region. Must be >= to
                               Block_Size_Bits_Row.
                            */
    UINT32 rsvd_13 : 3;

                            /* Bits[15:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 region_size_max_bank : 5;

                            /* Bits[20:16], Access Type=RW, default=0x00000000*/

                            /*
                               Region_Size_Max_Bank+1 is the number of Banks to
                               test for a Region (value = top Bank number).[br]
                               All Bank Address values go through the Bank
                               Address Lookup table.[br] Minimum value is =
                               Block_Size_Max_Bank.
                            */
    UINT32 rsvd_21 : 3;

                            /* Bits[23:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 region_size_max_rank : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000000*/

                            /*
                               Region_Size_Max_Rank+1 is the number of Ranks to
                               test for the Region (value = top Rank
                               number).[br] All Rank Addresses go through the
                               Rank Address Lookup table.[br] Minimum value is
                               Block_Size_Max_Rank.
                            */
    UINT32 rsvd_29 : 1;

                            /* Bits[29:29], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 request_data_size : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000001*/

                            /*
                               Size of requests CPGC is issuing, 64B and 32B
                               transactions and is encoded as follows:[br] 0 -
                               32 Byte Transactions.[br] 1 - 64 Byte
                               Transactions.[br] This bit is ineffective and
                               considered 1b1 if CPGC_32BYTE_SUPPORT == 0.
                            */
    UINT32 bl_chop_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               In 64B request length, if BurstChop (half cache-
                               line) accesses are to be issued for a given
                               test, enable this bit:[br] 0 - 64 Byte
                               Transactions only (Hammer, NonPosted have normal
                               definitions).[br] 1 - 64 Byte Transactions that
                               can be chopped to half cache-line requests
                               (Hammer used to enable, and NonPosted used to
                               select which critical chunk is requested).[br]
                               Hammer and NonPosted functionality is thus
                               disabled if this bit is set (only valid when
                               REQUEST_DATA_SIZE = 1).[br] This bit is
                               ineffective and considered 1b0 if
                               CPGC_32BYTE_SUPPORT == 0.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_ADDRESS_SIZE_N1_MCCPGC_MAIN_STRUCT;

/* CPGC2_BASE_ADDRESS_CONTROL_MCCPGC_MAIN_REG supported on:                     */
/*      SPRA0 (0x200090e0)                                                      */
/*      SPRB0 (0x200090e0)                                                      */
/*      SPRHBM (0x200090e0)                                                     */
/*      SPRC0 (0x200090e0)                                                      */
/*      SPRMCC (0x200090e0)                                                     */
/*      SPRUCC (0x200090e0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Control handling of Base Address - inversion and increment rates and increment amounts.
*/


#define CPGC2_BASE_ADDRESS_CONTROL_MCCPGC_MAIN_REG 0x280290E0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 block_col_move_one_col : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /* See Block_Col_Move_Half_Block for description. */
    UINT32 block_col_move_half_block : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               Used jointly with Block_Col_Move_One_Col[br] {
                               Block_Col_Move_Half_Block,
                               Block_Col_Move_One_Col }[br] 00 : The Block is
                               moved by 2^(Block_Size_Bits_Col) Columns[br] 01
                               : The Block is moved by 1 Columns[br] 10 : The
                               block is moved by 2^(Block_Size_Bits_Col)/2
                               Columns[br] 11 : Reserved (undefined behavior)
                            */
    UINT32 hammer_inc_rate : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               If Address_Order0_Inc_Rate == 1, and
                               Hammer_Inc_Rate ==1, then a Hammer repeated
                               command will advance the address for each
                               access.
                            */
    UINT32 block_bank_move_one : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               1: The Block is moved by 1 Bank[br] 0: The Block
                               is moved by Block_Size_Max_Bank+1.[br] The
                               resultant Bank address is modulo
                               Region_Size_Max_Bank.
                            */
    UINT32 block_row_move_one_row : 1;

                            /* Bits[4:4], Access Type=RW, default=0x00000000*/

                            /* See Block_Row_Move_Half_Block for description. */
    UINT32 block_row_move_half_block : 1;

                            /* Bits[5:5], Access Type=RW, default=0x00000000*/

                            /*
                               Used jointly with Block_Row_Move_One_Row[br] {
                               Block_Row_Move_Half_Block,
                               Block_Row_Move_One_Row }[br] 00 : The Block is
                               moved by 2^(Block_Size_Bits_Row) Rows[br] 01 :
                               The Block is moved by 1 Row[br] 10 : The block
                               is moved by 2^(Block_Size_Bits_Row)/2 Rows[br]
                               11 : Reserved (undefined behavior)
                            */
    UINT32 row_inc : 4;

                            /* Bits[9:6], Access Type=RW, default=0x00000000*/

                            /*
                               All Base and Offset Row addresses are
                               incremented (or decremented) by 2^Row_Inc
                               (unsigned value)
                            */
    UINT32 block_rank_move_one : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               1: The Block is moved by 1 Rank[br] 0: The Block
                               is moved by Block_Size_Max_Rank+1.[br] The
                               resultant Rank address is modulo
                               Region_Size_Max_Rank.
                            */
    UINT32 col_inc : 4;

                            /* Bits[14:11], Access Type=RW, default=0x00000000*/

                            /*
                               All Base and Offset Column addresses are
                               incremented (or decremented) by 2^Col_Inc
                               (unsigned value)
                            */
    UINT32 bank_inc : 3;

                            /* Bits[17:15], Access Type=RW, default=0x00000000*/

                            /*
                               All Base Bank addresses are incremented (or
                               decremented) by 2^Bank_Inc (unsigned value).[br]
                               Currently limited to the values of 000 for an
                               increment of 1 Bank, or[br] 001 for a BankGroup
                               increment with 2 Banks, or[br] 010 for a
                               Bankgroup increment with 4 Banks.[br] A choice
                               of only 3 values are available:[br] 000 -
                               Constant increment of 1 Bank.[br] 001 -
                               Bankgroup increment of 2 Banks.[br] 010 -
                               Bankgroup increment of 4 Banks.[br] Other values
                               revert to an increment of 1.[br] If the
                               Block_Size_Max_Bank is not 3, 7, 15, or 31 the
                               value reverts to an increment of 1. [br] If the
                               Block_Size_Max_Bank is 3, and increment of 010
                               is invalid and the value reverts to an increment
                               of 1. [br] Increments other than 3'b000 are a
                               special increment intended for Bank Group
                               oriented memories:[br] Logically, the Bank
                               counter is always incremented by 1, but the bits
                               are re-mapped as follows:[br] Increment by 2
                               (think of it as a rotate to left by 1 bit):[br]
                               If Block_Size_Max_Bank=3: Logical_Bank[1:0] =
                               {Bank_Cnt[0],Bank_Cnt[1]}.[br] If
                               Block_Size_Max_Bank=7: Logical_Bank[2:0] =
                               {Bank_Cnt[1:0],Bank_Cnt[2]}.[br] If
                               Block_Size_Max_Bank=15: Logical_Bank[3:0] =
                               {Bank_Cnt[2:0],Bank_Cnt[3]}.[br] If
                               Block_Size_Max_Bank=31: Logical_Bank[4:0] =
                               {Bank_Cnt[3:0],Bank_Cnt[4]}..[br] Increment by 4
                               (think of it as a rotate to left by 2 bits):[br]
                               If Block_Size_Max_Bank=7: Logical_Bank[2:0] =
                               {Bank_Cnt[0],Bank_Cnt[2:1]}.[br] If
                               Block_Size_Max_Bank=15: Logical_Bank[3:0] =
                               {Bank_Cnt[1:0],Bank_Cnt[3:2]}.[br] If
                               Block_Size_Max_Bank=31: Logical_Bank[4:0] =
                               {Bank_Cnt[2:0],Bank_Cnt[4:3]}..[br] The above
                               can also be accomplished using the L2P_MAPPING
                               or ADDR_SWIZZLE registers but is less intuitive.
                            */
    UINT32 reserved_rank_inc : 3;

                            /* Bits[20:18], Access Type=RO, default=0x00000000*/

                            /*
                               All Base Rank addresses are incremented (or
                               decremented) by 2^Rank_Inc (unsigned value).
                               Fixed at 0 for a constant increment of only 1
                               for Rank.
                            */
    UINT32 address_order0_inc_rate : 1;

                            /* Bits[21:21], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Order0_Inc_Rate determines if the
                               Address Order 0 Field is incremented on the
                               Command Sequence Boundary (following a
                               Command_Instruction with the Last bit set) or
                               every Command_Instruction [br] 0 - Increment
                               Address after executing the Command_Instruction
                               with the Last bit set. [br] 1 - Increment
                               Address following each Command_Instruction
                            */
    UINT32 address_inversion_enable : 4;

                            /* Bits[25:22], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Inversion_Enable enables particular
                               Address Fields to be inverted.[br] [25]
                               Rank_Inversion_Enable, [24]
                               Bank_Inversion_Enable, [23]
                               Row_Inversion_Enable, [22]
                               Col_Inversion_Enable[br] This does not invert
                               any PRBS Address if enabled.
                            */
    UINT32 address_inversion_rate : 1;

                            /* Bits[26:26], Access Type=RW, default=0x00000000*/

                            /*
                               Address_Inversion_Rate determines if the enabled
                               Address Fields toggle inversion on the Command
                               Sequence Boundary (following a
                               Command_Instruction with the Last bit set) or
                               every Command_Instruction. [br] 0 - Invert
                               enabled Address fields after executing the
                               Command_Instruction with the Last bit set. [br]
                               1 - Invert enabled Address fields following each
                               Command_Instruction
                            */
    UINT32 addr_prbs_carry_mode : 1;

                            /* Bits[27:27], Access Type=RW, default=0x00000000*/

                            /*
                               1: Enable Address Direction/Order to dictate the
                               order of PRBS Address Generator fields
                               advancing.[br] 0: All PRBS Address Generator
                               fields will advance when the normally computed
                               address advances.
                            */
    UINT32 addr_prbs_col_en : 1;

                            /* Bits[28:28], Access Type=RW, default=0x00000000*/

                            /*
                               1: Enable Column Address from PRBS Address
                               generator.[br] 0: Normal Address generation used
                               for the Column address.
                            */
    UINT32 addr_prbs_row_en : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               1: Enable Row Address from PRBS Address
                               generator.[br] 0: Normal Address generation used
                               for the Row address.
                            */
    UINT32 addr_prbs_bnk_en : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               1: Enable Bank Address from PRBS Address
                               generator.[br] 0: Normal Address generation used
                               for the Bank address.
                            */
    UINT32 addr_prbs_rnk_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               1: Enable Rank Address from PRBS Address
                               generator.[br] 0: Normal Address generation used
                               for the Rank address.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_BASE_ADDRESS_CONTROL_MCCPGC_MAIN_STRUCT;

/* CPGC2_ADDRESS_PRBS_SEED_N0_MCCPGC_MAIN_REG supported on:                     */
/*      SPRA0 (0x200090e8)                                                      */
/*      SPRB0 (0x200090e8)                                                      */
/*      SPRHBM (0x200090e8)                                                     */
/*      SPRC0 (0x200090e8)                                                      */
/*      SPRMCC (0x200090e8)                                                     */
/*      SPRUCC (0x200090e8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Seed for Address PRBS generator.
*/


#define CPGC2_ADDRESS_PRBS_SEED_N0_MCCPGC_MAIN_REG 0x280290E8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 address_prbs_column_seed : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000000*/

                            /*
                               Seed for Address PRBS generator Column field. A
                               zero seed is acceptable and will not result in a
                               constant 0 address value. This seed is
                               internally masked based on the length inferred
                               by the Polynomial.
                            */
    UINT32 rsvd : 8;

                            /* Bits[23:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 address_prbs_rank_seed : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000000*/

                            /*
                               Seed for Address PRBS generator Rank field. A
                               zero seed is acceptable and will not result in a
                               constant 0 address value. This seed is
                               internally masked based on the length inferred
                               by the Polynomial.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC2_ADDRESS_PRBS_SEED_N0_MCCPGC_MAIN_STRUCT;

/* CPGC2_ADDRESS_PRBS_SEED_N1_MCCPGC_MAIN_REG supported on:                     */
/*      SPRA0 (0x200090ec)                                                      */
/*      SPRB0 (0x200090ec)                                                      */
/*      SPRHBM (0x200090ec)                                                     */
/*      SPRC0 (0x200090ec)                                                      */
/*      SPRMCC (0x200090ec)                                                     */
/*      SPRUCC (0x200090ec)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Seed for Address PRBS generator.
*/


#define CPGC2_ADDRESS_PRBS_SEED_N1_MCCPGC_MAIN_REG 0x280290EC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 address_prbs_row_seed : 18;

                            /* Bits[17:0], Access Type=RW, default=0x00000000*/

                            /*
                               Seed for Address PRBS generator Row field. A
                               zero seed is acceptable and will not result in a
                               constant 0 address value. This seed is
                               internally masked based on the length inferred
                               by the Polynomial.
                            */
    UINT32 rsvd : 6;

                            /* Bits[23:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 address_prbs_bank_seed : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000000*/

                            /*
                               Seed for Address PRBS generator Bank field. A
                               zero seed is acceptable and will not result in a
                               constant 0 address value. This seed is
                               internally masked based on the length inferred
                               by the Polynomial.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC2_ADDRESS_PRBS_SEED_N1_MCCPGC_MAIN_STRUCT;

/* CPGC2_ADDRESS_PRBS_CURRENT_N0_MCCPGC_MAIN_REG supported on:                  */
/*      SPRA0 (0x200090f0)                                                      */
/*      SPRB0 (0x200090f0)                                                      */
/*      SPRHBM (0x200090f0)                                                     */
/*      SPRC0 (0x200090f0)                                                      */
/*      SPRMCC (0x200090f0)                                                     */
/*      SPRUCC (0x200090f0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Current value of Address PRBS generator.
*/


#define CPGC2_ADDRESS_PRBS_CURRENT_N0_MCCPGC_MAIN_REG 0x280290F0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 address_prbs_column_current : 16;

                            /* Bits[15:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Current value of Address PRBS generator Column
                               field. Address either advances as
                               Address_Order0_Inc_Rate, or if Address PRBS
                               Carry Mode is set, then the advancement is at
                               the time as the same field of the non-PRBS
                               address generator. The Seed is (re)loaded (from
                               Save) at the start of each
                               Algorithm_Instruction.
                            */
    UINT32 rsvd : 8;

                            /* Bits[23:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 address_prbs_rank_current : 5;

                            /* Bits[28:24], Access Type=RO/V, default=0x00000000*/

                            /*
                               Current value of Address PRBS generator Bank
                               field. Address either advances as
                               Address_Order0_Inc_Rate, or if Address PRBS
                               Carry Mode is set, then the advancement is at
                               the time as the same field of the non-PRBS
                               address generator. The Seed is (re)loaded (from
                               Save) at the start of each
                               Algorithm_Instruction.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC2_ADDRESS_PRBS_CURRENT_N0_MCCPGC_MAIN_STRUCT;

/* CPGC2_ADDRESS_PRBS_CURRENT_N1_MCCPGC_MAIN_REG supported on:                  */
/*      SPRA0 (0x200090f4)                                                      */
/*      SPRB0 (0x200090f4)                                                      */
/*      SPRHBM (0x200090f4)                                                     */
/*      SPRC0 (0x200090f4)                                                      */
/*      SPRMCC (0x200090f4)                                                     */
/*      SPRUCC (0x200090f4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Current value of Address PRBS generator.
*/


#define CPGC2_ADDRESS_PRBS_CURRENT_N1_MCCPGC_MAIN_REG 0x280290F4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 address_prbs_row_current : 18;

                            /* Bits[17:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Current value of Address PRBS generator Row
                               field. Address either advances as
                               Address_Order0_Inc_Rate, or if Address PRBS
                               Carry Mode is set, then the advancement is at
                               the time as the same field of the non-PRBS
                               address generator. The Seed is (re)loaded (from
                               Save) at the start of each
                               Algorithm_Instruction.
                            */
    UINT32 rsvd : 6;

                            /* Bits[23:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 address_prbs_bank_current : 5;

                            /* Bits[28:24], Access Type=RO/V, default=0x00000000*/

                            /*
                               Current value of Address PRBS generator Bank
                               field. Address either advances as
                               Address_Order0_Inc_Rate, or if Address PRBS
                               Carry Mode is set, then the advancement is at
                               the time as the same field of the non-PRBS
                               address generator. The Seed is (re)loaded (from
                               Save) at the start of each
                               Algorithm_Instruction.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC2_ADDRESS_PRBS_CURRENT_N1_MCCPGC_MAIN_STRUCT;

/* CPGC2_ADDRESS_PRBS_SAVE_N0_MCCPGC_MAIN_REG supported on:                     */
/*      SPRA0 (0x200090f8)                                                      */
/*      SPRB0 (0x200090f8)                                                      */
/*      SPRHBM (0x200090f8)                                                     */
/*      SPRC0 (0x200090f8)                                                      */
/*      SPRMCC (0x200090f8)                                                     */
/*      SPRUCC (0x200090f8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Currently saved Address PRBS seed (Galois).
*/


#define CPGC2_ADDRESS_PRBS_SAVE_N0_MCCPGC_MAIN_REG 0x280290F8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 address_prbs_column_save : 16;

                            /* Bits[15:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               Saved value of Address PRBS generator Column
                               field.
                            */
    UINT32 rsvd : 8;

                            /* Bits[23:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 address_prbs_rank_save : 5;

                            /* Bits[28:24], Access Type=RO/V, default=0x00000000*/

                            /*
                               Saved value of Address PRBS generator Rank
                               field.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC2_ADDRESS_PRBS_SAVE_N0_MCCPGC_MAIN_STRUCT;

/* CPGC2_ADDRESS_PRBS_SAVE_N1_MCCPGC_MAIN_REG supported on:                     */
/*      SPRA0 (0x200090fc)                                                      */
/*      SPRB0 (0x200090fc)                                                      */
/*      SPRHBM (0x200090fc)                                                     */
/*      SPRC0 (0x200090fc)                                                      */
/*      SPRMCC (0x200090fc)                                                     */
/*      SPRUCC (0x200090fc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Currently saved Address PRBS seed (Galois).
*/


#define CPGC2_ADDRESS_PRBS_SAVE_N1_MCCPGC_MAIN_REG 0x280290FC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 address_prbs_row_save : 18;

                            /* Bits[17:0], Access Type=RO/V, default=0x00000000*/

                            /* Saved value of Address PRBS generator Row field. */
    UINT32 rsvd : 6;

                            /* Bits[23:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 address_prbs_bank_save : 5;

                            /* Bits[28:24], Access Type=RO/V, default=0x00000000*/

                            /*
                               Saved value of Address PRBS generator Bank
                               field.[br] The following applies to all fields
                               of this register:[br] The value is (re)loaded
                               (from Seed) when Block Traversal (Repeats) is
                               started, and saved automatically during block
                               advance (at the end of the list of Algorithm
                               Instructions). Thus, rather than using the Block
                               Origin, a PRBS address field will begin a new
                               sequence of addresses (assuming the block is not
                               the entire sequence length) when the block is
                               'moved'.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC2_ADDRESS_PRBS_SAVE_N1_MCCPGC_MAIN_STRUCT;

/* CPGC2_ADDRESS_PRBS_POLY_N0_MCCPGC_MAIN_REG supported on:                     */
/*      SPRA0 (0x20009100)                                                      */
/*      SPRB0 (0x20009100)                                                      */
/*      SPRHBM (0x20009100)                                                     */
/*      SPRC0 (0x20009100)                                                      */
/*      SPRMCC (0x20009100)                                                     */
/*      SPRUCC (0x20009100)                                                     */
/* Register default value on SPRA0: 0x03000072                                  */
/* Register default value on SPRB0: 0x03000072                                  */
/* Register default value on SPRHBM: 0x03000072                                 */
/* Register default value on SPRC0: 0x03000072                                  */
/* Register default value on SPRMCC: 0x03000072                                 */
/* Register default value on SPRUCC: 0x03000072                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Address PRBS generator polynomial (Galois)
*/


#define CPGC2_ADDRESS_PRBS_POLY_N0_MCCPGC_MAIN_REG 0x28029100

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 address_prbs_column_poly : 16;

                            /* Bits[15:0], Access Type=RW, default=0x00000072*/

                            /*
                               Polynomial tap value of Address PRBS generator
                               Column field. Default PRBS7.[br] PRBS8=[8, 6, 5,
                               2]=0x000B2[br] PRBS7=[7, 6, 5, 2]=0x00072[br]
                               PRBS6=[6,5,3,2]=0x00036[br]
                               PRBS5=[5,3]=0x00014[br] PRBS4=[4,3]=0x0000C[br]
                               PRBS3=[3,2]=0x00006[br] PRBS2=[2,1]=0x00003
                            */
    UINT32 rsvd : 8;

                            /* Bits[23:16], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 address_prbs_rank_poly : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000003*/

                            /*
                               Polynomial tap value of Address PRBS generator
                               Rank field. Default PRBS2.[br] PRBS13=[13, 11,
                               9, 8, 5, 2]=0x01592[br] PRBS12=[12, 10, 9, 7, 5,
                               2]=0x00B52[br] PRBS11=[11, 10, 8, 7, 6,
                               3]=0x006E4[br] PRBS10=[10, 9, 7, 5, 4,
                               2]=0x0035A[br] PRBS9=[9, 7, 5, 2]=0x00152
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC2_ADDRESS_PRBS_POLY_N0_MCCPGC_MAIN_STRUCT;

/* CPGC2_ADDRESS_PRBS_POLY_N1_MCCPGC_MAIN_REG supported on:                     */
/*      SPRA0 (0x20009104)                                                      */
/*      SPRB0 (0x20009104)                                                      */
/*      SPRHBM (0x20009104)                                                     */
/*      SPRC0 (0x20009104)                                                      */
/*      SPRMCC (0x20009104)                                                     */
/*      SPRUCC (0x20009104)                                                     */
/* Register default value on SPRA0: 0x06009924                                  */
/* Register default value on SPRB0: 0x06009924                                  */
/* Register default value on SPRHBM: 0x06009924                                 */
/* Register default value on SPRC0: 0x06009924                                  */
/* Register default value on SPRMCC: 0x06009924                                 */
/* Register default value on SPRUCC: 0x06009924                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Address PRBS generator polynomial (Galois)
*/


#define CPGC2_ADDRESS_PRBS_POLY_N1_MCCPGC_MAIN_REG 0x28029104

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 address_prbs_row_poly : 18;

                            /* Bits[17:0], Access Type=RW, default=0x00009924*/

                            /*
                               Polynomial tap value of Address PRBS generator
                               Row field. Default PRBS16.[br] PRBS18=[18, 15,
                               13, 11, 10, 8, 5, 3]=0x25694[br] PRBS17=[17, 14,
                               12, 9, 6, 3]=0x12924[br] PRBS16=[16, 13, 12, 9,
                               6, 3]=0x09924[br] PRBS15=[15, 12, 9, 8, 6,
                               3]=0x049A4[br] PRBS14=[14, 11, 9, 8, 6,
                               3]=0x025A4
                            */
    UINT32 rsvd : 6;

                            /* Bits[23:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 address_prbs_bank_poly : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000006*/

                            /*
                               Polynomial tap value of Address PRBS generator
                               Bank field. Default PRBS3.[br] The following
                               description applies to all the other Poly
                               fields.[br] A Zero polynomial value will result
                               in the resultant address field always being
                               0.[br] The user should select a maximal length
                               feedback set for the desired number of field
                               bits.[br] There is no Block or Region masking on
                               this value.[br] If address aliasing is not
                               desired, then the length must be selected to be
                               within the number of active (Region) address
                               bits.[br] Address field inversion does not apply
                               to a PRBS based address field.[br]
                               Example/recommended polynomials are listed in
                               the other fields of this register.[br] It is
                               recommended to select polynomials that have a
                               distance between feedback terms of 4 or less:
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC2_ADDRESS_PRBS_POLY_N1_MCCPGC_MAIN_STRUCT;

/* CPGC2_BASE_CLOCK_CONFIG_MCCPGC_MAIN_REG supported on:                        */
/*      SPRA0 (0x20009108)                                                      */
/*      SPRB0 (0x20009108)                                                      */
/*      SPRHBM (0x20009108)                                                     */
/*      SPRC0 (0x20009108)                                                      */
/*      SPRMCC (0x20009108)                                                     */
/*      SPRUCC (0x20009108)                                                     */
/* Register default value on SPRA0: 0x11900001                                  */
/* Register default value on SPRB0: 0x11900001                                  */
/* Register default value on SPRHBM: 0x11900001                                 */
/* Register default value on SPRC0: 0x11900001                                  */
/* Register default value on SPRMCC: 0x11900001                                 */
/* Register default value on SPRUCC: 0x11900001                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Configure the timebase for the Algorithm Wait Timer.
*/


#define CPGC2_BASE_CLOCK_CONFIG_MCCPGC_MAIN_REG 0x28029108

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 prescaler_for_clock_freq : 12;

                            /* Bits[11:0], Access Type=RW, default=0x00000001*/

                            /*
                               In order to make the 'standard' 1 GHz clock for
                               the CPGC specified Wait_Clock_Frequency setting,
                               we need to provide a Prescaler, and Increment
                               Value to modify the existing Wait_Timer_Current
                               advancement. This field will divide the native
                               Memory Controller clock by the provided value,
                               with '1' being 'No Divide'. After that divide,
                               the Wait_Timer_Current will advance by the
                               'Increment_Value' field. In this way, we are
                               creating a clock ratio able to 'multiply' the
                               native Memory Controller clock by
                               'Increment_Value/Prescaler'. For small values of
                               Wait_Time, the error will be substantial, and it
                               may be better to modify the programming to the
                               '11' Native Clock setting and manually compute
                               the required Wait_Time for the desired delay.
                            */
    UINT32 rsvd : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 clock_freq : 12;

                            /* Bits[27:16], Access Type=RW, default=0x00000190*/

                            /*
                               This field provides a way to tell the hardware
                               the native Memory Controller clock
                               frequency.[br] Wait_Clock_Frequency determines
                               if this field, or a fixed value of 1, or
                               Prescaler value is used to divide the MC
                               clock.[br] When a setting of 1MHz or 1KHz is
                               used in , this fields value is feed into the
                               counter automatically, with a 1 for the
                               Increment_Value.[br] When GHz is used in
                               Wait_Clock_Frequency, this field is ignored and
                               Prescaler is fed into the counter, dividing the
                               Native MC clock by the Prescaler, then
                               incrementing by Increment_Value.[br] When using
                               Native MC clock, this field is ignored and 1 fed
                               into the counter with a 1 for the
                               Increment_Value.
                            */
    UINT32 increment_value : 4;

                            /* Bits[31:28], Access Type=RW, default=0x00000001*/

                            /*
                               See Prescaler field for information on this
                               field.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_BASE_CLOCK_CONFIG_MCCPGC_MAIN_STRUCT;

/* CPGC2_CMD_FSM_CURRENT_MCCPGC_MAIN_REG supported on:                          */
/*      SPRA0 (0x2000910c)                                                      */
/*      SPRB0 (0x2000910c)                                                      */
/*      SPRHBM (0x2000910c)                                                     */
/*      SPRC0 (0x2000910c)                                                      */
/*      SPRMCC (0x2000910c)                                                     */
/*      SPRUCC (0x2000910c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Current state of Command FSM - used at stop-on-error to determine the current progress in the test at the time of the error.
*/


#define CPGC2_CMD_FSM_CURRENT_MCCPGC_MAIN_REG 0x2802910C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 offset_command_instruction_current : 3;

                            /* Bits[2:0], Access Type=RO/V, default=0x00000000*/

                            /* Current Offset_Command_Instruction pointer. */
    UINT32 offset_address_instruction_current : 3;

                            /* Bits[5:3], Access Type=RO/V, default=0x00000000*/

                            /* Current Offset_Address_Instruction pointer. */
    UINT32 offset_group_instruction_current : 1;

                            /* Bits[6:6], Access Type=RO/V, default=0x00000000*/

                            /*
                               Current Offset_Group as pointed to by the
                               Current Command_Instruction (if an Offset
                               instruction).
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 command_instruction_current : 5;

                            /* Bits[12:8], Access Type=RO/V, default=0x00000000*/

                            /* Current Command_Instruction pointer. */
    UINT32 rsvd_13 : 2;

                            /* Bits[14:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 algorithm_instruction_current : 3;

                            /* Bits[17:15], Access Type=RO/V, default=0x00000000*/

                            /* Current Algorithm_Instruction pointer. */
    UINT32 rsvd_18 : 6;

                            /* Bits[23:18], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 data_instruction_current : 2;

                            /* Bits[25:24], Access Type=RO/V, default=0x00000000*/

                            /* Current Data_Instruction pointer. */
    UINT32 rsvd_26 : 2;

                            /* Bits[27:26], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 address_instruction_current : 2;

                            /* Bits[29:28], Access Type=RO/V, default=0x00000000*/

                            /* Current Address_Instruction pointer. */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC2_CMD_FSM_CURRENT_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_CFG_A_MCCPGC_MAIN_REG supported on:                                 */
/*      SPRA0 (0x20009110)                                                      */
/*      SPRB0 (0x20009110)                                                      */
/*      SPRHBM (0x20009110)                                                     */
/*      SPRC0 (0x20009110)                                                      */
/*      SPRMCC (0x20009110)                                                     */
/*      SPRUCC (0x20009110)                                                     */
/* Register default value on SPRA0: 0x00010000                                  */
/* Register default value on SPRB0: 0x00010000                                  */
/* Register default value on SPRHBM: 0x00010000                                 */
/* Register default value on SPRC0: 0x00010000                                  */
/* Register default value on SPRMCC: 0x00010000                                 */
/* Register default value on SPRUCC: 0x00010000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Sequence Configuration Low.
*/


#define CPGC_SEQ_CFG_A_MCCPGC_MAIN_REG 0x28029110

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 8;

                            /* Bits[7:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 global_clear_err_bind : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will bind this request engine
                               to all other globally enabled request engines.
                               Clearing the error status for any channel
                               attached to a request engine with
                               GLOBAL_CLEAR_ERR_BIND set will cause the same
                               action to occur on all channels attached to any
                               request engines with GLOBAL_CLEAR_ERR_BIND set.
                               This feature is usually used when
                               synchronization between multiple
                               engines/channels necessitates a global control
                               of all supported engines. Note: this field is
                               only available if multiple channels/engines
                               synchronization is provisioned for the current
                               implementation, otherwise it is reserved.
                            */
    UINT32 global_stop_on_err_bind : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will bind this request engine
                               to all other globally enabled request engines. A
                               test stop (due to an error condition) for any
                               channel associated with the current request
                               engine with GLOBAL_STOP_ON_ERR_BIND set will
                               cause the same action to occur on all engines
                               with GLOBAL_STOP_ON_ERR_BIND set. This feature
                               is usually used when synchronization between
                               multiple engines/channels necessitates a global
                               control of all supported engines. Note: this
                               field is only available if multiple
                               channels/engines synchronization is provisioned
                               for the current implementation, otherwise it is
                               reserved.
                            */
    UINT32 global_start_bind : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will bind this request engine
                               to all other globally enabled request engines. A
                               Start_Test for any request engine with
                               GLOBAL_START_BIND set will cause the same action
                               to occur on all engines with GLOBAL_START_BIND
                               set. This feature is usually used when
                               synchronization between multiple
                               engines/channels necessitates a global control
                               of all supported engines. Note: this field is
                               only available if multiple channels/engines
                               synchronization is provisioned for the current
                               implementation, otherwise it is reserved.
                            */
    UINT32 global_stop_bind : 1;

                            /* Bits[11:11], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will bind this request engine
                               to all other globally enabled request engines. A
                               test stop (using Stop Test) for any request
                               engine with GLOBAL_STOP_BIND set will cause the
                               same action to occur on all engines with
                               GLOBAL_STOP_BIND set. This feature is usually
                               used when synchronization between multiple
                               engines/channels necessitates a global control
                               of all supported engines. Note: this field is
                               only available if multiple channels/engine
                               synchronization is provisioned for the current
                               implementation, otherwise it is reserved.
                            */
    UINT32 initialization_mode : 3;

                            /* Bits[14:12], Access Type=RW, default=0x00000000*/

                            /*
                               000 - IDLE MODE[br] 001 - ACTIVE MODE[br] 010 -
                               DIRECT MODE[br] 011 - (Reserved)[br] 100 -
                               (Reserved)[br] 101 - (Reserved)[br] 110 -
                               (Reserved)[br] 111 - (Reserved)
                            */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 channel_assign : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000001*/

                            /*
                               Assigns which channel(s) this request generator
                               will generate requests for. Multiple channels
                               are acceptable. The same channel should not be
                               set in more than one instance of Channel Assign.
                               At least one bit must be set (before setting
                               START_TEST) in order to use this request
                               generator. Only Request Generator [0] has the
                               reset default to 4'b0001, all others have a
                               reset default of 4'b0000.
                            */
    UINT32 rsvd_20 : 4;

                            /* Bits[23:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 strict_wr_to_rd_order : 1;

                            /* Bits[24:24], Access Type=RW, default=0x00000000*/

                            /*
                               Force address matching when testing read
                               accesses against writes which are requesting a
                               response, and vice versa:[br] 0 - Addresses must
                               match for request to be blocked.[br] 1 -
                               Addresses are forced to always match.[br]
                               Matches are always restricted to within same
                               channel.[br] This field holds for each channel
                               as designated in Channel Assign.
                            */
    UINT32 posted_wr_to_rd_order : 1;

                            /* Bits[25:25], Access Type=RW, default=0x00000000*/

                            /*
                               Enable address matching when testing read
                               accesses against writes, and write against
                               reads, even if previous request was Posted:[br]
                               0 - Addresses must match and earlier request
                               must be NonPosted for later request to be
                               blocked.[br] 1 - Addresses only need to match
                               for later request to be blocked.[br] Matches are
                               always restricted to within same channel.[br]
                               This field holds for each channel as designated
                               in Channel Assign.
                            */
    UINT32 rsvd_26 : 6;

                            /* Bits[31:26], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_CFG_A_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_CFG_B_MCCPGC_MAIN_REG supported on:                                 */
/*      SPRA0 (0x20009114)                                                      */
/*      SPRB0 (0x20009114)                                                      */
/*      SPRHBM (0x20009114)                                                     */
/*      SPRC0 (0x20009114)                                                      */
/*      SPRMCC (0x20009114)                                                     */
/*      SPRUCC (0x20009114)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Sequence Config High.
*/


#define CPGC_SEQ_CFG_B_MCCPGC_MAIN_REG 0x28029114

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 start_delay : 10;

                            /* Bits[9:0], Access Type=RW, default=0x00000000*/

                            /*
                               Number of clock cycles (in CPGC-S clock domain)
                               the start of the test is delayed by after
                               START_TEST has been asserted by the user. This
                               is usually used to synchronize multiple SoC CPGC
                               engines on multiple channels according to a
                               defined phase relationship.
                            */
    UINT32 rsvd : 22;

                            /* Bits[31:10], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_CFG_B_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_CTL_MCCPGC_MAIN_REG supported on:                                   */
/*      SPRA0 (0x20009118)                                                      */
/*      SPRB0 (0x20009118)                                                      */
/*      SPRHBM (0x20009118)                                                     */
/*      SPRC0 (0x20009118)                                                      */
/*      SPRMCC (0x20009118)                                                     */
/*      SPRUCC (0x20009118)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Sequence Control for test execution.
*/


#define CPGC_SEQ_CTL_MCCPGC_MAIN_REG 0x28029118

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 start_test : 1;

                            /* Bits[0:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Used to initiate a transition to active mode on
                               this engine/channel (note that INIT_MODE has to
                               be programmed first). Note that this will also
                               cause a test start for all engines with
                               GLOBAL_START_BIND set.[br] This bit will self-
                               clear.
                            */
    UINT32 stop_test : 1;

                            /* Bits[1:1], Access Type=RW/V, default=0x00000000*/

                            /*
                               Forces an exit from the tests running on this
                               engine/channel. Note that this will also cause a
                               test stop for all engines with GLOBAL_STOP_BIND
                               set. This bit will self-clear.
                            */
    UINT32 clear_errors : 1;

                            /* Bits[2:2], Access Type=RW/V, default=0x00000000*/

                            /*
                               Setting this bit will immediately clear all
                               error registers and error status except for the
                               Raster Repository which has its own clear
                               control. Note that this will also cause an error
                               clear for all engines with GLOBAL_CLEAR_ERR_BIND
                               set. This bit will self-clear.
                            */
    UINT32 rsvd : 5;

                            /* Bits[7:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 single_cmd_mode : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               Enter Single Command mode were we will issue one
                               command from CPGC and then pause command
                               issuing. This may be resumed by setting
                               Continue_Single_Mode, or normal continuous
                               operation resumed by clearing this bit.
                            */
    UINT32 continue_single_mode : 1;

                            /* Bits[9:9], Access Type=RW/V, default=0x00000000*/

                            /*
                               When in Single_Command_Mode setting this bit
                               will enable a new command to be issued. This bit
                               immediately clears after being set.
                            */
    UINT32 single_march_element_mode : 1;

                            /* Bits[10:10], Access Type=RW, default=0x00000000*/

                            /*
                               Enter Single March Element mode were we will
                               issue all the commands from one CPGC March
                               Element (aka Algorithm Instruction) and then
                               pause command issuing. This may be resumed by
                               setting Continue_Single_Mode, or normal
                               continuous operation resumed by clearing this
                               bit.
                            */
    UINT32 rsvd_11 : 21;

                            /* Bits[31:11], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_CTL_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_STATUS_MCCPGC_MAIN_REG supported on:                                */
/*      SPRA0 (0x2000911c)                                                      */
/*      SPRB0 (0x2000911c)                                                      */
/*      SPRHBM (0x2000911c)                                                     */
/*      SPRC0 (0x2000911c)                                                      */
/*      SPRMCC (0x2000911c)                                                     */
/*      SPRUCC (0x2000911c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_t/cpgc_t_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Sequence Test Status of test execution.
*/


#define CPGC_SEQ_STATUS_MCCPGC_MAIN_REG 0x2802911C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 rsvd : 13;

                            /* Bits[12:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 internal_err : 1;

                            /* Bits[13:13], Access Type=RO/V, default=0x00000000*/

                            /*
                               If this bit is set, an internal error has
                               occurred (fifo/queue overflow etc). The only way
                               to recover is to give a warm reset. This bit is
                               replicated to each request generator
                               CPGC_SEQ_STATUS for convenience and is sourced
                               from CPGC2_V_CHICKEN.
                            */
    UINT32 credits_initialized : 1;

                            /* Bits[14:14], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit will be set when the credit negotiation
                               process is complete. (This bit is replicated to
                               each request generator for convenience and is
                               sourced from CPGC2_CREDIT_CONFIG)
                            */
    UINT32 channel_cfg_err : 1;

                            /* Bits[15:15], Access Type=RO/V, default=0x00000000*/

                            /*
                               If a value in CHANNEL_ASSIGN conflicts with the
                               CHANNEL_AVAILABLE or with lower request
                               generators CHANNEL_ASSIGN fields, then this bit
                               will be set and the request generator will not
                               operate.
                            */
    UINT32 channel_available : 4;

                            /* Bits[19:16], Access Type=RO/V, default=0x00000000*/

                            /*
                               Reflects the channel bits that can be set in the
                               CHANNEL_ASSIGN field of the CPGC_SEQ_CFG_A. This
                               field is dependent on the Memory Controllers
                               configuration such as 1x64, 2x32 and 4x16
                               channels and not dependent on other request
                               generators CHANNEL_ASSIGN values. If there is
                               any restrictions such as a channel only being
                               able to be controled from a specific Request
                               Generator, then this is reflected in differences
                               in these fields.
                            */
    UINT32 rsvd_20 : 4;

                            /* Bits[23:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 test_aborted : 1;

                            /* Bits[24:24], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit will be set when, following a Start
                               Test, while in Start Test Delay period, the
                               Request Generator encounters a stop condition.
                               In this case, Test Done will not be set, however
                               this bit will be set instead. Possible stop
                               conditions include Stop Test or an external Stop
                               Test from another Request Generator or CPGC/CADB
                               instance with Bind Stop Test set in both or by
                               an Error on another CPGC with Bind Stop-on-
                               Error.[br] This bit is also set if Test_Busy,
                               and the user sets Stop_Test and we end up
                               ignoring/aborting any Algo Wait condition/timer
                               in the course of stopping.[br] This field is
                               automatically cleared on a cold reset or Start
                               Test. It is recommended to explicitly clear this
                               field.
                            */
    UINT32 event_not_seen : 1;

                            /* Bits[25:25], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit will be set when we are paused due to
                               Wait_Event in the current
                               Algorithm_Instruction_Ctrl and we continued
                               because Event Timer got saturated (and we did
                               not see the event). This field is automatically
                               cleared on a cold reset or Start Test. It is
                               recommended to explicitly clear this field.
                            */
    UINT32 algo_wait : 1;

                            /* Bits[26:26], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit will be set when we are paused due to
                               Wait_Count_Start or Wait_Event in the current
                               Algorithm_Instruction_Ctrl. The test may be
                               terminated by setting Stop_Test.
                            */
    UINT32 single_mode_paused : 1;

                            /* Bits[27:27], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit will be set when a command has been
                               issued and we are paused due to
                               Single_Command_Mode. The test may be continued
                               by either clearing Single_Command_Mode or by
                               setting Continue_Single_Mode.
                            */
    UINT32 algo_done : 1;

                            /* Bits[28:28], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit will be set when all the algorithms are
                               complete. This field is automatically cleared on
                               a cold reset or Start Test. It is recommended to
                               explicitly clear this field.
                            */
    UINT32 start_test_delay_busy : 1;

                            /* Bits[29:29], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit will be set between the time Start Test
                               is set, and Test Busy is set. It marks the time
                               of Start Test Delay. Bit is cleared on a
                               STOP_TEST or after waiting for START_TEST_DELAY
                               clocks. The test may be Aborted by setting
                               Stop_Test.
                            */
    UINT32 test_busy : 1;

                            /* Bits[30:30], Access Type=RO/V, default=0x00000000*/

                            /*
                               This bit will be set when once a test has
                               started. Bit is cleared once the test is done
                               (or has been forced to exit due a stop
                               condition).
                            */
    UINT32 test_done : 1;

                            /* Bits[31:31], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               This bit will be set when the test is complete
                               (or has been forced to exit due to a stop
                               condition). This field is automatically cleared
                               on a cold reset or Start Test. It is recommended
                               to explicitly clear this field.
                            */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_STATUS_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_0_N0_MCCPGC_MAIN_REG supported on:                 */
/*      SPRA0 (0x20009120)                                                      */
/*      SPRB0 (0x20009120)                                                      */
/*      SPRHBM (0x20009120)                                                     */
/*      SPRC0 (0x20009120)                                                      */
/*      SPRMCC (0x20009120)                                                     */
/*      SPRUCC (0x20009120)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository. Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.
*/


#define CPGC2_RASTER_REPO_CONTENT_0_N0_MCCPGC_MAIN_REG 0x28029120

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 1: A complete
                               64-bit (or 72-bit, or 80-bit) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Chunk0-bit0 is in Content bit 0.[br]
                               Mode 2: One Error_Summary entry. Same format as
                               the Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] Mode 5: A complete 64-bit (or 72-bit,
                               or 32+32, or 36+36, or 40+40) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Segregated into entires Content[0] (Even
                               UI's), and Content[1] (Odd UI's). This would
                               include the lower 16-bits of both
                               ECC_Content[1:0] registers for ECC lanes. Think
                               of this as laying out each group of 128-bits of
                               compare (plus any ECC bits) into the same 2
                               entries in the Raster Repository by ORing them
                               each together. This provides both an Even/Odd UI
                               status for x64 buses, and 4-UI status for x32
                               buses, and 8-UI status for x16 buses. If 'more
                               compact' status is required, then software will
                               have to compress the shorter UI's together as
                               needed.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_0_N0_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_0_N1_MCCPGC_MAIN_REG supported on:                 */
/*      SPRA0 (0x20009124)                                                      */
/*      SPRB0 (0x20009124)                                                      */
/*      SPRHBM (0x20009124)                                                     */
/*      SPRC0 (0x20009124)                                                      */
/*      SPRMCC (0x20009124)                                                     */
/*      SPRUCC (0x20009124)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository. Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.
*/


#define CPGC2_RASTER_REPO_CONTENT_0_N1_MCCPGC_MAIN_REG 0x28029124

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 1: A complete
                               64-bit (or 72-bit, or 80-bit) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Chunk0-bit0 is in Content bit 0.[br]
                               Mode 2: One Error_Summary entry. Same format as
                               the Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] Mode 5: A complete 64-bit (or 72-bit,
                               or 32+32, or 36+36, or 40+40) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Segregated into entires Content[0] (Even
                               UI's), and Content[1] (Odd UI's). This would
                               include the lower 16-bits of both
                               ECC_Content[1:0] registers for ECC lanes. Think
                               of this as laying out each group of 128-bits of
                               compare (plus any ECC bits) into the same 2
                               entries in the Raster Repository by ORing them
                               each together. This provides both an Even/Odd UI
                               status for x64 buses, and 4-UI status for x32
                               buses, and 8-UI status for x16 buses. If 'more
                               compact' status is required, then software will
                               have to compress the shorter UI's together as
                               needed.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_0_N1_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_1_N0_MCCPGC_MAIN_REG supported on:                 */
/*      SPRA0 (0x20009128)                                                      */
/*      SPRB0 (0x20009128)                                                      */
/*      SPRHBM (0x20009128)                                                     */
/*      SPRC0 (0x20009128)                                                      */
/*      SPRMCC (0x20009128)                                                     */
/*      SPRUCC (0x20009128)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository. Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.
*/


#define CPGC2_RASTER_REPO_CONTENT_1_N0_MCCPGC_MAIN_REG 0x28029128

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 1: A complete
                               64-bit (or 72-bit, or 80-bit) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Chunk0-bit0 is in Content bit 0.[br]
                               Mode 2: One Error_Summary entry. Same format as
                               the Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] Mode 5: A complete 64-bit (or 72-bit,
                               or 32+32, or 36+36, or 40+40) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Segregated into entires Content[0] (Even
                               UI's), and Content[1] (Odd UI's). This would
                               include the lower 16-bits of both
                               ECC_Content[1:0] registers for ECC lanes. Think
                               of this as laying out each group of 128-bits of
                               compare (plus any ECC bits) into the same 2
                               entries in the Raster Repository by ORing them
                               each together. This provides both an Even/Odd UI
                               status for x64 buses, and 4-UI status for x32
                               buses, and 8-UI status for x16 buses. If 'more
                               compact' status is required, then software will
                               have to compress the shorter UI's together as
                               needed.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_1_N0_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_1_N1_MCCPGC_MAIN_REG supported on:                 */
/*      SPRA0 (0x2000912c)                                                      */
/*      SPRB0 (0x2000912c)                                                      */
/*      SPRHBM (0x2000912c)                                                     */
/*      SPRC0 (0x2000912c)                                                      */
/*      SPRMCC (0x2000912c)                                                     */
/*      SPRUCC (0x2000912c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository. Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.
*/


#define CPGC2_RASTER_REPO_CONTENT_1_N1_MCCPGC_MAIN_REG 0x2802912C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 1: A complete
                               64-bit (or 72-bit, or 80-bit) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Chunk0-bit0 is in Content bit 0.[br]
                               Mode 2: One Error_Summary entry. Same format as
                               the Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] Mode 5: A complete 64-bit (or 72-bit,
                               or 32+32, or 36+36, or 40+40) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Segregated into entires Content[0] (Even
                               UI's), and Content[1] (Odd UI's). This would
                               include the lower 16-bits of both
                               ECC_Content[1:0] registers for ECC lanes. Think
                               of this as laying out each group of 128-bits of
                               compare (plus any ECC bits) into the same 2
                               entries in the Raster Repository by ORing them
                               each together. This provides both an Even/Odd UI
                               status for x64 buses, and 4-UI status for x32
                               buses, and 8-UI status for x16 buses. If 'more
                               compact' status is required, then software will
                               have to compress the shorter UI's together as
                               needed.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_1_N1_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_2_N0_MCCPGC_MAIN_REG supported on:                 */
/*      SPRA0 (0x20009130)                                                      */
/*      SPRB0 (0x20009130)                                                      */
/*      SPRHBM (0x20009130)                                                     */
/*      SPRC0 (0x20009130)                                                      */
/*      SPRMCC (0x20009130)                                                     */
/*      SPRUCC (0x20009130)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository. Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.
*/


#define CPGC2_RASTER_REPO_CONTENT_2_N0_MCCPGC_MAIN_REG 0x28029130

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 1: A complete
                               64-bit (or 72-bit, or 80-bit) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Chunk0-bit0 is in Content bit 0.[br]
                               Mode 2: One Error_Summary entry. Same format as
                               the Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] Mode 5: A complete 64-bit (or 72-bit,
                               or 32+32, or 36+36, or 40+40) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Segregated into entires Content[0] (Even
                               UI's), and Content[1] (Odd UI's). This would
                               include the lower 16-bits of both
                               ECC_Content[1:0] registers for ECC lanes. Think
                               of this as laying out each group of 128-bits of
                               compare (plus any ECC bits) into the same 2
                               entries in the Raster Repository by ORing them
                               each together. This provides both an Even/Odd UI
                               status for x64 buses, and 4-UI status for x32
                               buses, and 8-UI status for x16 buses. If 'more
                               compact' status is required, then software will
                               have to compress the shorter UI's together as
                               needed.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_2_N0_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_2_N1_MCCPGC_MAIN_REG supported on:                 */
/*      SPRA0 (0x20009134)                                                      */
/*      SPRB0 (0x20009134)                                                      */
/*      SPRHBM (0x20009134)                                                     */
/*      SPRC0 (0x20009134)                                                      */
/*      SPRMCC (0x20009134)                                                     */
/*      SPRUCC (0x20009134)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository. Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.
*/


#define CPGC2_RASTER_REPO_CONTENT_2_N1_MCCPGC_MAIN_REG 0x28029134

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 1: A complete
                               64-bit (or 72-bit, or 80-bit) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Chunk0-bit0 is in Content bit 0.[br]
                               Mode 2: One Error_Summary entry. Same format as
                               the Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] Mode 5: A complete 64-bit (or 72-bit,
                               or 32+32, or 36+36, or 40+40) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Segregated into entires Content[0] (Even
                               UI's), and Content[1] (Odd UI's). This would
                               include the lower 16-bits of both
                               ECC_Content[1:0] registers for ECC lanes. Think
                               of this as laying out each group of 128-bits of
                               compare (plus any ECC bits) into the same 2
                               entries in the Raster Repository by ORing them
                               each together. This provides both an Even/Odd UI
                               status for x64 buses, and 4-UI status for x32
                               buses, and 8-UI status for x16 buses. If 'more
                               compact' status is required, then software will
                               have to compress the shorter UI's together as
                               needed.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_2_N1_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_3_N0_MCCPGC_MAIN_REG supported on:                 */
/*      SPRA0 (0x20009138)                                                      */
/*      SPRB0 (0x20009138)                                                      */
/*      SPRHBM (0x20009138)                                                     */
/*      SPRC0 (0x20009138)                                                      */
/*      SPRMCC (0x20009138)                                                     */
/*      SPRUCC (0x20009138)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository. Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.
*/


#define CPGC2_RASTER_REPO_CONTENT_3_N0_MCCPGC_MAIN_REG 0x28029138

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 1: A complete
                               64-bit (or 72-bit, or 80-bit) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Chunk0-bit0 is in Content bit 0.[br]
                               Mode 2: One Error_Summary entry. Same format as
                               the Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] Mode 5: A complete 64-bit (or 72-bit,
                               or 32+32, or 36+36, or 40+40) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Segregated into entires Content[0] (Even
                               UI's), and Content[1] (Odd UI's). This would
                               include the lower 16-bits of both
                               ECC_Content[1:0] registers for ECC lanes. Think
                               of this as laying out each group of 128-bits of
                               compare (plus any ECC bits) into the same 2
                               entries in the Raster Repository by ORing them
                               each together. This provides both an Even/Odd UI
                               status for x64 buses, and 4-UI status for x32
                               buses, and 8-UI status for x16 buses. If 'more
                               compact' status is required, then software will
                               have to compress the shorter UI's together as
                               needed.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_3_N0_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_3_N1_MCCPGC_MAIN_REG supported on:                 */
/*      SPRA0 (0x2000913c)                                                      */
/*      SPRB0 (0x2000913c)                                                      */
/*      SPRHBM (0x2000913c)                                                     */
/*      SPRC0 (0x2000913c)                                                      */
/*      SPRMCC (0x2000913c)                                                     */
/*      SPRUCC (0x2000913c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository. Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.
*/


#define CPGC2_RASTER_REPO_CONTENT_3_N1_MCCPGC_MAIN_REG 0x2802913C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 1: A complete
                               64-bit (or 72-bit, or 80-bit) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Chunk0-bit0 is in Content bit 0.[br]
                               Mode 2: One Error_Summary entry. Same format as
                               the Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] Mode 5: A complete 64-bit (or 72-bit,
                               or 32+32, or 36+36, or 40+40) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Segregated into entires Content[0] (Even
                               UI's), and Content[1] (Odd UI's). This would
                               include the lower 16-bits of both
                               ECC_Content[1:0] registers for ECC lanes. Think
                               of this as laying out each group of 128-bits of
                               compare (plus any ECC bits) into the same 2
                               entries in the Raster Repository by ORing them
                               each together. This provides both an Even/Odd UI
                               status for x64 buses, and 4-UI status for x32
                               buses, and 8-UI status for x16 buses. If 'more
                               compact' status is required, then software will
                               have to compress the shorter UI's together as
                               needed.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_3_N1_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_4_N0_MCCPGC_MAIN_REG supported on:                 */
/*      SPRA0 (0x20009140)                                                      */
/*      SPRB0 (0x20009140)                                                      */
/*      SPRHBM (0x20009140)                                                     */
/*      SPRC0 (0x20009140)                                                      */
/*      SPRMCC (0x20009140)                                                     */
/*      SPRUCC (0x20009140)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository. Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.
*/


#define CPGC2_RASTER_REPO_CONTENT_4_N0_MCCPGC_MAIN_REG 0x28029140

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 1: A complete
                               64-bit (or 72-bit, or 80-bit) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Chunk0-bit0 is in Content bit 0.[br]
                               Mode 2: One Error_Summary entry. Same format as
                               the Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] Mode 5: A complete 64-bit (or 72-bit,
                               or 32+32, or 36+36, or 40+40) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Segregated into entires Content[0] (Even
                               UI's), and Content[1] (Odd UI's). This would
                               include the lower 16-bits of both
                               ECC_Content[1:0] registers for ECC lanes. Think
                               of this as laying out each group of 128-bits of
                               compare (plus any ECC bits) into the same 2
                               entries in the Raster Repository by ORing them
                               each together. This provides both an Even/Odd UI
                               status for x64 buses, and 4-UI status for x32
                               buses, and 8-UI status for x16 buses. If 'more
                               compact' status is required, then software will
                               have to compress the shorter UI's together as
                               needed.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_4_N0_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_4_N1_MCCPGC_MAIN_REG supported on:                 */
/*      SPRA0 (0x20009144)                                                      */
/*      SPRB0 (0x20009144)                                                      */
/*      SPRHBM (0x20009144)                                                     */
/*      SPRC0 (0x20009144)                                                      */
/*      SPRMCC (0x20009144)                                                     */
/*      SPRUCC (0x20009144)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository. Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.
*/


#define CPGC2_RASTER_REPO_CONTENT_4_N1_MCCPGC_MAIN_REG 0x28029144

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 1: A complete
                               64-bit (or 72-bit, or 80-bit) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Chunk0-bit0 is in Content bit 0.[br]
                               Mode 2: One Error_Summary entry. Same format as
                               the Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] Mode 5: A complete 64-bit (or 72-bit,
                               or 32+32, or 36+36, or 40+40) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Segregated into entires Content[0] (Even
                               UI's), and Content[1] (Odd UI's). This would
                               include the lower 16-bits of both
                               ECC_Content[1:0] registers for ECC lanes. Think
                               of this as laying out each group of 128-bits of
                               compare (plus any ECC bits) into the same 2
                               entries in the Raster Repository by ORing them
                               each together. This provides both an Even/Odd UI
                               status for x64 buses, and 4-UI status for x32
                               buses, and 8-UI status for x16 buses. If 'more
                               compact' status is required, then software will
                               have to compress the shorter UI's together as
                               needed.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_4_N1_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_5_N0_MCCPGC_MAIN_REG supported on:                 */
/*      SPRA0 (0x20009148)                                                      */
/*      SPRB0 (0x20009148)                                                      */
/*      SPRHBM (0x20009148)                                                     */
/*      SPRC0 (0x20009148)                                                      */
/*      SPRMCC (0x20009148)                                                     */
/*      SPRUCC (0x20009148)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository. Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.
*/


#define CPGC2_RASTER_REPO_CONTENT_5_N0_MCCPGC_MAIN_REG 0x28029148

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 1: A complete
                               64-bit (or 72-bit, or 80-bit) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Chunk0-bit0 is in Content bit 0.[br]
                               Mode 2: One Error_Summary entry. Same format as
                               the Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] Mode 5: A complete 64-bit (or 72-bit,
                               or 32+32, or 36+36, or 40+40) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Segregated into entires Content[0] (Even
                               UI's), and Content[1] (Odd UI's). This would
                               include the lower 16-bits of both
                               ECC_Content[1:0] registers for ECC lanes. Think
                               of this as laying out each group of 128-bits of
                               compare (plus any ECC bits) into the same 2
                               entries in the Raster Repository by ORing them
                               each together. This provides both an Even/Odd UI
                               status for x64 buses, and 4-UI status for x32
                               buses, and 8-UI status for x16 buses. If 'more
                               compact' status is required, then software will
                               have to compress the shorter UI's together as
                               needed.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_5_N0_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_5_N1_MCCPGC_MAIN_REG supported on:                 */
/*      SPRA0 (0x2000914c)                                                      */
/*      SPRB0 (0x2000914c)                                                      */
/*      SPRHBM (0x2000914c)                                                     */
/*      SPRC0 (0x2000914c)                                                      */
/*      SPRMCC (0x2000914c)                                                     */
/*      SPRUCC (0x2000914c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository. Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.
*/


#define CPGC2_RASTER_REPO_CONTENT_5_N1_MCCPGC_MAIN_REG 0x2802914C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 1: A complete
                               64-bit (or 72-bit, or 80-bit) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Chunk0-bit0 is in Content bit 0.[br]
                               Mode 2: One Error_Summary entry. Same format as
                               the Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] Mode 5: A complete 64-bit (or 72-bit,
                               or 32+32, or 36+36, or 40+40) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Segregated into entires Content[0] (Even
                               UI's), and Content[1] (Odd UI's). This would
                               include the lower 16-bits of both
                               ECC_Content[1:0] registers for ECC lanes. Think
                               of this as laying out each group of 128-bits of
                               compare (plus any ECC bits) into the same 2
                               entries in the Raster Repository by ORing them
                               each together. This provides both an Even/Odd UI
                               status for x64 buses, and 4-UI status for x32
                               buses, and 8-UI status for x16 buses. If 'more
                               compact' status is required, then software will
                               have to compress the shorter UI's together as
                               needed.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_5_N1_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_6_N0_MCCPGC_MAIN_REG supported on:                 */
/*      SPRA0 (0x20009150)                                                      */
/*      SPRB0 (0x20009150)                                                      */
/*      SPRHBM (0x20009150)                                                     */
/*      SPRC0 (0x20009150)                                                      */
/*      SPRMCC (0x20009150)                                                     */
/*      SPRUCC (0x20009150)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository. Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.
*/


#define CPGC2_RASTER_REPO_CONTENT_6_N0_MCCPGC_MAIN_REG 0x28029150

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 1: A complete
                               64-bit (or 72-bit, or 80-bit) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Chunk0-bit0 is in Content bit 0.[br]
                               Mode 2: One Error_Summary entry. Same format as
                               the Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] Mode 5: A complete 64-bit (or 72-bit,
                               or 32+32, or 36+36, or 40+40) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Segregated into entires Content[0] (Even
                               UI's), and Content[1] (Odd UI's). This would
                               include the lower 16-bits of both
                               ECC_Content[1:0] registers for ECC lanes. Think
                               of this as laying out each group of 128-bits of
                               compare (plus any ECC bits) into the same 2
                               entries in the Raster Repository by ORing them
                               each together. This provides both an Even/Odd UI
                               status for x64 buses, and 4-UI status for x32
                               buses, and 8-UI status for x16 buses. If 'more
                               compact' status is required, then software will
                               have to compress the shorter UI's together as
                               needed.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_6_N0_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_6_N1_MCCPGC_MAIN_REG supported on:                 */
/*      SPRA0 (0x20009154)                                                      */
/*      SPRB0 (0x20009154)                                                      */
/*      SPRHBM (0x20009154)                                                     */
/*      SPRC0 (0x20009154)                                                      */
/*      SPRMCC (0x20009154)                                                     */
/*      SPRUCC (0x20009154)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository. Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.
*/


#define CPGC2_RASTER_REPO_CONTENT_6_N1_MCCPGC_MAIN_REG 0x28029154

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 1: A complete
                               64-bit (or 72-bit, or 80-bit) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Chunk0-bit0 is in Content bit 0.[br]
                               Mode 2: One Error_Summary entry. Same format as
                               the Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] Mode 5: A complete 64-bit (or 72-bit,
                               or 32+32, or 36+36, or 40+40) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Segregated into entires Content[0] (Even
                               UI's), and Content[1] (Odd UI's). This would
                               include the lower 16-bits of both
                               ECC_Content[1:0] registers for ECC lanes. Think
                               of this as laying out each group of 128-bits of
                               compare (plus any ECC bits) into the same 2
                               entries in the Raster Repository by ORing them
                               each together. This provides both an Even/Odd UI
                               status for x64 buses, and 4-UI status for x32
                               buses, and 8-UI status for x16 buses. If 'more
                               compact' status is required, then software will
                               have to compress the shorter UI's together as
                               needed.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_6_N1_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_7_N0_MCCPGC_MAIN_REG supported on:                 */
/*      SPRA0 (0x20009158)                                                      */
/*      SPRB0 (0x20009158)                                                      */
/*      SPRHBM (0x20009158)                                                     */
/*      SPRC0 (0x20009158)                                                      */
/*      SPRMCC (0x20009158)                                                     */
/*      SPRUCC (0x20009158)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository. Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.
*/


#define CPGC2_RASTER_REPO_CONTENT_7_N0_MCCPGC_MAIN_REG 0x28029158

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 1: A complete
                               64-bit (or 72-bit, or 80-bit) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Chunk0-bit0 is in Content bit 0.[br]
                               Mode 2: One Error_Summary entry. Same format as
                               the Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] Mode 5: A complete 64-bit (or 72-bit,
                               or 32+32, or 36+36, or 40+40) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Segregated into entires Content[0] (Even
                               UI's), and Content[1] (Odd UI's). This would
                               include the lower 16-bits of both
                               ECC_Content[1:0] registers for ECC lanes. Think
                               of this as laying out each group of 128-bits of
                               compare (plus any ECC bits) into the same 2
                               entries in the Raster Repository by ORing them
                               each together. This provides both an Even/Odd UI
                               status for x64 buses, and 4-UI status for x32
                               buses, and 8-UI status for x16 buses. If 'more
                               compact' status is required, then software will
                               have to compress the shorter UI's together as
                               needed.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_7_N0_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_7_N1_MCCPGC_MAIN_REG supported on:                 */
/*      SPRA0 (0x2000915c)                                                      */
/*      SPRB0 (0x2000915c)                                                      */
/*      SPRHBM (0x2000915c)                                                     */
/*      SPRC0 (0x2000915c)                                                      */
/*      SPRMCC (0x2000915c)                                                     */
/*      SPRUCC (0x2000915c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository. Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.
*/


#define CPGC2_RASTER_REPO_CONTENT_7_N1_MCCPGC_MAIN_REG 0x2802915C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 1: A complete
                               64-bit (or 72-bit, or 80-bit) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Chunk0-bit0 is in Content bit 0.[br]
                               Mode 2: One Error_Summary entry. Same format as
                               the Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] Mode 5: A complete 64-bit (or 72-bit,
                               or 32+32, or 36+36, or 40+40) logical data chunk
                               error bit-map (1 or more DQ UI's depending on DQ
                               width). Segregated into entires Content[0] (Even
                               UI's), and Content[1] (Odd UI's). This would
                               include the lower 16-bits of both
                               ECC_Content[1:0] registers for ECC lanes. Think
                               of this as laying out each group of 128-bits of
                               compare (plus any ECC bits) into the same 2
                               entries in the Raster Repository by ORing them
                               each together. This provides both an Even/Odd UI
                               status for x64 buses, and 4-UI status for x32
                               buses, and 8-UI status for x16 buses. If 'more
                               compact' status is required, then software will
                               have to compress the shorter UI's together as
                               needed.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_7_N1_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_ECC_0_N0_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x20009160)                                                      */
/*      SPRB0 (0x20009160)                                                      */
/*      SPRHBM (0x20009160)                                                     */
/*      SPRC0 (0x20009160)                                                      */
/*      SPRMCC (0x20009160)                                                     */
/*      SPRUCC (0x20009160)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository.[br]
Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.[br]
This register is present even if no ECC support is provisioned in the IP to provide data storage in Modes 0, 2 and 3.
*/


#define CPGC2_RASTER_REPO_CONTENT_ECC_0_N0_MCCPGC_MAIN_REG 0x28029160

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 0: Up to 64 Lane
                               error status information for Even UI mismatches
                               in ECC[0] and Odd UI Lane error status
                               mismatches in ECC[1]. ECC lanes are in
                               CPGC2_ERR_SUMMARY_A and B along with per-nibble
                               summary bits.[br] Mode 1: A complete 64-bit (or
                               72-bit, or 32+32, or 36+36, or 40+40) logical
                               data chunk error bit-map (1 or more DQ UI's
                               depending on DQ width). Chunk0-bit0 is in
                               Content bit 0. Note if the channel supports
                               40-bit interface then in 72-lane mode, both
                               ECC[1] and ECC[0] are used (16 virtual ECC
                               lanes). See HAS text for format.[br] Mode 2: One
                               Error_Summary entry. Same format as the
                               Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] ECC[1] is formatted to store the
                               status for Mode 3 Row address validity. 1 bit
                               per entry location in RASTER_REPO_CONTENT and 1
                               bit per bank:[br] [31:0] -> [entry]=Valid[br]
                               [63:32] -> [bank] Attempt to store additional
                               entry when hit FAIL_MAX for that bank.[br] Mode
                               5: See description in CONTENT. Lower 16 bits in
                               each contain the ECC lane error status for Even
                               and Odd UI in x64 buses or 4 UI for x32 buses.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_ECC_0_N0_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_ECC_0_N1_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x20009164)                                                      */
/*      SPRB0 (0x20009164)                                                      */
/*      SPRHBM (0x20009164)                                                     */
/*      SPRC0 (0x20009164)                                                      */
/*      SPRMCC (0x20009164)                                                     */
/*      SPRUCC (0x20009164)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository.[br]
Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.[br]
This register is present even if no ECC support is provisioned in the IP to provide data storage in Modes 0, 2 and 3.
*/


#define CPGC2_RASTER_REPO_CONTENT_ECC_0_N1_MCCPGC_MAIN_REG 0x28029164

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 0: Up to 64 Lane
                               error status information for Even UI mismatches
                               in ECC[0] and Odd UI Lane error status
                               mismatches in ECC[1]. ECC lanes are in
                               CPGC2_ERR_SUMMARY_A and B along with per-nibble
                               summary bits.[br] Mode 1: A complete 64-bit (or
                               72-bit, or 32+32, or 36+36, or 40+40) logical
                               data chunk error bit-map (1 or more DQ UI's
                               depending on DQ width). Chunk0-bit0 is in
                               Content bit 0. Note if the channel supports
                               40-bit interface then in 72-lane mode, both
                               ECC[1] and ECC[0] are used (16 virtual ECC
                               lanes). See HAS text for format.[br] Mode 2: One
                               Error_Summary entry. Same format as the
                               Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] ECC[1] is formatted to store the
                               status for Mode 3 Row address validity. 1 bit
                               per entry location in RASTER_REPO_CONTENT and 1
                               bit per bank:[br] [31:0] -> [entry]=Valid[br]
                               [63:32] -> [bank] Attempt to store additional
                               entry when hit FAIL_MAX for that bank.[br] Mode
                               5: See description in CONTENT. Lower 16 bits in
                               each contain the ECC lane error status for Even
                               and Odd UI in x64 buses or 4 UI for x32 buses.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_ECC_0_N1_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_ECC_1_N0_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x20009168)                                                      */
/*      SPRB0 (0x20009168)                                                      */
/*      SPRHBM (0x20009168)                                                     */
/*      SPRC0 (0x20009168)                                                      */
/*      SPRMCC (0x20009168)                                                     */
/*      SPRUCC (0x20009168)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository.[br]
Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.[br]
This register is present even if no ECC support is provisioned in the IP to provide data storage in Modes 0, 2 and 3.
*/


#define CPGC2_RASTER_REPO_CONTENT_ECC_1_N0_MCCPGC_MAIN_REG 0x28029168

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 0: Up to 64 Lane
                               error status information for Even UI mismatches
                               in ECC[0] and Odd UI Lane error status
                               mismatches in ECC[1]. ECC lanes are in
                               CPGC2_ERR_SUMMARY_A and B along with per-nibble
                               summary bits.[br] Mode 1: A complete 64-bit (or
                               72-bit, or 32+32, or 36+36, or 40+40) logical
                               data chunk error bit-map (1 or more DQ UI's
                               depending on DQ width). Chunk0-bit0 is in
                               Content bit 0. Note if the channel supports
                               40-bit interface then in 72-lane mode, both
                               ECC[1] and ECC[0] are used (16 virtual ECC
                               lanes). See HAS text for format.[br] Mode 2: One
                               Error_Summary entry. Same format as the
                               Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] ECC[1] is formatted to store the
                               status for Mode 3 Row address validity. 1 bit
                               per entry location in RASTER_REPO_CONTENT and 1
                               bit per bank:[br] [31:0] -> [entry]=Valid[br]
                               [63:32] -> [bank] Attempt to store additional
                               entry when hit FAIL_MAX for that bank.[br] Mode
                               5: See description in CONTENT. Lower 16 bits in
                               each contain the ECC lane error status for Even
                               and Odd UI in x64 buses or 4 UI for x32 buses.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_ECC_1_N0_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONTENT_ECC_1_N1_MCCPGC_MAIN_REG supported on:             */
/*      SPRA0 (0x2000916c)                                                      */
/*      SPRB0 (0x2000916c)                                                      */
/*      SPRHBM (0x2000916c)                                                     */
/*      SPRC0 (0x2000916c)                                                      */
/*      SPRMCC (0x2000916c)                                                     */
/*      SPRUCC (0x2000916c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Flat register read access to Raster Repository.[br]
Cleared with CPGC2_RASTER_REPO_STATUS.RasterRepoClear.[br]
This register can be written after the repo is cleared to preload the repo before enabling the Post Package Repair Engine.[br]
This register is present even if no ECC support is provisioned in the IP to provide data storage in Modes 0, 2 and 3.
*/


#define CPGC2_RASTER_REPO_CONTENT_ECC_1_N1_MCCPGC_MAIN_REG 0x2802916C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 content : 32;

                            /* Bits[31:0], Access Type=RW/V/P, default=0x00000000*/

                            /*
                               For each CONTENT[] and 8-bits worth of the
                               CONTENT_ECC registers:[br] Mode 0: Up to 64 Lane
                               error status information for Even UI mismatches
                               in ECC[0] and Odd UI Lane error status
                               mismatches in ECC[1]. ECC lanes are in
                               CPGC2_ERR_SUMMARY_A and B along with per-nibble
                               summary bits.[br] Mode 1: A complete 64-bit (or
                               72-bit, or 32+32, or 36+36, or 40+40) logical
                               data chunk error bit-map (1 or more DQ UI's
                               depending on DQ width). Chunk0-bit0 is in
                               Content bit 0. Note if the channel supports
                               40-bit interface then in 72-lane mode, both
                               ECC[1] and ECC[0] are used (16 virtual ECC
                               lanes). See HAS text for format.[br] Mode 2: One
                               Error_Summary entry. Same format as the
                               Error_Summary registers extending into
                               associated 8-bits of RASTER_REPO_CONTENT_ECC[0].
                               ECC[1] unused.[br] Mode 3: 4 18-bit Row
                               addresses for read failures for the associated
                               Bank(s) as 4 entries of 16 bits of address in
                               the lower CONTENT register, and 2 bits
                               additional as part of the 8 associated ECC[0]
                               bits.[br] ECC[1] is formatted to store the
                               status for Mode 3 Row address validity. 1 bit
                               per entry location in RASTER_REPO_CONTENT and 1
                               bit per bank:[br] [31:0] -> [entry]=Valid[br]
                               [63:32] -> [bank] Attempt to store additional
                               entry when hit FAIL_MAX for that bank.[br] Mode
                               5: See description in CONTENT. Lower 16 bits in
                               each contain the ECC lane error status for Even
                               and Odd UI in x64 buses or 4 UI for x32 buses.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_REPO_CONTENT_ECC_1_N1_MCCPGC_MAIN_STRUCT;

/* CPGC2_READ_COMMAND_COUNT_CURRENT_MCCPGC_MAIN_REG supported on:               */
/*      SPRA0 (0x20009170)                                                      */
/*      SPRB0 (0x20009170)                                                      */
/*      SPRHBM (0x20009170)                                                     */
/*      SPRC0 (0x20009170)                                                      */
/*      SPRMCC (0x20009170)                                                     */
/*      SPRUCC (0x20009170)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Current count of reads.
*/


#define CPGC2_READ_COMMAND_COUNT_CURRENT_MCCPGC_MAIN_REG 0x28029170

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 read_command_count_current : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Current count of reads - freezes on
                               stop_on_error conditions at the number of reads
                               including the error that caused the stop.
                               Cleared on Start Test.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_READ_COMMAND_COUNT_CURRENT_MCCPGC_MAIN_STRUCT;

/* CPGC2_MASK_ERRS_FIRST_N_READS_MCCPGC_MAIN_REG supported on:                  */
/*      SPRA0 (0x20009174)                                                      */
/*      SPRB0 (0x20009174)                                                      */
/*      SPRHBM (0x20009174)                                                     */
/*      SPRC0 (0x20009174)                                                      */
/*      SPRMCC (0x20009174)                                                     */
/*      SPRUCC (0x20009174)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Masking for the first N read operations - all errors are ignored.
*/


#define CPGC2_MASK_ERRS_FIRST_N_READS_MCCPGC_MAIN_REG 0x28029174

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 mask_first_n_reads : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               Masking for the first N read operations - all
                               errors are ignored.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_MASK_ERRS_FIRST_N_READS_MCCPGC_MAIN_STRUCT;

/* CPGC2_ERR_SUMMARY_A_MCCPGC_MAIN_REG supported on:                            */
/*      SPRA0 (0x20009178)                                                      */
/*      SPRB0 (0x20009178)                                                      */
/*      SPRHBM (0x20009178)                                                     */
/*      SPRC0 (0x20009178)                                                      */
/*      SPRMCC (0x20009178)                                                     */
/*      SPRUCC (0x20009178)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Most recent error summary data, not yet written to the Raster Repository.
*/


#define CPGC2_ERR_SUMMARY_A_MCCPGC_MAIN_REG 0x28029178

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 error_summary : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Error_Summary -[br] Error Summary is contained
                               in the flat combination of CPGC2_ERR_SUMMARY_A,
                               CPGC2_ERR_SUMMARY_B, and
                               CPGC2_ERR_SUMMARY_C.[br] Mode 0: These registers
                               include enhanced per UI and Nibble Lane error
                               status information.[br] Bits [7:0] Even UI ECC
                               Lane Error status (not all bits valid if using
                               narrower interfaces).[br] Bits [25:8] 18 bits of
                               Even UI Nibble Error status (not all bits valid
                               if using narrower interfaces). ECC nibbles are
                               always nibbles [17:16].[br] Bits [32+ 7:0] Odd
                               UI ECC Lane Error status (not all bits valid if
                               using narrower interfaces).[br] Bits [32+ 25:8]
                               18 bits of Odd UI Nibble Error status (not all
                               bits valid if using narrower interfaces). ECC
                               nibbles are always nibbles [17:16].[br] Mode 1
                               and 3: These registers hold a summary of the
                               first data mismatch encountered.[br] Mode 2:
                               These registers hold a summary of the most
                               recent data mismatch up to the 9th mismatch. As
                               each new mismatch occurs, this value is written
                               to the Raster Repository Content storage before
                               it is updated with new information.[br] Format
                               in Modes 1, 2 and 3 consist of all bits of the
                               registers as follows:[br] Bits [15:0] - Data
                               Error Syndrome - A pair of adjacent bits for
                               each 64-bit section of data (and ECC).[br] 00=no
                               error in that logical chunk[br] 01=one error in
                               that logical chunk[br] 10=two errors in that
                               logical chunk[br] 11=three or more errors in
                               that logical chunk.[br] Bits [33:16] - Algorithm
                               Summary - A summary of the failing command
                               sequence ID for the cycle.[br] [2:0]
                               Offset_Command_Instruction_Current.[br] [5:3]
                               Offset_Address_Instruction_Current.[br] [10:6]
                               Command_Instruction_Current.[br] [13:11]
                               Algorithm_Instruction_Current.[br] [15:14]
                               Data_Instruction_Current.[br] [17:16]
                               Address_Instruction_Current.[br] Bits [71:18] -
                               Physical Address - A summary of the failing
                               command address for the cycle.[br] This Field is
                               formatted based on project specific CPGC
                               instance parameters and product documentation
                               should be referenced for actual bit to field
                               locations (not all bits will be used).[br] Mode
                               5: These registers contain the Nibble status for
                               Even UI (SummaryA) and Odd UI (SummaryB). It is
                               a logical layout, so 2UI is captured for each in
                               x32, and 4UI is captured for each in x16 (see
                               RASTER_REPO_CONTENT for Mode5). Think of these
                               bits as OR of each nibble worth of bits in
                               RASTER_REPO_CONTENT[1:0]. See HAS for layout in
                               each bus width.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_ERR_SUMMARY_A_MCCPGC_MAIN_STRUCT;

/* CPGC2_ERR_SUMMARY_B_MCCPGC_MAIN_REG supported on:                            */
/*      SPRA0 (0x2000917c)                                                      */
/*      SPRB0 (0x2000917c)                                                      */
/*      SPRHBM (0x2000917c)                                                     */
/*      SPRC0 (0x2000917c)                                                      */
/*      SPRMCC (0x2000917c)                                                     */
/*      SPRUCC (0x2000917c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Most recent error summary data, not yet written to the Raster Repository.
*/


#define CPGC2_ERR_SUMMARY_B_MCCPGC_MAIN_REG 0x2802917C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 error_summary : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Error_Summary -[br] Continuation of Error
                               Summary A.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_ERR_SUMMARY_B_MCCPGC_MAIN_STRUCT;

/* CPGC2_ERR_SUMMARY_C_MCCPGC_MAIN_REG supported on:                            */
/*      SPRA0 (0x20009180)                                                      */
/*      SPRB0 (0x20009180)                                                      */
/*      SPRHBM (0x20009180)                                                     */
/*      SPRC0 (0x20009180)                                                      */
/*      SPRMCC (0x20009180)                                                     */
/*      SPRUCC (0x20009180)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Most recent error summary data, not yet written to the Raster Repository.
*/


#define CPGC2_ERR_SUMMARY_C_MCCPGC_MAIN_REG 0x28029180

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 error_summary : 16;

                            /* Bits[15:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Error_Summary -[br] Continuation of Error
                               Summary A and B.
                            */
    UINT32 rsvd : 16;

                            /* Bits[31:16], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC2_ERR_SUMMARY_C_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_MODE3_MAX_MCCPGC_MAIN_REG supported on:                         */
/*      SPRA0 (0x20009184)                                                      */
/*      SPRB0 (0x20009184)                                                      */
/*      SPRHBM (0x20009184)                                                     */
/*      SPRC0 (0x20009184)                                                      */
/*      SPRMCC (0x20009184)                                                     */
/*      SPRUCC (0x20009184)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Raster repository Mode 3 max limit per Bank.[br]
The format of the contents of the register changes based on the number of Banks as set in the CPGC2_RASTER_REPO_CONFIG.MODE3_BANKS.
*/


#define CPGC2_RASTER_MODE3_MAX_MCCPGC_MAIN_REG 0x28029184

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 fail_max : 32;

                            /* Bits[31:0], Access Type=RW/P, default=0xFFFFFFFF*/

                            /*
                               Maximum number of failing address before an
                               additional failing address will set fail_excess
                               for the respective Bank.[br] Values in 8-Bank
                               mode:[br] 0000 = 0 Failures can be repaired for
                               this Bank, any Row error will trigger an Excess
                               flag.[br] 0001 = 1 Failures can be repaired.[br]
                               0010 = 2 Failures can be repaired.[br] 0011 = 3
                               Failures can be repaired.[br] 0100 = 4 Failures
                               can be repaired.[br] Other values are assumed to
                               be the same as 0100 due to hardware
                               limitations.[br] Values in 16-Bank mode:[br] 00
                               = 0 Failures can be repaired for this Bank, any
                               Row error will trigger an Excess flag.[br] 01 =
                               1 Failures can be repaired.[br] 10 = 2 Failures
                               can be repaired.[br] Other values are assumed to
                               be the same as 10 due to hardware
                               limitations.[br] Values in 32-Bank mode:[br] 0 =
                               0 Failures can be repaired for this Bank, any
                               Row error will trigger an Excess flag.[br] 1 = 1
                               Failures can be repaired.
                            */

  } Bits;
  UINT32 Data;

} CPGC2_RASTER_MODE3_MAX_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_CONFIG_MCCPGC_MAIN_REG supported on:                       */
/*      SPRA0 (0x10009188)                                                      */
/*      SPRB0 (0x10009188)                                                      */
/*      SPRHBM (0x10009188)                                                     */
/*      SPRC0 (0x10009188)                                                      */
/*      SPRMCC (0x10009188)                                                     */
/*      SPRUCC (0x10009188)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Raster repository control and configuration.
*/


#define CPGC2_RASTER_REPO_CONFIG_MCCPGC_MAIN_REG 0x28019188

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT16 rsvd : 2;

                            /* Bits[1:0], Access Type=RO, default=None*/

                            /* Reserved */
    UINT16 mode3_banks : 2;

                            /* Bits[3:2], Access Type=RW/P, default=0x00000000*/

                            /*
                               If Raster Mode 3, this field sets the number of
                               Banks checked/stored for this Channel.[br] 2b00
                               - 8-Banks (up to 4 Row addresses stored per
                               Bank).[br] 2b01 - 16-Banks (up to 2 Row
                               addresses stored per Bank).[br] 2b10 - 32-Banks
                               (up to 1 Row addresses stored per Bank).[br]
                               2b11 - Rsvd.[br] If set to a value less than the
                               actual number of banks of the memory, then
                               addresses not within the selected banks (via
                               MODE3_BANKS and UPPER_BANKS) are effectively
                               masked in regards to Mode 3 logging.[br] By
                               testing and repairing in sections (multiple
                               passes), more repairs can be done when the
                               Raster Repository is not sufficient to cover all
                               banks for all available repairs.
                            */
    UINT16 upper_banks : 2;

                            /* Bits[5:4], Access Type=RW/P, default=0x00000000*/

                            /*
                               In Raster Mode 3, this field sets the base Bank
                               that is stored. Since the Bank field is not
                               actually stored, this provides a way to
                               interpret the locations within the
                               CPGC2_RASTER_REPO_CONTENT when in Mode 3.[br]
                               8-Banks Mode | 16-Bank Mode | 32-Banks Mode[br]
                               2b00 - Bank 0-7 | Bank 0-15 | Bank 0-31[br] 2b01
                               - Bank 8-15 | Invalid | Invalid[br] 2b10 - Bank
                               16-23 | Bank 16-31 | Invalid[br] 2b11 - Bank
                               24-31 | Invalid | Invalid[br] Invalid settings
                               default to Bank 0 and up.[br] Errors in Banks
                               not covered by MODE3_BANKS and UPPER_BANKS are
                               not stored for Mode 3.
                            */
    UINT16 stoponraster : 1;

                            /* Bits[6:6], Access Type=RW/P, default=0x00000000*/

                            /*
                               The test will stop after status condition is met
                               in the raster repo.[br] 0 - No auto stop due to
                               Raster.[br] 1 - Auto stop due to Raster.[br]
                               Mode1: BitmapValid[br] Mode2: RasterRepoFull[br]
                               Mode3: FailExcessAll
                            */
    UINT16 rasterrepoclear : 1;

                            /* Bits[7:7], Access Type=RW/V, default=0x00000000*/

                            /*
                               Reset the raster repo entries. This bit auto-
                               clears.
                            */
    UINT16 rasterrepomode : 3;

                            /* Bits[10:8], Access Type=RW/P, default=0x00000000*/

                            /*
                               000 Inactive[br] 001 Mode 1 BitMap Mode.[br] 010
                               Mode 2 Summary Mode.[br] 011 Mode 3 Filtered
                               Failed Row Mode.[br] 101 Mode 5 Accumulated
                               BitMap Mode (2-UI/4-UI status).
                            */
    UINT16 rsvd_11 : 5;

                            /* Bits[15:11], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT16 Data;

} CPGC2_RASTER_REPO_CONFIG_MCCPGC_MAIN_STRUCT;

/* CPGC2_RASTER_REPO_STATUS_MCCPGC_MAIN_REG supported on:                       */
/*      SPRA0 (0x918c)                                                          */
/*      SPRB0 (0x918c)                                                          */
/*      SPRHBM (0x918c)                                                         */
/*      SPRC0 (0x918c)                                                          */
/*      SPRMCC (0x918c)                                                         */
/*      SPRUCC (0x918c)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Raster repository status.
*/


#define CPGC2_RASTER_REPO_STATUS_MCCPGC_MAIN_REG 0x2800918C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 bitmapvalid : 1;

                            /* Bits[0:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Indicates when Mode 1 erroneous bitmap data is
                               loaded in the raster repo.
                            */
    UINT8 summaryvalid : 1;

                            /* Bits[1:1], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Indicates when the summary information of the
                               erroneous bitmap is loaded in the current
                               summary buffer. This information consists of
                               Algorithmic data, Physical Addr (Rank, Bank,
                               Row, Col) and 8 2-bit error summary for every
                               chunk.
                            */
    UINT8 failexcessall : 1;

                            /* Bits[2:2], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               0 - indicates less than max_fail failing
                               addresses on all banks, 1 - indicates that at
                               least one bank had more than the max_fail
                               setting.
                            */
    UINT8 failanyall : 1;

                            /* Bits[3:3], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               0 - indicates no failing address, 1 - indicates
                               1 or more failing address
                            */
    UINT8 numerrlogged : 3;

                            /* Bits[6:4], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Indicates the current number of errors loaded in
                               the raster repo in Mode 2. Max value is 8.[br] 0
                               = none or 8 summary entries loaded. See Full to
                               determine which.
                            */
    UINT8 rasterrepofull : 1;

                            /* Bits[7:7], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Indicates when the number of summary entries
                               logged has hit the max value of 8. A
                               Stop_On_Raster_Full can be issued if enabled.
                            */

  } Bits;
  UINT8 Data;

} CPGC2_RASTER_REPO_STATUS_MCCPGC_MAIN_STRUCT;

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* CPGC_DPAT_CFG_MCCPGC_MAIN_REG supported on:                                  */
/*      SPRA0 (0x20009190)                                                      */
/*      SPRB0 (0x20009190)                                                      */
/*      SPRC0 (0x20009190)                                                      */
/*      SPRMCC (0x20009190)                                                     */
/*      SPRUCC (0x20009190)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Unisequencer Mode, PRBS Save/Reload and Data Pattern Configuration.
*/


#define CPGC_DPAT_CFG_MCCPGC_MAIN_REG 0x28029190

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lane_rotate_rate : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               Separate Write and Read rotation pointers are
                               maintained for Write data generation and Check
                               data generation.[br] Rotate the 8 lanes of each
                               bytelane up in lane every 2^(Lane_Rotate_Rate-1)
                               Cache Line Reads (or Writes).[br] Examples:[br]
                               0 = Disable - No rotation.[br] 1 = Causes the
                               effect of rotating EXTBUF registers following
                               every Cache Line access.[br] 2 = Causes the
                               effect of rotating EXTBUF registers following
                               every other Cache Line access.[br] 3 = Causes
                               the effect of rotating EXTBUF registers
                               following each fourth Cache Line access.[br]
                               When the EXTBUF registers are (virtually)
                               rotated EXTBUF[0] shifts to EXTBUF[1] all the
                               way up to EXTBUF[7] then back to EXTBUF[0].[br]
                               When the EXTBUF registers are (virtually)
                               rotated EXTBUF[8] shifts to EXTBUF[9] all the
                               way up to EXTBUF[15] then back to EXTBUF[8].
                            */
    UINT32 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 write_address_as_data : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When Write_Address_as_Data is set to '1' the
                               functional address fields are used for
                               generating the write data.[br] Data Construction
                               rules follow the same as for
                               READ_ADDRESS_AS_DATA.
                            */
    UINT32 read_address_as_data : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               When Read_Address_as_Data is set to '1' the
                               functional address fields are used for comparing
                               the incoming data.[br] This override of the
                               reference data will not respect any inversion,
                               rotation or other data modification. This
                               override of the data will only be active
                               (override the normal output/reference) when
                               Alternate_Data is active in either the
                               Command_Instruction or the
                               Offset_Command_Instruction as appropriate.[br]
                               The functional path decoded address field used
                               for read comparison is repeated in chunk and
                               should follow the Data Construction rules
                               described below on what bytegroup relates to
                               what decoded address (assuming 64-DQ lanes):[br]
                               Chunk0 - Byte0 =Column(7:0)[br] Chunk0 - Byte1
                               =Column(9:8) <- as many Column bits as
                               supported[br] Chunk0 - Byte2 =Row(0:7)[br]
                               Chunk0 - Byte3 =Row(15:8)[br] Chunk0 - Byte4
                               =Row(17:16)<- as many Row bits as supported[br]
                               Chunk0 - Byte5 =Bank(3:0) [Note: Bank Group may
                               be part of this field] <- as many Bank bits as
                               supported[br] Chunk0 - Byte6 = Rank(1:0) <- as
                               many Rank bits as supported (would be CS# if
                               CADB output supported)[br] Chunk0 - Byte7
                               =reserved (set to 0)[br] [br] When the memory
                               interface has 32 or 16 DQ lanes, the data is
                               further 'folded' into subsequent UI(s) (Chunks).
                               All bits are actually inverted. This format is
                               subject to change based on memory technology
                               supported and other reasons and the main HAS
                               documentation should be referenced if required.
                               What is to be guaranteed is that every Cache
                               Line of data will be unique to each address.
                            */
    UINT32 rsvd_10 : 3;

                            /* Bits[12:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ecc_disable : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will internally disable all
                               related ECC features in CPGC having the effect
                               of generating all '0 in the ECC CPGC interface
                               outputs, and of binding to '0 all the ECC
                               interface CPGC inputs. Also masks any error
                               comparisons on ECC lanes.[br] When ECC is
                               disabled with this bit, then the BE outputs of
                               CPGC may be controlled. If provisioned with the
                               CPGC_MI_BE_EN parameter, their behavior will be
                               determined based on BE_TRAIN_ERR_EN and may
                               output all 1's or the content of the DRAMDM and
                               XDRAMDM registers as Byte-Enables, or 0 for
                               Flush and MWrPCmt transactions.
                            */
    UINT32 ecc_replace_byte_control : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will replace the ECC byte with
                               a selected Data byte, when ECC is not disabled.
                               When it's not set, it follows BYTEGROUP_MAPPING
                               setting or ALT_DATA.
                            */
    UINT32 ecc_data_source_sel : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               When ECC is not disabled and
                               ECC_REPLACE_BYTE_CONTROL is 1, this bit will
                               indicate which Data Byte is used to replace the
                               ECC Byte. [br] 0 - Byte 0 used to replace ECC
                               byte [source lanes starting at lane 0][br] 1 -
                               Byte 7 (64 DQ) [source lanes starting at lane
                               56] OR[br] Byte 3 (32 DQ) [source lanes starting
                               at lane 24] OR [br] Byte 1 (16 DQ) [source lanes
                               starting at lane 14]
                            */
    UINT32 save_lfsr_seed_rate : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /*
                               Sets the number of Reloads counted before the
                               CPGC_DPAT_UNISEQ_RD(WR)STAT is saved into
                               CPGC_DPAT_UNISEQ_RD(WR)SAVE.[br] See
                               Reload_LFSR_Seed_Rate for use model.[br]
                               CPGC_DPAT_UNISEQ_RD(WR)SAVE is initially loaded
                               at the start of a test with the Seed from
                               CPGC_DPAT_UNISEQ.PATTERN_BUFFER. [br] The
                               current LFSR state is saved into
                               CPGC_DPAT_UNISEQ_RDSAVE every
                               2^(Reload_LFSR_Seed_Rate-1) *
                               (Save_LFSR_Seed_Rate) Cache Lines worth of Reads
                               (Writes).[br] When the Save_LFSR_Seed_Rate and
                               Reload_LFSR_Seed_Rate is reached following the
                               same Read (Write), only the saving of the LFSR
                               seed takes place.[br] Examples:[br] 0 = Disable
                               - The current LFSR seed is saved only at the
                               start of the test into
                               CPGC_DPAT_UNISEQ_RD(WR)SAVE.[br] 1 = Save every
                               Reload (Effectively disables Reload).[br] 2 =
                               The current LFSR seed is saved every other
                               Reload (2^(Reload_LFSR_Seed_Rate) Cache
                               Lines).[br] 3 = The current LFSR seed is saved
                               every third Reload.
                            */
    UINT32 reload_lfsr_seed_rate : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000000*/

                            /*
                               The current LFSR state
                               CPGC_DPAT_UNISEQ_RD(WR)STAT is reloaded from
                               CPGC_DPAT_UNISEQ_RD(WR)SAVE every[br]
                               2^(Reload_LFSR_Seed_Rate-1) Cache Lines worth of
                               Reads (Writes).[br] When the Save_LFSR_Seed_Rate
                               and Reload_LFSR_Seed_Rate is reached in the same
                               transaction, only the saving of the LFSR seed
                               takes place. A Save Rate of 1 will override this
                               and effectively disable reloads.[br]
                               Examples:[br] 0=Disable - The current LFSR seed
                               is never reloaded. Also disables Saves.[br] 1=
                               The current LFSR seed is reloaded every Cache
                               Line.[br] 2=The current LFSR seed is reloaded
                               every other Cache Line.[br] 3=The current LFSR
                               seed is reloaded every fourth Cache Line.[br]
                               [br] Reload_LFSR_Seed_Rate and
                               Save_LFSR_Seed_Rate are most often used in
                               conjunction with Lane_Rotate_Rate where the user
                               desires to replay the same deterministic LFSR
                               stress as the victim aggressor patterns shifts
                               Lanes left. When the victim aggressor pattern
                               returns to the starting position the current
                               LFSR stress is saved using Save_LFSR_Seed_Rate
                               to allow the LFSR stress to advance for the new
                               period.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_CFG_MCCPGC_MAIN_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#ifdef SPRHBM_HOST
/* CPGC_DPAT_MCCPGC_MAIN_REG supported on:                                      */
/*      SPRHBM (0x20009190)                                                     */
/* Register default value on SPRHBM: 0x00000000                                 */
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRHBM BDF: 0_0_0                                      */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* Unisequencer Mode, PRBS Save/Reload and Data Pattern Configuration.
*/


#define CPGC_DPAT_MCCPGC_MAIN_REG 0x28029190

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lane_rotate_rate : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               Separate Write and Read rotation pointers are
                               maintained for Write data generation and Check
                               data generation.[br] Rotate the 8 lanes of each
                               bytelane up in lane every 2^(Lane_Rotate_Rate-1)
                               Cache Line Reads (or Writes).[br] Examples:[br]
                               0 = Disable - No rotation.[br] 1 = Causes the
                               effect of rotating EXTBUF registers following
                               every Cache Line access.[br] 2 = Causes the
                               effect of rotating EXTBUF registers following
                               every other Cache Line access.[br] 3 = Causes
                               the effect of rotating EXTBUF registers
                               following each fourth Cache Line access.[br]
                               When the EXTBUF registers are (virtually)
                               rotated EXTBUF[0] shifts to EXTBUF[1] all the
                               way up to EXTBUF[7] then back to EXTBUF[0].[br]
                               When the EXTBUF registers are (virtually)
                               rotated EXTBUF[8] shifts to EXTBUF[9] all the
                               way up to EXTBUF[15] then back to EXTBUF[8].
                            */
    UINT32 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 write_address_as_data : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000000*/

                            /*
                               When Write_Address_as_Data is set to '1' the
                               functional address fields are used for
                               generating the write data.[br] Data Construction
                               rules follow the same as for
                               READ_ADDRESS_AS_DATA.
                            */
    UINT32 read_address_as_data : 1;

                            /* Bits[9:9], Access Type=RW, default=0x00000000*/

                            /*
                               When Read_Address_as_Data is set to '1' the
                               functional address fields are used for comparing
                               the incoming data.[br] This override of the
                               reference data will not respect any inversion,
                               rotation or other data modification. This
                               override of the data will only be active
                               (override the normal output/reference) when
                               Alternate_Data is active in either the
                               Command_Instruction or the
                               Offset_Command_Instruction as appropriate.[br]
                               The functional path decoded address field used
                               for read comparison is repeated in chunk and
                               should follow the Data Construction rules
                               described below on what bytegroup relates to
                               what decoded address (assuming 64-DQ lanes):[br]
                               Chunk0 - Byte0 =Column(7:0)[br] Chunk0 - Byte1
                               =Column(9:8) <- as many Column bits as
                               supported[br] Chunk0 - Byte2 =Row(0:7)[br]
                               Chunk0 - Byte3 =Row(15:8)[br] Chunk0 - Byte4
                               =Row(17:16)<- as many Row bits as supported[br]
                               Chunk0 - Byte5 =Bank(3:0) [Note: Bank Group may
                               be part of this field] <- as many Bank bits as
                               supported[br] Chunk0 - Byte6 = Rank(1:0) <- as
                               many Rank bits as supported (would be CS# if
                               CADB output supported)[br] Chunk0 - Byte7
                               =reserved (set to 0)[br] [br] When the memory
                               interface has 32 or 16 DQ lanes, the data is
                               further 'folded' into subsequent UI(s) (Chunks).
                               All bits are actually inverted. This format is
                               subject to change based on memory technology
                               supported and other reasons and the main HAS
                               documentation should be referenced if required.
                               What is to be guaranteed is that every Cache
                               Line of data will be unique to each address.
                            */
    UINT32 rsvd_10 : 3;

                            /* Bits[12:10], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 ecc_disable : 1;

                            /* Bits[13:13], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will internally disable all
                               related ECC features in CPGC having the effect
                               of generating all '0 in the ECC CPGC interface
                               outputs, and of binding to '0 all the ECC
                               interface CPGC inputs. Also masks any error
                               comparisons on ECC lanes.[br] When ECC is
                               disabled with this bit, then the BE outputs of
                               CPGC may be controlled. If provisioned with the
                               CPGC_MI_BE_EN parameter, their behavior will be
                               determined based on BE_TRAIN_ERR_EN and may
                               output all 1's or the content of the DRAMDM and
                               XDRAMDM registers as Byte-Enables, or 0 for
                               Flush and MWrPCmt transactions.
                            */
    UINT32 ecc_replace_byte_control : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               Setting this bit will replace the ECC byte with
                               a selected Data byte, when ECC is not disabled.
                               When it's not set, it follows BYTEGROUP_MAPPING
                               setting or ALT_DATA.
                            */
    UINT32 ecc_data_source_sel : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               When ECC is not disabled and
                               ECC_REPLACE_BYTE_CONTROL is 1, this bit will
                               indicate which Data Byte is used to replace the
                               ECC Byte. [br] 0 - Byte 0 used to replace ECC
                               byte [source lanes starting at lane 0][br] 1 -
                               Byte 7 (64 DQ) [source lanes starting at lane
                               56] OR[br] Byte 3 (32 DQ) [source lanes starting
                               at lane 24] OR [br] Byte 1 (16 DQ) [source lanes
                               starting at lane 14]
                            */
    UINT32 save_lfsr_seed_rate : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /*
                               Sets the number of Reloads counted before the
                               CPGC_DPAT_UNISEQ_RD(WR)STAT is saved into
                               CPGC_DPAT_UNISEQ_RD(WR)SAVE.[br] See
                               Reload_LFSR_Seed_Rate for use model.[br]
                               CPGC_DPAT_UNISEQ_RD(WR)SAVE is initially loaded
                               at the start of a test with the Seed from
                               CPGC_DPAT_UNISEQ.PATTERN_BUFFER. [br] The
                               current LFSR state is saved into
                               CPGC_DPAT_UNISEQ_RDSAVE every
                               2^(Reload_LFSR_Seed_Rate-1) *
                               (Save_LFSR_Seed_Rate) Cache Lines worth of Reads
                               (Writes).[br] When the Save_LFSR_Seed_Rate and
                               Reload_LFSR_Seed_Rate is reached following the
                               same Read (Write), only the saving of the LFSR
                               seed takes place.[br] Examples:[br] 0 = Disable
                               - The current LFSR seed is saved only at the
                               start of the test into
                               CPGC_DPAT_UNISEQ_RD(WR)SAVE.[br] 1 = Save every
                               Reload (Effectively disables Reload).[br] 2 =
                               The current LFSR seed is saved every other
                               Reload (2^(Reload_LFSR_Seed_Rate) Cache
                               Lines).[br] 3 = The current LFSR seed is saved
                               every third Reload.
                            */
    UINT32 reload_lfsr_seed_rate : 5;

                            /* Bits[28:24], Access Type=RW, default=0x00000000*/

                            /*
                               The current LFSR state
                               CPGC_DPAT_UNISEQ_RD(WR)STAT is reloaded from
                               CPGC_DPAT_UNISEQ_RD(WR)SAVE every[br]
                               2^(Reload_LFSR_Seed_Rate-1) Cache Lines worth of
                               Reads (Writes).[br] When the Save_LFSR_Seed_Rate
                               and Reload_LFSR_Seed_Rate is reached in the same
                               transaction, only the saving of the LFSR seed
                               takes place. A Save Rate of 1 will override this
                               and effectively disable reloads.[br]
                               Examples:[br] 0=Disable - The current LFSR seed
                               is never reloaded. Also disables Saves.[br] 1=
                               The current LFSR seed is reloaded every Cache
                               Line.[br] 2=The current LFSR seed is reloaded
                               every other Cache Line.[br] 3=The current LFSR
                               seed is reloaded every fourth Cache Line.[br]
                               [br] Reload_LFSR_Seed_Rate and
                               Save_LFSR_Seed_Rate are most often used in
                               conjunction with Lane_Rotate_Rate where the user
                               desires to replay the same deterministic LFSR
                               stress as the victim aggressor patterns shifts
                               Lanes left. When the victim aggressor pattern
                               returns to the starting position the current
                               LFSR stress is saved using Save_LFSR_Seed_Rate
                               to allow the LFSR stress to advance for the new
                               period.
                            */
    UINT32 rsvd_29 : 3;

                            /* Bits[31:29], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_MCCPGC_MAIN_STRUCT;
#endif /* (SPRHBM_HOST) */

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* CPGC_DPAT_INVDC_CFG_MCCPGC_MAIN_REG supported on:                            */
/*      SPRA0 (0x20009194)                                                      */
/*      SPRB0 (0x20009194)                                                      */
/*      SPRC0 (0x20009194)                                                      */
/*      SPRMCC (0x20009194)                                                     */
/*      SPRUCC (0x20009194)                                                     */
/* Register default value on SPRA0: 0x00AA0000                                  */
/* Register default value on SPRB0: 0x00AA0000                                  */
/* Register default value on SPRC0: 0x00AA0000                                  */
/* Register default value on SPRMCC: 0x00AA0000                                 */
/* Register default value on SPRUCC: 0x00AA0000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Data Pattern Inversion/DC Control.
*/


#define CPGC_DPAT_INVDC_CFG_MCCPGC_MAIN_REG 0x28029194

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecc_inv_dc_mask : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               A value of 1 for any of the bits means the
                               corresponding ECC lane will be inverted or a DC
                               value driven on it. Note that this field is used
                               to load bits [71:64] of the continuous shift
                               register composed of this field along with
                               DATA_INV_DC_MASK_HI and DATA_INV_DC_MASK_LO.
                               Note: this field is only available if ECC is
                               provisioned for the current implementation,
                               otherwise it is reserved.
                            */
    UINT32 mask_rotate_rate : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000000*/

                            /*
                               If inversion mask rotation is enabled through
                               MASK_ROTATE_EN, the mask will rotate to the left
                               every time 2^MASK_ROTATE_RATE bursts (64Bytes)
                               have been have been issued.
                            */
    UINT32 rsvd : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 bytegroup_mapping : 9;

                            /* Bits[24:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Select between the two bytes of unique lanes
                               being generated by the DPAT pattern generator,
                               to be applied in each DQ byte group, as many
                               byte groups as required by the number of DQ
                               pins. MSB is always for the ECC byte group, used
                               only if ECC is present.
                            */
    UINT32 rsvd_25 : 4;

                            /* Bits[28:25], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dc_pol : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Selects the polarity of the signal to be driven
                               through the inversion/DC mask if DC_OR_INV is
                               set to 1:[br] 0 - Drive a logic low (zero).[br]
                               1 - Drive a logic high (one).
                            */
    UINT32 dc_or_inv : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Selects between using the inversion/DC mask for
                               inversion or DC as follows:[br] 0 - Mask used
                               for inversion.[br] 1 - Mask used for driving a
                               DC signal of polarity DC_POL.
                            */
    UINT32 mask_rotate_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the inversion/DC mask will rotate to the
                               left at a rate defined by the MASK_ROTATE_RATE
                               field.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_INVDC_CFG_MCCPGC_MAIN_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#ifdef SPRHBM_HOST
/* CPGC_DPAT_INVDC_MCCPGC_MAIN_REG supported on:                                */
/*      SPRHBM (0x20009194)                                                     */
/* Register default value on SPRHBM: 0x00AA0000                                 */
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRHBM BDF: 0_0_0                                      */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* Data Pattern Inversion/DC Control.
*/


#define CPGC_DPAT_INVDC_MCCPGC_MAIN_REG 0x28029194

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecc_inv_dc_mask : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               A value of 1 for any of the bits means the
                               corresponding ECC lane will be inverted or a DC
                               value driven on it. Note that this field is used
                               to load bits [71:64] of the continuous shift
                               register composed of this field along with
                               DATA_INV_DC_MASK_HI and DATA_INV_DC_MASK_LO.
                               Note: this field is only available if ECC is
                               provisioned for the current implementation,
                               otherwise it is reserved.
                            */
    UINT32 mask_rotate_rate : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000000*/

                            /*
                               If inversion mask rotation is enabled through
                               MASK_ROTATE_EN, the mask will rotate to the left
                               every time 2^MASK_ROTATE_RATE bursts (64Bytes)
                               have been have been issued.
                            */
    UINT32 rsvd : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 bytegroup_mapping : 9;

                            /* Bits[24:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Select between the two bytes of unique lanes
                               being generated by the DPAT pattern generator,
                               to be applied in each DQ byte group, as many
                               byte groups as required by the number of DQ
                               pins. MSB is always for the ECC byte group, used
                               only if ECC is present.
                            */
    UINT32 rsvd_25 : 4;

                            /* Bits[28:25], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 dc_pol : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Selects the polarity of the signal to be driven
                               through the inversion/DC mask if DC_OR_INV is
                               set to 1:[br] 0 - Drive a logic low (zero).[br]
                               1 - Drive a logic high (one).
                            */
    UINT32 dc_or_inv : 1;

                            /* Bits[30:30], Access Type=RW, default=0x00000000*/

                            /*
                               Selects between using the inversion/DC mask for
                               inversion or DC as follows:[br] 0 - Mask used
                               for inversion.[br] 1 - Mask used for driving a
                               DC signal of polarity DC_POL.
                            */
    UINT32 mask_rotate_en : 1;

                            /* Bits[31:31], Access Type=RW, default=0x00000000*/

                            /*
                               If set, the inversion/DC mask will rotate to the
                               left at a rate defined by the MASK_ROTATE_RATE
                               field.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_INVDC_MCCPGC_MAIN_STRUCT;
#endif /* (SPRHBM_HOST) */

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* CPGC_DPAT_BUF_CFG_MCCPGC_MAIN_REG supported on:                              */
/*      SPRA0 (0x20009198)                                                      */
/*      SPRB0 (0x20009198)                                                      */
/*      SPRC0 (0x20009198)                                                      */
/*      SPRMCC (0x20009198)                                                     */
/*      SPRUCC (0x20009198)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Data Pattern Buffer Control.
*/


#define CPGC_DPAT_BUF_CFG_MCCPGC_MAIN_REG 0x28029198

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 buf_pntr_inc_rate : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               Number of triggers as set by BUF_PNTR_INC_SCALE
                               before advancing.[br] Expo values only use
                               BUF_PNTR_INC_RATE[2:0] with a maximum value of
                               3b111 (7) or 128 counts.[br] Note: To disable
                               Buffer Pointer increments, set
                               BUF_END_PNTR==BUF_STRT_PNTR.
                            */
    UINT32 buf_pntr_inc_scale : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Sets the buffer pointer advancement rate as set
                               in BUF_PNTR_INC_RATE.[br] 0=Buffer Pointer
                               Increment Rate field is treated is an
                               exponential number of Cache Lines (64Bytes)
                               (0=1, 1=2, 2=4, etc).[br] 1=Buffer Pointer
                               Increment Rate field is treated as a linear
                               number of 8-UI (0=8UI, 1=16UI etc).
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 buf_strt_pntr : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000000*/

                            /*
                               Pointer to initial data pattern buffer Line.[br]
                               The actual size of this field depends on the
                               total # of buffers (CPGC_DPAT_EXTBUF_SIZE) in
                               the CPGC Instance. They are organized in groups
                               of 4 Lines of 16 Lanes each. Each channel
                               addresses based on the BUF_PNTR value, with the
                               Channel number, multiplied by
                               CPGC_DPAT_EXTBUF_SIZE/CPGC_NUM_CHANNELS, added
                               to the value. The BUF_PNTR value wraps at
                               CPGC_DPAT_EXTBUF_SIZE. A value of 0 selects this
                               Channel's first Line.[br] RD_BUF_PNTR,
                               WR_BUF_PNTR are reset to BUF_STRT_PNTR and the
                               internal advance counters are reset on start of
                               a new Data Instruction.
                            */
    UINT32 rsvd_12 : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 buf_end_pntr : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000000*/

                            /*
                               Pointer to last data pattern buffer Line before
                               wrapping back to BUF_STRT_PNTR if incrementing
                               is enabled through being different from
                               BUF_STRT_PNTR. The actual size of this field
                               matches BUF_STRT_PNTR.
                            */
    UINT32 rsvd_20 : 4;

                            /* Bits[23:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 wr_buf_ptr : 4;

                            /* Bits[27:24], Access Type=RO/V, default=0x00000000*/

                            /*
                               Pointer to current Line in the data pattern
                               buffers used for generating the write data.
                            */
    UINT32 rd_buf_ptr : 4;

                            /* Bits[31:28], Access Type=RO/V, default=0x00000000*/

                            /*
                               Pointer to current Line in the data pattern
                               buffers used for generating the read data.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_BUF_CFG_MCCPGC_MAIN_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#ifdef SPRHBM_HOST
/* CPGC_DPAT_BUF_MCCPGC_MAIN_REG supported on:                                  */
/*      SPRHBM (0x20009198)                                                     */
/* Register default value on SPRHBM: 0x00000000                                 */
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRHBM BDF: 0_0_0                                      */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* Data Pattern Buffer Control.
*/


#define CPGC_DPAT_BUF_MCCPGC_MAIN_REG 0x28029198

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 buf_pntr_inc_rate : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               Number of triggers as set by BUF_PNTR_INC_SCALE
                               before advancing.[br] Expo values only use
                               BUF_PNTR_INC_RATE[2:0] with a maximum value of
                               3b111 (7) or 128 counts.[br] Note: To disable
                               Buffer Pointer increments, set
                               BUF_END_PNTR==BUF_STRT_PNTR.
                            */
    UINT32 buf_pntr_inc_scale : 1;

                            /* Bits[6:6], Access Type=RW, default=0x00000000*/

                            /*
                               Sets the buffer pointer advancement rate as set
                               in BUF_PNTR_INC_RATE.[br] 0=Buffer Pointer
                               Increment Rate field is treated is an
                               exponential number of Cache Lines (64Bytes)
                               (0=1, 1=2, 2=4, etc).[br] 1=Buffer Pointer
                               Increment Rate field is treated as a linear
                               number of 8-UI (0=8UI, 1=16UI etc).
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 buf_strt_pntr : 4;

                            /* Bits[11:8], Access Type=RW, default=0x00000000*/

                            /*
                               Pointer to initial data pattern buffer Line.[br]
                               The actual size of this field depends on the
                               total # of buffers (CPGC_DPAT_EXTBUF_SIZE) in
                               the CPGC Instance. They are organized in groups
                               of 4 Lines of 16 Lanes each. Each channel
                               addresses based on the BUF_PNTR value, with the
                               Channel number, multiplied by
                               CPGC_DPAT_EXTBUF_SIZE/CPGC_NUM_CHANNELS, added
                               to the value. The BUF_PNTR value wraps at
                               CPGC_DPAT_EXTBUF_SIZE. A value of 0 selects this
                               Channel's first Line.[br] RD_BUF_PNTR,
                               WR_BUF_PNTR are reset to BUF_STRT_PNTR and the
                               internal advance counters are reset on start of
                               a new Data Instruction.
                            */
    UINT32 rsvd_12 : 4;

                            /* Bits[15:12], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 buf_end_pntr : 4;

                            /* Bits[19:16], Access Type=RW, default=0x00000000*/

                            /*
                               Pointer to last data pattern buffer Line before
                               wrapping back to BUF_STRT_PNTR if incrementing
                               is enabled through being different from
                               BUF_STRT_PNTR. The actual size of this field
                               matches BUF_STRT_PNTR.
                            */
    UINT32 rsvd_20 : 4;

                            /* Bits[23:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 wr_buf_ptr : 4;

                            /* Bits[27:24], Access Type=RO/V, default=0x00000000*/

                            /*
                               Pointer to current Line in the data pattern
                               buffers used for generating the write data.
                            */
    UINT32 rd_buf_ptr : 4;

                            /* Bits[31:28], Access Type=RO/V, default=0x00000000*/

                            /*
                               Pointer to current Line in the data pattern
                               buffers used for generating the read data.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_BUF_MCCPGC_MAIN_STRUCT;
#endif /* (SPRHBM_HOST) */

#if defined(SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST)
/* CPGC_DPAT_ALT_BUF_CFG_MCCPGC_MAIN_REG supported on:                          */
/*      SPRA0 (0x2000919c)                                                      */
/*      SPRB0 (0x2000919c)                                                      */
/*      SPRC0 (0x2000919c)                                                      */
/*      SPRMCC (0x2000919c)                                                     */
/*      SPRUCC (0x2000919c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Alternate Data Pattern Buffer Control.
*/


#define CPGC_DPAT_ALT_BUF_CFG_MCCPGC_MAIN_REG 0x2802919C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 buf_pntr_inc_rate : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               Number of triggers as set by BUF_PNTR_INC_MODE
                               and BUF_PNTR_INC_SCALE before advancing.[br]
                               Expo values only use BUF_PNTR_INC_RATE[3:0] with
                               a maximum value of 4b1000 (8) or 256 counts.[br]
                               Linear and Expo ranges are identical and either
                               can be used for convenience.[br] Note: To
                               disable Buffer Pointer increments, set
                               BUF_END_PNTR==BUF_STRT_PNTR.
                            */
    UINT32 buf_strt_pntr : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000000*/

                            /*
                               Pointer to initial Zero Data Pattern buffer
                               Value.[br] The actual size of this field depends
                               on the total # of buffers
                               (CPGC_DPAT_EXTBUF_SIZE) in the CPGC Instance.
                               They are organized in groups of 8 Zero Data
                               Pattern Values of 64-bits each. The BUF_PNTR
                               value wraps at CPGC_DPAT_EXTBUF_SIZE*2. The
                               Channel number is not used to offset each
                               channel.[br] BUF_PNTR is reset to BUF_STRT_PNTR
                               and the internal advance counter is reset on
                               start of a new Data Instruction, except if
                               BUF_PNTR_INC_MODE is 2b10.
                            */
    UINT32 rsvd : 1;

                            /* Bits[13:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 buf_pntr_zro_shft : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               0=ZERO_DATA_EN will internally rotate every 64
                               Zero Data Rotations, unless a pointer update has
                               occurred to restart the process.[br]
                               1=ZERO_DATA_EN will internally rotate every
                               natural advance for 8 times, and then the PNTR
                               advance will actualy happen. This effectively
                               multiplies the Increment Rate by 8.[br] This
                               allows patterns such as a Lone1 bit (or Lone0
                               bit) to be shifted through the entire Cache
                               Line.
                            */
    UINT32 buf_pntr_inc_scale : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Sets the buffer pointer advancement rate as set
                               in BUF_PNTR_INC_RATE.[br] 0=Buffer Pointer
                               Increment Rate field is treated is an
                               exponential number of Cache Lines, Data Rotates,
                               or Data Instructions (0=1, 1=2, 2=4, etc).[br]
                               1=Buffer Pointer Increment Rate field is treated
                               as a linear number of 8-UI (0=8UI, 1=16UI etc),
                               Data Rotates, or Data Instructions (0=1, 1=2,
                               2=4, etc).
                            */
    UINT32 buf_end_pntr : 5;

                            /* Bits[20:16], Access Type=RW, default=0x00000000*/

                            /*
                               Pointer to last Zero Data Pattern buffer entry
                               before wrapping back to BUF_STRT_PNTR if
                               incrementing is enabled through being different
                               from BUF_STRT_PNTR. The actual size of this
                               field matches BUF_STRT_PNTR.
                            */
    UINT32 rsvd_21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 buf_pntr_inc_mode : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               00=Buffer Pointer Increment Rate field is
                               treated is an expo number of Cache Lines or
                               linear number of 8-UI.[br] 01=Buffer Pointer
                               Increment Rate field is treated as a linear or
                               expo number of Data Instruction Rotates to
                               execute before advancing.[br] 10=Buffer Pointer
                               Increment Rate field is treated as a linear or
                               expo number of Data Instructions to execute
                               before advancing.[br] 11=Reserved. Treated as if
                               set to 2b00.[br] The Pointer is returned to
                               BUF_STRT_PNTR at the start of each Data
                               Instruction as a Pointer Update unless
                               BUF_PNTR_INC_MODE==2b10.
                            */
    UINT32 zero_data_en : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit field indicating which 64-bit sections
                               within each Cache Line will contain the 64-bit
                               Zero Data Pattern as selected by the current
                               BUF_PNTR.[br] 0 - Pattern is set to 64'h0[br] 1
                               - Enable Pattern from EXTBUF[br] A value of 8h00
                               will result in the CPGC_DPAT_INV_DC_MASK being
                               used as in earlier spec revisions.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_ALT_BUF_CFG_MCCPGC_MAIN_STRUCT;
#endif /* (SPRA0_HOST) || defined(SPRB0_HOST) || defined(SPRC0_HOST) || defined(SPRMCC_HOST) || defined(SPRUCC_HOST) */

#ifdef SPRHBM_HOST
/* CPGC_DPAT_ALT_BUF_MCCPGC_MAIN_REG supported on:                              */
/*      SPRHBM (0x2000919c)                                                     */
/* Register default value on SPRHBM: 0x00000000                                 */
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRHBM BDF: 0_0_0                                      */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* Alternate Data Pattern Buffer Control.
*/


#define CPGC_DPAT_ALT_BUF_MCCPGC_MAIN_REG 0x2802919C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 buf_pntr_inc_rate : 8;

                            /* Bits[7:0], Access Type=RW, default=0x00000000*/

                            /*
                               Number of triggers as set by BUF_PNTR_INC_MODE
                               and BUF_PNTR_INC_SCALE before advancing.[br]
                               Expo values only use BUF_PNTR_INC_RATE[3:0] with
                               a maximum value of 4b1000 (8) or 256 counts.[br]
                               Linear and Expo ranges are identical and either
                               can be used for convenience.[br] Note: To
                               disable Buffer Pointer increments, set
                               BUF_END_PNTR==BUF_STRT_PNTR.
                            */
    UINT32 buf_strt_pntr : 5;

                            /* Bits[12:8], Access Type=RW, default=0x00000000*/

                            /*
                               Pointer to initial Zero Data Pattern buffer
                               Value.[br] The actual size of this field depends
                               on the total # of buffers
                               (CPGC_DPAT_EXTBUF_SIZE) in the CPGC Instance.
                               They are organized in groups of 8 Zero Data
                               Pattern Values of 64-bits each. The BUF_PNTR
                               value wraps at CPGC_DPAT_EXTBUF_SIZE*2. The
                               Channel number is not used to offset each
                               channel.[br] BUF_PNTR is reset to BUF_STRT_PNTR
                               and the internal advance counter is reset on
                               start of a new Data Instruction, except if
                               BUF_PNTR_INC_MODE is 2b10.
                            */
    UINT32 rsvd : 1;

                            /* Bits[13:13], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 buf_pntr_zro_shft : 1;

                            /* Bits[14:14], Access Type=RW, default=0x00000000*/

                            /*
                               0=ZERO_DATA_EN will internally rotate every 64
                               Zero Data Rotations, unless a pointer update has
                               occurred to restart the process.[br]
                               1=ZERO_DATA_EN will internally rotate every
                               natural advance for 8 times, and then the PNTR
                               advance will actualy happen. This effectively
                               multiplies the Increment Rate by 8.[br] This
                               allows patterns such as a Lone1 bit (or Lone0
                               bit) to be shifted through the entire Cache
                               Line.
                            */
    UINT32 buf_pntr_inc_scale : 1;

                            /* Bits[15:15], Access Type=RW, default=0x00000000*/

                            /*
                               Sets the buffer pointer advancement rate as set
                               in BUF_PNTR_INC_RATE.[br] 0=Buffer Pointer
                               Increment Rate field is treated is an
                               exponential number of Cache Lines, Data Rotates,
                               or Data Instructions (0=1, 1=2, 2=4, etc).[br]
                               1=Buffer Pointer Increment Rate field is treated
                               as a linear number of 8-UI (0=8UI, 1=16UI etc),
                               Data Rotates, or Data Instructions (0=1, 1=2,
                               2=4, etc).
                            */
    UINT32 buf_end_pntr : 5;

                            /* Bits[20:16], Access Type=RW, default=0x00000000*/

                            /*
                               Pointer to last Zero Data Pattern buffer entry
                               before wrapping back to BUF_STRT_PNTR if
                               incrementing is enabled through being different
                               from BUF_STRT_PNTR. The actual size of this
                               field matches BUF_STRT_PNTR.
                            */
    UINT32 rsvd_21 : 1;

                            /* Bits[21:21], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 buf_pntr_inc_mode : 2;

                            /* Bits[23:22], Access Type=RW, default=0x00000000*/

                            /*
                               00=Buffer Pointer Increment Rate field is
                               treated is an expo number of Cache Lines or
                               linear number of 8-UI.[br] 01=Buffer Pointer
                               Increment Rate field is treated as a linear or
                               expo number of Data Instruction Rotates to
                               execute before advancing.[br] 10=Buffer Pointer
                               Increment Rate field is treated as a linear or
                               expo number of Data Instructions to execute
                               before advancing.[br] 11=Reserved. Treated as if
                               set to 2b00.[br] The Pointer is returned to
                               BUF_STRT_PNTR at the start of each Data
                               Instruction as a Pointer Update unless
                               BUF_PNTR_INC_MODE==2b10.
                            */
    UINT32 zero_data_en : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000000*/

                            /*
                               Bit field indicating which 64-bit sections
                               within each Cache Line will contain the 64-bit
                               Zero Data Pattern as selected by the current
                               BUF_PNTR.[br] 0 - Pattern is set to 64'h0[br] 1
                               - Enable Pattern from EXTBUF[br] A value of 8h00
                               will result in the CPGC_DPAT_INV_DC_MASK being
                               used as in earlier spec revisions.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_ALT_BUF_MCCPGC_MAIN_STRUCT;
#endif /* (SPRHBM_HOST) */

/* CPGC_DPAT_USQ_CFG_0_MCCPGC_MAIN_REG supported on:                            */
/*      SPRA0 (0x91a0)                                                          */
/*      SPRB0 (0x91a0)                                                          */
/*      SPRHBM (0x91a0)                                                         */
/*      SPRC0 (0x91a0)                                                          */
/*      SPRMCC (0x91a0)                                                         */
/*      SPRUCC (0x91a0)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Unisequencer Mode and Pseudo Random Polynomial Configuration.
*/


#define CPGC_DPAT_USQ_CFG_0_MCCPGC_MAIN_REG 0x280091A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 uniseq_mode : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Defines the operational mode for the
                               Unisequencer Pattern Gen as follows:[br] 00 -
                               LMN Clock Pattern Generator[br] 01 - Pattern
                               Buffer Shift Pattern Generator[br] 10 -
                               Fibonacci LFSR based PRBS Pattern Generator
                               (fixed polynomials)[br] 11 - Galois LFSR based
                               PRBS Pattern Generator (programmable
                               polynomials)
                            */
    UINT8 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 uniseq_lfsr_stagger : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               0=No Stagger, 1=Stagger.[br] This bit must not
                               be set unless Uniseq_Mode is programmed to
                               Select LFSR or the behavior is undefined.
                            */
    UINT8 uniseq_lfsr_polynomial_size : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /*
                               Fibonacci Polynomial Sizes:[br] 0x0=Use 8 bit
                               LFSR. (x8 + x6 + x5 + x4)[br] 0x1=Use 15 bit
                               LFSR. (x15 + x14)[br] 0x2=Use 31 bit LFSR. (x31
                               + x28)[br] 0x3=Use 23 bit LFSR. (x23 + x18)[br]
                               0x4=Use 7 bit LFSR. (x7 + x6)[br] 0x5=Use 16 bit
                               LFSR. (x16+x5+x4+x3)[br] 0x6=Use 23 bit LFSR.
                               (x23+x21+x18+x15+x7+x2)[br] 0x7=Use 32 bit LFSR.
                               (x32+x22+x2+x1)[br] Used when UNISEQ_MODE = 2b10
                               (LFSR Fibonacci mode)
                            */
    UINT8 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} CPGC_DPAT_USQ_CFG_0_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_USQ_CFG_1_MCCPGC_MAIN_REG supported on:                            */
/*      SPRA0 (0x91a1)                                                          */
/*      SPRB0 (0x91a1)                                                          */
/*      SPRHBM (0x91a1)                                                         */
/*      SPRC0 (0x91a1)                                                          */
/*      SPRMCC (0x91a1)                                                         */
/*      SPRUCC (0x91a1)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Unisequencer Mode and Pseudo Random Polynomial Configuration.
*/


#define CPGC_DPAT_USQ_CFG_1_MCCPGC_MAIN_REG 0x280091A1

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 uniseq_mode : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Defines the operational mode for the
                               Unisequencer Pattern Gen as follows:[br] 00 -
                               LMN Clock Pattern Generator[br] 01 - Pattern
                               Buffer Shift Pattern Generator[br] 10 -
                               Fibonacci LFSR based PRBS Pattern Generator
                               (fixed polynomials)[br] 11 - Galois LFSR based
                               PRBS Pattern Generator (programmable
                               polynomials)
                            */
    UINT8 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 uniseq_lfsr_stagger : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               0=No Stagger, 1=Stagger.[br] This bit must not
                               be set unless Uniseq_Mode is programmed to
                               Select LFSR or the behavior is undefined.
                            */
    UINT8 uniseq_lfsr_polynomial_size : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /*
                               Fibonacci Polynomial Sizes:[br] 0x0=Use 8 bit
                               LFSR. (x8 + x6 + x5 + x4)[br] 0x1=Use 15 bit
                               LFSR. (x15 + x14)[br] 0x2=Use 31 bit LFSR. (x31
                               + x28)[br] 0x3=Use 23 bit LFSR. (x23 + x18)[br]
                               0x4=Use 7 bit LFSR. (x7 + x6)[br] 0x5=Use 16 bit
                               LFSR. (x16+x5+x4+x3)[br] 0x6=Use 23 bit LFSR.
                               (x23+x21+x18+x15+x7+x2)[br] 0x7=Use 32 bit LFSR.
                               (x32+x22+x2+x1)[br] Used when UNISEQ_MODE = 2b10
                               (LFSR Fibonacci mode)
                            */
    UINT8 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} CPGC_DPAT_USQ_CFG_1_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_USQ_CFG_2_MCCPGC_MAIN_REG supported on:                            */
/*      SPRA0 (0x91a2)                                                          */
/*      SPRB0 (0x91a2)                                                          */
/*      SPRHBM (0x91a2)                                                         */
/*      SPRC0 (0x91a2)                                                          */
/*      SPRMCC (0x91a2)                                                         */
/*      SPRUCC (0x91a2)                                                         */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Unisequencer Mode and Pseudo Random Polynomial Configuration.
*/


#define CPGC_DPAT_USQ_CFG_2_MCCPGC_MAIN_REG 0x280091A2

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT8 uniseq_mode : 2;

                            /* Bits[1:0], Access Type=RW, default=0x00000000*/

                            /*
                               Defines the operational mode for the
                               Unisequencer Pattern Gen as follows:[br] 00 -
                               LMN Clock Pattern Generator[br] 01 - Pattern
                               Buffer Shift Pattern Generator[br] 10 -
                               Fibonacci LFSR based PRBS Pattern Generator
                               (fixed polynomials)[br] 11 - Galois LFSR based
                               PRBS Pattern Generator (programmable
                               polynomials)
                            */
    UINT8 rsvd : 1;

                            /* Bits[2:2], Access Type=RO, default=None*/

                            /* Reserved */
    UINT8 uniseq_lfsr_stagger : 1;

                            /* Bits[3:3], Access Type=RW, default=0x00000000*/

                            /*
                               0=No Stagger, 1=Stagger.[br] This bit must not
                               be set unless Uniseq_Mode is programmed to
                               Select LFSR or the behavior is undefined.
                            */
    UINT8 uniseq_lfsr_polynomial_size : 3;

                            /* Bits[6:4], Access Type=RW, default=0x00000000*/

                            /*
                               Fibonacci Polynomial Sizes:[br] 0x0=Use 8 bit
                               LFSR. (x8 + x6 + x5 + x4)[br] 0x1=Use 15 bit
                               LFSR. (x15 + x14)[br] 0x2=Use 31 bit LFSR. (x31
                               + x28)[br] 0x3=Use 23 bit LFSR. (x23 + x18)[br]
                               0x4=Use 7 bit LFSR. (x7 + x6)[br] 0x5=Use 16 bit
                               LFSR. (x16+x5+x4+x3)[br] 0x6=Use 23 bit LFSR.
                               (x23+x21+x18+x15+x7+x2)[br] 0x7=Use 32 bit LFSR.
                               (x32+x22+x2+x1)[br] Used when UNISEQ_MODE = 2b10
                               (LFSR Fibonacci mode)
                            */
    UINT8 rsvd_7 : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT8 Data;

} CPGC_DPAT_USQ_CFG_2_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_0_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x200091a8)                                                      */
/*      SPRB0 (0x200091a8)                                                      */
/*      SPRHBM (0x200091a8)                                                     */
/*      SPRC0 (0x200091a8)                                                      */
/*      SPRMCC (0x200091a8)                                                     */
/*      SPRUCC (0x200091a8)                                                     */
/* Register default value on SPRA0: 0xAA55AA55                                  */
/* Register default value on SPRB0: 0xAA55AA55                                  */
/* Register default value on SPRHBM: 0xAA55AA55                                 */
/* Register default value on SPRC0: 0xAA55AA55                                  */
/* Register default value on SPRMCC: 0xAA55AA55                                 */
/* Register default value on SPRUCC: 0xAA55AA55                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Unisequencer # Data Pattern Seed.
*/


#define CPGC_DPAT_UNISEQ_0_MCCPGC_MAIN_REG 0x280291A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pattern_buffer : 32;

                            /* Bits[31:0], Access Type=RW, default=0xAA55AA55*/

                            /*
                               This register has meaning according to the
                               UniSeq# mode.[br] If UniSeq_Mode is set to
                               Pattern Buffer mode, then this field represents
                               the initial content of the rotating pattern
                               buffer for the unified sequencer.[br] If
                               UniSeq_Mode is set to Fibonacci or Galois PRBS
                               modes, then this field represents the (up to)
                               32-bit LFSR seed for the unified sequencer.[br]
                               For PRBS lengths less than or equal to 8, the
                               seed must contain 16 bits of the correct initial
                               PRBS sequence (CPGC 2.1 and below).
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_0_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_1_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x200091ac)                                                      */
/*      SPRB0 (0x200091ac)                                                      */
/*      SPRHBM (0x200091ac)                                                     */
/*      SPRC0 (0x200091ac)                                                      */
/*      SPRMCC (0x200091ac)                                                     */
/*      SPRUCC (0x200091ac)                                                     */
/* Register default value on SPRA0: 0xAA55AA55                                  */
/* Register default value on SPRB0: 0xAA55AA55                                  */
/* Register default value on SPRHBM: 0xAA55AA55                                 */
/* Register default value on SPRC0: 0xAA55AA55                                  */
/* Register default value on SPRMCC: 0xAA55AA55                                 */
/* Register default value on SPRUCC: 0xAA55AA55                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Unisequencer # Data Pattern Seed.
*/


#define CPGC_DPAT_UNISEQ_1_MCCPGC_MAIN_REG 0x280291AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pattern_buffer : 32;

                            /* Bits[31:0], Access Type=RW, default=0xAA55AA55*/

                            /*
                               This register has meaning according to the
                               UniSeq# mode.[br] If UniSeq_Mode is set to
                               Pattern Buffer mode, then this field represents
                               the initial content of the rotating pattern
                               buffer for the unified sequencer.[br] If
                               UniSeq_Mode is set to Fibonacci or Galois PRBS
                               modes, then this field represents the (up to)
                               32-bit LFSR seed for the unified sequencer.[br]
                               For PRBS lengths less than or equal to 8, the
                               seed must contain 16 bits of the correct initial
                               PRBS sequence (CPGC 2.1 and below).
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_1_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_2_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x200091b0)                                                      */
/*      SPRB0 (0x200091b0)                                                      */
/*      SPRHBM (0x200091b0)                                                     */
/*      SPRC0 (0x200091b0)                                                      */
/*      SPRMCC (0x200091b0)                                                     */
/*      SPRUCC (0x200091b0)                                                     */
/* Register default value on SPRA0: 0xAA55AA55                                  */
/* Register default value on SPRB0: 0xAA55AA55                                  */
/* Register default value on SPRHBM: 0xAA55AA55                                 */
/* Register default value on SPRC0: 0xAA55AA55                                  */
/* Register default value on SPRMCC: 0xAA55AA55                                 */
/* Register default value on SPRUCC: 0xAA55AA55                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Unisequencer # Data Pattern Seed.
*/


#define CPGC_DPAT_UNISEQ_2_MCCPGC_MAIN_REG 0x280291B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pattern_buffer : 32;

                            /* Bits[31:0], Access Type=RW, default=0xAA55AA55*/

                            /*
                               This register has meaning according to the
                               UniSeq# mode.[br] If UniSeq_Mode is set to
                               Pattern Buffer mode, then this field represents
                               the initial content of the rotating pattern
                               buffer for the unified sequencer.[br] If
                               UniSeq_Mode is set to Fibonacci or Galois PRBS
                               modes, then this field represents the (up to)
                               32-bit LFSR seed for the unified sequencer.[br]
                               For PRBS lengths less than or equal to 8, the
                               seed must contain 16 bits of the correct initial
                               PRBS sequence (CPGC 2.1 and below).
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_2_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_POLY_0_MCCPGC_MAIN_REG supported on:                        */
/*      SPRA0 (0x200091b8)                                                      */
/*      SPRB0 (0x200091b8)                                                      */
/*      SPRHBM (0x200091b8)                                                     */
/*      SPRC0 (0x200091b8)                                                      */
/*      SPRMCC (0x200091b8)                                                     */
/*      SPRUCC (0x200091b8)                                                     */
/* Register default value on SPRA0: 0x80000000                                  */
/* Register default value on SPRB0: 0x80000000                                  */
/* Register default value on SPRHBM: 0x80000000                                 */
/* Register default value on SPRC0: 0x80000000                                  */
/* Register default value on SPRMCC: 0x80000000                                 */
/* Register default value on SPRUCC: 0x80000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Unisequencer # Galois PRBS Polynomial.
*/


#define CPGC_DPAT_UNISEQ_POLY_0_MCCPGC_MAIN_REG 0x280291B8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 galois_poly : 32;

                            /* Bits[31:0], Access Type=RW, default=0x80000000*/

                            /*
                               When programmed to a value that has a single bit
                               set, this will create a shift register of the
                               CPGC_DPAT_UNISEQ.PATTERN_BUFFER of the length
                               from bit 0 including that set bit. The default
                               value is for a 32-bit shift register. Normal
                               maximal length polynomial values will have an
                               odd number of bits set. Some validated values
                               for different PRBS lengths:[br] 32'h0000_00B8 //
                               x8 + x6 + x5 + x4 +1[br] 32'h0000_6000 // x15 +
                               x14 + 1[br] 32'h4800_0000 // x31 + x28 + 1[br]
                               32'h0042_0000 // x23 + x18 + 1[br] 32'h0000_0060
                               // x7 + x6 + 1[br] 32'h0000_801C // x16 + x5 +
                               x4 + x3 + 1[br] 32'h0052_4042 // x23 + x21 + x18
                               + x15 + x7 + x2 + 1[br] 32'h8020_0003 // x32 +
                               x22 + x2 + x1 + 1[br] 32'h8000_0000 // 32-bit
                               shift register[br] 32'h0000_8000 // 16-bit shift
                               register
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_POLY_0_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_POLY_1_MCCPGC_MAIN_REG supported on:                        */
/*      SPRA0 (0x200091bc)                                                      */
/*      SPRB0 (0x200091bc)                                                      */
/*      SPRHBM (0x200091bc)                                                     */
/*      SPRC0 (0x200091bc)                                                      */
/*      SPRMCC (0x200091bc)                                                     */
/*      SPRUCC (0x200091bc)                                                     */
/* Register default value on SPRA0: 0x80000000                                  */
/* Register default value on SPRB0: 0x80000000                                  */
/* Register default value on SPRHBM: 0x80000000                                 */
/* Register default value on SPRC0: 0x80000000                                  */
/* Register default value on SPRMCC: 0x80000000                                 */
/* Register default value on SPRUCC: 0x80000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Unisequencer # Galois PRBS Polynomial.
*/


#define CPGC_DPAT_UNISEQ_POLY_1_MCCPGC_MAIN_REG 0x280291BC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 galois_poly : 32;

                            /* Bits[31:0], Access Type=RW, default=0x80000000*/

                            /*
                               When programmed to a value that has a single bit
                               set, this will create a shift register of the
                               CPGC_DPAT_UNISEQ.PATTERN_BUFFER of the length
                               from bit 0 including that set bit. The default
                               value is for a 32-bit shift register. Normal
                               maximal length polynomial values will have an
                               odd number of bits set. Some validated values
                               for different PRBS lengths:[br] 32'h0000_00B8 //
                               x8 + x6 + x5 + x4 +1[br] 32'h0000_6000 // x15 +
                               x14 + 1[br] 32'h4800_0000 // x31 + x28 + 1[br]
                               32'h0042_0000 // x23 + x18 + 1[br] 32'h0000_0060
                               // x7 + x6 + 1[br] 32'h0000_801C // x16 + x5 +
                               x4 + x3 + 1[br] 32'h0052_4042 // x23 + x21 + x18
                               + x15 + x7 + x2 + 1[br] 32'h8020_0003 // x32 +
                               x22 + x2 + x1 + 1[br] 32'h8000_0000 // 32-bit
                               shift register[br] 32'h0000_8000 // 16-bit shift
                               register
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_POLY_1_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_POLY_2_MCCPGC_MAIN_REG supported on:                        */
/*      SPRA0 (0x200091c0)                                                      */
/*      SPRB0 (0x200091c0)                                                      */
/*      SPRHBM (0x200091c0)                                                     */
/*      SPRC0 (0x200091c0)                                                      */
/*      SPRMCC (0x200091c0)                                                     */
/*      SPRUCC (0x200091c0)                                                     */
/* Register default value on SPRA0: 0x80000000                                  */
/* Register default value on SPRB0: 0x80000000                                  */
/* Register default value on SPRHBM: 0x80000000                                 */
/* Register default value on SPRC0: 0x80000000                                  */
/* Register default value on SPRMCC: 0x80000000                                 */
/* Register default value on SPRUCC: 0x80000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Unisequencer # Galois PRBS Polynomial.
*/


#define CPGC_DPAT_UNISEQ_POLY_2_MCCPGC_MAIN_REG 0x280291C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 galois_poly : 32;

                            /* Bits[31:0], Access Type=RW, default=0x80000000*/

                            /*
                               When programmed to a value that has a single bit
                               set, this will create a shift register of the
                               CPGC_DPAT_UNISEQ.PATTERN_BUFFER of the length
                               from bit 0 including that set bit. The default
                               value is for a 32-bit shift register. Normal
                               maximal length polynomial values will have an
                               odd number of bits set. Some validated values
                               for different PRBS lengths:[br] 32'h0000_00B8 //
                               x8 + x6 + x5 + x4 +1[br] 32'h0000_6000 // x15 +
                               x14 + 1[br] 32'h4800_0000 // x31 + x28 + 1[br]
                               32'h0042_0000 // x23 + x18 + 1[br] 32'h0000_0060
                               // x7 + x6 + 1[br] 32'h0000_801C // x16 + x5 +
                               x4 + x3 + 1[br] 32'h0052_4042 // x23 + x21 + x18
                               + x15 + x7 + x2 + 1[br] 32'h8020_0003 // x32 +
                               x22 + x2 + x1 + 1[br] 32'h8000_0000 // 32-bit
                               shift register[br] 32'h0000_8000 // 16-bit shift
                               register
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_POLY_2_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_STAGR_0_MCCPGC_MAIN_REG supported on:                       */
/*      SPRA0 (0x200091c8)                                                      */
/*      SPRB0 (0x200091c8)                                                      */
/*      SPRHBM (0x200091c8)                                                     */
/*      SPRC0 (0x200091c8)                                                      */
/*      SPRMCC (0x200091c8)                                                     */
/*      SPRUCC (0x200091c8)                                                     */
/* Register default value on SPRA0: 0x01010101                                  */
/* Register default value on SPRB0: 0x01010101                                  */
/* Register default value on SPRHBM: 0x01010101                                 */
/* Register default value on SPRC0: 0x01010101                                  */
/* Register default value on SPRMCC: 0x01010101                                 */
/* Register default value on SPRUCC: 0x01010101                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Specifies the polynomial for each of the staggered lane outputs.  The stagger only applies to the USQ_GALOIS generator and is disabled if the CPGC_DPAT_UNISEQ_POLY has only 1 bit set (PBUF mode) (or an odd number of bits set).
*/


#define CPGC_DPAT_UNISEQ_STAGR_0_MCCPGC_MAIN_REG 0x280291C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 stagr1_poly : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000001*/

                            /*
                               This specifies the polynomial for the output
                               function for the 2nd lane in the cycle. A value
                               of 7b0000001 would be identical to the lane 0
                               output sequence.
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 stagr2_poly : 7;

                            /* Bits[14:8], Access Type=RW, default=0x00000001*/

                            /*
                               This specifies the polynomial for the output
                               function for the 3rd lane in the cycle. A value
                               of 7b0000001 would be identical to the lane 0
                               output sequence.
                            */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 stagr3_poly : 7;

                            /* Bits[22:16], Access Type=RW, default=0x00000001*/

                            /*
                               This specifies the polynomial for the output
                               function for the 4th lane in the cycle. A value
                               of 7b0000001 would be identical to the lane 0
                               output sequence.
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 stagr4_poly : 7;

                            /* Bits[30:24], Access Type=RW, default=0x00000001*/

                            /*
                               When the stagger cycle is 5 lanes, this
                               specifies the polynomial for the output function
                               for the 5th lane in the cycle. A value of
                               7b0000001 would be identical to the lane 0
                               output sequence.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_STAGR_0_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_STAGR_1_MCCPGC_MAIN_REG supported on:                       */
/*      SPRA0 (0x200091cc)                                                      */
/*      SPRB0 (0x200091cc)                                                      */
/*      SPRHBM (0x200091cc)                                                     */
/*      SPRC0 (0x200091cc)                                                      */
/*      SPRMCC (0x200091cc)                                                     */
/*      SPRUCC (0x200091cc)                                                     */
/* Register default value on SPRA0: 0x01010101                                  */
/* Register default value on SPRB0: 0x01010101                                  */
/* Register default value on SPRHBM: 0x01010101                                 */
/* Register default value on SPRC0: 0x01010101                                  */
/* Register default value on SPRMCC: 0x01010101                                 */
/* Register default value on SPRUCC: 0x01010101                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Specifies the polynomial for each of the staggered lane outputs.  The stagger only applies to the USQ_GALOIS generator and is disabled if the CPGC_DPAT_UNISEQ_POLY has only 1 bit set (PBUF mode) (or an odd number of bits set).
*/


#define CPGC_DPAT_UNISEQ_STAGR_1_MCCPGC_MAIN_REG 0x280291CC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 stagr1_poly : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000001*/

                            /*
                               This specifies the polynomial for the output
                               function for the 2nd lane in the cycle. A value
                               of 7b0000001 would be identical to the lane 0
                               output sequence.
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 stagr2_poly : 7;

                            /* Bits[14:8], Access Type=RW, default=0x00000001*/

                            /*
                               This specifies the polynomial for the output
                               function for the 3rd lane in the cycle. A value
                               of 7b0000001 would be identical to the lane 0
                               output sequence.
                            */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 stagr3_poly : 7;

                            /* Bits[22:16], Access Type=RW, default=0x00000001*/

                            /*
                               This specifies the polynomial for the output
                               function for the 4th lane in the cycle. A value
                               of 7b0000001 would be identical to the lane 0
                               output sequence.
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 stagr4_poly : 7;

                            /* Bits[30:24], Access Type=RW, default=0x00000001*/

                            /*
                               When the stagger cycle is 5 lanes, this
                               specifies the polynomial for the output function
                               for the 5th lane in the cycle. A value of
                               7b0000001 would be identical to the lane 0
                               output sequence.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_STAGR_1_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_STAGR_2_MCCPGC_MAIN_REG supported on:                       */
/*      SPRA0 (0x200091d0)                                                      */
/*      SPRB0 (0x200091d0)                                                      */
/*      SPRHBM (0x200091d0)                                                     */
/*      SPRC0 (0x200091d0)                                                      */
/*      SPRMCC (0x200091d0)                                                     */
/*      SPRUCC (0x200091d0)                                                     */
/* Register default value on SPRA0: 0x01010101                                  */
/* Register default value on SPRB0: 0x01010101                                  */
/* Register default value on SPRHBM: 0x01010101                                 */
/* Register default value on SPRC0: 0x01010101                                  */
/* Register default value on SPRMCC: 0x01010101                                 */
/* Register default value on SPRUCC: 0x01010101                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Specifies the polynomial for each of the staggered lane outputs.  The stagger only applies to the USQ_GALOIS generator and is disabled if the CPGC_DPAT_UNISEQ_POLY has only 1 bit set (PBUF mode) (or an odd number of bits set).
*/


#define CPGC_DPAT_UNISEQ_STAGR_2_MCCPGC_MAIN_REG 0x280291D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 stagr1_poly : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000001*/

                            /*
                               This specifies the polynomial for the output
                               function for the 2nd lane in the cycle. A value
                               of 7b0000001 would be identical to the lane 0
                               output sequence.
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 stagr2_poly : 7;

                            /* Bits[14:8], Access Type=RW, default=0x00000001*/

                            /*
                               This specifies the polynomial for the output
                               function for the 3rd lane in the cycle. A value
                               of 7b0000001 would be identical to the lane 0
                               output sequence.
                            */
    UINT32 rsvd_15 : 1;

                            /* Bits[15:15], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 stagr3_poly : 7;

                            /* Bits[22:16], Access Type=RW, default=0x00000001*/

                            /*
                               This specifies the polynomial for the output
                               function for the 4th lane in the cycle. A value
                               of 7b0000001 would be identical to the lane 0
                               output sequence.
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 stagr4_poly : 7;

                            /* Bits[30:24], Access Type=RW, default=0x00000001*/

                            /*
                               When the stagger cycle is 5 lanes, this
                               specifies the polynomial for the output function
                               for the 5th lane in the cycle. A value of
                               7b0000001 would be identical to the lane 0
                               output sequence.
                            */
    UINT32 rsvd_31 : 1;

                            /* Bits[31:31], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_STAGR_2_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_LMN_0_MCCPGC_MAIN_REG supported on:                         */
/*      SPRA0 (0x200091d8)                                                      */
/*      SPRB0 (0x200091d8)                                                      */
/*      SPRHBM (0x200091d8)                                                     */
/*      SPRC0 (0x200091d8)                                                      */
/*      SPRMCC (0x200091d8)                                                     */
/*      SPRUCC (0x200091d8)                                                     */
/* Register default value on SPRA0: 0x01010100                                  */
/* Register default value on SPRB0: 0x01010100                                  */
/* Register default value on SPRHBM: 0x01010100                                 */
/* Register default value on SPRC0: 0x01010100                                  */
/* Register default value on SPRMCC: 0x01010100                                 */
/* Register default value on SPRUCC: 0x01010100                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Unisequencer # Data Pattern LMN control.
*/


#define CPGC_DPAT_UNISEQ_LMN_0_MCCPGC_MAIN_REG 0x280291D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l_sel : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               The initial logic output of the sequencer is
                               defined as follows:[br] 0 - Initial Output Logic
                               '0'[br] 1 - Initial Output Logic '1'
                            */
    UINT32 freq_sweep_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               If L-Count mode, then the following pattern is
                               continuously repeated:[br] 1) Drive L_Polarity
                               for L_Count Bits[br] 2) Drive inverse of
                               L_Polarity for L_Count Bits[br] 3) Go to step 1
                               [br] [br] If Normal LMN mode, then the following
                               pattern is continuously repeated:[br] 1) Drive
                               L_Count bits with the polarity set by
                               L_Polarity[br] 2) Drive M_Count bits with the
                               inverse of L_Polarity[br] 3) Drive N_Count bits
                               with the value of L_Polarity[br] 4) Go to step
                               2)[br] If any L_Count, M_Count, or N_Count=0
                               then the state will freeze at the polarity
                               driven for that stage.[br] [br] If Frequency
                               Sweep mode, then the following pattern is
                               continuously repeated:[br] 1) Drive L_Count bits
                               with the polarity set by L_Polarity[br] 2)
                               X_Count=M_Count [br] 3) Drive X_Count bits with
                               the inverse of L_Polarity[br] 4) Drive X_Count
                               bits with the value of L_Polarity[br] 5) Drive
                               X_Count bits with the inverse of L_Polarity[br]
                               6) If X_Count==N_Count then go to step 9[br] 7)
                               X_Count=X_Count-1[br] 8) Go to step 10[br] 9)
                               X_Count=M_Count[br] 10) Drive X_Count bits with
                               the value of L_Polarity[br] 11) Go to step 3[br]
                               [br] In Dwell Frequency Sweep mode, behavior is
                               similar to normal Frequency Sweep mode[br] 1)
                               X_Count=M_Count [br] 2) Drive X_Count bits with
                               the value of L_Polarity[br] 3) Drive X_Count
                               bits with the inverse of L_Polarity[br] 4)
                               Repeat 2 through 3 for L_Count times[br] 5) If
                               X_Count==N_Count then go to step 1[br] 6)
                               X_Count=X_Count-1[br] 7) Go to step 2[br] [br]
                               For {L_COUNT_EN,FREQ_SWEEP_EN}[br] if {x,1},
                               L_Count, M_Count, and N_Count must never be
                               programmed to 0 and is considered undefined.[br]
                               if {x,1}, M_Count and N_Count must be greater
                               than or equal to 8 or behavior may be
                               implementation specific.[br] if {x,1}, N_Count
                               must be programmed less than M_Count.[br] if
                               {1,0}, L_Count must never be programmed to 0 and
                               is considered undefined.[br] if {1,1}, L_Count
                               is not recommended be programmed to 1.
                            */
    UINT32 l_count_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Used in concatenation with FREQ_SWEEP_EN to
                               enable 4 possible modes of LMN behavior.[br]
                               {L_COUNT_EN,FREQ_SWEEP_EN}[br] {0,0} - Normal
                               LMN - clock pattern using an initial L clock
                               phase followed by M and N repeating.[br] {0,1} -
                               Frequency Sweep mode - clock pattern from 2*M
                               period down to 2*N_Count period and repeat. Four
                               phases per frequency.[br] {1,0} - L-Counter -
                               clock pattern of 2*L period.[br] {1,1} - Dwell
                               Frequency Sweep mode - clock pattern from 2*M
                               period down to 2*N_Count period and repeat.
                               2*L_Count phases per frequency.
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 l_counter_hi : 4;

                            /* Bits[7:4], Access Type=RW, default=0x00000000*/

                            /*
                               Additional 4 bits to increase the size of L
                               Count up to 12. Considered as 4'b0000 in Dwell
                               Frequency Sweep mode (ignored).[br] For all the
                               following descriptions, L_Count is considered to
                               be this concatenation of {L_COUNTER_HI,L_CNT}.
                            */
    UINT32 l_cnt : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000001*/

                            /*
                               Lower portion of L_Count, used for generating a
                               clock pattern from the LMN patgen.[br] See
                               L_Count_En and Frequency_Sweep_En for exact
                               behavior.
                            */
    UINT32 m_cnt : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000001*/

                            /*
                               M_Count, used for generating a clock pattern
                               from the LMN patgen.[br] See L_Count_En and
                               Frequency_Sweep_En for exact behavior.
                            */
    UINT32 n_cnt : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000001*/

                            /*
                               N_Count, used for generating a clock pattern
                               from the LMN patgen.[br] [br] In L-Counter mode
                               (L Counter Mode Enable =1, Frequency Sweep Mode
                               Enable = 0), the values of the M and N count
                               fields are ignored, and a periodic square wave
                               is generated where each phase is L_Count bits
                               long.[br] In Normal LMN Counter mode (L Counter
                               Mode Enable =0, Frequency Sweep Mode Enable =
                               0), a steady state frequency is driven using an
                               initial phase of L_Count bits, followed by a
                               repeating clock pattern using M and N as the two
                               phases.[br] In Normal Frequency Sweep mode (L
                               Counter Mode Enable =0, Frequency Sweep Mode
                               Enable = 1), a frequency sweep is continuously
                               generated ranging from 2*(M) to 2*(N) in period
                               with 4 phases per frequency step before
                               increasing the frequency.[br] The initial phase
                               of the 2*M period clock is held for L Count
                               bits.[br] In Dwell Frequency Sweep mode (L
                               Counter Mode Enable =1, Frequency Sweep Mode
                               Enable = 1), a frequency sweep is continuously
                               generated ranging from 2*(M) to 2*(N) in period
                               with 2*L_Count phases per frequency step before
                               increasing the frequency.[br] [br] See
                               L_Counter_Mode_En and Frequency_Sweep_Mode_En
                               for exact behavior.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_LMN_0_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_LMN_1_MCCPGC_MAIN_REG supported on:                         */
/*      SPRA0 (0x200091dc)                                                      */
/*      SPRB0 (0x200091dc)                                                      */
/*      SPRHBM (0x200091dc)                                                     */
/*      SPRC0 (0x200091dc)                                                      */
/*      SPRMCC (0x200091dc)                                                     */
/*      SPRUCC (0x200091dc)                                                     */
/* Register default value on SPRA0: 0x01010100                                  */
/* Register default value on SPRB0: 0x01010100                                  */
/* Register default value on SPRHBM: 0x01010100                                 */
/* Register default value on SPRC0: 0x01010100                                  */
/* Register default value on SPRMCC: 0x01010100                                 */
/* Register default value on SPRUCC: 0x01010100                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Unisequencer # Data Pattern LMN control.
*/


#define CPGC_DPAT_UNISEQ_LMN_1_MCCPGC_MAIN_REG 0x280291DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l_sel : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               The initial logic output of the sequencer is
                               defined as follows:[br] 0 - Initial Output Logic
                               '0'[br] 1 - Initial Output Logic '1'
                            */
    UINT32 freq_sweep_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               If L-Count mode, then the following pattern is
                               continuously repeated:[br] 1) Drive L_Polarity
                               for L_Count Bits[br] 2) Drive inverse of
                               L_Polarity for L_Count Bits[br] 3) Go to step 1
                               [br] [br] If Normal LMN mode, then the following
                               pattern is continuously repeated:[br] 1) Drive
                               L_Count bits with the polarity set by
                               L_Polarity[br] 2) Drive M_Count bits with the
                               inverse of L_Polarity[br] 3) Drive N_Count bits
                               with the value of L_Polarity[br] 4) Go to step
                               2)[br] If any L_Count, M_Count, or N_Count=0
                               then the state will freeze at the polarity
                               driven for that stage.[br] [br] If Frequency
                               Sweep mode, then the following pattern is
                               continuously repeated:[br] 1) Drive L_Count bits
                               with the polarity set by L_Polarity[br] 2)
                               X_Count=M_Count [br] 3) Drive X_Count bits with
                               the inverse of L_Polarity[br] 4) Drive X_Count
                               bits with the value of L_Polarity[br] 5) Drive
                               X_Count bits with the inverse of L_Polarity[br]
                               6) If X_Count==N_Count then go to step 9[br] 7)
                               X_Count=X_Count-1[br] 8) Go to step 10[br] 9)
                               X_Count=M_Count[br] 10) Drive X_Count bits with
                               the value of L_Polarity[br] 11) Go to step 3[br]
                               [br] In Dwell Frequency Sweep mode, behavior is
                               similar to normal Frequency Sweep mode[br] 1)
                               X_Count=M_Count [br] 2) Drive X_Count bits with
                               the value of L_Polarity[br] 3) Drive X_Count
                               bits with the inverse of L_Polarity[br] 4)
                               Repeat 2 through 3 for L_Count times[br] 5) If
                               X_Count==N_Count then go to step 1[br] 6)
                               X_Count=X_Count-1[br] 7) Go to step 2[br] [br]
                               For {L_COUNT_EN,FREQ_SWEEP_EN}[br] if {x,1},
                               L_Count, M_Count, and N_Count must never be
                               programmed to 0 and is considered undefined.[br]
                               if {x,1}, M_Count and N_Count must be greater
                               than or equal to 8 or behavior may be
                               implementation specific.[br] if {x,1}, N_Count
                               must be programmed less than M_Count.[br] if
                               {1,0}, L_Count must never be programmed to 0 and
                               is considered undefined.[br] if {1,1}, L_Count
                               is not recommended be programmed to 1.
                            */
    UINT32 l_count_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Used in concatenation with FREQ_SWEEP_EN to
                               enable 4 possible modes of LMN behavior.[br]
                               {L_COUNT_EN,FREQ_SWEEP_EN}[br] {0,0} - Normal
                               LMN - clock pattern using an initial L clock
                               phase followed by M and N repeating.[br] {0,1} -
                               Frequency Sweep mode - clock pattern from 2*M
                               period down to 2*N_Count period and repeat. Four
                               phases per frequency.[br] {1,0} - L-Counter -
                               clock pattern of 2*L period.[br] {1,1} - Dwell
                               Frequency Sweep mode - clock pattern from 2*M
                               period down to 2*N_Count period and repeat.
                               2*L_Count phases per frequency.
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 l_counter_hi : 4;

                            /* Bits[7:4], Access Type=RW, default=0x00000000*/

                            /*
                               Additional 4 bits to increase the size of L
                               Count up to 12. Considered as 4'b0000 in Dwell
                               Frequency Sweep mode (ignored).[br] For all the
                               following descriptions, L_Count is considered to
                               be this concatenation of {L_COUNTER_HI,L_CNT}.
                            */
    UINT32 l_cnt : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000001*/

                            /*
                               Lower portion of L_Count, used for generating a
                               clock pattern from the LMN patgen.[br] See
                               L_Count_En and Frequency_Sweep_En for exact
                               behavior.
                            */
    UINT32 m_cnt : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000001*/

                            /*
                               M_Count, used for generating a clock pattern
                               from the LMN patgen.[br] See L_Count_En and
                               Frequency_Sweep_En for exact behavior.
                            */
    UINT32 n_cnt : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000001*/

                            /*
                               N_Count, used for generating a clock pattern
                               from the LMN patgen.[br] [br] In L-Counter mode
                               (L Counter Mode Enable =1, Frequency Sweep Mode
                               Enable = 0), the values of the M and N count
                               fields are ignored, and a periodic square wave
                               is generated where each phase is L_Count bits
                               long.[br] In Normal LMN Counter mode (L Counter
                               Mode Enable =0, Frequency Sweep Mode Enable =
                               0), a steady state frequency is driven using an
                               initial phase of L_Count bits, followed by a
                               repeating clock pattern using M and N as the two
                               phases.[br] In Normal Frequency Sweep mode (L
                               Counter Mode Enable =0, Frequency Sweep Mode
                               Enable = 1), a frequency sweep is continuously
                               generated ranging from 2*(M) to 2*(N) in period
                               with 4 phases per frequency step before
                               increasing the frequency.[br] The initial phase
                               of the 2*M period clock is held for L Count
                               bits.[br] In Dwell Frequency Sweep mode (L
                               Counter Mode Enable =1, Frequency Sweep Mode
                               Enable = 1), a frequency sweep is continuously
                               generated ranging from 2*(M) to 2*(N) in period
                               with 2*L_Count phases per frequency step before
                               increasing the frequency.[br] [br] See
                               L_Counter_Mode_En and Frequency_Sweep_Mode_En
                               for exact behavior.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_LMN_1_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_LMN_2_MCCPGC_MAIN_REG supported on:                         */
/*      SPRA0 (0x200091e0)                                                      */
/*      SPRB0 (0x200091e0)                                                      */
/*      SPRHBM (0x200091e0)                                                     */
/*      SPRC0 (0x200091e0)                                                      */
/*      SPRMCC (0x200091e0)                                                     */
/*      SPRUCC (0x200091e0)                                                     */
/* Register default value on SPRA0: 0x01010100                                  */
/* Register default value on SPRB0: 0x01010100                                  */
/* Register default value on SPRHBM: 0x01010100                                 */
/* Register default value on SPRC0: 0x01010100                                  */
/* Register default value on SPRMCC: 0x01010100                                 */
/* Register default value on SPRUCC: 0x01010100                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Unisequencer # Data Pattern LMN control.
*/


#define CPGC_DPAT_UNISEQ_LMN_2_MCCPGC_MAIN_REG 0x280291E0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l_sel : 1;

                            /* Bits[0:0], Access Type=RW, default=0x00000000*/

                            /*
                               The initial logic output of the sequencer is
                               defined as follows:[br] 0 - Initial Output Logic
                               '0'[br] 1 - Initial Output Logic '1'
                            */
    UINT32 freq_sweep_en : 1;

                            /* Bits[1:1], Access Type=RW, default=0x00000000*/

                            /*
                               If L-Count mode, then the following pattern is
                               continuously repeated:[br] 1) Drive L_Polarity
                               for L_Count Bits[br] 2) Drive inverse of
                               L_Polarity for L_Count Bits[br] 3) Go to step 1
                               [br] [br] If Normal LMN mode, then the following
                               pattern is continuously repeated:[br] 1) Drive
                               L_Count bits with the polarity set by
                               L_Polarity[br] 2) Drive M_Count bits with the
                               inverse of L_Polarity[br] 3) Drive N_Count bits
                               with the value of L_Polarity[br] 4) Go to step
                               2)[br] If any L_Count, M_Count, or N_Count=0
                               then the state will freeze at the polarity
                               driven for that stage.[br] [br] If Frequency
                               Sweep mode, then the following pattern is
                               continuously repeated:[br] 1) Drive L_Count bits
                               with the polarity set by L_Polarity[br] 2)
                               X_Count=M_Count [br] 3) Drive X_Count bits with
                               the inverse of L_Polarity[br] 4) Drive X_Count
                               bits with the value of L_Polarity[br] 5) Drive
                               X_Count bits with the inverse of L_Polarity[br]
                               6) If X_Count==N_Count then go to step 9[br] 7)
                               X_Count=X_Count-1[br] 8) Go to step 10[br] 9)
                               X_Count=M_Count[br] 10) Drive X_Count bits with
                               the value of L_Polarity[br] 11) Go to step 3[br]
                               [br] In Dwell Frequency Sweep mode, behavior is
                               similar to normal Frequency Sweep mode[br] 1)
                               X_Count=M_Count [br] 2) Drive X_Count bits with
                               the value of L_Polarity[br] 3) Drive X_Count
                               bits with the inverse of L_Polarity[br] 4)
                               Repeat 2 through 3 for L_Count times[br] 5) If
                               X_Count==N_Count then go to step 1[br] 6)
                               X_Count=X_Count-1[br] 7) Go to step 2[br] [br]
                               For {L_COUNT_EN,FREQ_SWEEP_EN}[br] if {x,1},
                               L_Count, M_Count, and N_Count must never be
                               programmed to 0 and is considered undefined.[br]
                               if {x,1}, M_Count and N_Count must be greater
                               than or equal to 8 or behavior may be
                               implementation specific.[br] if {x,1}, N_Count
                               must be programmed less than M_Count.[br] if
                               {1,0}, L_Count must never be programmed to 0 and
                               is considered undefined.[br] if {1,1}, L_Count
                               is not recommended be programmed to 1.
                            */
    UINT32 l_count_en : 1;

                            /* Bits[2:2], Access Type=RW, default=0x00000000*/

                            /*
                               Used in concatenation with FREQ_SWEEP_EN to
                               enable 4 possible modes of LMN behavior.[br]
                               {L_COUNT_EN,FREQ_SWEEP_EN}[br] {0,0} - Normal
                               LMN - clock pattern using an initial L clock
                               phase followed by M and N repeating.[br] {0,1} -
                               Frequency Sweep mode - clock pattern from 2*M
                               period down to 2*N_Count period and repeat. Four
                               phases per frequency.[br] {1,0} - L-Counter -
                               clock pattern of 2*L period.[br] {1,1} - Dwell
                               Frequency Sweep mode - clock pattern from 2*M
                               period down to 2*N_Count period and repeat.
                               2*L_Count phases per frequency.
                            */
    UINT32 rsvd : 1;

                            /* Bits[3:3], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 l_counter_hi : 4;

                            /* Bits[7:4], Access Type=RW, default=0x00000000*/

                            /*
                               Additional 4 bits to increase the size of L
                               Count up to 12. Considered as 4'b0000 in Dwell
                               Frequency Sweep mode (ignored).[br] For all the
                               following descriptions, L_Count is considered to
                               be this concatenation of {L_COUNTER_HI,L_CNT}.
                            */
    UINT32 l_cnt : 8;

                            /* Bits[15:8], Access Type=RW, default=0x00000001*/

                            /*
                               Lower portion of L_Count, used for generating a
                               clock pattern from the LMN patgen.[br] See
                               L_Count_En and Frequency_Sweep_En for exact
                               behavior.
                            */
    UINT32 m_cnt : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000001*/

                            /*
                               M_Count, used for generating a clock pattern
                               from the LMN patgen.[br] See L_Count_En and
                               Frequency_Sweep_En for exact behavior.
                            */
    UINT32 n_cnt : 8;

                            /* Bits[31:24], Access Type=RW, default=0x00000001*/

                            /*
                               N_Count, used for generating a clock pattern
                               from the LMN patgen.[br] [br] In L-Counter mode
                               (L Counter Mode Enable =1, Frequency Sweep Mode
                               Enable = 0), the values of the M and N count
                               fields are ignored, and a periodic square wave
                               is generated where each phase is L_Count bits
                               long.[br] In Normal LMN Counter mode (L Counter
                               Mode Enable =0, Frequency Sweep Mode Enable =
                               0), a steady state frequency is driven using an
                               initial phase of L_Count bits, followed by a
                               repeating clock pattern using M and N as the two
                               phases.[br] In Normal Frequency Sweep mode (L
                               Counter Mode Enable =0, Frequency Sweep Mode
                               Enable = 1), a frequency sweep is continuously
                               generated ranging from 2*(M) to 2*(N) in period
                               with 4 phases per frequency step before
                               increasing the frequency.[br] The initial phase
                               of the 2*M period clock is held for L Count
                               bits.[br] In Dwell Frequency Sweep mode (L
                               Counter Mode Enable =1, Frequency Sweep Mode
                               Enable = 1), a frequency sweep is continuously
                               generated ranging from 2*(M) to 2*(N) in period
                               with 2*L_Count phases per frequency step before
                               increasing the frequency.[br] [br] See
                               L_Counter_Mode_En and Frequency_Sweep_Mode_En
                               for exact behavior.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_LMN_2_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_INV_DC_MASK_LO_MCCPGC_MAIN_REG supported on:                       */
/*      SPRA0 (0x200091e8)                                                      */
/*      SPRB0 (0x200091e8)                                                      */
/*      SPRHBM (0x200091e8)                                                     */
/*      SPRC0 (0x200091e8)                                                      */
/*      SPRMCC (0x200091e8)                                                     */
/*      SPRUCC (0x200091e8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Low Data Pattern Inversion/DC Mask.
*/


#define CPGC_DPAT_INV_DC_MASK_LO_MCCPGC_MAIN_REG 0x280291E8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_inv_dc_mask_lo : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               A value of 1 for any of the bits means the
                               corresponding data lane will be inverted or a DC
                               value driven on it. Note that this field is used
                               to load bits [31:0] of the continuous shift
                               register composed of this field along with
                               ECC_INV_DC_MASK and DATA_INV_DC_MASK_HI.[br] The
                               DPAT generator only uses the appropriate bits
                               based on the widest bus that this CPGC block is
                               designed to support.[br] This register is also
                               used to provide the Initial value for the
                               Alternate Data pattern generator.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_INV_DC_MASK_LO_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_INV_DC_MASK_HI_MCCPGC_MAIN_REG supported on:                       */
/*      SPRA0 (0x200091ec)                                                      */
/*      SPRB0 (0x200091ec)                                                      */
/*      SPRHBM (0x200091ec)                                                     */
/*      SPRC0 (0x200091ec)                                                      */
/*      SPRMCC (0x200091ec)                                                     */
/*      SPRUCC (0x200091ec)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* High Data Pattern Inversion/DC Mask.
*/


#define CPGC_DPAT_INV_DC_MASK_HI_MCCPGC_MAIN_REG 0x280291EC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_inv_dc_mask_hi : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               A value of 1 for any of the bits means the
                               corresponding data lane will be inverted or a DC
                               value driven on it. Note that this field is used
                               to load bits [63:32] of the continuous shift
                               register composed of this field along with
                               ECC_INV_DC_MASK and DATA_INV_DC_MASK_LO.[br] The
                               DPAT generator only uses the appropriate bits
                               based on the widest bus that this CPGC block is
                               designed to support.[br] This register is also
                               used to provide the Initial value for the
                               Alternate Data pattern generator.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_INV_DC_MASK_HI_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_DRAMDM_MCCPGC_MAIN_REG supported on:                               */
/*      SPRA0 (0x200091f0)                                                      */
/*      SPRB0 (0x200091f0)                                                      */
/*      SPRHBM (0x200091f0)                                                     */
/*      SPRC0 (0x200091f0)                                                      */
/*      SPRMCC (0x200091f0)                                                     */
/*      SPRUCC (0x200091f0)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Data Pattern DRAM Data Mask.
*/


#define CPGC_DPAT_DRAMDM_MCCPGC_MAIN_REG 0x280291F0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_mask_lo : 32;

                            /* Bits[31:0], Access Type=RW, default=0xFFFFFFFF*/

                            /*
                               A byte enable field with each bit corresponding
                               to a data byte sent during a burst such
                               that:[br] 0 - Mask the Corresponding Byte[br] 1
                               - No Mask to the Corresponding Byte[br] The
                               byte-to-bit mapping is given by Byte[n] ->
                               bit[n].[br] This register is for the first half
                               Cache Line of data.[br] It is only used when ECC
                               is not present or is disabled.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_DRAMDM_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_XDRAMDM_MCCPGC_MAIN_REG supported on:                              */
/*      SPRA0 (0x200091f4)                                                      */
/*      SPRB0 (0x200091f4)                                                      */
/*      SPRHBM (0x200091f4)                                                     */
/*      SPRC0 (0x200091f4)                                                      */
/*      SPRMCC (0x200091f4)                                                     */
/*      SPRUCC (0x200091f4)                                                     */
/* Register default value on SPRA0: 0xFFFFFFFF                                  */
/* Register default value on SPRB0: 0xFFFFFFFF                                  */
/* Register default value on SPRHBM: 0xFFFFFFFF                                 */
/* Register default value on SPRC0: 0xFFFFFFFF                                  */
/* Register default value on SPRMCC: 0xFFFFFFFF                                 */
/* Register default value on SPRUCC: 0xFFFFFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Extended Data Pattern DRAM Data Mask Register
*/


#define CPGC_DPAT_XDRAMDM_MCCPGC_MAIN_REG 0x280291F4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_mask_hi : 32;

                            /* Bits[31:0], Access Type=RW, default=0xFFFFFFFF*/

                            /*
                               A byte enable field with each bit corresponding
                               to a data byte sent during a burst such
                               that:[br] 0 - Mask the Corresponding Byte[br] 1
                               - No Mask to the Corresponding Byte[br] The
                               byte-to-bit mapping is given by Byte[n+32] ->
                               bit[n].[br] This register is for the Second half
                               Cache Line of data.[br] It is only used when ECC
                               is not present or is disabled.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_XDRAMDM_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_WRSTAT_0_MCCPGC_MAIN_REG supported on:                      */
/*      SPRA0 (0x200091f8)                                                      */
/*      SPRB0 (0x200091f8)                                                      */
/*      SPRHBM (0x200091f8)                                                     */
/*      SPRC0 (0x200091f8)                                                      */
/*      SPRMCC (0x200091f8)                                                     */
/*      SPRUCC (0x200091f8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Write Unisequencer Buffer/LFSR Status.
*/


#define CPGC_DPAT_UNISEQ_WRSTAT_0_MCCPGC_MAIN_REG 0x280291F8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 uniseq_wrstat : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the Pattern/LFSR buffer
                               in Write generation domain.[br] At the start of
                               a test the CPGC_DPAT_UNISEQ.PATTERN_BUFFER is
                               copied into CPGC_DPAT_UNISEQ_WRSTAT and
                               CPGC_DPAT_UNISEQ_WRSAVE.[br] If Pattern Buffer
                               Mode, this register is then used as a fixed
                               buffer that is output in serial fashion. After
                               all the bits in the Pattern_Buffer have been
                               transmitted the pattern will simply repeat
                               itself continuously while a Test is in
                               progress.[br] If LFSR mode, then this register
                               is used as a seed to a fixed LFSR that is output
                               in serial fashion, following the selected PRBS
                               setting in CPGC_DPAT_XTRA_LFSR_CFG. A zero seed
                               in PRBS mode is illegal. Over time the LFSR
                               pattern will repeat itself continuously while a
                               Test is in progress.[br] In LFSR Mode the
                               contents of Pattern_Buffer will interact with
                               the LFSR in the following ways:[br] If
                               LFSR_Save_Restore is set then
                               CPGC_DPAT_UNISEQ_WRSAVE will interact with
                               CPGC_DPAT_UNISEQ_WRSTAT in the following
                               ways:[br] 1) CPGC_DPAT_UNISEQ_WRSTAT will be
                               periodically saved into CPGC_DPAT_UNISEQ_WRSAVE
                               based on Save_LFSR_Seed_Rate (see
                               Save_LFSR_Seed_Rate for more details).[br] 2)
                               CPGC_DPAT_UNISEQ_WRSTAT will be periodically
                               reloaded with CPGC_DPAT_UNISEQ_WRSAVE based on
                               Reload_LFSR_Seed_Rate (see Reload_LFSR_Seed_Rate
                               for more details).
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_WRSTAT_0_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_WRSTAT_1_MCCPGC_MAIN_REG supported on:                      */
/*      SPRA0 (0x200091fc)                                                      */
/*      SPRB0 (0x200091fc)                                                      */
/*      SPRHBM (0x200091fc)                                                     */
/*      SPRC0 (0x200091fc)                                                      */
/*      SPRMCC (0x200091fc)                                                     */
/*      SPRUCC (0x200091fc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Write Unisequencer Buffer/LFSR Status.
*/


#define CPGC_DPAT_UNISEQ_WRSTAT_1_MCCPGC_MAIN_REG 0x280291FC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 uniseq_wrstat : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the Pattern/LFSR buffer
                               in Write generation domain.[br] At the start of
                               a test the CPGC_DPAT_UNISEQ.PATTERN_BUFFER is
                               copied into CPGC_DPAT_UNISEQ_WRSTAT and
                               CPGC_DPAT_UNISEQ_WRSAVE.[br] If Pattern Buffer
                               Mode, this register is then used as a fixed
                               buffer that is output in serial fashion. After
                               all the bits in the Pattern_Buffer have been
                               transmitted the pattern will simply repeat
                               itself continuously while a Test is in
                               progress.[br] If LFSR mode, then this register
                               is used as a seed to a fixed LFSR that is output
                               in serial fashion, following the selected PRBS
                               setting in CPGC_DPAT_XTRA_LFSR_CFG. A zero seed
                               in PRBS mode is illegal. Over time the LFSR
                               pattern will repeat itself continuously while a
                               Test is in progress.[br] In LFSR Mode the
                               contents of Pattern_Buffer will interact with
                               the LFSR in the following ways:[br] If
                               LFSR_Save_Restore is set then
                               CPGC_DPAT_UNISEQ_WRSAVE will interact with
                               CPGC_DPAT_UNISEQ_WRSTAT in the following
                               ways:[br] 1) CPGC_DPAT_UNISEQ_WRSTAT will be
                               periodically saved into CPGC_DPAT_UNISEQ_WRSAVE
                               based on Save_LFSR_Seed_Rate (see
                               Save_LFSR_Seed_Rate for more details).[br] 2)
                               CPGC_DPAT_UNISEQ_WRSTAT will be periodically
                               reloaded with CPGC_DPAT_UNISEQ_WRSAVE based on
                               Reload_LFSR_Seed_Rate (see Reload_LFSR_Seed_Rate
                               for more details).
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_WRSTAT_1_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_WRSTAT_2_MCCPGC_MAIN_REG supported on:                      */
/*      SPRA0 (0x20009200)                                                      */
/*      SPRB0 (0x20009200)                                                      */
/*      SPRHBM (0x20009200)                                                     */
/*      SPRC0 (0x20009200)                                                      */
/*      SPRMCC (0x20009200)                                                     */
/*      SPRUCC (0x20009200)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Write Unisequencer Buffer/LFSR Status.
*/


#define CPGC_DPAT_UNISEQ_WRSTAT_2_MCCPGC_MAIN_REG 0x28029200

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 uniseq_wrstat : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the Pattern/LFSR buffer
                               in Write generation domain.[br] At the start of
                               a test the CPGC_DPAT_UNISEQ.PATTERN_BUFFER is
                               copied into CPGC_DPAT_UNISEQ_WRSTAT and
                               CPGC_DPAT_UNISEQ_WRSAVE.[br] If Pattern Buffer
                               Mode, this register is then used as a fixed
                               buffer that is output in serial fashion. After
                               all the bits in the Pattern_Buffer have been
                               transmitted the pattern will simply repeat
                               itself continuously while a Test is in
                               progress.[br] If LFSR mode, then this register
                               is used as a seed to a fixed LFSR that is output
                               in serial fashion, following the selected PRBS
                               setting in CPGC_DPAT_XTRA_LFSR_CFG. A zero seed
                               in PRBS mode is illegal. Over time the LFSR
                               pattern will repeat itself continuously while a
                               Test is in progress.[br] In LFSR Mode the
                               contents of Pattern_Buffer will interact with
                               the LFSR in the following ways:[br] If
                               LFSR_Save_Restore is set then
                               CPGC_DPAT_UNISEQ_WRSAVE will interact with
                               CPGC_DPAT_UNISEQ_WRSTAT in the following
                               ways:[br] 1) CPGC_DPAT_UNISEQ_WRSTAT will be
                               periodically saved into CPGC_DPAT_UNISEQ_WRSAVE
                               based on Save_LFSR_Seed_Rate (see
                               Save_LFSR_Seed_Rate for more details).[br] 2)
                               CPGC_DPAT_UNISEQ_WRSTAT will be periodically
                               reloaded with CPGC_DPAT_UNISEQ_WRSAVE based on
                               Reload_LFSR_Seed_Rate (see Reload_LFSR_Seed_Rate
                               for more details).
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_WRSTAT_2_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_RDSTAT_0_MCCPGC_MAIN_REG supported on:                      */
/*      SPRA0 (0x20009208)                                                      */
/*      SPRB0 (0x20009208)                                                      */
/*      SPRHBM (0x20009208)                                                     */
/*      SPRC0 (0x20009208)                                                      */
/*      SPRMCC (0x20009208)                                                     */
/*      SPRUCC (0x20009208)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Read Unisequencer Buffer/LFSR Status.
*/


#define CPGC_DPAT_UNISEQ_RDSTAT_0_MCCPGC_MAIN_REG 0x28029208

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 uniseq_rdstat : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the Pattern/LFSR buffer
                               in Read generation domain.[br] At the start of a
                               test the CPGC_DPAT_UNISEQ.PATTERN_BUFFER is
                               copied into CPGC_DPAT_UNISEQ_RDSTAT and
                               CPGC_DPAT_UNISEQ_RDSAVE.[br] If Pattern Buffer
                               Mode, this register is then used as a fixed
                               buffer that is output in serial fashion. After
                               all the bits in the Pattern_Buffer have been
                               transmitted the pattern will simply repeat
                               itself continuously while a Test is in
                               progress.[br] If LFSR mode, then this register
                               is used as a seed to a fixed LFSR that is output
                               in serial fashion, following the selected PRBS
                               setting in CPGC_DPAT_XTRA_LFSR_CFG. A zero seed
                               in PRBS mode is illegal. Over time the LFSR
                               pattern will repeat itself continuously while a
                               Test is in progress.[br] In LFSR Mode the
                               contents of Pattern_Buffer will interact with
                               the LFSR in the following ways:[br] If
                               LFSR_Save_Restore is set then
                               CPGC_DPAT_UNISEQ_RDSAVE will interact with
                               CPGC_DPAT_UNISEQ_RDSTAT in the following
                               ways:[br] 1) CPGC_DPAT_UNISEQ_RDSTAT will be
                               periodically saved into CPGC_DPAT_UNISEQ_RDSAVE
                               based on Save_LFSR_Seed_Rate (see
                               Save_LFSR_Seed_Rate for more details).[br] 2)
                               CPGC_DPAT_UNISEQ_RDSTAT will be periodically
                               reloaded with CPGC_DPAT_UNISEQ_RDSAVE based on
                               Reload_LFSR_Seed_Rate (see Reload_LFSR_Seed_Rate
                               for more details).
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_RDSTAT_0_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_RDSTAT_1_MCCPGC_MAIN_REG supported on:                      */
/*      SPRA0 (0x2000920c)                                                      */
/*      SPRB0 (0x2000920c)                                                      */
/*      SPRHBM (0x2000920c)                                                     */
/*      SPRC0 (0x2000920c)                                                      */
/*      SPRMCC (0x2000920c)                                                     */
/*      SPRUCC (0x2000920c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Read Unisequencer Buffer/LFSR Status.
*/


#define CPGC_DPAT_UNISEQ_RDSTAT_1_MCCPGC_MAIN_REG 0x2802920C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 uniseq_rdstat : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the Pattern/LFSR buffer
                               in Read generation domain.[br] At the start of a
                               test the CPGC_DPAT_UNISEQ.PATTERN_BUFFER is
                               copied into CPGC_DPAT_UNISEQ_RDSTAT and
                               CPGC_DPAT_UNISEQ_RDSAVE.[br] If Pattern Buffer
                               Mode, this register is then used as a fixed
                               buffer that is output in serial fashion. After
                               all the bits in the Pattern_Buffer have been
                               transmitted the pattern will simply repeat
                               itself continuously while a Test is in
                               progress.[br] If LFSR mode, then this register
                               is used as a seed to a fixed LFSR that is output
                               in serial fashion, following the selected PRBS
                               setting in CPGC_DPAT_XTRA_LFSR_CFG. A zero seed
                               in PRBS mode is illegal. Over time the LFSR
                               pattern will repeat itself continuously while a
                               Test is in progress.[br] In LFSR Mode the
                               contents of Pattern_Buffer will interact with
                               the LFSR in the following ways:[br] If
                               LFSR_Save_Restore is set then
                               CPGC_DPAT_UNISEQ_RDSAVE will interact with
                               CPGC_DPAT_UNISEQ_RDSTAT in the following
                               ways:[br] 1) CPGC_DPAT_UNISEQ_RDSTAT will be
                               periodically saved into CPGC_DPAT_UNISEQ_RDSAVE
                               based on Save_LFSR_Seed_Rate (see
                               Save_LFSR_Seed_Rate for more details).[br] 2)
                               CPGC_DPAT_UNISEQ_RDSTAT will be periodically
                               reloaded with CPGC_DPAT_UNISEQ_RDSAVE based on
                               Reload_LFSR_Seed_Rate (see Reload_LFSR_Seed_Rate
                               for more details).
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_RDSTAT_1_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_RDSTAT_2_MCCPGC_MAIN_REG supported on:                      */
/*      SPRA0 (0x20009210)                                                      */
/*      SPRB0 (0x20009210)                                                      */
/*      SPRHBM (0x20009210)                                                     */
/*      SPRC0 (0x20009210)                                                      */
/*      SPRMCC (0x20009210)                                                     */
/*      SPRUCC (0x20009210)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Read Unisequencer Buffer/LFSR Status.
*/


#define CPGC_DPAT_UNISEQ_RDSTAT_2_MCCPGC_MAIN_REG 0x28029210

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 uniseq_rdstat : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the Pattern/LFSR buffer
                               in Read generation domain.[br] At the start of a
                               test the CPGC_DPAT_UNISEQ.PATTERN_BUFFER is
                               copied into CPGC_DPAT_UNISEQ_RDSTAT and
                               CPGC_DPAT_UNISEQ_RDSAVE.[br] If Pattern Buffer
                               Mode, this register is then used as a fixed
                               buffer that is output in serial fashion. After
                               all the bits in the Pattern_Buffer have been
                               transmitted the pattern will simply repeat
                               itself continuously while a Test is in
                               progress.[br] If LFSR mode, then this register
                               is used as a seed to a fixed LFSR that is output
                               in serial fashion, following the selected PRBS
                               setting in CPGC_DPAT_XTRA_LFSR_CFG. A zero seed
                               in PRBS mode is illegal. Over time the LFSR
                               pattern will repeat itself continuously while a
                               Test is in progress.[br] In LFSR Mode the
                               contents of Pattern_Buffer will interact with
                               the LFSR in the following ways:[br] If
                               LFSR_Save_Restore is set then
                               CPGC_DPAT_UNISEQ_RDSAVE will interact with
                               CPGC_DPAT_UNISEQ_RDSTAT in the following
                               ways:[br] 1) CPGC_DPAT_UNISEQ_RDSTAT will be
                               periodically saved into CPGC_DPAT_UNISEQ_RDSAVE
                               based on Save_LFSR_Seed_Rate (see
                               Save_LFSR_Seed_Rate for more details).[br] 2)
                               CPGC_DPAT_UNISEQ_RDSTAT will be periodically
                               reloaded with CPGC_DPAT_UNISEQ_RDSAVE based on
                               Reload_LFSR_Seed_Rate (see Reload_LFSR_Seed_Rate
                               for more details).
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_RDSTAT_2_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_LMN_WRSTAT_0_MCCPGC_MAIN_REG supported on:                         */
/*      SPRA0 (0x20009218)                                                      */
/*      SPRB0 (0x20009218)                                                      */
/*      SPRHBM (0x20009218)                                                     */
/*      SPRC0 (0x20009218)                                                      */
/*      SPRMCC (0x20009218)                                                     */
/*      SPRUCC (0x20009218)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Write LMN Status.
*/


#define CPGC_DPAT_LMN_WRSTAT_0_MCCPGC_MAIN_REG 0x28029218

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lmn_wrstat : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the LMN buffer in write
                               comparison domain.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_LMN_WRSTAT_0_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_LMN_WRSTAT_1_MCCPGC_MAIN_REG supported on:                         */
/*      SPRA0 (0x2000921c)                                                      */
/*      SPRB0 (0x2000921c)                                                      */
/*      SPRHBM (0x2000921c)                                                     */
/*      SPRC0 (0x2000921c)                                                      */
/*      SPRMCC (0x2000921c)                                                     */
/*      SPRUCC (0x2000921c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Write LMN Status.
*/


#define CPGC_DPAT_LMN_WRSTAT_1_MCCPGC_MAIN_REG 0x2802921C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lmn_wrstat : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the LMN buffer in write
                               comparison domain.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_LMN_WRSTAT_1_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_LMN_WRSTAT_2_MCCPGC_MAIN_REG supported on:                         */
/*      SPRA0 (0x20009220)                                                      */
/*      SPRB0 (0x20009220)                                                      */
/*      SPRHBM (0x20009220)                                                     */
/*      SPRC0 (0x20009220)                                                      */
/*      SPRMCC (0x20009220)                                                     */
/*      SPRUCC (0x20009220)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Write LMN Status.
*/


#define CPGC_DPAT_LMN_WRSTAT_2_MCCPGC_MAIN_REG 0x28029220

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lmn_wrstat : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the LMN buffer in write
                               comparison domain.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_LMN_WRSTAT_2_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_LMN_RDSTAT_0_MCCPGC_MAIN_REG supported on:                         */
/*      SPRA0 (0x20009228)                                                      */
/*      SPRB0 (0x20009228)                                                      */
/*      SPRHBM (0x20009228)                                                     */
/*      SPRC0 (0x20009228)                                                      */
/*      SPRMCC (0x20009228)                                                     */
/*      SPRUCC (0x20009228)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Read LMN Status.
*/


#define CPGC_DPAT_LMN_RDSTAT_0_MCCPGC_MAIN_REG 0x28029228

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lmn_rdstat : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the LMN buffer in read
                               comparison domain.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_LMN_RDSTAT_0_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_LMN_RDSTAT_1_MCCPGC_MAIN_REG supported on:                         */
/*      SPRA0 (0x2000922c)                                                      */
/*      SPRB0 (0x2000922c)                                                      */
/*      SPRHBM (0x2000922c)                                                     */
/*      SPRC0 (0x2000922c)                                                      */
/*      SPRMCC (0x2000922c)                                                     */
/*      SPRUCC (0x2000922c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Read LMN Status.
*/


#define CPGC_DPAT_LMN_RDSTAT_1_MCCPGC_MAIN_REG 0x2802922C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lmn_rdstat : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the LMN buffer in read
                               comparison domain.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_LMN_RDSTAT_1_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_LMN_RDSTAT_2_MCCPGC_MAIN_REG supported on:                         */
/*      SPRA0 (0x20009230)                                                      */
/*      SPRB0 (0x20009230)                                                      */
/*      SPRHBM (0x20009230)                                                     */
/*      SPRC0 (0x20009230)                                                      */
/*      SPRMCC (0x20009230)                                                     */
/*      SPRUCC (0x20009230)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Read LMN Status.
*/


#define CPGC_DPAT_LMN_RDSTAT_2_MCCPGC_MAIN_REG 0x28029230

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lmn_rdstat : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the LMN buffer in read
                               comparison domain.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_LMN_RDSTAT_2_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_WRSAVE_0_MCCPGC_MAIN_REG supported on:                      */
/*      SPRA0 (0x20009238)                                                      */
/*      SPRB0 (0x20009238)                                                      */
/*      SPRHBM (0x20009238)                                                     */
/*      SPRC0 (0x20009238)                                                      */
/*      SPRMCC (0x20009238)                                                     */
/*      SPRUCC (0x20009238)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Write PRBS Save.
*/


#define CPGC_DPAT_UNISEQ_WRSAVE_0_MCCPGC_MAIN_REG 0x28029238

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pattern_buffer : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the LFSR Save register
                               in the write domain.[br]
                               CPGC_DPAT_UNISEQ_WRSAVE.Pattern_Buffer will
                               reflect either the initial or last saved value
                               of CPGC_DPAT_UNISEQ_WRSTAT.[br] If PATBUF mode,
                               then Pattern_Buffer is used as a fixed buffer
                               that is output in serial fashion. After all the
                               bits in the Pattern_Buffer have been transmitted
                               the pattern will simply repeat itself
                               continuously while a Test is in progress.[br] If
                               LFSR mode, then this register is used as a seed
                               to a fixed LFSR that is output in serial
                               fashion, following the selected PRBS setting in
                               CPGC_DPAT_XTRA_LFSR_CFG. Over time the LFSR
                               pattern will repeat itself continuously while a
                               Test is in progress.[br] In LFSR Mode the
                               contents of Pattern_Buffer will interact with
                               the LFSR in the following ways:[br] If
                               LFSR_Save_Restore is set then
                               CPGC_DPAT_UNISEQ_WRSAVE will interact with
                               CPGC_DPAT_UNISEQ_WRSTAT in the following
                               ways:[br] 1) CPGC_DPAT_UNISEQ_WRSTAT will be
                               periodically saved into CPGC_DPAT_UNISEQ_WRSAVE
                               based on Save_LFSR_Seed_Rate (see
                               Save_LFSR_Seed_Rate for more details).[br] 2)
                               CPGC_DPAT_UNISEQ_WRSTAT will be periodically
                               reloaded with CPGC_DPAT_UNISEQ_WRSAVE based on
                               Reload_LFSR_Seed_Rate (see Reload_LFSR_Seed_Rate
                               for more details).
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_WRSAVE_0_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_WRSAVE_1_MCCPGC_MAIN_REG supported on:                      */
/*      SPRA0 (0x2000923c)                                                      */
/*      SPRB0 (0x2000923c)                                                      */
/*      SPRHBM (0x2000923c)                                                     */
/*      SPRC0 (0x2000923c)                                                      */
/*      SPRMCC (0x2000923c)                                                     */
/*      SPRUCC (0x2000923c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Write PRBS Save.
*/


#define CPGC_DPAT_UNISEQ_WRSAVE_1_MCCPGC_MAIN_REG 0x2802923C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pattern_buffer : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the LFSR Save register
                               in the write domain.[br]
                               CPGC_DPAT_UNISEQ_WRSAVE.Pattern_Buffer will
                               reflect either the initial or last saved value
                               of CPGC_DPAT_UNISEQ_WRSTAT.[br] If PATBUF mode,
                               then Pattern_Buffer is used as a fixed buffer
                               that is output in serial fashion. After all the
                               bits in the Pattern_Buffer have been transmitted
                               the pattern will simply repeat itself
                               continuously while a Test is in progress.[br] If
                               LFSR mode, then this register is used as a seed
                               to a fixed LFSR that is output in serial
                               fashion, following the selected PRBS setting in
                               CPGC_DPAT_XTRA_LFSR_CFG. Over time the LFSR
                               pattern will repeat itself continuously while a
                               Test is in progress.[br] In LFSR Mode the
                               contents of Pattern_Buffer will interact with
                               the LFSR in the following ways:[br] If
                               LFSR_Save_Restore is set then
                               CPGC_DPAT_UNISEQ_WRSAVE will interact with
                               CPGC_DPAT_UNISEQ_WRSTAT in the following
                               ways:[br] 1) CPGC_DPAT_UNISEQ_WRSTAT will be
                               periodically saved into CPGC_DPAT_UNISEQ_WRSAVE
                               based on Save_LFSR_Seed_Rate (see
                               Save_LFSR_Seed_Rate for more details).[br] 2)
                               CPGC_DPAT_UNISEQ_WRSTAT will be periodically
                               reloaded with CPGC_DPAT_UNISEQ_WRSAVE based on
                               Reload_LFSR_Seed_Rate (see Reload_LFSR_Seed_Rate
                               for more details).
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_WRSAVE_1_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_WRSAVE_2_MCCPGC_MAIN_REG supported on:                      */
/*      SPRA0 (0x20009240)                                                      */
/*      SPRB0 (0x20009240)                                                      */
/*      SPRHBM (0x20009240)                                                     */
/*      SPRC0 (0x20009240)                                                      */
/*      SPRMCC (0x20009240)                                                     */
/*      SPRUCC (0x20009240)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Write PRBS Save.
*/


#define CPGC_DPAT_UNISEQ_WRSAVE_2_MCCPGC_MAIN_REG 0x28029240

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pattern_buffer : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the LFSR Save register
                               in the write domain.[br]
                               CPGC_DPAT_UNISEQ_WRSAVE.Pattern_Buffer will
                               reflect either the initial or last saved value
                               of CPGC_DPAT_UNISEQ_WRSTAT.[br] If PATBUF mode,
                               then Pattern_Buffer is used as a fixed buffer
                               that is output in serial fashion. After all the
                               bits in the Pattern_Buffer have been transmitted
                               the pattern will simply repeat itself
                               continuously while a Test is in progress.[br] If
                               LFSR mode, then this register is used as a seed
                               to a fixed LFSR that is output in serial
                               fashion, following the selected PRBS setting in
                               CPGC_DPAT_XTRA_LFSR_CFG. Over time the LFSR
                               pattern will repeat itself continuously while a
                               Test is in progress.[br] In LFSR Mode the
                               contents of Pattern_Buffer will interact with
                               the LFSR in the following ways:[br] If
                               LFSR_Save_Restore is set then
                               CPGC_DPAT_UNISEQ_WRSAVE will interact with
                               CPGC_DPAT_UNISEQ_WRSTAT in the following
                               ways:[br] 1) CPGC_DPAT_UNISEQ_WRSTAT will be
                               periodically saved into CPGC_DPAT_UNISEQ_WRSAVE
                               based on Save_LFSR_Seed_Rate (see
                               Save_LFSR_Seed_Rate for more details).[br] 2)
                               CPGC_DPAT_UNISEQ_WRSTAT will be periodically
                               reloaded with CPGC_DPAT_UNISEQ_WRSAVE based on
                               Reload_LFSR_Seed_Rate (see Reload_LFSR_Seed_Rate
                               for more details).
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_WRSAVE_2_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_RDSAVE_0_MCCPGC_MAIN_REG supported on:                      */
/*      SPRA0 (0x20009248)                                                      */
/*      SPRB0 (0x20009248)                                                      */
/*      SPRHBM (0x20009248)                                                     */
/*      SPRC0 (0x20009248)                                                      */
/*      SPRMCC (0x20009248)                                                     */
/*      SPRUCC (0x20009248)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Read PRBS Save.
*/


#define CPGC_DPAT_UNISEQ_RDSAVE_0_MCCPGC_MAIN_REG 0x28029248

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pattern_buffer : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the LFSR Save register
                               in the read domain.[br]
                               CPGC_DPAT_UNISEQ_RDSAVE.Pattern_Buffer will
                               reflect either the initial or last saved value
                               of CPGC_DPAT_UNISEQ_RDSTAT.[br] If PATBUF mode,
                               then Pattern_Buffer is used as a fixed buffer
                               that is output in serial fashion. After all the
                               bits in the Pattern_Buffer have been transmitted
                               the pattern will simply repeat itself
                               continuously while a Test is in progress.[br] If
                               LFSR mode, then this register is used as a seed
                               to a fixed LFSR that is output in serial
                               fashion, following the selected PRBS setting in
                               CPGC_DPAT_XTRA_LFSR_CFG. Over time the LFSR
                               pattern will repeat itself continuously while a
                               Test is in progress.[br] In LFSR Mode the
                               contents of Pattern_Buffer will interact with
                               the LFSR in the following ways:[br] If
                               LFSR_Save_Restore is set then
                               CPGC_DPAT_UNISEQ_RDSAVE will interact with
                               CPGC_DPAT_UNISEQ_RDSTAT in the following
                               ways:[br] 1) CPGC_DPAT_UNISEQ_RDSTAT will be
                               periodically saved into CPGC_DPAT_UNISEQ_RDSAVE
                               based on Save_LFSR_Seed_Rate (see
                               Save_LFSR_Seed_Rate for more details).[br] 2)
                               CPGC_DPAT_UNISEQ_RDSTAT will be periodically
                               reloaded with CPGC_DPAT_UNISEQ_RDSAVE based on
                               Reload_LFSR_Seed_Rate (see Reload_LFSR_Seed_Rate
                               for more details).
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_RDSAVE_0_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_RDSAVE_1_MCCPGC_MAIN_REG supported on:                      */
/*      SPRA0 (0x2000924c)                                                      */
/*      SPRB0 (0x2000924c)                                                      */
/*      SPRHBM (0x2000924c)                                                     */
/*      SPRC0 (0x2000924c)                                                      */
/*      SPRMCC (0x2000924c)                                                     */
/*      SPRUCC (0x2000924c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Read PRBS Save.
*/


#define CPGC_DPAT_UNISEQ_RDSAVE_1_MCCPGC_MAIN_REG 0x2802924C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pattern_buffer : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the LFSR Save register
                               in the read domain.[br]
                               CPGC_DPAT_UNISEQ_RDSAVE.Pattern_Buffer will
                               reflect either the initial or last saved value
                               of CPGC_DPAT_UNISEQ_RDSTAT.[br] If PATBUF mode,
                               then Pattern_Buffer is used as a fixed buffer
                               that is output in serial fashion. After all the
                               bits in the Pattern_Buffer have been transmitted
                               the pattern will simply repeat itself
                               continuously while a Test is in progress.[br] If
                               LFSR mode, then this register is used as a seed
                               to a fixed LFSR that is output in serial
                               fashion, following the selected PRBS setting in
                               CPGC_DPAT_XTRA_LFSR_CFG. Over time the LFSR
                               pattern will repeat itself continuously while a
                               Test is in progress.[br] In LFSR Mode the
                               contents of Pattern_Buffer will interact with
                               the LFSR in the following ways:[br] If
                               LFSR_Save_Restore is set then
                               CPGC_DPAT_UNISEQ_RDSAVE will interact with
                               CPGC_DPAT_UNISEQ_RDSTAT in the following
                               ways:[br] 1) CPGC_DPAT_UNISEQ_RDSTAT will be
                               periodically saved into CPGC_DPAT_UNISEQ_RDSAVE
                               based on Save_LFSR_Seed_Rate (see
                               Save_LFSR_Seed_Rate for more details).[br] 2)
                               CPGC_DPAT_UNISEQ_RDSTAT will be periodically
                               reloaded with CPGC_DPAT_UNISEQ_RDSAVE based on
                               Reload_LFSR_Seed_Rate (see Reload_LFSR_Seed_Rate
                               for more details).
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_RDSAVE_1_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_UNISEQ_RDSAVE_2_MCCPGC_MAIN_REG supported on:                      */
/*      SPRA0 (0x20009250)                                                      */
/*      SPRB0 (0x20009250)                                                      */
/*      SPRHBM (0x20009250)                                                     */
/*      SPRC0 (0x20009250)                                                      */
/*      SPRMCC (0x20009250)                                                     */
/*      SPRUCC (0x20009250)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Read PRBS Save.
*/


#define CPGC_DPAT_UNISEQ_RDSAVE_2_MCCPGC_MAIN_REG 0x28029250

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 pattern_buffer : 32;

                            /* Bits[31:0], Access Type=RO/V, default=0x00000000*/

                            /*
                               The current contents of the LFSR Save register
                               in the read domain.[br]
                               CPGC_DPAT_UNISEQ_RDSAVE.Pattern_Buffer will
                               reflect either the initial or last saved value
                               of CPGC_DPAT_UNISEQ_RDSTAT.[br] If PATBUF mode,
                               then Pattern_Buffer is used as a fixed buffer
                               that is output in serial fashion. After all the
                               bits in the Pattern_Buffer have been transmitted
                               the pattern will simply repeat itself
                               continuously while a Test is in progress.[br] If
                               LFSR mode, then this register is used as a seed
                               to a fixed LFSR that is output in serial
                               fashion, following the selected PRBS setting in
                               CPGC_DPAT_XTRA_LFSR_CFG. Over time the LFSR
                               pattern will repeat itself continuously while a
                               Test is in progress.[br] In LFSR Mode the
                               contents of Pattern_Buffer will interact with
                               the LFSR in the following ways:[br] If
                               LFSR_Save_Restore is set then
                               CPGC_DPAT_UNISEQ_RDSAVE will interact with
                               CPGC_DPAT_UNISEQ_RDSTAT in the following
                               ways:[br] 1) CPGC_DPAT_UNISEQ_RDSTAT will be
                               periodically saved into CPGC_DPAT_UNISEQ_RDSAVE
                               based on Save_LFSR_Seed_Rate (see
                               Save_LFSR_Seed_Rate for more details).[br] 2)
                               CPGC_DPAT_UNISEQ_RDSTAT will be periodically
                               reloaded with CPGC_DPAT_UNISEQ_RDSAVE based on
                               Reload_LFSR_Seed_Rate (see Reload_LFSR_Seed_Rate
                               for more details).
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_UNISEQ_RDSAVE_2_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_LNEN_LO_MCCPGC_MAIN_REG supported on:                               */
/*      SPRA0 (0x20009258)                                                      */
/*      SPRB0 (0x20009258)                                                      */
/*      SPRHBM (0x20009258)                                                     */
/*      SPRC0 (0x20009258)                                                      */
/*      SPRMCC (0x20009258)                                                     */
/*      SPRUCC (0x20009258)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Lane Error Checking Disable Mask for Byte Groups 0-3.
*/


#define CPGC_ERR_LNEN_LO_MCCPGC_MAIN_REG 0x28029258

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_errchk_mask_lo : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               A mask used to disable error checking on data
                               lanes [31:0]. Lanes selected through this mask
                               will not be checked for errors. The lane-to-bit
                               mapping for this mask is given by the following
                               formula: Lane[n] -> bit[n].[br] When DQ lanes
                               are < 64 (or 72), such as for a x16 channel,
                               unused lanes are automatically masked in
                               hardware. It is recommended that the user
                               program the mask for consistency.[br] Only Lanes
                               with a corresponding bit value of 0 will be
                               checked for errors.
                            */

  } Bits;
  UINT32 Data;

} CPGC_ERR_LNEN_LO_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_LNEN_HI_MCCPGC_MAIN_REG supported on:                               */
/*      SPRA0 (0x2000925c)                                                      */
/*      SPRB0 (0x2000925c)                                                      */
/*      SPRHBM (0x2000925c)                                                     */
/*      SPRC0 (0x2000925c)                                                      */
/*      SPRMCC (0x2000925c)                                                     */
/*      SPRUCC (0x2000925c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Lane Error Checking Disable Mask for Byte Groups 4-7 or Extended Chunk Check Enable.
*/


#define CPGC_ERR_LNEN_HI_MCCPGC_MAIN_REG 0x2802925C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_errchk_mask_hi : 32;

                            /* Bits[31:0], Access Type=RW, default=0x00000000*/

                            /*
                               A mask used to disable error checking on data
                               lanes [63:32]. Lanes selected through this mask
                               will not be checked for errors. The lane-to-bit
                               mapping for this mask is given by the following
                               formula: Lane[n+32] -> bit[n].[br] Only Lanes
                               with a corresponding bit value of 0 will be
                               checked for errors.[br] When DQ lanes are < 64
                               (or 72), such as for a x32 or x16 channel,
                               unused lanes are automatically masked in
                               hardware. It is recommended that the user
                               program the mask for consistency.[br]
                               Functionality will change with special mapping
                               when DQ lanes is < 64 (or 72) such that
                               ChunkMask (UI Enable) will move to this field
                               starting at lane [...:32] extending the
                               necessary number of bits for a full cache line
                               of data. The mask in ERR_CTL will be unused for
                               these narrower busses.[br] Only Chunks with a
                               corresponding bit value of 1 will be checked for
                               errors.
                            */

  } Bits;
  UINT32 Data;

} CPGC_ERR_LNEN_HI_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_XLNEN_MCCPGC_MAIN_REG supported on:                                 */
/*      SPRA0 (0x20009260)                                                      */
/*      SPRB0 (0x20009260)                                                      */
/*      SPRHBM (0x20009260)                                                     */
/*      SPRC0 (0x20009260)                                                      */
/*      SPRMCC (0x20009260)                                                     */
/*      SPRUCC (0x20009260)                                                     */
/* Register default value on SPRA0: 0x000000FF                                  */
/* Register default value on SPRB0: 0x000000FF                                  */
/* Register default value on SPRHBM: 0x000000FF                                 */
/* Register default value on SPRC0: 0x000000FF                                  */
/* Register default value on SPRMCC: 0x000000FF                                 */
/* Register default value on SPRUCC: 0x000000FF                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* ECC Lane and Rank Error Disable Mask.
*/


#define CPGC_ERR_XLNEN_MCCPGC_MAIN_REG 0x28029260

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecc_errchk_mask : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000FF*/

                            /*
                               A mask used to disable error checking on ECC
                               lanes. Lanes selected through the mask will not
                               be checked for errors. The lane-to-bit mapping
                               is 1-to-1 and hence field bit 0 corresponds to
                               ECC lane 0, field bit 1 corresponds to ECC lane
                               1, and so on.[br] Note: This field is available
                               only if ECC is supported. The default state is
                               to disable ECC checking.[br] An active
                               CPGC_DPAT_CFG.ECC_DISABLE automatically masks
                               ECC lanes, but it is recommended that this field
                               be programmed for consistency.[br] Only Lanes
                               with a corresponding bit value of 0 will be
                               checked for errors.
                            */
    UINT32 rsvd : 8;

                            /* Bits[15:8], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rank_errchk_mask : 8;

                            /* Bits[23:16], Access Type=RW, default=0x00000000*/

                            /*
                               A mask used to disable error checking on entire
                               Ranks. Ranks selected through the mask will not
                               be checked for errors. The rank-to-bit mapping
                               is 1-to-1 and hence field bit 0 corresponds to
                               Rank 0, field bit 1 corresponds to Rank 1, and
                               so on.[br] Only Ranks with a corresponding bit
                               value of 0 will be checked for errors.
                            */
    UINT32 rsvd_24 : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_XLNEN_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CTL_MCCPGC_MAIN_REG supported on:                                   */
/*      SPRA0 (0x20009264)                                                      */
/*      SPRB0 (0x20009264)                                                      */
/*      SPRHBM (0x20009264)                                                     */
/*      SPRC0 (0x20009264)                                                      */
/*      SPRMCC (0x20009264)                                                     */
/*      SPRUCC (0x20009264)                                                     */
/* Register default value on SPRA0: 0xFFFF0100                                  */
/* Register default value on SPRB0: 0xFFFF0100                                  */
/* Register default value on SPRHBM: 0xFFFF0100                                 */
/* Register default value on SPRC0: 0xFFFF0100                                  */
/* Register default value on SPRMCC: 0xFFFF0100                                 */
/* Register default value on SPRUCC: 0xFFFF0100                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Control for Error Checker.
*/


#define CPGC_ERR_CTL_MCCPGC_MAIN_REG 0x28029264

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 stop_on_n : 6;

                            /* Bits[5:0], Access Type=RW, default=0x00000000*/

                            /*
                               If STOP_ON_ERROR is set to Stop on Nth Error
                               Mode, the test will stop after (STOP_ON_N + 1)
                               or more errors have been accumulated in the Nth
                               Error Count Status (Nth_ERROR). One Error is
                               counted if any unmasked lane in an enabled UI
                               has miscompares.
                            */
    UINT32 rsvd : 2;

                            /* Bits[7:6], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 be_train_err_en : 1;

                            /* Bits[8:8], Access Type=RW, default=0x00000001*/

                            /*
                               Enable BE Training Error Detection Feature. If
                               0, then special encodings on the transaction
                               command types are possible and the Algorithm
                               Instruction Control BE_TRAIN_EN bit is used to
                               select the specific cycle type. See the
                               documentation for specifics. Default should be 1
                               to enable MWrPtl etc.
                            */
    UINT32 rsvd_9 : 3;

                            /* Bits[11:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 stop_on_error_ctl : 2;

                            /* Bits[13:12], Access Type=RW, default=0x00000000*/

                            /*
                               Defines test stop conditions based on error
                               checking as follows:[br] 00 - Never stop:
                               Prevents any error from stopping the test.[br]
                               01 - Stop On Nth Error: Stop once Nth Error
                               Count Status (Nth_ERROR) has accumulated at
                               least (STOP_ON_N + 1) errors.[br] 10 - Stop On
                               All Byte Groups Error: Stop if every byte group
                               indicates that at least one of its lanes
                               accumulated at least one error. That is, if all
                               bits BYTEGRP_ERR_STAT, (and ECC_GRP_ERR_STAT if
                               supported), are all set.[br] 11 - Stop On All
                               Lanes Error: Stop if every lane within every
                               byte group has accumulated at least one
                               error.[br] That is, if all bits in
                               LANE_ERR_STAT_LO, LANE_ERR_STAT_HI, (and
                               LANE_ERR_STATECC if supported) are all set.
                            */
    UINT32 rsvd_14 : 2;

                            /* Bits[15:14], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 errchk_mask_chunk : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000FF*/

                            /*
                               Defines a periodic chunk (UI) check enable
                               mask.[br] CPGC: This field is only used for full
                               width (64bit) DQ busses. Otherwise the upper 32
                               bits of the Lane Mask (CPGC_ERR_LNEN_HI) is used
                               as the Chunk Enable.[br] Direct Mode/Loopback:
                               This field is used for all DQ sizes.[br] This
                               mask is used for 8 chunks (UI) and repeats as
                               follows:[br] Bit 0 - Chunk 0[br] Bit 1 - Chunk
                               1[br] ...[br] Bit 7 - Chunk 7[br] Only chunks
                               with a corresponding bit value of 1 will be
                               checked for errors.
                            */
    UINT32 errchk_mask_cacheline : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000FF*/

                            /*
                               Defines a periodic burst check enable mask.[br]
                               CPGC Mode: Burst = Cache-Line (64 Bytes) worth
                               of data being checked.[br] Direct Mode/Loopback:
                               Burst = 8-UI worth of data being checked.[br]
                               This mask is used for 8 Bursts and repeats as
                               follows:[br] Bit 0 - Burst 0.[br] Bit 1 - Burst
                               1.[br] ...[br] Bit 7 - Burst 7.[br] Only bursts
                               with a corresponding bit value of 1 will be
                               checked for errors. [br] In Loopback each bit of
                               this register controls the check of each
                               ByteTime (8-bits) on the bus for all DQ sizes.
                            */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CTL_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_STAT03_MCCPGC_MAIN_REG supported on:                                */
/*      SPRA0 (0x20009268)                                                      */
/*      SPRB0 (0x20009268)                                                      */
/*      SPRHBM (0x20009268)                                                     */
/*      SPRC0 (0x20009268)                                                      */
/*      SPRMCC (0x20009268)                                                     */
/*      SPRUCC (0x20009268)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Error Status DQ Lanes 31-0.
*/


#define CPGC_ERR_STAT03_MCCPGC_MAIN_REG 0x28029268

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lane_err_stat_lo : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Indicates if a mismatch was detected between the
                               WR and the RD data on one of the lanes belonging
                               to byte groups 0 - 3. Hence lanes [31:0] map to
                               bits [31:0] respectively. The error status
                               information is encoded as follows:[br] 0: No
                               mismatches detected on corresponding lane.[br]
                               1: At least one mismatch detected on
                               corresponding lane.[br] Cleared on Local Clear
                               Errors.
                            */

  } Bits;
  UINT32 Data;

} CPGC_ERR_STAT03_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_STAT47_MCCPGC_MAIN_REG supported on:                                */
/*      SPRA0 (0x2000926c)                                                      */
/*      SPRB0 (0x2000926c)                                                      */
/*      SPRHBM (0x2000926c)                                                     */
/*      SPRC0 (0x2000926c)                                                      */
/*      SPRMCC (0x2000926c)                                                     */
/*      SPRUCC (0x2000926c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Error Status DQ Lanes 63-32.
*/


#define CPGC_ERR_STAT47_MCCPGC_MAIN_REG 0x2802926C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 lane_err_stat_hi : 32;

                            /* Bits[31:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Indicates if a mismatch was detected between the
                               WR and the RD data on one of the lanes belonging
                               to byte groups 4 - 7. Hence lanes [63:32] map to
                               bits [31:0] respectively.[br] If there are 32 or
                               less data lanes in the current channel
                               configuration, then this register is used to
                               indicate the Extended Chunk Error Status, and
                               the Chunk Error Status in ECC_CHNK_RANK_STAT is
                               not used. Chunks 0 through 15 (32-bit bus) or 0
                               through 31 (16-bit bus).[br] The error status
                               information is encoded as follows:[br] 0: No
                               mismatches detected on corresponding lane
                               (chunk).[br] 1: At least one mismatch detected
                               on corresponding lane (chunk).[br] Cleared on
                               Local Clear Errors.
                            */

  } Bits;
  UINT32 Data;

} CPGC_ERR_STAT47_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_ECC_CHNK_RANK_STAT_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x20009270)                                                      */
/*      SPRB0 (0x20009270)                                                      */
/*      SPRHBM (0x20009270)                                                     */
/*      SPRC0 (0x20009270)                                                      */
/*      SPRMCC (0x20009270)                                                     */
/*      SPRUCC (0x20009270)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Error Status for ECC, Chunks and Ranks.
*/


#define CPGC_ERR_ECC_CHNK_RANK_STAT_MCCPGC_MAIN_REG 0x28029270

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 ecc_lane_err_stat : 8;

                            /* Bits[7:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               A fag field which indicates if a mismatch was
                               detected between the WR and the RD data on one
                               of the lanes belonging to the ECC byte group.
                               The error status information is encoded as
                               follows:[br] 0: No mismatches detected on
                               corresponding lane.[br] 1: At least one mismatch
                               detected on corresponding lane.[br] Note: this
                               field is only available if ECC is supported for
                               the current implementation, otherwise it is
                               reserved.[br] If BE Training Enable is set then
                               this field indicates that the particular BE lane
                               had a fault during the write pass.[br] Cleared
                               on Local Clear Errors.
                            */
    UINT32 chunk_err_stat : 8;

                            /* Bits[15:8], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               A flag field where each bit corresponds to a
                               specific chunk (i.e. bit within a burst of
                               8-bits). If set, the corresponding chunk (UI)
                               has accumulated at least one error.[br] Cleared
                               on Local Clear Errors.
                            */
    UINT32 rank_err_stat : 8;

                            /* Bits[23:16], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               A status field where each bit corresponds to a
                               specific rank. If set, the corresponding rank
                               has accumulated at least one error.[br] Cleared
                               on Local Clear Errors.
                            */
    UINT32 rsvd : 8;

                            /* Bits[31:24], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_ECC_CHNK_RANK_STAT_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_BYTE_NTH_PAR_STAT_MCCPGC_MAIN_REG supported on:                     */
/*      SPRA0 (0x20009274)                                                      */
/*      SPRB0 (0x20009274)                                                      */
/*      SPRHBM (0x20009274)                                                     */
/*      SPRC0 (0x20009274)                                                      */
/*      SPRMCC (0x20009274)                                                     */
/*      SPRUCC (0x20009274)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Error Status for ByteGroup and Error Stop.
*/


#define CPGC_ERR_BYTE_NTH_PAR_STAT_MCCPGC_MAIN_REG 0x28029274

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 bytegrp_err_stat : 8;

                            /* Bits[7:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A flag field with each bit corresponding to a
                               specific byte group. Bit 0 corresponds to byte
                               group 0, bit 1 corresponds to byte group 1, bit
                               2 corresponds to byte group 2, and so on. A set
                               bit implies that the corresponding byte group
                               has at least one lane that accumulated at least
                               one error.[br] When BE Training Enable is set
                               (and ECC disabled), then this field will
                               indicate that a data error has occurred that was
                               not due to the corresponding BE signal.[br] Can
                               also be cleared on Local Clear Errors or
                               Global_Control and a Global_Clear_Errors.
                            */
    UINT32 eccgrp_err_stat : 1;

                            /* Bits[8:8], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               A set bit implies that the ECC bytegroup has at
                               least one lane that accumulated at least one
                               error.[br] Can also be cleared on Local Clear
                               Errors or Global_Control and a
                               Global_Clear_Errors.
                            */
    UINT32 rsvd : 11;

                            /* Bits[19:9], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 rd_chunk_num_stat : 3;

                            /* Bits[22:20], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               RD_Chunk_Num_Status corresponds to the chunk
                               number being read out of the EXTBUF for a
                               comparison operation while logging an error
                               during Loopback.Pattern.[br] RD_Chunk_Num_Status
                               can be cleared by setting Local_Clear_Errors to
                               1 or via a Global_Clear_Bind and
                               Global_Clear_Errors.
                            */
    UINT32 rsvd_23 : 1;

                            /* Bits[23:23], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 nth_error : 6;

                            /* Bits[29:24], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Nth_Error Count Status indicates the current Nth
                               Error that has occurred.[br] Nth_Error will roll
                               over upon exceeding its maximum value.[br] An
                               Nth error is defined as 1 or more lane
                               miscompares within a single comparison cycle
                               (i.e. Chunk).[br] This field is auto cleared on
                               Start_Test and is not cleared via ClearErrors.
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_BYTE_NTH_PAR_STAT_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTRCTL_0_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x20009278)                                                      */
/*      SPRB0 (0x20009278)                                                      */
/*      SPRHBM (0x20009278)                                                     */
/*      SPRC0 (0x20009278)                                                      */
/*      SPRMCC (0x20009278)                                                     */
/*      SPRUCC (0x20009278)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Counter Control is used to control what is captured in the CPGC_ERR_ERRCNTR#
*/


#define CPGC_ERR_CNTRCTL_0_MCCPGC_MAIN_REG 0x28029278

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 counter_pointer : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               Used in conjunction with Counter_Control to
                               indicate which Lane, which ByteLane or which
                               Chunk the CPGC_ERR_CNTR_#.Error_Counter will
                               count errors on.
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 counter_control_sel : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_SEL controls the item that is
                               considered when COUNTER_CONTROL_SCOPE is set to
                               Particular mode.[br] COUNTER_POINTER value is
                               used to select which of the Particular item is
                               being counted.[br] 00 Count Errors on Particular
                               Lane.[br] 01 Count Errors on Particular
                               ByteGroup.[br] 10 Count Errors on Particular
                               NibbleGroup.[br] 11 Count Errors on Particular
                               UI. (Also required to set in
                               COUNTER_CONTROL_SCOPE and COUNTER_CONTROL_UI.)
                            */
    UINT32 counter_control_ui : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_UI selects which UI will be
                               considered when counting of errors.[br] 00 Count
                               Errors on All UI.[br] 01 Count Errors on Even
                               UI.[br] 10 Count Errors on Odd UI.[br] 11 Count
                               Errors on Particular UI. (Also required to set
                               in COUNTER_CONTROL_SCOPE and
                               COUNTER_CONTROL_SEL[br] If COUNTER_CONTROL_SEL
                               is not 11, then this setting is ignored and
                               overridden to 00.)
                            */
    UINT32 counter_control_scope : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br] 0 Non
                               Specific Selection (Pointer Unused).[br] 1
                               Particular Lane/ByteGroup/NibbleGroup/UI
                               Selection.
                            */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTRCTL_0_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTRCTL_1_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x2000927c)                                                      */
/*      SPRB0 (0x2000927c)                                                      */
/*      SPRHBM (0x2000927c)                                                     */
/*      SPRC0 (0x2000927c)                                                      */
/*      SPRMCC (0x2000927c)                                                     */
/*      SPRUCC (0x2000927c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Counter Control is used to control what is captured in the CPGC_ERR_ERRCNTR#
*/


#define CPGC_ERR_CNTRCTL_1_MCCPGC_MAIN_REG 0x2802927C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 counter_pointer : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               Used in conjunction with Counter_Control to
                               indicate which Lane, which ByteLane or which
                               Chunk the CPGC_ERR_CNTR_#.Error_Counter will
                               count errors on.
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 counter_control_sel : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_SEL controls the item that is
                               considered when COUNTER_CONTROL_SCOPE is set to
                               Particular mode.[br] COUNTER_POINTER value is
                               used to select which of the Particular item is
                               being counted.[br] 00 Count Errors on Particular
                               Lane.[br] 01 Count Errors on Particular
                               ByteGroup.[br] 10 Count Errors on Particular
                               NibbleGroup.[br] 11 Count Errors on Particular
                               UI. (Also required to set in
                               COUNTER_CONTROL_SCOPE and COUNTER_CONTROL_UI.)
                            */
    UINT32 counter_control_ui : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_UI selects which UI will be
                               considered when counting of errors.[br] 00 Count
                               Errors on All UI.[br] 01 Count Errors on Even
                               UI.[br] 10 Count Errors on Odd UI.[br] 11 Count
                               Errors on Particular UI. (Also required to set
                               in COUNTER_CONTROL_SCOPE and
                               COUNTER_CONTROL_SEL[br] If COUNTER_CONTROL_SEL
                               is not 11, then this setting is ignored and
                               overridden to 00.)
                            */
    UINT32 counter_control_scope : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br] 0 Non
                               Specific Selection (Pointer Unused).[br] 1
                               Particular Lane/ByteGroup/NibbleGroup/UI
                               Selection.
                            */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTRCTL_1_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTRCTL_2_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x20009280)                                                      */
/*      SPRB0 (0x20009280)                                                      */
/*      SPRHBM (0x20009280)                                                     */
/*      SPRC0 (0x20009280)                                                      */
/*      SPRMCC (0x20009280)                                                     */
/*      SPRUCC (0x20009280)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Counter Control is used to control what is captured in the CPGC_ERR_ERRCNTR#
*/


#define CPGC_ERR_CNTRCTL_2_MCCPGC_MAIN_REG 0x28029280

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 counter_pointer : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               Used in conjunction with Counter_Control to
                               indicate which Lane, which ByteLane or which
                               Chunk the CPGC_ERR_CNTR_#.Error_Counter will
                               count errors on.
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 counter_control_sel : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_SEL controls the item that is
                               considered when COUNTER_CONTROL_SCOPE is set to
                               Particular mode.[br] COUNTER_POINTER value is
                               used to select which of the Particular item is
                               being counted.[br] 00 Count Errors on Particular
                               Lane.[br] 01 Count Errors on Particular
                               ByteGroup.[br] 10 Count Errors on Particular
                               NibbleGroup.[br] 11 Count Errors on Particular
                               UI. (Also required to set in
                               COUNTER_CONTROL_SCOPE and COUNTER_CONTROL_UI.)
                            */
    UINT32 counter_control_ui : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_UI selects which UI will be
                               considered when counting of errors.[br] 00 Count
                               Errors on All UI.[br] 01 Count Errors on Even
                               UI.[br] 10 Count Errors on Odd UI.[br] 11 Count
                               Errors on Particular UI. (Also required to set
                               in COUNTER_CONTROL_SCOPE and
                               COUNTER_CONTROL_SEL[br] If COUNTER_CONTROL_SEL
                               is not 11, then this setting is ignored and
                               overridden to 00.)
                            */
    UINT32 counter_control_scope : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br] 0 Non
                               Specific Selection (Pointer Unused).[br] 1
                               Particular Lane/ByteGroup/NibbleGroup/UI
                               Selection.
                            */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTRCTL_2_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTRCTL_3_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x20009284)                                                      */
/*      SPRB0 (0x20009284)                                                      */
/*      SPRHBM (0x20009284)                                                     */
/*      SPRC0 (0x20009284)                                                      */
/*      SPRMCC (0x20009284)                                                     */
/*      SPRUCC (0x20009284)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Counter Control is used to control what is captured in the CPGC_ERR_ERRCNTR#
*/


#define CPGC_ERR_CNTRCTL_3_MCCPGC_MAIN_REG 0x28029284

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 counter_pointer : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               Used in conjunction with Counter_Control to
                               indicate which Lane, which ByteLane or which
                               Chunk the CPGC_ERR_CNTR_#.Error_Counter will
                               count errors on.
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 counter_control_sel : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_SEL controls the item that is
                               considered when COUNTER_CONTROL_SCOPE is set to
                               Particular mode.[br] COUNTER_POINTER value is
                               used to select which of the Particular item is
                               being counted.[br] 00 Count Errors on Particular
                               Lane.[br] 01 Count Errors on Particular
                               ByteGroup.[br] 10 Count Errors on Particular
                               NibbleGroup.[br] 11 Count Errors on Particular
                               UI. (Also required to set in
                               COUNTER_CONTROL_SCOPE and COUNTER_CONTROL_UI.)
                            */
    UINT32 counter_control_ui : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_UI selects which UI will be
                               considered when counting of errors.[br] 00 Count
                               Errors on All UI.[br] 01 Count Errors on Even
                               UI.[br] 10 Count Errors on Odd UI.[br] 11 Count
                               Errors on Particular UI. (Also required to set
                               in COUNTER_CONTROL_SCOPE and
                               COUNTER_CONTROL_SEL[br] If COUNTER_CONTROL_SEL
                               is not 11, then this setting is ignored and
                               overridden to 00.)
                            */
    UINT32 counter_control_scope : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br] 0 Non
                               Specific Selection (Pointer Unused).[br] 1
                               Particular Lane/ByteGroup/NibbleGroup/UI
                               Selection.
                            */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTRCTL_3_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTRCTL_4_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x20009288)                                                      */
/*      SPRB0 (0x20009288)                                                      */
/*      SPRHBM (0x20009288)                                                     */
/*      SPRC0 (0x20009288)                                                      */
/*      SPRMCC (0x20009288)                                                     */
/*      SPRUCC (0x20009288)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Counter Control is used to control what is captured in the CPGC_ERR_ERRCNTR#
*/


#define CPGC_ERR_CNTRCTL_4_MCCPGC_MAIN_REG 0x28029288

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 counter_pointer : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               Used in conjunction with Counter_Control to
                               indicate which Lane, which ByteLane or which
                               Chunk the CPGC_ERR_CNTR_#.Error_Counter will
                               count errors on.
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 counter_control_sel : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_SEL controls the item that is
                               considered when COUNTER_CONTROL_SCOPE is set to
                               Particular mode.[br] COUNTER_POINTER value is
                               used to select which of the Particular item is
                               being counted.[br] 00 Count Errors on Particular
                               Lane.[br] 01 Count Errors on Particular
                               ByteGroup.[br] 10 Count Errors on Particular
                               NibbleGroup.[br] 11 Count Errors on Particular
                               UI. (Also required to set in
                               COUNTER_CONTROL_SCOPE and COUNTER_CONTROL_UI.)
                            */
    UINT32 counter_control_ui : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_UI selects which UI will be
                               considered when counting of errors.[br] 00 Count
                               Errors on All UI.[br] 01 Count Errors on Even
                               UI.[br] 10 Count Errors on Odd UI.[br] 11 Count
                               Errors on Particular UI. (Also required to set
                               in COUNTER_CONTROL_SCOPE and
                               COUNTER_CONTROL_SEL[br] If COUNTER_CONTROL_SEL
                               is not 11, then this setting is ignored and
                               overridden to 00.)
                            */
    UINT32 counter_control_scope : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br] 0 Non
                               Specific Selection (Pointer Unused).[br] 1
                               Particular Lane/ByteGroup/NibbleGroup/UI
                               Selection.
                            */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTRCTL_4_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTRCTL_5_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x2000928c)                                                      */
/*      SPRB0 (0x2000928c)                                                      */
/*      SPRHBM (0x2000928c)                                                     */
/*      SPRC0 (0x2000928c)                                                      */
/*      SPRMCC (0x2000928c)                                                     */
/*      SPRUCC (0x2000928c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Counter Control is used to control what is captured in the CPGC_ERR_ERRCNTR#
*/


#define CPGC_ERR_CNTRCTL_5_MCCPGC_MAIN_REG 0x2802928C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 counter_pointer : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               Used in conjunction with Counter_Control to
                               indicate which Lane, which ByteLane or which
                               Chunk the CPGC_ERR_CNTR_#.Error_Counter will
                               count errors on.
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 counter_control_sel : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_SEL controls the item that is
                               considered when COUNTER_CONTROL_SCOPE is set to
                               Particular mode.[br] COUNTER_POINTER value is
                               used to select which of the Particular item is
                               being counted.[br] 00 Count Errors on Particular
                               Lane.[br] 01 Count Errors on Particular
                               ByteGroup.[br] 10 Count Errors on Particular
                               NibbleGroup.[br] 11 Count Errors on Particular
                               UI. (Also required to set in
                               COUNTER_CONTROL_SCOPE and COUNTER_CONTROL_UI.)
                            */
    UINT32 counter_control_ui : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_UI selects which UI will be
                               considered when counting of errors.[br] 00 Count
                               Errors on All UI.[br] 01 Count Errors on Even
                               UI.[br] 10 Count Errors on Odd UI.[br] 11 Count
                               Errors on Particular UI. (Also required to set
                               in COUNTER_CONTROL_SCOPE and
                               COUNTER_CONTROL_SEL[br] If COUNTER_CONTROL_SEL
                               is not 11, then this setting is ignored and
                               overridden to 00.)
                            */
    UINT32 counter_control_scope : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br] 0 Non
                               Specific Selection (Pointer Unused).[br] 1
                               Particular Lane/ByteGroup/NibbleGroup/UI
                               Selection.
                            */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTRCTL_5_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTRCTL_6_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x20009290)                                                      */
/*      SPRB0 (0x20009290)                                                      */
/*      SPRHBM (0x20009290)                                                     */
/*      SPRC0 (0x20009290)                                                      */
/*      SPRMCC (0x20009290)                                                     */
/*      SPRUCC (0x20009290)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Counter Control is used to control what is captured in the CPGC_ERR_ERRCNTR#
*/


#define CPGC_ERR_CNTRCTL_6_MCCPGC_MAIN_REG 0x28029290

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 counter_pointer : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               Used in conjunction with Counter_Control to
                               indicate which Lane, which ByteLane or which
                               Chunk the CPGC_ERR_CNTR_#.Error_Counter will
                               count errors on.
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 counter_control_sel : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_SEL controls the item that is
                               considered when COUNTER_CONTROL_SCOPE is set to
                               Particular mode.[br] COUNTER_POINTER value is
                               used to select which of the Particular item is
                               being counted.[br] 00 Count Errors on Particular
                               Lane.[br] 01 Count Errors on Particular
                               ByteGroup.[br] 10 Count Errors on Particular
                               NibbleGroup.[br] 11 Count Errors on Particular
                               UI. (Also required to set in
                               COUNTER_CONTROL_SCOPE and COUNTER_CONTROL_UI.)
                            */
    UINT32 counter_control_ui : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_UI selects which UI will be
                               considered when counting of errors.[br] 00 Count
                               Errors on All UI.[br] 01 Count Errors on Even
                               UI.[br] 10 Count Errors on Odd UI.[br] 11 Count
                               Errors on Particular UI. (Also required to set
                               in COUNTER_CONTROL_SCOPE and
                               COUNTER_CONTROL_SEL[br] If COUNTER_CONTROL_SEL
                               is not 11, then this setting is ignored and
                               overridden to 00.)
                            */
    UINT32 counter_control_scope : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br] 0 Non
                               Specific Selection (Pointer Unused).[br] 1
                               Particular Lane/ByteGroup/NibbleGroup/UI
                               Selection.
                            */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTRCTL_6_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTRCTL_7_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x20009294)                                                      */
/*      SPRB0 (0x20009294)                                                      */
/*      SPRHBM (0x20009294)                                                     */
/*      SPRC0 (0x20009294)                                                      */
/*      SPRMCC (0x20009294)                                                     */
/*      SPRUCC (0x20009294)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Counter Control is used to control what is captured in the CPGC_ERR_ERRCNTR#
*/


#define CPGC_ERR_CNTRCTL_7_MCCPGC_MAIN_REG 0x28029294

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 counter_pointer : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               Used in conjunction with Counter_Control to
                               indicate which Lane, which ByteLane or which
                               Chunk the CPGC_ERR_CNTR_#.Error_Counter will
                               count errors on.
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 counter_control_sel : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_SEL controls the item that is
                               considered when COUNTER_CONTROL_SCOPE is set to
                               Particular mode.[br] COUNTER_POINTER value is
                               used to select which of the Particular item is
                               being counted.[br] 00 Count Errors on Particular
                               Lane.[br] 01 Count Errors on Particular
                               ByteGroup.[br] 10 Count Errors on Particular
                               NibbleGroup.[br] 11 Count Errors on Particular
                               UI. (Also required to set in
                               COUNTER_CONTROL_SCOPE and COUNTER_CONTROL_UI.)
                            */
    UINT32 counter_control_ui : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_UI selects which UI will be
                               considered when counting of errors.[br] 00 Count
                               Errors on All UI.[br] 01 Count Errors on Even
                               UI.[br] 10 Count Errors on Odd UI.[br] 11 Count
                               Errors on Particular UI. (Also required to set
                               in COUNTER_CONTROL_SCOPE and
                               COUNTER_CONTROL_SEL[br] If COUNTER_CONTROL_SEL
                               is not 11, then this setting is ignored and
                               overridden to 00.)
                            */
    UINT32 counter_control_scope : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br] 0 Non
                               Specific Selection (Pointer Unused).[br] 1
                               Particular Lane/ByteGroup/NibbleGroup/UI
                               Selection.
                            */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTRCTL_7_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTRCTL_8_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x20009298)                                                      */
/*      SPRB0 (0x20009298)                                                      */
/*      SPRHBM (0x20009298)                                                     */
/*      SPRC0 (0x20009298)                                                      */
/*      SPRMCC (0x20009298)                                                     */
/*      SPRUCC (0x20009298)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Counter Control is used to control what is captured in the CPGC_ERR_ERRCNTR#
*/


#define CPGC_ERR_CNTRCTL_8_MCCPGC_MAIN_REG 0x28029298

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 counter_pointer : 7;

                            /* Bits[6:0], Access Type=RW, default=0x00000000*/

                            /*
                               Used in conjunction with Counter_Control to
                               indicate which Lane, which ByteLane or which
                               Chunk the CPGC_ERR_CNTR_#.Error_Counter will
                               count errors on.
                            */
    UINT32 rsvd : 1;

                            /* Bits[7:7], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 counter_control_sel : 2;

                            /* Bits[9:8], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_SEL controls the item that is
                               considered when COUNTER_CONTROL_SCOPE is set to
                               Particular mode.[br] COUNTER_POINTER value is
                               used to select which of the Particular item is
                               being counted.[br] 00 Count Errors on Particular
                               Lane.[br] 01 Count Errors on Particular
                               ByteGroup.[br] 10 Count Errors on Particular
                               NibbleGroup.[br] 11 Count Errors on Particular
                               UI. (Also required to set in
                               COUNTER_CONTROL_SCOPE and COUNTER_CONTROL_UI.)
                            */
    UINT32 counter_control_ui : 2;

                            /* Bits[11:10], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br]
                               COUNTER_CONTROL_UI selects which UI will be
                               considered when counting of errors.[br] 00 Count
                               Errors on All UI.[br] 01 Count Errors on Even
                               UI.[br] 10 Count Errors on Odd UI.[br] 11 Count
                               Errors on Particular UI. (Also required to set
                               in COUNTER_CONTROL_SCOPE and
                               COUNTER_CONTROL_SEL[br] If COUNTER_CONTROL_SEL
                               is not 11, then this setting is ignored and
                               overridden to 00.)
                            */
    UINT32 counter_control_scope : 1;

                            /* Bits[12:12], Access Type=RW, default=0x00000000*/

                            /*
                               COUNTER_CONTROL_SCOPE, COUNTER_CONTROL_UI and
                               COUNTER_CONTROL_SEL determines what gets counted
                               by CPGC_ERR_CNTR_#.Error_Counter.[br] 0 Non
                               Specific Selection (Pointer Unused).[br] 1
                               Particular Lane/ByteGroup/NibbleGroup/UI
                               Selection.
                            */
    UINT32 rsvd_13 : 19;

                            /* Bits[31:13], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTRCTL_8_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTR_0_MCCPGC_MAIN_REG supported on:                                */
/*      SPRA0 (0x200092a0)                                                      */
/*      SPRB0 (0x200092a0)                                                      */
/*      SPRHBM (0x200092a0)                                                     */
/*      SPRC0 (0x200092a0)                                                      */
/*      SPRMCC (0x200092a0)                                                     */
/*      SPRUCC (0x200092a0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Indicates the current error counter value.
*/


#define CPGC_ERR_CNTR_0_MCCPGC_MAIN_REG 0x280292A0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 error_counter : 23;

                            /* Bits[22:0], Access Type=RW/1S/V/P, default=0x00000000*/

                            /*
                               CPGC_ERR_ERRCNTR indicates the current error
                               counter value which is configured by
                               CPGC_ERR_CNTRCTL.Counter_Control. The
                               Counter_Status will not saturate and will wrap
                               around, but any overflow of this counter will
                               set the corresponding overflow status bit in CPG
                               C_ERR_ERRCNTR_OVERFLOW_STATUS.ERROR_COUNTER_OVER
                               FLOW.[br] Counter_Status can only be cleared by
                               setting Local_Clear_Errors or Global_Control and
                               a Global_Clear_Errors.
                            */
    UINT32 rsvd : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTR_0_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTR_1_MCCPGC_MAIN_REG supported on:                                */
/*      SPRA0 (0x200092a4)                                                      */
/*      SPRB0 (0x200092a4)                                                      */
/*      SPRHBM (0x200092a4)                                                     */
/*      SPRC0 (0x200092a4)                                                      */
/*      SPRMCC (0x200092a4)                                                     */
/*      SPRUCC (0x200092a4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Indicates the current error counter value.
*/


#define CPGC_ERR_CNTR_1_MCCPGC_MAIN_REG 0x280292A4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 error_counter : 23;

                            /* Bits[22:0], Access Type=RW/1S/V/P, default=0x00000000*/

                            /*
                               CPGC_ERR_ERRCNTR indicates the current error
                               counter value which is configured by
                               CPGC_ERR_CNTRCTL.Counter_Control. The
                               Counter_Status will not saturate and will wrap
                               around, but any overflow of this counter will
                               set the corresponding overflow status bit in CPG
                               C_ERR_ERRCNTR_OVERFLOW_STATUS.ERROR_COUNTER_OVER
                               FLOW.[br] Counter_Status can only be cleared by
                               setting Local_Clear_Errors or Global_Control and
                               a Global_Clear_Errors.
                            */
    UINT32 rsvd : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTR_1_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTR_2_MCCPGC_MAIN_REG supported on:                                */
/*      SPRA0 (0x200092a8)                                                      */
/*      SPRB0 (0x200092a8)                                                      */
/*      SPRHBM (0x200092a8)                                                     */
/*      SPRC0 (0x200092a8)                                                      */
/*      SPRMCC (0x200092a8)                                                     */
/*      SPRUCC (0x200092a8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Indicates the current error counter value.
*/


#define CPGC_ERR_CNTR_2_MCCPGC_MAIN_REG 0x280292A8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 error_counter : 23;

                            /* Bits[22:0], Access Type=RW/1S/V/P, default=0x00000000*/

                            /*
                               CPGC_ERR_ERRCNTR indicates the current error
                               counter value which is configured by
                               CPGC_ERR_CNTRCTL.Counter_Control. The
                               Counter_Status will not saturate and will wrap
                               around, but any overflow of this counter will
                               set the corresponding overflow status bit in CPG
                               C_ERR_ERRCNTR_OVERFLOW_STATUS.ERROR_COUNTER_OVER
                               FLOW.[br] Counter_Status can only be cleared by
                               setting Local_Clear_Errors or Global_Control and
                               a Global_Clear_Errors.
                            */
    UINT32 rsvd : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTR_2_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTR_3_MCCPGC_MAIN_REG supported on:                                */
/*      SPRA0 (0x200092ac)                                                      */
/*      SPRB0 (0x200092ac)                                                      */
/*      SPRHBM (0x200092ac)                                                     */
/*      SPRC0 (0x200092ac)                                                      */
/*      SPRMCC (0x200092ac)                                                     */
/*      SPRUCC (0x200092ac)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Indicates the current error counter value.
*/


#define CPGC_ERR_CNTR_3_MCCPGC_MAIN_REG 0x280292AC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 error_counter : 23;

                            /* Bits[22:0], Access Type=RW/1S/V/P, default=0x00000000*/

                            /*
                               CPGC_ERR_ERRCNTR indicates the current error
                               counter value which is configured by
                               CPGC_ERR_CNTRCTL.Counter_Control. The
                               Counter_Status will not saturate and will wrap
                               around, but any overflow of this counter will
                               set the corresponding overflow status bit in CPG
                               C_ERR_ERRCNTR_OVERFLOW_STATUS.ERROR_COUNTER_OVER
                               FLOW.[br] Counter_Status can only be cleared by
                               setting Local_Clear_Errors or Global_Control and
                               a Global_Clear_Errors.
                            */
    UINT32 rsvd : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTR_3_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTR_4_MCCPGC_MAIN_REG supported on:                                */
/*      SPRA0 (0x200092b0)                                                      */
/*      SPRB0 (0x200092b0)                                                      */
/*      SPRHBM (0x200092b0)                                                     */
/*      SPRC0 (0x200092b0)                                                      */
/*      SPRMCC (0x200092b0)                                                     */
/*      SPRUCC (0x200092b0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Indicates the current error counter value.
*/


#define CPGC_ERR_CNTR_4_MCCPGC_MAIN_REG 0x280292B0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 error_counter : 23;

                            /* Bits[22:0], Access Type=RW/1S/V/P, default=0x00000000*/

                            /*
                               CPGC_ERR_ERRCNTR indicates the current error
                               counter value which is configured by
                               CPGC_ERR_CNTRCTL.Counter_Control. The
                               Counter_Status will not saturate and will wrap
                               around, but any overflow of this counter will
                               set the corresponding overflow status bit in CPG
                               C_ERR_ERRCNTR_OVERFLOW_STATUS.ERROR_COUNTER_OVER
                               FLOW.[br] Counter_Status can only be cleared by
                               setting Local_Clear_Errors or Global_Control and
                               a Global_Clear_Errors.
                            */
    UINT32 rsvd : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTR_4_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTR_5_MCCPGC_MAIN_REG supported on:                                */
/*      SPRA0 (0x200092b4)                                                      */
/*      SPRB0 (0x200092b4)                                                      */
/*      SPRHBM (0x200092b4)                                                     */
/*      SPRC0 (0x200092b4)                                                      */
/*      SPRMCC (0x200092b4)                                                     */
/*      SPRUCC (0x200092b4)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Indicates the current error counter value.
*/


#define CPGC_ERR_CNTR_5_MCCPGC_MAIN_REG 0x280292B4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 error_counter : 23;

                            /* Bits[22:0], Access Type=RW/1S/V/P, default=0x00000000*/

                            /*
                               CPGC_ERR_ERRCNTR indicates the current error
                               counter value which is configured by
                               CPGC_ERR_CNTRCTL.Counter_Control. The
                               Counter_Status will not saturate and will wrap
                               around, but any overflow of this counter will
                               set the corresponding overflow status bit in CPG
                               C_ERR_ERRCNTR_OVERFLOW_STATUS.ERROR_COUNTER_OVER
                               FLOW.[br] Counter_Status can only be cleared by
                               setting Local_Clear_Errors or Global_Control and
                               a Global_Clear_Errors.
                            */
    UINT32 rsvd : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTR_5_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTR_6_MCCPGC_MAIN_REG supported on:                                */
/*      SPRA0 (0x200092b8)                                                      */
/*      SPRB0 (0x200092b8)                                                      */
/*      SPRHBM (0x200092b8)                                                     */
/*      SPRC0 (0x200092b8)                                                      */
/*      SPRMCC (0x200092b8)                                                     */
/*      SPRUCC (0x200092b8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Indicates the current error counter value.
*/


#define CPGC_ERR_CNTR_6_MCCPGC_MAIN_REG 0x280292B8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 error_counter : 23;

                            /* Bits[22:0], Access Type=RW/1S/V/P, default=0x00000000*/

                            /*
                               CPGC_ERR_ERRCNTR indicates the current error
                               counter value which is configured by
                               CPGC_ERR_CNTRCTL.Counter_Control. The
                               Counter_Status will not saturate and will wrap
                               around, but any overflow of this counter will
                               set the corresponding overflow status bit in CPG
                               C_ERR_ERRCNTR_OVERFLOW_STATUS.ERROR_COUNTER_OVER
                               FLOW.[br] Counter_Status can only be cleared by
                               setting Local_Clear_Errors or Global_Control and
                               a Global_Clear_Errors.
                            */
    UINT32 rsvd : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTR_6_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTR_7_MCCPGC_MAIN_REG supported on:                                */
/*      SPRA0 (0x200092bc)                                                      */
/*      SPRB0 (0x200092bc)                                                      */
/*      SPRHBM (0x200092bc)                                                     */
/*      SPRC0 (0x200092bc)                                                      */
/*      SPRMCC (0x200092bc)                                                     */
/*      SPRUCC (0x200092bc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Indicates the current error counter value.
*/


#define CPGC_ERR_CNTR_7_MCCPGC_MAIN_REG 0x280292BC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 error_counter : 23;

                            /* Bits[22:0], Access Type=RW/1S/V/P, default=0x00000000*/

                            /*
                               CPGC_ERR_ERRCNTR indicates the current error
                               counter value which is configured by
                               CPGC_ERR_CNTRCTL.Counter_Control. The
                               Counter_Status will not saturate and will wrap
                               around, but any overflow of this counter will
                               set the corresponding overflow status bit in CPG
                               C_ERR_ERRCNTR_OVERFLOW_STATUS.ERROR_COUNTER_OVER
                               FLOW.[br] Counter_Status can only be cleared by
                               setting Local_Clear_Errors or Global_Control and
                               a Global_Clear_Errors.
                            */
    UINT32 rsvd : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTR_7_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTR_8_MCCPGC_MAIN_REG supported on:                                */
/*      SPRA0 (0x200092c0)                                                      */
/*      SPRB0 (0x200092c0)                                                      */
/*      SPRHBM (0x200092c0)                                                     */
/*      SPRC0 (0x200092c0)                                                      */
/*      SPRMCC (0x200092c0)                                                     */
/*      SPRUCC (0x200092c0)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Indicates the current error counter value.
*/


#define CPGC_ERR_CNTR_8_MCCPGC_MAIN_REG 0x280292C0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 error_counter : 23;

                            /* Bits[22:0], Access Type=RW/1S/V/P, default=0x00000000*/

                            /*
                               CPGC_ERR_ERRCNTR indicates the current error
                               counter value which is configured by
                               CPGC_ERR_CNTRCTL.Counter_Control. The
                               Counter_Status will not saturate and will wrap
                               around, but any overflow of this counter will
                               set the corresponding overflow status bit in CPG
                               C_ERR_ERRCNTR_OVERFLOW_STATUS.ERROR_COUNTER_OVER
                               FLOW.[br] Counter_Status can only be cleared by
                               setting Local_Clear_Errors or Global_Control and
                               a Global_Clear_Errors.
                            */
    UINT32 rsvd : 9;

                            /* Bits[31:23], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTR_8_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_CNTR_OV_MCCPGC_MAIN_REG supported on:                               */
/*      SPRA0 (0x200092c8)                                                      */
/*      SPRB0 (0x200092c8)                                                      */
/*      SPRHBM (0x200092c8)                                                     */
/*      SPRC0 (0x200092c8)                                                      */
/*      SPRMCC (0x200092c8)                                                     */
/*      SPRUCC (0x200092c8)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Indicates the current error counter overflow value.
*/


#define CPGC_ERR_CNTR_OV_MCCPGC_MAIN_REG 0x280292C8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 error_counter_overflow : 9;

                            /* Bits[8:0], Access Type=RW/1C/V/P, default=0x00000000*/

                            /*
                               Contains the overflow flags for all Error
                               Counters.[br] Bit 0 corresponds to
                               ERROR_COUNTER_0[br] Bit 1 corresponds to
                               ERROR_COUNTER_1[br] ..[br] Bit 8 corresponds to
                               ERROR_COUNTER_8[br] Error Counter Overflow
                               Status can be cleared by one of two ways:[br] 1.
                               Local_Clear_Errors (or Global_Control and a
                               Global_Clear_Errors) to 1[br] 2. Writing the
                               corresponding Error Counter Overflow Status bit
                               to 1.[br] Writing a 0 to bits in
                               Counter_Overflow_Status can be cleared
                               independently of Data_Error_Status,
                               Byte_Group_Error_Status, Chunk_Error_Status, and
                               ECC_Error_Status.
                            */
    UINT32 rsvd : 23;

                            /* Bits[31:9], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_ERR_CNTR_OV_MCCPGC_MAIN_STRUCT;

/* CPGC_ERR_TEST_ERR_STAT_MCCPGC_MAIN_REG supported on:                         */
/*      SPRA0 (0x200092cc)                                                      */
/*      SPRB0 (0x200092cc)                                                      */
/*      SPRHBM (0x200092cc)                                                     */
/*      SPRC0 (0x200092cc)                                                      */
/*      SPRMCC (0x200092cc)                                                     */
/*      SPRUCC (0x200092cc)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_channel0/cpgc_d/cpgc_d_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Indicates when a test is active and if any errors occurred for the Channel.  The Channel 0 version of the register contains the status for all channels.
*/


#define CPGC_ERR_TEST_ERR_STAT_MCCPGC_MAIN_REG 0x280292CC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 error_status : 20;

                            /* Bits[19:0], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               Field identifies if an error occurred during the
                               test for this channel. Each bit starting at LSB
                               represents 4 lanes of data. ECC lanes begin at
                               bit 16. See documentation for specifics for
                               Channel 0 which aggregates all channels
                               information for all fields in this register.
                            */
    UINT32 test_in_progress : 4;

                            /* Bits[23:20], Access Type=RO/V, default=0x00000000*/

                            /*
                               The LSB bit will be set to indicate a test is in
                               progress (Including Start Test Delay and Test
                               Busy). This field is a copy of the bit(s) in
                               CPGC_SEQ_STATUS.
                            */
    UINT32 algo_wait_test_done : 4;

                            /* Bits[27:24], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               While TEST_IN_PROGRESS is set, the LSB bit will
                               be set when we are paused due to
                               Wait_Count_Start or Wait_Event in the current
                               Algorithm_Instruction_Ctrl. When the
                               TEST_IN_PROGRESS is not set, the LSB bit will be
                               set if the Test is Done. This field is a copy of
                               the bit(s) in CPGC_SEQ_STATUS.
                            */
    UINT32 event_not_seen_internal_err : 4;

                            /* Bits[31:28], Access Type=RO/V/P, default=0x00000000*/

                            /*
                               The LSB bit will be set when we are paused due
                               to Wait_Event in the current
                               Algorithm_Instruction_Ctrl and we continued
                               because Event Timer got saturated (and we did
                               not see the event). It will also indicate if an
                               internal error has occured, and CPGC_SEQ_STATUS
                               will need to be consulted to determine the
                               ultimate source of this bit. This bit is a per-
                               channel version of the bit in CPGC_SEQ_STATUS.
                            */

  } Bits;
  UINT32 Data;

} CPGC_ERR_TEST_ERR_STAT_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_EXTBUF_0_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x200092d0)                                                      */
/*      SPRB0 (0x200092d0)                                                      */
/*      SPRHBM (0x200092d0)                                                     */
/*      SPRC0 (0x200092d0)                                                      */
/*      SPRMCC (0x200092d0)                                                     */
/*      SPRUCC (0x200092d0)                                                     */
/* Register default value on SPRA0: 0xAAAAAAAA                                  */
/* Register default value on SPRB0: 0xAAAAAAAA                                  */
/* Register default value on SPRHBM: 0xAAAAAAAA                                 */
/* Register default value on SPRC0: 0xAAAAAAAA                                  */
/* Register default value on SPRMCC: 0xAAAAAAAA                                 */
/* Register default value on SPRUCC: 0xAAAAAAAA                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DPAT Pattern Select Buffer.
*/


#define CPGC_DPAT_EXTBUF_0_MCCPGC_MAIN_REG 0x280292D0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_line0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 0 */
    UINT32 data_line1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 1 */
    UINT32 data_line2 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 2[br]
                               Line 2 (and same for Lines 3..0) refers to the
                               8-UI partial cache line as pointed to current
                               status at CPGC_DPAT_BUF_CTL.[br] This
                               advancement is controlled by CPGC_DPAT_BUF_CTL.
                            */
    UINT32 data_line3 : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 3.[br]
                               EXTBUF[0] corresponds to Lane 0 (32 UI of data
                               maximum).[br] EXTBUF[1] corresponds to Lane 1
                               (32 UI of data maximum).[br] .....[br]
                               EXTBUF[15] corresponds to Lane 15.[br] These 16
                               lanes are replicated across the number of active
                               DQ lanes on the memory interface.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_EXTBUF_0_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_EXTBUF_1_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x200092d4)                                                      */
/*      SPRB0 (0x200092d4)                                                      */
/*      SPRHBM (0x200092d4)                                                     */
/*      SPRC0 (0x200092d4)                                                      */
/*      SPRMCC (0x200092d4)                                                     */
/*      SPRUCC (0x200092d4)                                                     */
/* Register default value on SPRA0: 0xAAAAAAAA                                  */
/* Register default value on SPRB0: 0xAAAAAAAA                                  */
/* Register default value on SPRHBM: 0xAAAAAAAA                                 */
/* Register default value on SPRC0: 0xAAAAAAAA                                  */
/* Register default value on SPRMCC: 0xAAAAAAAA                                 */
/* Register default value on SPRUCC: 0xAAAAAAAA                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DPAT Pattern Select Buffer.
*/


#define CPGC_DPAT_EXTBUF_1_MCCPGC_MAIN_REG 0x280292D4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_line0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 0 */
    UINT32 data_line1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 1 */
    UINT32 data_line2 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 2[br]
                               Line 2 (and same for Lines 3..0) refers to the
                               8-UI partial cache line as pointed to current
                               status at CPGC_DPAT_BUF_CTL.[br] This
                               advancement is controlled by CPGC_DPAT_BUF_CTL.
                            */
    UINT32 data_line3 : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 3.[br]
                               EXTBUF[0] corresponds to Lane 0 (32 UI of data
                               maximum).[br] EXTBUF[1] corresponds to Lane 1
                               (32 UI of data maximum).[br] .....[br]
                               EXTBUF[15] corresponds to Lane 15.[br] These 16
                               lanes are replicated across the number of active
                               DQ lanes on the memory interface.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_EXTBUF_1_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_EXTBUF_2_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x200092d8)                                                      */
/*      SPRB0 (0x200092d8)                                                      */
/*      SPRHBM (0x200092d8)                                                     */
/*      SPRC0 (0x200092d8)                                                      */
/*      SPRMCC (0x200092d8)                                                     */
/*      SPRUCC (0x200092d8)                                                     */
/* Register default value on SPRA0: 0xAAAAAAAA                                  */
/* Register default value on SPRB0: 0xAAAAAAAA                                  */
/* Register default value on SPRHBM: 0xAAAAAAAA                                 */
/* Register default value on SPRC0: 0xAAAAAAAA                                  */
/* Register default value on SPRMCC: 0xAAAAAAAA                                 */
/* Register default value on SPRUCC: 0xAAAAAAAA                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DPAT Pattern Select Buffer.
*/


#define CPGC_DPAT_EXTBUF_2_MCCPGC_MAIN_REG 0x280292D8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_line0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 0 */
    UINT32 data_line1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 1 */
    UINT32 data_line2 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 2[br]
                               Line 2 (and same for Lines 3..0) refers to the
                               8-UI partial cache line as pointed to current
                               status at CPGC_DPAT_BUF_CTL.[br] This
                               advancement is controlled by CPGC_DPAT_BUF_CTL.
                            */
    UINT32 data_line3 : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 3.[br]
                               EXTBUF[0] corresponds to Lane 0 (32 UI of data
                               maximum).[br] EXTBUF[1] corresponds to Lane 1
                               (32 UI of data maximum).[br] .....[br]
                               EXTBUF[15] corresponds to Lane 15.[br] These 16
                               lanes are replicated across the number of active
                               DQ lanes on the memory interface.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_EXTBUF_2_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_EXTBUF_3_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x200092dc)                                                      */
/*      SPRB0 (0x200092dc)                                                      */
/*      SPRHBM (0x200092dc)                                                     */
/*      SPRC0 (0x200092dc)                                                      */
/*      SPRMCC (0x200092dc)                                                     */
/*      SPRUCC (0x200092dc)                                                     */
/* Register default value on SPRA0: 0xAAAAAAAA                                  */
/* Register default value on SPRB0: 0xAAAAAAAA                                  */
/* Register default value on SPRHBM: 0xAAAAAAAA                                 */
/* Register default value on SPRC0: 0xAAAAAAAA                                  */
/* Register default value on SPRMCC: 0xAAAAAAAA                                 */
/* Register default value on SPRUCC: 0xAAAAAAAA                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DPAT Pattern Select Buffer.
*/


#define CPGC_DPAT_EXTBUF_3_MCCPGC_MAIN_REG 0x280292DC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_line0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 0 */
    UINT32 data_line1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 1 */
    UINT32 data_line2 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 2[br]
                               Line 2 (and same for Lines 3..0) refers to the
                               8-UI partial cache line as pointed to current
                               status at CPGC_DPAT_BUF_CTL.[br] This
                               advancement is controlled by CPGC_DPAT_BUF_CTL.
                            */
    UINT32 data_line3 : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 3.[br]
                               EXTBUF[0] corresponds to Lane 0 (32 UI of data
                               maximum).[br] EXTBUF[1] corresponds to Lane 1
                               (32 UI of data maximum).[br] .....[br]
                               EXTBUF[15] corresponds to Lane 15.[br] These 16
                               lanes are replicated across the number of active
                               DQ lanes on the memory interface.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_EXTBUF_3_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_EXTBUF_4_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x200092e0)                                                      */
/*      SPRB0 (0x200092e0)                                                      */
/*      SPRHBM (0x200092e0)                                                     */
/*      SPRC0 (0x200092e0)                                                      */
/*      SPRMCC (0x200092e0)                                                     */
/*      SPRUCC (0x200092e0)                                                     */
/* Register default value on SPRA0: 0xAAAAAAAA                                  */
/* Register default value on SPRB0: 0xAAAAAAAA                                  */
/* Register default value on SPRHBM: 0xAAAAAAAA                                 */
/* Register default value on SPRC0: 0xAAAAAAAA                                  */
/* Register default value on SPRMCC: 0xAAAAAAAA                                 */
/* Register default value on SPRUCC: 0xAAAAAAAA                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DPAT Pattern Select Buffer.
*/


#define CPGC_DPAT_EXTBUF_4_MCCPGC_MAIN_REG 0x280292E0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_line0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 0 */
    UINT32 data_line1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 1 */
    UINT32 data_line2 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 2[br]
                               Line 2 (and same for Lines 3..0) refers to the
                               8-UI partial cache line as pointed to current
                               status at CPGC_DPAT_BUF_CTL.[br] This
                               advancement is controlled by CPGC_DPAT_BUF_CTL.
                            */
    UINT32 data_line3 : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 3.[br]
                               EXTBUF[0] corresponds to Lane 0 (32 UI of data
                               maximum).[br] EXTBUF[1] corresponds to Lane 1
                               (32 UI of data maximum).[br] .....[br]
                               EXTBUF[15] corresponds to Lane 15.[br] These 16
                               lanes are replicated across the number of active
                               DQ lanes on the memory interface.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_EXTBUF_4_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_EXTBUF_5_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x200092e4)                                                      */
/*      SPRB0 (0x200092e4)                                                      */
/*      SPRHBM (0x200092e4)                                                     */
/*      SPRC0 (0x200092e4)                                                      */
/*      SPRMCC (0x200092e4)                                                     */
/*      SPRUCC (0x200092e4)                                                     */
/* Register default value on SPRA0: 0xAAAAAAAA                                  */
/* Register default value on SPRB0: 0xAAAAAAAA                                  */
/* Register default value on SPRHBM: 0xAAAAAAAA                                 */
/* Register default value on SPRC0: 0xAAAAAAAA                                  */
/* Register default value on SPRMCC: 0xAAAAAAAA                                 */
/* Register default value on SPRUCC: 0xAAAAAAAA                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DPAT Pattern Select Buffer.
*/


#define CPGC_DPAT_EXTBUF_5_MCCPGC_MAIN_REG 0x280292E4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_line0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 0 */
    UINT32 data_line1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 1 */
    UINT32 data_line2 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 2[br]
                               Line 2 (and same for Lines 3..0) refers to the
                               8-UI partial cache line as pointed to current
                               status at CPGC_DPAT_BUF_CTL.[br] This
                               advancement is controlled by CPGC_DPAT_BUF_CTL.
                            */
    UINT32 data_line3 : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 3.[br]
                               EXTBUF[0] corresponds to Lane 0 (32 UI of data
                               maximum).[br] EXTBUF[1] corresponds to Lane 1
                               (32 UI of data maximum).[br] .....[br]
                               EXTBUF[15] corresponds to Lane 15.[br] These 16
                               lanes are replicated across the number of active
                               DQ lanes on the memory interface.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_EXTBUF_5_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_EXTBUF_6_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x200092e8)                                                      */
/*      SPRB0 (0x200092e8)                                                      */
/*      SPRHBM (0x200092e8)                                                     */
/*      SPRC0 (0x200092e8)                                                      */
/*      SPRMCC (0x200092e8)                                                     */
/*      SPRUCC (0x200092e8)                                                     */
/* Register default value on SPRA0: 0xAAAAAAAA                                  */
/* Register default value on SPRB0: 0xAAAAAAAA                                  */
/* Register default value on SPRHBM: 0xAAAAAAAA                                 */
/* Register default value on SPRC0: 0xAAAAAAAA                                  */
/* Register default value on SPRMCC: 0xAAAAAAAA                                 */
/* Register default value on SPRUCC: 0xAAAAAAAA                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DPAT Pattern Select Buffer.
*/


#define CPGC_DPAT_EXTBUF_6_MCCPGC_MAIN_REG 0x280292E8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_line0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 0 */
    UINT32 data_line1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 1 */
    UINT32 data_line2 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 2[br]
                               Line 2 (and same for Lines 3..0) refers to the
                               8-UI partial cache line as pointed to current
                               status at CPGC_DPAT_BUF_CTL.[br] This
                               advancement is controlled by CPGC_DPAT_BUF_CTL.
                            */
    UINT32 data_line3 : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 3.[br]
                               EXTBUF[0] corresponds to Lane 0 (32 UI of data
                               maximum).[br] EXTBUF[1] corresponds to Lane 1
                               (32 UI of data maximum).[br] .....[br]
                               EXTBUF[15] corresponds to Lane 15.[br] These 16
                               lanes are replicated across the number of active
                               DQ lanes on the memory interface.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_EXTBUF_6_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_EXTBUF_7_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x200092ec)                                                      */
/*      SPRB0 (0x200092ec)                                                      */
/*      SPRHBM (0x200092ec)                                                     */
/*      SPRC0 (0x200092ec)                                                      */
/*      SPRMCC (0x200092ec)                                                     */
/*      SPRUCC (0x200092ec)                                                     */
/* Register default value on SPRA0: 0xAAAAAAAA                                  */
/* Register default value on SPRB0: 0xAAAAAAAA                                  */
/* Register default value on SPRHBM: 0xAAAAAAAA                                 */
/* Register default value on SPRC0: 0xAAAAAAAA                                  */
/* Register default value on SPRMCC: 0xAAAAAAAA                                 */
/* Register default value on SPRUCC: 0xAAAAAAAA                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DPAT Pattern Select Buffer.
*/


#define CPGC_DPAT_EXTBUF_7_MCCPGC_MAIN_REG 0x280292EC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_line0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 0 */
    UINT32 data_line1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 1 */
    UINT32 data_line2 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 2[br]
                               Line 2 (and same for Lines 3..0) refers to the
                               8-UI partial cache line as pointed to current
                               status at CPGC_DPAT_BUF_CTL.[br] This
                               advancement is controlled by CPGC_DPAT_BUF_CTL.
                            */
    UINT32 data_line3 : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 3.[br]
                               EXTBUF[0] corresponds to Lane 0 (32 UI of data
                               maximum).[br] EXTBUF[1] corresponds to Lane 1
                               (32 UI of data maximum).[br] .....[br]
                               EXTBUF[15] corresponds to Lane 15.[br] These 16
                               lanes are replicated across the number of active
                               DQ lanes on the memory interface.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_EXTBUF_7_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_EXTBUF_8_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x200092f0)                                                      */
/*      SPRB0 (0x200092f0)                                                      */
/*      SPRHBM (0x200092f0)                                                     */
/*      SPRC0 (0x200092f0)                                                      */
/*      SPRMCC (0x200092f0)                                                     */
/*      SPRUCC (0x200092f0)                                                     */
/* Register default value on SPRA0: 0xAAAAAAAA                                  */
/* Register default value on SPRB0: 0xAAAAAAAA                                  */
/* Register default value on SPRHBM: 0xAAAAAAAA                                 */
/* Register default value on SPRC0: 0xAAAAAAAA                                  */
/* Register default value on SPRMCC: 0xAAAAAAAA                                 */
/* Register default value on SPRUCC: 0xAAAAAAAA                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DPAT Pattern Select Buffer.
*/


#define CPGC_DPAT_EXTBUF_8_MCCPGC_MAIN_REG 0x280292F0

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_line0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 0 */
    UINT32 data_line1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 1 */
    UINT32 data_line2 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 2[br]
                               Line 2 (and same for Lines 3..0) refers to the
                               8-UI partial cache line as pointed to current
                               status at CPGC_DPAT_BUF_CTL.[br] This
                               advancement is controlled by CPGC_DPAT_BUF_CTL.
                            */
    UINT32 data_line3 : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 3.[br]
                               EXTBUF[0] corresponds to Lane 0 (32 UI of data
                               maximum).[br] EXTBUF[1] corresponds to Lane 1
                               (32 UI of data maximum).[br] .....[br]
                               EXTBUF[15] corresponds to Lane 15.[br] These 16
                               lanes are replicated across the number of active
                               DQ lanes on the memory interface.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_EXTBUF_8_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_EXTBUF_9_MCCPGC_MAIN_REG supported on:                             */
/*      SPRA0 (0x200092f4)                                                      */
/*      SPRB0 (0x200092f4)                                                      */
/*      SPRHBM (0x200092f4)                                                     */
/*      SPRC0 (0x200092f4)                                                      */
/*      SPRMCC (0x200092f4)                                                     */
/*      SPRUCC (0x200092f4)                                                     */
/* Register default value on SPRA0: 0xAAAAAAAA                                  */
/* Register default value on SPRB0: 0xAAAAAAAA                                  */
/* Register default value on SPRHBM: 0xAAAAAAAA                                 */
/* Register default value on SPRC0: 0xAAAAAAAA                                  */
/* Register default value on SPRMCC: 0xAAAAAAAA                                 */
/* Register default value on SPRUCC: 0xAAAAAAAA                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DPAT Pattern Select Buffer.
*/


#define CPGC_DPAT_EXTBUF_9_MCCPGC_MAIN_REG 0x280292F4

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_line0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 0 */
    UINT32 data_line1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 1 */
    UINT32 data_line2 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 2[br]
                               Line 2 (and same for Lines 3..0) refers to the
                               8-UI partial cache line as pointed to current
                               status at CPGC_DPAT_BUF_CTL.[br] This
                               advancement is controlled by CPGC_DPAT_BUF_CTL.
                            */
    UINT32 data_line3 : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 3.[br]
                               EXTBUF[0] corresponds to Lane 0 (32 UI of data
                               maximum).[br] EXTBUF[1] corresponds to Lane 1
                               (32 UI of data maximum).[br] .....[br]
                               EXTBUF[15] corresponds to Lane 15.[br] These 16
                               lanes are replicated across the number of active
                               DQ lanes on the memory interface.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_EXTBUF_9_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_EXTBUF_10_MCCPGC_MAIN_REG supported on:                            */
/*      SPRA0 (0x200092f8)                                                      */
/*      SPRB0 (0x200092f8)                                                      */
/*      SPRHBM (0x200092f8)                                                     */
/*      SPRC0 (0x200092f8)                                                      */
/*      SPRMCC (0x200092f8)                                                     */
/*      SPRUCC (0x200092f8)                                                     */
/* Register default value on SPRA0: 0xAAAAAAAA                                  */
/* Register default value on SPRB0: 0xAAAAAAAA                                  */
/* Register default value on SPRHBM: 0xAAAAAAAA                                 */
/* Register default value on SPRC0: 0xAAAAAAAA                                  */
/* Register default value on SPRMCC: 0xAAAAAAAA                                 */
/* Register default value on SPRUCC: 0xAAAAAAAA                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DPAT Pattern Select Buffer.
*/


#define CPGC_DPAT_EXTBUF_10_MCCPGC_MAIN_REG 0x280292F8

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_line0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 0 */
    UINT32 data_line1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 1 */
    UINT32 data_line2 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 2[br]
                               Line 2 (and same for Lines 3..0) refers to the
                               8-UI partial cache line as pointed to current
                               status at CPGC_DPAT_BUF_CTL.[br] This
                               advancement is controlled by CPGC_DPAT_BUF_CTL.
                            */
    UINT32 data_line3 : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 3.[br]
                               EXTBUF[0] corresponds to Lane 0 (32 UI of data
                               maximum).[br] EXTBUF[1] corresponds to Lane 1
                               (32 UI of data maximum).[br] .....[br]
                               EXTBUF[15] corresponds to Lane 15.[br] These 16
                               lanes are replicated across the number of active
                               DQ lanes on the memory interface.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_EXTBUF_10_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_EXTBUF_11_MCCPGC_MAIN_REG supported on:                            */
/*      SPRA0 (0x200092fc)                                                      */
/*      SPRB0 (0x200092fc)                                                      */
/*      SPRHBM (0x200092fc)                                                     */
/*      SPRC0 (0x200092fc)                                                      */
/*      SPRMCC (0x200092fc)                                                     */
/*      SPRUCC (0x200092fc)                                                     */
/* Register default value on SPRA0: 0xAAAAAAAA                                  */
/* Register default value on SPRB0: 0xAAAAAAAA                                  */
/* Register default value on SPRHBM: 0xAAAAAAAA                                 */
/* Register default value on SPRC0: 0xAAAAAAAA                                  */
/* Register default value on SPRMCC: 0xAAAAAAAA                                 */
/* Register default value on SPRUCC: 0xAAAAAAAA                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DPAT Pattern Select Buffer.
*/


#define CPGC_DPAT_EXTBUF_11_MCCPGC_MAIN_REG 0x280292FC

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_line0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 0 */
    UINT32 data_line1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 1 */
    UINT32 data_line2 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 2[br]
                               Line 2 (and same for Lines 3..0) refers to the
                               8-UI partial cache line as pointed to current
                               status at CPGC_DPAT_BUF_CTL.[br] This
                               advancement is controlled by CPGC_DPAT_BUF_CTL.
                            */
    UINT32 data_line3 : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 3.[br]
                               EXTBUF[0] corresponds to Lane 0 (32 UI of data
                               maximum).[br] EXTBUF[1] corresponds to Lane 1
                               (32 UI of data maximum).[br] .....[br]
                               EXTBUF[15] corresponds to Lane 15.[br] These 16
                               lanes are replicated across the number of active
                               DQ lanes on the memory interface.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_EXTBUF_11_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_EXTBUF_12_MCCPGC_MAIN_REG supported on:                            */
/*      SPRA0 (0x20009300)                                                      */
/*      SPRB0 (0x20009300)                                                      */
/*      SPRHBM (0x20009300)                                                     */
/*      SPRC0 (0x20009300)                                                      */
/*      SPRMCC (0x20009300)                                                     */
/*      SPRUCC (0x20009300)                                                     */
/* Register default value on SPRA0: 0xAAAAAAAA                                  */
/* Register default value on SPRB0: 0xAAAAAAAA                                  */
/* Register default value on SPRHBM: 0xAAAAAAAA                                 */
/* Register default value on SPRC0: 0xAAAAAAAA                                  */
/* Register default value on SPRMCC: 0xAAAAAAAA                                 */
/* Register default value on SPRUCC: 0xAAAAAAAA                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DPAT Pattern Select Buffer.
*/


#define CPGC_DPAT_EXTBUF_12_MCCPGC_MAIN_REG 0x28029300

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_line0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 0 */
    UINT32 data_line1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 1 */
    UINT32 data_line2 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 2[br]
                               Line 2 (and same for Lines 3..0) refers to the
                               8-UI partial cache line as pointed to current
                               status at CPGC_DPAT_BUF_CTL.[br] This
                               advancement is controlled by CPGC_DPAT_BUF_CTL.
                            */
    UINT32 data_line3 : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 3.[br]
                               EXTBUF[0] corresponds to Lane 0 (32 UI of data
                               maximum).[br] EXTBUF[1] corresponds to Lane 1
                               (32 UI of data maximum).[br] .....[br]
                               EXTBUF[15] corresponds to Lane 15.[br] These 16
                               lanes are replicated across the number of active
                               DQ lanes on the memory interface.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_EXTBUF_12_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_EXTBUF_13_MCCPGC_MAIN_REG supported on:                            */
/*      SPRA0 (0x20009304)                                                      */
/*      SPRB0 (0x20009304)                                                      */
/*      SPRHBM (0x20009304)                                                     */
/*      SPRC0 (0x20009304)                                                      */
/*      SPRMCC (0x20009304)                                                     */
/*      SPRUCC (0x20009304)                                                     */
/* Register default value on SPRA0: 0xAAAAAAAA                                  */
/* Register default value on SPRB0: 0xAAAAAAAA                                  */
/* Register default value on SPRHBM: 0xAAAAAAAA                                 */
/* Register default value on SPRC0: 0xAAAAAAAA                                  */
/* Register default value on SPRMCC: 0xAAAAAAAA                                 */
/* Register default value on SPRUCC: 0xAAAAAAAA                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DPAT Pattern Select Buffer.
*/


#define CPGC_DPAT_EXTBUF_13_MCCPGC_MAIN_REG 0x28029304

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_line0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 0 */
    UINT32 data_line1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 1 */
    UINT32 data_line2 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 2[br]
                               Line 2 (and same for Lines 3..0) refers to the
                               8-UI partial cache line as pointed to current
                               status at CPGC_DPAT_BUF_CTL.[br] This
                               advancement is controlled by CPGC_DPAT_BUF_CTL.
                            */
    UINT32 data_line3 : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 3.[br]
                               EXTBUF[0] corresponds to Lane 0 (32 UI of data
                               maximum).[br] EXTBUF[1] corresponds to Lane 1
                               (32 UI of data maximum).[br] .....[br]
                               EXTBUF[15] corresponds to Lane 15.[br] These 16
                               lanes are replicated across the number of active
                               DQ lanes on the memory interface.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_EXTBUF_13_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_EXTBUF_14_MCCPGC_MAIN_REG supported on:                            */
/*      SPRA0 (0x20009308)                                                      */
/*      SPRB0 (0x20009308)                                                      */
/*      SPRHBM (0x20009308)                                                     */
/*      SPRC0 (0x20009308)                                                      */
/*      SPRMCC (0x20009308)                                                     */
/*      SPRUCC (0x20009308)                                                     */
/* Register default value on SPRA0: 0xAAAAAAAA                                  */
/* Register default value on SPRB0: 0xAAAAAAAA                                  */
/* Register default value on SPRHBM: 0xAAAAAAAA                                 */
/* Register default value on SPRC0: 0xAAAAAAAA                                  */
/* Register default value on SPRMCC: 0xAAAAAAAA                                 */
/* Register default value on SPRUCC: 0xAAAAAAAA                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DPAT Pattern Select Buffer.
*/


#define CPGC_DPAT_EXTBUF_14_MCCPGC_MAIN_REG 0x28029308

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_line0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 0 */
    UINT32 data_line1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 1 */
    UINT32 data_line2 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 2[br]
                               Line 2 (and same for Lines 3..0) refers to the
                               8-UI partial cache line as pointed to current
                               status at CPGC_DPAT_BUF_CTL.[br] This
                               advancement is controlled by CPGC_DPAT_BUF_CTL.
                            */
    UINT32 data_line3 : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 3.[br]
                               EXTBUF[0] corresponds to Lane 0 (32 UI of data
                               maximum).[br] EXTBUF[1] corresponds to Lane 1
                               (32 UI of data maximum).[br] .....[br]
                               EXTBUF[15] corresponds to Lane 15.[br] These 16
                               lanes are replicated across the number of active
                               DQ lanes on the memory interface.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_EXTBUF_14_MCCPGC_MAIN_STRUCT;

/* CPGC_DPAT_EXTBUF_15_MCCPGC_MAIN_REG supported on:                            */
/*      SPRA0 (0x2000930c)                                                      */
/*      SPRB0 (0x2000930c)                                                      */
/*      SPRHBM (0x2000930c)                                                     */
/*      SPRC0 (0x2000930c)                                                      */
/*      SPRMCC (0x2000930c)                                                     */
/*      SPRUCC (0x2000930c)                                                     */
/* Register default value on SPRA0: 0xAAAAAAAA                                  */
/* Register default value on SPRB0: 0xAAAAAAAA                                  */
/* Register default value on SPRHBM: 0xAAAAAAAA                                 */
/* Register default value on SPRC0: 0xAAAAAAAA                                  */
/* Register default value on SPRMCC: 0xAAAAAAAA                                 */
/* Register default value on SPRUCC: 0xAAAAAAAA                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DPAT Pattern Select Buffer.
*/


#define CPGC_DPAT_EXTBUF_15_MCCPGC_MAIN_REG 0x2802930C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data_line0 : 8;

                            /* Bits[7:0], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 0 */
    UINT32 data_line1 : 8;

                            /* Bits[15:8], Access Type=RW, default=0x000000AA*/

                            /* Contents of Pattern Buffer for Cache Line 1 */
    UINT32 data_line2 : 8;

                            /* Bits[23:16], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 2[br]
                               Line 2 (and same for Lines 3..0) refers to the
                               8-UI partial cache line as pointed to current
                               status at CPGC_DPAT_BUF_CTL.[br] This
                               advancement is controlled by CPGC_DPAT_BUF_CTL.
                            */
    UINT32 data_line3 : 8;

                            /* Bits[31:24], Access Type=RW, default=0x000000AA*/

                            /*
                               Contents of Pattern Buffer for Cache Line 3.[br]
                               EXTBUF[0] corresponds to Lane 0 (32 UI of data
                               maximum).[br] EXTBUF[1] corresponds to Lane 1
                               (32 UI of data maximum).[br] .....[br]
                               EXTBUF[15] corresponds to Lane 15.[br] These 16
                               lanes are replicated across the number of active
                               DQ lanes on the memory interface.
                            */

  } Bits;
  UINT32 Data;

} CPGC_DPAT_EXTBUF_15_MCCPGC_MAIN_STRUCT;

/* CPGC_B_DUMMY_N0_MCCPGC_MAIN_REG supported on:                                */
/*      SPRA0 (0x20009310)                                                      */
/*      SPRB0 (0x20009310)                                                      */
/*      SPRHBM (0x20009310)                                                     */
/*      SPRC0 (0x20009310)                                                      */
/*      SPRMCC (0x20009310)                                                     */
/*      SPRUCC (0x20009310)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Dummy register to generate RTL packages with Access Width = 64 for cpgc_b submap.
*/


#define CPGC_B_DUMMY_N0_MCCPGC_MAIN_REG 0x28029310

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dummy : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /*
                               Dummy register field to generate RTL packages
                               with Access Width = 64 for cpgc_b submap.
                            */

  } Bits;
  UINT32 Data;

} CPGC_B_DUMMY_N0_MCCPGC_MAIN_STRUCT;

/* CPGC_B_DUMMY_N1_MCCPGC_MAIN_REG supported on:                                */
/*      SPRA0 (0x20009314)                                                      */
/*      SPRB0 (0x20009314)                                                      */
/*      SPRHBM (0x20009314)                                                     */
/*      SPRC0 (0x20009314)                                                      */
/*      SPRMCC (0x20009314)                                                     */
/*      SPRUCC (0x20009314)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_buffer0/cpgc_b/cpgc_b_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Dummy register to generate RTL packages with Access Width = 64 for cpgc_b submap.
*/


#define CPGC_B_DUMMY_N1_MCCPGC_MAIN_REG 0x28029314

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dummy : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /*
                               Dummy register field to generate RTL packages
                               with Access Width = 64 for cpgc_b submap.
                            */

  } Bits;
  UINT32 Data;

} CPGC_B_DUMMY_N1_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_RANK_L2P_MAPPING_A_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x20009320)                                                      */
/*      SPRB0 (0x20009320)                                                      */
/*      SPRHBM (0x20009320)                                                     */
/*      SPRC0 (0x20009320)                                                      */
/*      SPRMCC (0x20009320)                                                     */
/*      SPRUCC (0x20009320)                                                     */
/* Register default value on SPRA0: 0x0A418820                                  */
/* Register default value on SPRB0: 0x0A418820                                  */
/* Register default value on SPRHBM: 0x0A418820                                 */
/* Register default value on SPRC0: 0x0A418820                                  */
/* Register default value on SPRMCC: 0x0A418820                                 */
/* Register default value on SPRUCC: 0x0A418820                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Rank Logical to Physical Mapping Lookup Table.
*/


#define CPGC_SEQ_RANK_L2P_MAPPING_A_MCCPGC_MAIN_REG 0x28029320

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_rank0_mapping : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank1_mapping : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000001*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank2_mapping : 5;

                            /* Bits[14:10], Access Type=RW, default=0x00000002*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank3_mapping : 5;

                            /* Bits[19:15], Access Type=RW, default=0x00000003*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank4_mapping : 5;

                            /* Bits[24:20], Access Type=RW, default=0x00000004*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank5_mapping : 5;

                            /* Bits[29:25], Access Type=RW, default=0x00000005*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_RANK_L2P_MAPPING_A_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_RANK_L2P_MAPPING_B_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x20009324)                                                      */
/*      SPRB0 (0x20009324)                                                      */
/*      SPRHBM (0x20009324)                                                     */
/*      SPRC0 (0x20009324)                                                      */
/*      SPRMCC (0x20009324)                                                     */
/*      SPRUCC (0x20009324)                                                     */
/* Register default value on SPRA0: 0x16A4A0E6                                  */
/* Register default value on SPRB0: 0x16A4A0E6                                  */
/* Register default value on SPRHBM: 0x16A4A0E6                                 */
/* Register default value on SPRC0: 0x16A4A0E6                                  */
/* Register default value on SPRMCC: 0x16A4A0E6                                 */
/* Register default value on SPRUCC: 0x16A4A0E6                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Rank Logical to Physical Mapping Lookup Table.
*/


#define CPGC_SEQ_RANK_L2P_MAPPING_B_MCCPGC_MAIN_REG 0x28029324

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_rank6_mapping : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000006*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank7_mapping : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000007*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank8_mapping : 5;

                            /* Bits[14:10], Access Type=RW, default=0x00000008*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank9_mapping : 5;

                            /* Bits[19:15], Access Type=RW, default=0x00000009*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank10_mapping : 5;

                            /* Bits[24:20], Access Type=RW, default=0x0000000A*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank11_mapping : 5;

                            /* Bits[29:25], Access Type=RW, default=0x0000000B*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_RANK_L2P_MAPPING_B_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_RANK_L2P_MAPPING_C_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x20009328)                                                      */
/*      SPRB0 (0x20009328)                                                      */
/*      SPRHBM (0x20009328)                                                     */
/*      SPRC0 (0x20009328)                                                      */
/*      SPRMCC (0x20009328)                                                     */
/*      SPRUCC (0x20009328)                                                     */
/* Register default value on SPRA0: 0x2307B9AC                                  */
/* Register default value on SPRB0: 0x2307B9AC                                  */
/* Register default value on SPRHBM: 0x2307B9AC                                 */
/* Register default value on SPRC0: 0x2307B9AC                                  */
/* Register default value on SPRMCC: 0x2307B9AC                                 */
/* Register default value on SPRUCC: 0x2307B9AC                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Rank Logical to Physical Mapping Lookup Table.
*/


#define CPGC_SEQ_RANK_L2P_MAPPING_C_MCCPGC_MAIN_REG 0x28029328

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_rank12_mapping : 5;

                            /* Bits[4:0], Access Type=RW, default=0x0000000C*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank13_mapping : 5;

                            /* Bits[9:5], Access Type=RW, default=0x0000000D*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank14_mapping : 5;

                            /* Bits[14:10], Access Type=RW, default=0x0000000E*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank15_mapping : 5;

                            /* Bits[19:15], Access Type=RW, default=0x0000000F*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank16_mapping : 5;

                            /* Bits[24:20], Access Type=RW, default=0x00000010*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank17_mapping : 5;

                            /* Bits[29:25], Access Type=RW, default=0x00000011*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_RANK_L2P_MAPPING_C_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_RANK_L2P_MAPPING_D_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x2000932c)                                                      */
/*      SPRB0 (0x2000932c)                                                      */
/*      SPRHBM (0x2000932c)                                                     */
/*      SPRC0 (0x2000932c)                                                      */
/*      SPRMCC (0x2000932c)                                                     */
/*      SPRUCC (0x2000932c)                                                     */
/* Register default value on SPRA0: 0x2F6AD272                                  */
/* Register default value on SPRB0: 0x2F6AD272                                  */
/* Register default value on SPRHBM: 0x2F6AD272                                 */
/* Register default value on SPRC0: 0x2F6AD272                                  */
/* Register default value on SPRMCC: 0x2F6AD272                                 */
/* Register default value on SPRUCC: 0x2F6AD272                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Rank Logical to Physical Mapping Lookup Table.
*/


#define CPGC_SEQ_RANK_L2P_MAPPING_D_MCCPGC_MAIN_REG 0x2802932C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_rank18_mapping : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000012*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank19_mapping : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000013*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank20_mapping : 5;

                            /* Bits[14:10], Access Type=RW, default=0x00000014*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank21_mapping : 5;

                            /* Bits[19:15], Access Type=RW, default=0x00000015*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank22_mapping : 5;

                            /* Bits[24:20], Access Type=RW, default=0x00000016*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank23_mapping : 5;

                            /* Bits[29:25], Access Type=RW, default=0x00000017*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_RANK_L2P_MAPPING_D_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_RANK_L2P_MAPPING_E_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x20009330)                                                      */
/*      SPRB0 (0x20009330)                                                      */
/*      SPRHBM (0x20009330)                                                     */
/*      SPRC0 (0x20009330)                                                      */
/*      SPRMCC (0x20009330)                                                     */
/*      SPRUCC (0x20009330)                                                     */
/* Register default value on SPRA0: 0x3BCDEB38                                  */
/* Register default value on SPRB0: 0x3BCDEB38                                  */
/* Register default value on SPRHBM: 0x3BCDEB38                                 */
/* Register default value on SPRC0: 0x3BCDEB38                                  */
/* Register default value on SPRMCC: 0x3BCDEB38                                 */
/* Register default value on SPRUCC: 0x3BCDEB38                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Rank Logical to Physical Mapping Lookup Table.
*/


#define CPGC_SEQ_RANK_L2P_MAPPING_E_MCCPGC_MAIN_REG 0x28029330

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_rank24_mapping : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000018*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank25_mapping : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000019*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank26_mapping : 5;

                            /* Bits[14:10], Access Type=RW, default=0x0000001A*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank27_mapping : 5;

                            /* Bits[19:15], Access Type=RW, default=0x0000001B*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank28_mapping : 5;

                            /* Bits[24:20], Access Type=RW, default=0x0000001C*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank29_mapping : 5;

                            /* Bits[29:25], Access Type=RW, default=0x0000001D*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_RANK_L2P_MAPPING_E_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_RANK_L2P_MAPPING_F_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x20009334)                                                      */
/*      SPRB0 (0x20009334)                                                      */
/*      SPRHBM (0x20009334)                                                     */
/*      SPRC0 (0x20009334)                                                      */
/*      SPRMCC (0x20009334)                                                     */
/*      SPRUCC (0x20009334)                                                     */
/* Register default value on SPRA0: 0x000003FE                                  */
/* Register default value on SPRB0: 0x000003FE                                  */
/* Register default value on SPRHBM: 0x000003FE                                 */
/* Register default value on SPRC0: 0x000003FE                                  */
/* Register default value on SPRMCC: 0x000003FE                                 */
/* Register default value on SPRUCC: 0x000003FE                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Rank Logical to Physical Mapping Lookup Table.
*/


#define CPGC_SEQ_RANK_L2P_MAPPING_F_MCCPGC_MAIN_REG 0x28029334

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_rank30_mapping : 5;

                            /* Bits[4:0], Access Type=RW, default=0x0000001E*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 l2p_rank31_mapping : 5;

                            /* Bits[9:5], Access Type=RW, default=0x0000001F*/

                            /*
                               Defines what Physical Rank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Rank address (Sequence Address Logic
                               Domain). Basically the Ranks are re-
                               ordered/swapped allowing you to skip unpopulated
                               Physical Rank numbers. It is possible to use
                               more Logical Ranks then Physical Ranks in more
                               complex tests where multiple non-linear Physical
                               Rank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Rank address.
                            */
    UINT32 rsvd : 22;

                            /* Bits[31:10], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_RANK_L2P_MAPPING_F_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_BANK_L2P_MAPPING_A_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x20009338)                                                      */
/*      SPRB0 (0x20009338)                                                      */
/*      SPRHBM (0x20009338)                                                     */
/*      SPRC0 (0x20009338)                                                      */
/*      SPRMCC (0x20009338)                                                     */
/*      SPRUCC (0x20009338)                                                     */
/* Register default value on SPRA0: 0x0A418820                                  */
/* Register default value on SPRB0: 0x0A418820                                  */
/* Register default value on SPRHBM: 0x0A418820                                 */
/* Register default value on SPRC0: 0x0A418820                                  */
/* Register default value on SPRMCC: 0x0A418820                                 */
/* Register default value on SPRUCC: 0x0A418820                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Bank Logical to Physical Mapping Lookup Table.
*/


#define CPGC_SEQ_BANK_L2P_MAPPING_A_MCCPGC_MAIN_REG 0x28029338

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_bank0_mapping : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank1_mapping : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000001*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank2_mapping : 5;

                            /* Bits[14:10], Access Type=RW, default=0x00000002*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank3_mapping : 5;

                            /* Bits[19:15], Access Type=RW, default=0x00000003*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank4_mapping : 5;

                            /* Bits[24:20], Access Type=RW, default=0x00000004*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank5_mapping : 5;

                            /* Bits[29:25], Access Type=RW, default=0x00000005*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_BANK_L2P_MAPPING_A_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_BANK_L2P_MAPPING_B_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x2000933c)                                                      */
/*      SPRB0 (0x2000933c)                                                      */
/*      SPRHBM (0x2000933c)                                                     */
/*      SPRC0 (0x2000933c)                                                      */
/*      SPRMCC (0x2000933c)                                                     */
/*      SPRUCC (0x2000933c)                                                     */
/* Register default value on SPRA0: 0x16A4A0E6                                  */
/* Register default value on SPRB0: 0x16A4A0E6                                  */
/* Register default value on SPRHBM: 0x16A4A0E6                                 */
/* Register default value on SPRC0: 0x16A4A0E6                                  */
/* Register default value on SPRMCC: 0x16A4A0E6                                 */
/* Register default value on SPRUCC: 0x16A4A0E6                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Bank Logical to Physical Mapping Lookup Table.
*/


#define CPGC_SEQ_BANK_L2P_MAPPING_B_MCCPGC_MAIN_REG 0x2802933C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_bank6_mapping : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000006*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank7_mapping : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000007*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank8_mapping : 5;

                            /* Bits[14:10], Access Type=RW, default=0x00000008*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank9_mapping : 5;

                            /* Bits[19:15], Access Type=RW, default=0x00000009*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank10_mapping : 5;

                            /* Bits[24:20], Access Type=RW, default=0x0000000A*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank11_mapping : 5;

                            /* Bits[29:25], Access Type=RW, default=0x0000000B*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_BANK_L2P_MAPPING_B_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_BANK_L2P_MAPPING_C_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x20009340)                                                      */
/*      SPRB0 (0x20009340)                                                      */
/*      SPRHBM (0x20009340)                                                     */
/*      SPRC0 (0x20009340)                                                      */
/*      SPRMCC (0x20009340)                                                     */
/*      SPRUCC (0x20009340)                                                     */
/* Register default value on SPRA0: 0x2307B9AC                                  */
/* Register default value on SPRB0: 0x2307B9AC                                  */
/* Register default value on SPRHBM: 0x2307B9AC                                 */
/* Register default value on SPRC0: 0x2307B9AC                                  */
/* Register default value on SPRMCC: 0x2307B9AC                                 */
/* Register default value on SPRUCC: 0x2307B9AC                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Bank Logical to Physical Mapping Lookup Table.
*/


#define CPGC_SEQ_BANK_L2P_MAPPING_C_MCCPGC_MAIN_REG 0x28029340

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_bank12_mapping : 5;

                            /* Bits[4:0], Access Type=RW, default=0x0000000C*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank13_mapping : 5;

                            /* Bits[9:5], Access Type=RW, default=0x0000000D*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank14_mapping : 5;

                            /* Bits[14:10], Access Type=RW, default=0x0000000E*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank15_mapping : 5;

                            /* Bits[19:15], Access Type=RW, default=0x0000000F*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank16_mapping : 5;

                            /* Bits[24:20], Access Type=RW, default=0x00000010*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank17_mapping : 5;

                            /* Bits[29:25], Access Type=RW, default=0x00000011*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_BANK_L2P_MAPPING_C_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_BANK_L2P_MAPPING_D_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x20009344)                                                      */
/*      SPRB0 (0x20009344)                                                      */
/*      SPRHBM (0x20009344)                                                     */
/*      SPRC0 (0x20009344)                                                      */
/*      SPRMCC (0x20009344)                                                     */
/*      SPRUCC (0x20009344)                                                     */
/* Register default value on SPRA0: 0x2F6AD272                                  */
/* Register default value on SPRB0: 0x2F6AD272                                  */
/* Register default value on SPRHBM: 0x2F6AD272                                 */
/* Register default value on SPRC0: 0x2F6AD272                                  */
/* Register default value on SPRMCC: 0x2F6AD272                                 */
/* Register default value on SPRUCC: 0x2F6AD272                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Bank Logical to Physical Mapping Lookup Table.
*/


#define CPGC_SEQ_BANK_L2P_MAPPING_D_MCCPGC_MAIN_REG 0x28029344

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_bank18_mapping : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000012*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank19_mapping : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000013*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank20_mapping : 5;

                            /* Bits[14:10], Access Type=RW, default=0x00000014*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank21_mapping : 5;

                            /* Bits[19:15], Access Type=RW, default=0x00000015*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank22_mapping : 5;

                            /* Bits[24:20], Access Type=RW, default=0x00000016*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank23_mapping : 5;

                            /* Bits[29:25], Access Type=RW, default=0x00000017*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_BANK_L2P_MAPPING_D_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_BANK_L2P_MAPPING_E_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x20009348)                                                      */
/*      SPRB0 (0x20009348)                                                      */
/*      SPRHBM (0x20009348)                                                     */
/*      SPRC0 (0x20009348)                                                      */
/*      SPRMCC (0x20009348)                                                     */
/*      SPRUCC (0x20009348)                                                     */
/* Register default value on SPRA0: 0x3BCDEB38                                  */
/* Register default value on SPRB0: 0x3BCDEB38                                  */
/* Register default value on SPRHBM: 0x3BCDEB38                                 */
/* Register default value on SPRC0: 0x3BCDEB38                                  */
/* Register default value on SPRMCC: 0x3BCDEB38                                 */
/* Register default value on SPRUCC: 0x3BCDEB38                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Bank Logical to Physical Mapping Lookup Table.
*/


#define CPGC_SEQ_BANK_L2P_MAPPING_E_MCCPGC_MAIN_REG 0x28029348

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_bank24_mapping : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000018*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank25_mapping : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000019*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank26_mapping : 5;

                            /* Bits[14:10], Access Type=RW, default=0x0000001A*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank27_mapping : 5;

                            /* Bits[19:15], Access Type=RW, default=0x0000001B*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank28_mapping : 5;

                            /* Bits[24:20], Access Type=RW, default=0x0000001C*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank29_mapping : 5;

                            /* Bits[29:25], Access Type=RW, default=0x0000001D*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_BANK_L2P_MAPPING_E_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_BANK_L2P_MAPPING_F_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x2000934c)                                                      */
/*      SPRB0 (0x2000934c)                                                      */
/*      SPRHBM (0x2000934c)                                                     */
/*      SPRC0 (0x2000934c)                                                      */
/*      SPRMCC (0x2000934c)                                                     */
/*      SPRUCC (0x2000934c)                                                     */
/* Register default value on SPRA0: 0x000003FE                                  */
/* Register default value on SPRB0: 0x000003FE                                  */
/* Register default value on SPRHBM: 0x000003FE                                 */
/* Register default value on SPRC0: 0x000003FE                                  */
/* Register default value on SPRMCC: 0x000003FE                                 */
/* Register default value on SPRUCC: 0x000003FE                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Bank Logical to Physical Mapping Lookup Table.
*/


#define CPGC_SEQ_BANK_L2P_MAPPING_F_MCCPGC_MAIN_REG 0x2802934C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_bank30_mapping : 5;

                            /* Bits[4:0], Access Type=RW, default=0x0000001E*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 l2p_bank31_mapping : 5;

                            /* Bits[9:5], Access Type=RW, default=0x0000001F*/

                            /*
                               Defines what Physical Bank address (Memory
                               Controller Address Domain) is mapped to this
                               Logical Bank address (Sequence Address Logic
                               Domain). Basically the Banks are re-
                               ordered/swapped allowing you to change the order
                               of Physical Bank numbers. It is possible to use
                               more Logical Banks then Physical Banks in more
                               complex tests where multiple non-linear Physical
                               Bank ordering is needed. The output still goes
                               through the L2P swizzle, so the field value is
                               still actually a Logical Bank address.
                            */
    UINT32 rsvd : 22;

                            /* Bits[31:10], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_BANK_L2P_MAPPING_F_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_RANK_ADDR_SWIZZLE_MCCPGC_MAIN_REG supported on:                     */
/*      SPRA0 (0x20009350)                                                      */
/*      SPRB0 (0x20009350)                                                      */
/*      SPRHBM (0x20009350)                                                     */
/*      SPRC0 (0x20009350)                                                      */
/*      SPRMCC (0x20009350)                                                     */
/*      SPRUCC (0x20009350)                                                     */
/* Register default value on SPRA0: 0x01CDEB38                                  */
/* Register default value on SPRB0: 0x01CDEB38                                  */
/* Register default value on SPRHBM: 0x01CDEB38                                 */
/* Register default value on SPRC0: 0x01CDEB38                                  */
/* Register default value on SPRMCC: 0x01CDEB38                                 */
/* Register default value on SPRUCC: 0x01CDEB38                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Swizzle the Logical to Physical Rank bits.
*/


#define CPGC_SEQ_RANK_ADDR_SWIZZLE_MCCPGC_MAIN_REG 0x28029350

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_rank0_swizzle : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000018*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Rank address bit.
                               Only Physical Rank address bits available to the
                               memory controller are valid, others should be
                               set to 0x1F.[br] Logical Column bits start at
                               index 0, Bank bits start at index 23 (and extend
                               down in index), and Rank bits start at index 24.
                               Row[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_rank1_swizzle : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000019*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Rank address bit.
                               Only Physical Rank address bits available to the
                               memory controller are valid, others should be
                               set to 0x1F.[br] Logical Column bits start at
                               index 0, Bank bits start at index 23 (and extend
                               down in index), and Rank bits start at index 24.
                               Row[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_rank2_swizzle : 5;

                            /* Bits[14:10], Access Type=RW, default=0x0000001A*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Rank address bit.
                               Only Physical Rank address bits available to the
                               memory controller are valid, others should be
                               set to 0x1F.[br] Logical Column bits start at
                               index 0, Bank bits start at index 23 (and extend
                               down in index), and Rank bits start at index 24.
                               Row[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_rank3_swizzle : 5;

                            /* Bits[19:15], Access Type=RW, default=0x0000001B*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Rank address bit.
                               Only Physical Rank address bits available to the
                               memory controller are valid, others should be
                               set to 0x1F.[br] Logical Column bits start at
                               index 0, Bank bits start at index 23 (and extend
                               down in index), and Rank bits start at index 24.
                               Row[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_rank4_swizzle : 5;

                            /* Bits[24:20], Access Type=RW, default=0x0000001C*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Rank address bit.
                               Only Physical Rank address bits available to the
                               memory controller are valid, others should be
                               set to 0x1F.[br] Logical Column bits start at
                               index 0, Bank bits start at index 23 (and extend
                               down in index), and Rank bits start at index 24.
                               Row[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 rsvd : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_RANK_ADDR_SWIZZLE_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_BANK_ADDR_SWIZZLE_MCCPGC_MAIN_REG supported on:                     */
/*      SPRA0 (0x20009354)                                                      */
/*      SPRB0 (0x20009354)                                                      */
/*      SPRHBM (0x20009354)                                                     */
/*      SPRC0 (0x20009354)                                                      */
/*      SPRMCC (0x20009354)                                                     */
/*      SPRUCC (0x20009354)                                                     */
/* Register default value on SPRA0: 0x01CDEB38                                  */
/* Register default value on SPRB0: 0x01CDEB38                                  */
/* Register default value on SPRHBM: 0x01CDEB38                                 */
/* Register default value on SPRC0: 0x01CDEB38                                  */
/* Register default value on SPRMCC: 0x01CDEB38                                 */
/* Register default value on SPRUCC: 0x01CDEB38                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Swizzle the Logical to Physical Bank bits.
*/


#define CPGC_SEQ_BANK_ADDR_SWIZZLE_MCCPGC_MAIN_REG 0x28029354

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_bank0_swizzle : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000018*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Bank address bit.
                               Only Physical Bank address bits available to the
                               memory controller are valid, others should be
                               set to 0x1F.[br] Logical Row bits start at index
                               0, Rank bits start at index 23 (and extend down
                               in index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29.
                            */
    UINT32 l2p_bank1_swizzle : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000019*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Bank address bit.
                               Only Physical Bank address bits available to the
                               memory controller are valid, others should be
                               set to 0x1F.[br] Logical Row bits start at index
                               0, Rank bits start at index 23 (and extend down
                               in index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_bank2_swizzle : 5;

                            /* Bits[14:10], Access Type=RW, default=0x0000001A*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Bank address bit.
                               Only Physical Bank address bits available to the
                               memory controller are valid, others should be
                               set to 0x1F.[br] Logical Row bits start at index
                               0, Rank bits start at index 23 (and extend down
                               in index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_bank3_swizzle : 5;

                            /* Bits[19:15], Access Type=RW, default=0x0000001B*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Bank address bit.
                               Only Physical Bank address bits available to the
                               memory controller are valid, others should be
                               set to 0x1F.[br] Logical Row bits start at index
                               0, Rank bits start at index 23 (and extend down
                               in index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_bank4_swizzle : 5;

                            /* Bits[24:20], Access Type=RW, default=0x0000001C*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Bank address bit.
                               Only Physical Bank address bits available to the
                               memory controller are valid, others should be
                               set to 0x1F.[br] Logical Row bits start at index
                               0, Rank bits start at index 23 (and extend down
                               in index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 rsvd : 7;

                            /* Bits[31:25], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_BANK_ADDR_SWIZZLE_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_ROW_ADDR_SWIZZLE_A_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x20009358)                                                      */
/*      SPRB0 (0x20009358)                                                      */
/*      SPRHBM (0x20009358)                                                     */
/*      SPRC0 (0x20009358)                                                      */
/*      SPRMCC (0x20009358)                                                     */
/*      SPRUCC (0x20009358)                                                     */
/* Register default value on SPRA0: 0x0A418820                                  */
/* Register default value on SPRB0: 0x0A418820                                  */
/* Register default value on SPRHBM: 0x0A418820                                 */
/* Register default value on SPRC0: 0x0A418820                                  */
/* Register default value on SPRMCC: 0x0A418820                                 */
/* Register default value on SPRUCC: 0x0A418820                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Swizzle the Logical to Physical Row bits.
*/


#define CPGC_SEQ_ROW_ADDR_SWIZZLE_A_MCCPGC_MAIN_REG 0x28029358

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_row0_swizzle : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_row1_swizzle : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000001*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_row2_swizzle : 5;

                            /* Bits[14:10], Access Type=RW, default=0x00000002*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_row3_swizzle : 5;

                            /* Bits[19:15], Access Type=RW, default=0x00000003*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_row4_swizzle : 5;

                            /* Bits[24:20], Access Type=RW, default=0x00000004*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_row5_swizzle : 5;

                            /* Bits[29:25], Access Type=RW, default=0x00000005*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_ROW_ADDR_SWIZZLE_A_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_ROW_ADDR_SWIZZLE_B_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x2000935c)                                                      */
/*      SPRB0 (0x2000935c)                                                      */
/*      SPRHBM (0x2000935c)                                                     */
/*      SPRC0 (0x2000935c)                                                      */
/*      SPRMCC (0x2000935c)                                                     */
/*      SPRUCC (0x2000935c)                                                     */
/* Register default value on SPRA0: 0x16A4A0E6                                  */
/* Register default value on SPRB0: 0x16A4A0E6                                  */
/* Register default value on SPRHBM: 0x16A4A0E6                                 */
/* Register default value on SPRC0: 0x16A4A0E6                                  */
/* Register default value on SPRMCC: 0x16A4A0E6                                 */
/* Register default value on SPRUCC: 0x16A4A0E6                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Swizzle the Logical to Physical Row bits.
*/


#define CPGC_SEQ_ROW_ADDR_SWIZZLE_B_MCCPGC_MAIN_REG 0x2802935C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_row6_swizzle : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000006*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_row7_swizzle : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000007*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_row8_swizzle : 5;

                            /* Bits[14:10], Access Type=RW, default=0x00000008*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_row9_swizzle : 5;

                            /* Bits[19:15], Access Type=RW, default=0x00000009*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_row10_swizzle : 5;

                            /* Bits[24:20], Access Type=RW, default=0x0000000A*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_row11_swizzle : 5;

                            /* Bits[29:25], Access Type=RW, default=0x0000000B*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_ROW_ADDR_SWIZZLE_B_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_ROW_ADDR_SWIZZLE_C_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x20009360)                                                      */
/*      SPRB0 (0x20009360)                                                      */
/*      SPRHBM (0x20009360)                                                     */
/*      SPRC0 (0x20009360)                                                      */
/*      SPRMCC (0x20009360)                                                     */
/*      SPRUCC (0x20009360)                                                     */
/* Register default value on SPRA0: 0x2307B9AC                                  */
/* Register default value on SPRB0: 0x2307B9AC                                  */
/* Register default value on SPRHBM: 0x2307B9AC                                 */
/* Register default value on SPRC0: 0x2307B9AC                                  */
/* Register default value on SPRMCC: 0x2307B9AC                                 */
/* Register default value on SPRUCC: 0x2307B9AC                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Swizzle the Logical to Physical Row bits.
*/


#define CPGC_SEQ_ROW_ADDR_SWIZZLE_C_MCCPGC_MAIN_REG 0x28029360

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_row12_swizzle : 5;

                            /* Bits[4:0], Access Type=RW, default=0x0000000C*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_row13_swizzle : 5;

                            /* Bits[9:5], Access Type=RW, default=0x0000000D*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_row14_swizzle : 5;

                            /* Bits[14:10], Access Type=RW, default=0x0000000E*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_row15_swizzle : 5;

                            /* Bits[19:15], Access Type=RW, default=0x0000000F*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_row16_swizzle : 5;

                            /* Bits[24:20], Access Type=RW, default=0x00000010*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_row17_swizzle : 5;

                            /* Bits[29:25], Access Type=RW, default=0x00000011*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Row address. Only
                               Row address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Row bits start at index 0,
                               Rank bits start at index 23 (and extend down in
                               index), and Bank bits start at index 24.
                               Column[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_ROW_ADDR_SWIZZLE_C_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_ROW_ADDR_SWIZZLE_X_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x20009364)                                                      */
/*      SPRB0 (0x20009364)                                                      */
/*      SPRHBM (0x20009364)                                                     */
/*      SPRC0 (0x20009364)                                                      */
/*      SPRMCC (0x20009364)                                                     */
/*      SPRUCC (0x20009364)                                                     */
/* Register default value on SPRA0: 0x000FFFFF                                  */
/* Register default value on SPRB0: 0x000FFFFF                                  */
/* Register default value on SPRHBM: 0x000FFFFF                                 */
/* Register default value on SPRC0: 0x000FFFFF                                  */
/* Register default value on SPRMCC: 0x000FFFFF                                 */
/* Register default value on SPRUCC: 0x000FFFFF                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Swizzle/Inject an XOR toggle (remapping of addresses) within the Physical Row bits.
*/


#define CPGC_SEQ_ROW_ADDR_SWIZZLE_X_MCCPGC_MAIN_REG 0x28029364

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_row0_xor_swizzle : 5;

                            /* Bits[4:0], Access Type=RW, default=0x0000001F*/

                            /*
                               Row XOR source selection for lower order Row
                               addresses. Select 31 if only using a direct
                               mapping with no XOR. A value of 31 will select a
                               constant '0' value.[br] Logical Row bits start
                               at index 0, Rank Bits start at index 23 (and
                               extend down in index), and Bank bits start at
                               index 24. Column[1:0] bits are at index 30 and
                               29. [18] is 1'b1 so that can be used to static
                               invert the Row bit.
                            */
    UINT32 l2p_row1_xor_swizzle : 5;

                            /* Bits[9:5], Access Type=RW, default=0x0000001F*/

                            /*
                               Row XOR source selection for lower order Row
                               addresses. Select 31 if only using a direct
                               mapping with no XOR. A value of 31 will select a
                               constant '0' value.[br] Logical Row bits start
                               at index 0, Rank Bits start at index 23 (and
                               extend down in index), and Bank bits start at
                               index 24. Column[1:0] bits are at index 30 and
                               29. [18] is 1'b1 so that can be used to static
                               invert the Row bit.
                            */
    UINT32 l2p_row2_xor_swizzle : 5;

                            /* Bits[14:10], Access Type=RW, default=0x0000001F*/

                            /*
                               Row XOR source selection for lower order Row
                               addresses. Select 31 if only using a direct
                               mapping with no XOR. A value of 31 will select a
                               constant '0' value.[br] Logical Row bits start
                               at index 0, Rank Bits start at index 23 (and
                               extend down in index), and Bank bits start at
                               index 24. Column[1:0] bits are at index 30 and
                               29. [18] is 1'b1 so that can be used to static
                               invert the Row bit.
                            */
    UINT32 l2p_row3_xor_swizzle : 5;

                            /* Bits[19:15], Access Type=RW, default=0x0000001F*/

                            /*
                               Row XOR source selection for lower order Row
                               addresses. Select 31 if only using a direct
                               mapping with no XOR. A value of 31 will select a
                               constant '0' value.[br] Logical Row bits start
                               at index 0, Rank Bits start at index 23 (and
                               extend down in index), and Bank bits start at
                               index 24. Column[1:0] bits are at index 30 and
                               29. [18] is 1'b1 so that can be used to static
                               invert the Row bit.
                            */
    UINT32 rsvd : 9;

                            /* Bits[28:20], Access Type=RO, default=None*/

                            /* Reserved */
    UINT32 addr_dq_inv_en : 1;

                            /* Bits[29:29], Access Type=RW, default=0x00000000*/

                            /*
                               Enables the lookup table to invert the DQs based
                               on select Row address bits.
                            */
    UINT32 rsvd_30 : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_ROW_ADDR_SWIZZLE_X_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_COL_ADDR_SWIZZLE_A_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x20009368)                                                      */
/*      SPRB0 (0x20009368)                                                      */
/*      SPRHBM (0x20009368)                                                     */
/*      SPRC0 (0x20009368)                                                      */
/*      SPRMCC (0x20009368)                                                     */
/*      SPRUCC (0x20009368)                                                     */
/* Register default value on SPRA0: 0x0A418820                                  */
/* Register default value on SPRB0: 0x0A418820                                  */
/* Register default value on SPRHBM: 0x0A418820                                 */
/* Register default value on SPRC0: 0x0A418820                                  */
/* Register default value on SPRMCC: 0x0A418820                                 */
/* Register default value on SPRUCC: 0x0A418820                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Swizzle the Logical to Physical Column bits.
*/


#define CPGC_SEQ_COL_ADDR_SWIZZLE_A_MCCPGC_MAIN_REG 0x28029368

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_col0_swizzle : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000000*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Column address.
                               Only Column address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Column bits start at index 0,
                               Bank bits start at index 23 (and extend down in
                               index), and Rank bits start at index 24.
                               Row[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_col1_swizzle : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000001*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Column address.
                               Only Column address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Column bits start at index 0,
                               Bank bits start at index 23 (and extend down in
                               index), and Rank bits start at index 24.
                               Row[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_col2_swizzle : 5;

                            /* Bits[14:10], Access Type=RW, default=0x00000002*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Column address.
                               Only Column address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Column bits start at index 0,
                               Bank bits start at index 23 (and extend down in
                               index), and Rank bits start at index 24.
                               Row[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_col3_swizzle : 5;

                            /* Bits[19:15], Access Type=RW, default=0x00000003*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Column address.
                               Only Column address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Column bits start at index 0,
                               Bank bits start at index 23 (and extend down in
                               index), and Rank bits start at index 24.
                               Row[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_col4_swizzle : 5;

                            /* Bits[24:20], Access Type=RW, default=0x00000004*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Column address.
                               Only Column address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Column bits start at index 0,
                               Bank bits start at index 23 (and extend down in
                               index), and Rank bits start at index 24.
                               Row[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_col5_swizzle : 5;

                            /* Bits[29:25], Access Type=RW, default=0x00000005*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Column address.
                               Only Column address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Column bits start at index 0,
                               Bank bits start at index 23 (and extend down in
                               index), and Rank bits start at index 24.
                               Row[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_COL_ADDR_SWIZZLE_A_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_COL_ADDR_SWIZZLE_B_MCCPGC_MAIN_REG supported on:                    */
/*      SPRA0 (0x2000936c)                                                      */
/*      SPRB0 (0x2000936c)                                                      */
/*      SPRHBM (0x2000936c)                                                     */
/*      SPRC0 (0x2000936c)                                                      */
/*      SPRMCC (0x2000936c)                                                     */
/*      SPRUCC (0x2000936c)                                                     */
/* Register default value on SPRA0: 0x16A4A0E6                                  */
/* Register default value on SPRB0: 0x16A4A0E6                                  */
/* Register default value on SPRHBM: 0x16A4A0E6                                 */
/* Register default value on SPRC0: 0x16A4A0E6                                  */
/* Register default value on SPRMCC: 0x16A4A0E6                                 */
/* Register default value on SPRUCC: 0x16A4A0E6                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Swizzle the Logical to Physical Column bits.
*/


#define CPGC_SEQ_COL_ADDR_SWIZZLE_B_MCCPGC_MAIN_REG 0x2802936C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 l2p_col6_swizzle : 5;

                            /* Bits[4:0], Access Type=RW, default=0x00000006*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Column address.
                               Only Column address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Column bits start at index 0,
                               Bank bits start at index 23 (and extend down in
                               index), and Rank bits start at index 24.
                               Row[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_col7_swizzle : 5;

                            /* Bits[9:5], Access Type=RW, default=0x00000007*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Column address.
                               Only Column address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Column bits start at index 0,
                               Bank bits start at index 23 (and extend down in
                               index), and Rank bits start at index 24.
                               Row[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_col8_swizzle : 5;

                            /* Bits[14:10], Access Type=RW, default=0x00000008*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Column address.
                               Only Column address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Column bits start at index 0,
                               Bank bits start at index 23 (and extend down in
                               index), and Rank bits start at index 24.
                               Row[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_col9_swizzle : 5;

                            /* Bits[19:15], Access Type=RW, default=0x00000009*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Column address.
                               Only Column address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Column bits start at index 0,
                               Bank bits start at index 23 (and extend down in
                               index), and Rank bits start at index 24.
                               Row[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_col10_swizzle : 5;

                            /* Bits[24:20], Access Type=RW, default=0x0000000A*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Column address.
                               Only Column address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Column bits start at index 0,
                               Bank bits start at index 23 (and extend down in
                               index), and Rank bits start at index 24.
                               Row[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 l2p_col11_swizzle : 5;

                            /* Bits[29:25], Access Type=RW, default=0x0000000B*/

                            /*
                               Defines the selection of a Logical Address bit
                               to be mapped to this Physical Column address.
                               Only Column address bits available to the memory
                               controller are valid, others should be set to
                               0x1F.[br] Logical Column bits start at index 0,
                               Bank bits start at index 23 (and extend down in
                               index), and Rank bits start at index 24.
                               Row[1:0] bits are at index 30 and 29. [18] is
                               1'b1 so that can be used to set a physical
                               address bit to a 1.
                            */
    UINT32 rsvd : 2;

                            /* Bits[31:30], Access Type=RO, default=None*/

                            /* Reserved */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_COL_ADDR_SWIZZLE_B_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_ROW_ADDR_DQ_MAP0_MCCPGC_MAIN_REG supported on:                      */
/*      SPRA0 (0x20009378)                                                      */
/*      SPRB0 (0x20009378)                                                      */
/*      SPRHBM (0x20009378)                                                     */
/*      SPRC0 (0x20009378)                                                      */
/*      SPRMCC (0x20009378)                                                     */
/*      SPRUCC (0x20009378)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DQ Map Register 0.
*/


#define CPGC_SEQ_ROW_ADDR_DQ_MAP0_MCCPGC_MAIN_REG 0x28029378

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Data written to this register will be placed in
                               the DQ Map register as a stack. Data is read
                               from the bottom of the stack (higher locations).
                               The last write covers Row addresses of Row[11:4]
                               == (0..31).[br] Reading requires you to write
                               into the stack to get the next location. Since
                               this is destructive, if the data is to be
                               preserved, then the data read should be used for
                               the write. See documentation for details.
                            */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_ROW_ADDR_DQ_MAP0_MCCPGC_MAIN_STRUCT;

/* CPGC_SEQ_ROW_ADDR_DQ_MAP1_MCCPGC_MAIN_REG supported on:                      */
/*      SPRA0 (0x2000937c)                                                      */
/*      SPRB0 (0x2000937c)                                                      */
/*      SPRHBM (0x2000937c)                                                     */
/*      SPRC0 (0x2000937c)                                                      */
/*      SPRMCC (0x2000937c)                                                     */
/*      SPRUCC (0x2000937c)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* DQ Map Register 1.
*/


#define CPGC_SEQ_ROW_ADDR_DQ_MAP1_MCCPGC_MAIN_REG 0x2802937C

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 data : 32;

                            /* Bits[31:0], Access Type=RW/V, default=0x00000000*/

                            /*
                               Data written to this register will be placed in
                               the DQ Map register as a stack. Data is read
                               from the bottom of the stack (higher locations).
                               The last write covers Row addresses of Row[11:4]
                               == (32..63).[br] Reading requires you to write
                               into the stack to get the next location. Since
                               this is destructive, if the data is to be
                               preserved, then the data read should be used for
                               the write. See documentation for details.
                            */

  } Bits;
  UINT32 Data;

} CPGC_SEQ_ROW_ADDR_DQ_MAP1_MCCPGC_MAIN_STRUCT;

/* CPGC_A_DUMMY_N0_MCCPGC_MAIN_REG supported on:                                */
/*      SPRA0 (0x20009380)                                                      */
/*      SPRB0 (0x20009380)                                                      */
/*      SPRHBM (0x20009380)                                                     */
/*      SPRC0 (0x20009380)                                                      */
/*      SPRMCC (0x20009380)                                                     */
/*      SPRUCC (0x20009380)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Dummy register to generate RTL packages with Access Width = 64 for cpgc_a submap.
*/


#define CPGC_A_DUMMY_N0_MCCPGC_MAIN_REG 0x28029380

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dummy : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /*
                               Dummy register field to generate RTL packages
                               with Access Width = 64 for cpgc_a submap.
                            */

  } Bits;
  UINT32 Data;

} CPGC_A_DUMMY_N0_MCCPGC_MAIN_STRUCT;

/* CPGC_A_DUMMY_N1_MCCPGC_MAIN_REG supported on:                                */
/*      SPRA0 (0x20009384)                                                      */
/*      SPRB0 (0x20009384)                                                      */
/*      SPRHBM (0x20009384)                                                     */
/*      SPRC0 (0x20009384)                                                      */
/*      SPRMCC (0x20009384)                                                     */
/*      SPRUCC (0x20009384)                                                     */
/* Register default value on SPRA0: 0x00000000                                  */
/* Register default value on SPRB0: 0x00000000                                  */
/* Register default value on SPRHBM: 0x00000000                                 */
/* Register default value on SPRC0: 0x00000000                                  */
/* Register default value on SPRMCC: 0x00000000                                 */
/* Register default value on SPRUCC: 0x00000000                                 */
/* SPRA0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRB0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRHBM Register File:    sprsp_top/mc_cpgc_reg[8]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRC0 Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRMCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* SPRUCC Register File:    sprsp_top/mc_cpgc_reg[0]/cpgc_reqgen0/cpgc_a/cpgc_a_sub_MEM*/
/* Struct generated from SPRA0 BDF: 0_0_0                                       */
/* SPRA0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRB0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRHBM Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRC0 Security PolicyGroup: CPGC_PROTECTED                                   */
/* SPRMCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* SPRUCC Security PolicyGroup: CPGC_PROTECTED                                  */
/* Dummy register to generate RTL packages with Access Width = 64 for cpgc_a submap.
*/


#define CPGC_A_DUMMY_N1_MCCPGC_MAIN_REG 0x28029384

typedef union {
  ///
  /// Individual bit fields
  ///
  struct {
    UINT32 dummy : 32;

                            /* Bits[31:0], Access Type=RO, default=0x00000000*/

                            /*
                               Dummy register field to generate RTL packages
                               with Access Width = 64 for cpgc_a submap.
                            */

  } Bits;
  UINT32 Data;

} CPGC_A_DUMMY_N1_MCCPGC_MAIN_STRUCT;
#endif /* _MCCPGC_MAIN_h */
