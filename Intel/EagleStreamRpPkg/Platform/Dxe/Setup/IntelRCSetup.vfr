/** @file

  @copyright
  INTEL CONFIDENTIAL
  Copyright 1999 - 2020 Intel Corporation. <BR>

  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary    and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.

  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.

  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.
**/

#include "Configuration.h"

#include "PlatformStrDefs.h"
#include <Guid/SetupVariable.h>
#include <SocketConfiguration.h>
#include <Guid/SocketVariable.h>
#include <CpuAndRevisionDefines.h>
//
// PCH_VARIABLE
// Add the PCH variables till we move to PCH pkg
//
#include <PchSetupVariable.h>

//
// ME_VARIABLE
// Add the ME variables till we move to ME pkg
//
#if defined(ME_SUPPORT_FLAG) && ME_SUPPORT_FLAG
#include <MeRcConfiguration.h>
#include <Guid/MeRcVariable.h>
#include <MeTypeDefs.h>
#include <MeSetup.h>
#include <IccSetupData.h>
#endif // ME_SUPPORT_FLAG




#include "Common.hfr"
#include "../Platform/Dxe/SocketSetup/VariableCommon.hfr"

#define SV_CONFIGURATION_GUID \
  { 0x8F5F20CA, 0x88EB, 0x4BE4, { 0x95, 0x79, 0x8F, 0xF7, 0xCC, 0xBA, 0x92, 0x4C } }
  
// APTIOV_SERVER_OVERRIDE_RC_START : Syncing Default value with AMI PCI driver.
#include <Token.h>
// APTIOV_SERVER_OVERRIDE_RC_END : Syncing Default value with AMI PCI driver.

// APTIOV_SERVER_OVERRIDE_RC_START : Name modified
formset
    guid      = SYSTEM_CONFIGURATION_GUID,
    title     = STRING_TOKEN(STR_INTELRCSETUP_TITLE),
    help      = STRING_TOKEN(STR_INTELRCSETUP_HELP),
    class     = VFR_INTELRCSETUP_CLASS,
    subclass  = 0,
// APTIOV_SERVER_OVERRIDE_RC_END : Name modified

    VFR_VARSTORE_SETUP
    efivarstore PCH_SETUP,                  attribute = PLATFORM_VARIABLE_ATTRIBUTES,  name = PchSetup,             guid = PCH_SETUP_GUID;
#if defined(ME_SUPPORT_FLAG) && ME_SUPPORT_FLAG
    efivarstore ME_RC_CONFIGURATION,        attribute = PLATFORM_VARIABLE_ATTRIBUTES,  name = MeRcConfiguration,       guid = ME_RC_CONFIGURATION_GUID;
    varstore    ME_SETUP_STORAGE,           varid = ME_SETUP_STORAGE_ID,               name = MeSetupStorage,          guid = ME_RC_CONFIGURATION_GUID;
    varstore    ICC_SETUP_DATA,             varid = ICC_SETUP_ID,                      name = IccAdvancedSetupDataVar, guid = ME_RC_CONFIGURATION_GUID;
#endif // ME_SUPPORT_FLAG

#ifdef IPMI_SUPPORT
        efivarstore UINT8,
                attribute =  EFI_VARIABLE_BOOTSERVICE_ACCESS,
                name = BmcEnabledFlag,
                guid = BMC_ENABLE_FLAG_GUID;
#endif //IPMI_SUPPORT
//
// Do not use these for any construct that will change values, they are not saved by the SetupPlatform.c config routines.
// so using them as a value in a Grayout or suppress is fine, in something like a "one of" or a checkbox is not
// Failure to follow this guideline will result in the changed values not being saved on setup exit.
// For those cases where the values need to be changed, they should be placed in the proper setup forms Pkg.
//
    VFR_VARSTORE_SOCKET

  VFR_FAKE_VARSTORE

    defaultstore MyStandardDefault,
      prompt      = STRING_TOKEN(STR_STANDARD_DEFAULT_PROMPT),
      attribute   = 0x0000;                         // Default ID: 0000 standard default

    defaultstore MyManufactureDefault,
      prompt      = STRING_TOKEN(STR_MANUFACTURE_DEFAULT_PROMPT),
      attribute   = 0x0001;

// APTIOV_SERVER_OVERRIDE_RC_START : Name modified
    form formid = VFR_FORMID_INTELRCSETUP,

        title = STRING_TOKEN(STR_INTELRCSETUP_TITLE);
// APTIOV_SERVER_OVERRIDE_RC_END : Name modified

        suppressif TRUE;
          oneof varid     = FAKE_VARSTORE.FakeItem,
              prompt      = STRING_TOKEN(STR_FAKE_VARSTORE),
              help        = STRING_TOKEN(STR_FAKE_VARSTORE_HELP),
              option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED | MANUFACTURING | DEFAULT;
              option text = STRING_TOKEN(STR_DISABLE),  value = 1, flags = RESET_REQUIRED;
          endoneof;
        endif;

        disableif TRUE;
            numeric varid     = SYSTEM_CONFIGURATION.VariablePlatId,
            prompt      = STRING_TOKEN(STR_PLATID_PROMPT_PC),
            help        = STRING_TOKEN(STR_PLATID_PROMPT_HELP_PC),
              minimum = 0,
              maximum = 0x1,
              step    = 1,
            endnumeric;
        endif;

        //
        //  Explicit definition of the following variables configured by BIOS at runtime:
        //    - PlatformOCSupport
        //    - AntiFlashWearoutSupported
        //    - BiosGuardPlatformSupported
        //  If not explicitly declared vfr compiler will set RESET_REQUIRED flag,
        //  potentially forcing reboot any time defaults are loaded.
        //
        suppressif TRUE;
          checkbox varid = SYSTEM_CONFIGURATION.PlatformOCSupport,
            prompt  = STRING_TOKEN(STR_PLATFORM_OC_SUPPORT_PROMPT),
            help    = STRING_TOKEN(STR_PLATFORM_OC_SUPPORT_HELP),
            flags    = 0,
            default  = 0, defaultstore = MyStandardDefault,
            default  = 0, defaultstore = MyManufactureDefault,
          endcheckbox;
        endif;

        suppressif TRUE;
          checkbox varid = SYSTEM_CONFIGURATION.AntiFlashWearoutSupported,
            prompt   = STRING_TOKEN(STR_ANTI_FW_SUPPORTED_PROMPT),
            help     = STRING_TOKEN(STR_ANTI_FW_SUPPORTED_HELP),
            flags    = 0,
            default  = 0, defaultstore = MyStandardDefault,
            default  = 0, defaultstore = MyManufactureDefault,
          endcheckbox;
        endif;

        suppressif TRUE;
          checkbox varid = SYSTEM_CONFIGURATION.BiosGuardPlatformSupported,
            prompt   = STRING_TOKEN(STR_BIOS_GUARD_SUPPORTED_PROMPT),
            help     = STRING_TOKEN(STR_BIOS_GUARD_SUPPORTED_HELP),
            flags    = 0,
            default  = 0, defaultstore = MyStandardDefault,
            default  = 0, defaultstore = MyManufactureDefault,
          endcheckbox;
        endif;

        // Jump to Pch Configuration Form
        //
        goto SB_FORM_ID,
            prompt = STRING_TOKEN(STR_SB_FORM),
            help   = STRING_TOKEN(STR_SB_FORM_HELP);


        // Jump to the Overclocking Form
        //
        suppressif  ideqval SYSTEM_CONFIGURATION.PlatformOCSupport == 0;
          goto VFR_FORMID_OVERCLOCKING,
              prompt = STRING_TOKEN(STR_OVERCLOCKING_MENU_CONFIGURATION),
              help   = STRING_TOKEN(STR_OVERCLOCKING_CONFIGURATION_HELP);
        endif;

        //
        // Jump to Miscelleneous Configuration Form
        //
        goto VFR_FORMID_MISC,
            prompt = STRING_TOKEN(STR_MISC_FORM_TITLE),
            help   = STRING_TOKEN(STR_MISC_FORM_HELP);
        // APTIOV_SERVER_OVERRIDE_RC_START : Removing as equivalent setup page is available from AMI
	/*
        //
        // Console Redirection setup
        //
        goto VFR_FORMID_CONSOLE_REDIRECTION_CONFIGURATION,
            prompt = STRING_TOKEN(STR_CONSOLE_REDIRECTION_CONFIGURATION_FORM_TITLE),
            help   = STRING_TOKEN(STR_CONSOLE_REDIRECTION_CONFIGURATION_FORM_TITLE_HELP);
        */
	// APTIOV_SERVER_OVERRIDE_RC_END
        //
        // Jump to Network Configuration Form
        //
        // APTIOV_SERVER_OVERRIDE_RC_START : Removing unused intel setup .uni/.hfr files.
        /*
        goto VFR_FORMID_NETWORK,
            prompt = STRING_TOKEN(STR_NETWORK_CONFIGURATION),
            help   = STRING_TOKEN(STR_NETWORK_CONFIGURATION_HELP);
        */
        // APTIOV_SERVER_OVERRIDE_RC_END
#if defined(ME_SUPPORT_FLAG) && ME_SUPPORT_FLAG
#if defined(ME_SPS_SUPPORT) && ME_SPS_SUPPORT
        //
        // Jump to Server ME FW Configuration Form
        //
        suppressif NOT ideqval ME_RC_CONFIGURATION.MeType == METYPE_SPS;
          goto VFR_FORMID_SPS_ME,
           prompt  = STRING_TOKEN(STR_SPS_FORM),
           help    = STRING_TOKEN(STR_SPS_FORM_HELP);
        endif; // Suppress if MeType != SPS

#if defined(ME_TESTMENU_FLAG) && ME_TESTMENU_FLAG
        //
        // Jump to Server ME FW Debug Form
        //
        suppressif NOT ideqval ME_RC_CONFIGURATION.MeType == METYPE_SPS;
          goto VFR_FORMID_SPS_FWDEBUG,
           prompt  = STRING_TOKEN(STR_SPS_FWDEBUG_FORM),
           help    = STRING_TOKEN(STR_SPS_FWDEBUG_FORM_HELP);
        endif; // Suppress if MeType != SPS
#endif // ME_TESTMENU_FLAG
#endif // ME_SPS_SUPPORT

#if defined(ME_TESTMENU_FLAG) && ME_TESTMENU_FLAG
        //
        // Jump to ME DFX FW Debug Form
        //
        suppressif NOT ideqval ME_RC_CONFIGURATION.MeType == METYPE_DFX;
          goto VFR_FORMID_DFX_FWDEBUG,
           prompt  = STRING_TOKEN(STR_DFX_FWDEBUG_FORM),
           help    = STRING_TOKEN(STR_DFX_FWDEBUG_FORM_HELP);
        endif; // Suppress if MeType != DFX
#endif // ME_TESTMENU_FLAG

#if defined(ME_WS_SUPPORT) && ME_WS_SUPPORT
        //
        // Jump to WS ME FW Configuration Form
        //
        suppressif NOT ideqval ME_RC_CONFIGURATION.MeType == METYPE_CLIENT;
          goto ME_FORM_ID,
            prompt  = STRING_TOKEN(STR_WS_FORM),
            help    = STRING_TOKEN(STR_WS_FORM_HELP);

          goto ICC_FORM_ID,
            prompt = STRING_TOKEN(STR_BCLK_FORM),
            help   = STRING_TOKEN(STR_BCLK_FORM_HELP),
            flags  = 0,
            key    = 0;
        endif; // Suppress if MeType != WS
#endif // ME_WS_SUPPORT
#endif // ME_SUPPORT_FLAG


        //
        // Jump to Event Log Form
        //
        goto VFR_FORMID_EVENT_LOG,
            prompt = STRING_TOKEN(STR_EVENT_LOG_FORM_TITLE),
            help   = STRING_TOKEN(STR_EVENT_LOG_FORM_HELP);

        //
        // Jump to Reserve Memory Form
        //
        goto VFR_RESERVE_MEMORY,
            prompt = STRING_TOKEN(STR_RESERVE_MEMORY_OPTION),
            help   = STRING_TOKEN(STR_RESERVE_MEMORY_OPTION_HELP);

        //
        // Jump to BootAllOptions Form
        //
        // APTIOV_SERVER_OVERRIDE_RC_START : Removing unused intel setup .uni/.hfr files.
        /*
        goto VFR_BOOT_ALL_OPTIONS,
            prompt = STRING_TOKEN(STR_BOOT_ALL_OPTIONS),
            help   = STRING_TOKEN(STR_BOOT_ALL_OPTIONS_HELP);
	*/
        // APTIOV_SERVER_OVERRIDE_RC_END
        //
        // Jump to CommonRc Configuration Form
        //

        subtitle text = STRING_TOKEN(STR_NULL_STRING);


        subtitle text = STRING_TOKEN(STR_HORIZONTAL_LINE);
        subtitle text = STRING_TOKEN(STR_WARNING_MESSAGE1);
        subtitle text = STRING_TOKEN(STR_WARNING_MESSAGE2);
        subtitle text = STRING_TOKEN(STR_WARNING_MESSAGE3);

    endform;



    //
    // Miscelleneous Configuration Form
    //
    form formid = VFR_FORMID_MISC,

        title    = STRING_TOKEN(STR_MISC_FORM_TITLE);

        subtitle text = STRING_TOKEN(STR_MISC_FORM_TITLE);
        subtitle text = STRING_TOKEN(STR_HORIZONTAL_LINE);
        subtitle text = STRING_TOKEN(STR_NULL_STRING);

        //
        // Select Benchmark
        //
        oneof varid     = SYSTEM_CONFIGURATION.ApplicationProfile,
            questionid  = KEY_PLATFORM_APPLICATION_PROFILE,
            prompt      = STRING_TOKEN(STR_APPLICATION_PROFILE_SELECT_PROMPT),
            help        = STRING_TOKEN(STR_APPLICATION_PROFILE_SELECT_HELP),
            flags       = INTERACTIVE,
            option text = STRING_TOKEN(STR_APPLICATION_PROFILE_AUTO),                   value = APPLICATION_PROFILE_AUTO_PROFILE, flags = RESET_REQUIRED | MANUFACTURING | DEFAULT;
            option text = STRING_TOKEN(STR_APPLICATION_PROFILE_GENERAL_COMPUTING),      value = APPLICATION_PROFILE_GENERAL_COMPUTING_PROFILE, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_APPLICATION_PROFILE_MEMORY_BANDWIDTH),       value = APPLICATION_PROFILE_MEMORY_BANDWIDTH_PROFILE, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_APPLICATION_PROFILE_MATRIX_CALCULATION),     value = APPLICATION_PROFILE_MATRIX_CALCULATION_PROFILE, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_APPLICATION_PROFILE_ENERGY_EFFICIENCY),      value = APPLICATION_PROFILE_ENERGY_EFFICIENCY_PROFILE, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_APPLICATION_PROFILE_SERVER_SIDE_JAVA),       value = APPLICATION_PROFILE_SERVER_SIDE_JAVA_PROFILE, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_APPLICATION_PROFILE_OLTP),                   value = APPLICATION_PROFILE_OLTP_PROFILE, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_APPLICATION_PROFILE_VIRTUALIZATION),         value = APPLICATION_PROFILE_VIRTUALIZATION_PROFILE, flags = RESET_REQUIRED;
        endoneof;

        //
        // Select Max Page Table Size
        //
        suppressif TRUE;
          oneof varid     = SYSTEM_CONFIGURATION.Use1GPageTable,
              prompt      = STRING_TOKEN(STR_MAX_PAGE_TABLE_SIZE_SELECT_PROMPT),
              help        = STRING_TOKEN(STR_MAX_PAGE_TABLE_SIZE_SELECT_HELP),
              option text = STRING_TOKEN(STR_1G_PAGE_TABLE),  value = 1, flags = RESET_REQUIRED | MANUFACTURING | DEFAULT;
          endoneof;
        endif;
        //
        // Reset on Memory Map Change
        //
        checkbox varid = SYSTEM_CONFIGURATION.ResetOnMemMapChange,
              prompt     = STRING_TOKEN(STR_MEM_CHANGE_RESET_PROMPT),
              help       = STRING_TOKEN(STR_MEM_CHANGE_RESET_HELP),
              flags      = RESET_REQUIRED,
        endcheckbox;

        oneof varid   = SYSTEM_CONFIGURATION.WakeOnLanSupport,
            prompt        = STRING_TOKEN(STR_WAKE_ON_LAN_SUPPORT_PROMPT),
            help          = STRING_TOKEN(STR_WAKE_ON_LAN_SUPPORT_HELP),
            option text   = STRING_TOKEN(STR_DISABLE),        value = 0, flags = RESET_REQUIRED  | MANUFACTURING | DEFAULT;
            option text   = STRING_TOKEN(STR_ENABLE),         value = 1, flags = RESET_REQUIRED;
        endoneof;
        //
        // Breakpoints
        //
        oneof varid = SYSTEM_CONFIGURATION.ValidationBreakpointType,
            prompt  = STRING_TOKEN(STR_VALIDATION_BREAKPOINT_TYPE),
            help    = STRING_TOKEN(STR_VALIDATION_BREAKPOINT_TYPE_HELP),
            option text = STRING_TOKEN(STR_NONE),           value = 0,  flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_BREAKPOINT_AFTER_MRC),     value = 1,  flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_BREAKPOINT_AFTER_KTIRC),   value = 2,  flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_BREAKPOINT_AFTER_RESOURCE_ALLOC), value = 3,  flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_BREAKPOINT_AFTER_POST), value = 4,  flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_BREAKPOINT_AFTER_FULL_SPEED_SETUP), value = 5,  flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_BREAKPOINT_READY_FOR_IBIST), value = 6, flags = RESET_REQUIRED;
        endoneof;

///
///

         //
         //  Force Setup
         //
         checkbox varid = SYSTEM_CONFIGURATION.ForceSetup,
              prompt   = STRING_TOKEN(STR_FORCE_SETUP_PROMPT),
              help     = STRING_TOKEN(STR_FORCE_SETUP_HELP),
              flags    = RESET_REQUIRED,
              default  = 0, defaultstore = MyStandardDefault,
         endcheckbox;


        //
        //  BIOS Guard setup question
        //
        grayoutif ideqval SYSTEM_CONFIGURATION.BiosGuardPlatformSupported == 0;
         checkbox varid = SYSTEM_CONFIGURATION.BiosGuardEnabled,
              prompt   = STRING_TOKEN(STR_BIOSGUARD_SETUP_PROMPT),
              help     = STRING_TOKEN(STR_BIOSGUARD_SETUP_HELP),
              flags    = RESET_REQUIRED,
              default  = 0, defaultstore = MyStandardDefault,
              default  = 0, defaultstore = MyManufactureDefault,
         endcheckbox;
        endif;

        //
        //  Populate BIOS Guard MSR with BG Directory pointer
        //
        // APTIOV_SERVER_OVERRIDE_RC_START
        suppressif TRUE;
       // APTIOV_SERVER_OVERRIDE_RC_END : Not used in AMI BG
        suppressif ideqval SYSTEM_CONFIGURATION.BiosGuardEnabled == 0;
         checkbox varid = SYSTEM_CONFIGURATION.DfxPopulateBGDirectory,
              prompt   = STRING_TOKEN(STR_DFX_BIOSGUARD_POPULATE_BGDIR_PROMPT),
              help     = STRING_TOKEN(STR_DFX_BIOSGUARD_POPULATE_BGDIR_HELP),
              flags    = RESET_REQUIRED,
              default  = 0, defaultstore = MyStandardDefault,
              default  = 0, defaultstore = MyManufactureDefault,
         endcheckbox;
        endif;
       // APTIOV_SERVER_OVERRIDE_RC_START
        endif; 
       // APTIOV_SERVER_OVERRIDE_RC_END : Not used in AMI BG

        //
        //  Anti Flash Wearout support
        //
        // APTIOV_SERVER_OVERRIDE_RC_START
        suppressif TRUE;
        // APTIOV_SERVER_OVERRIDE_RC_END : Not used in AMI BG
        suppressif ideqval SYSTEM_CONFIGURATION.AntiFlashWearoutSupported == 0;
         checkbox varid = SYSTEM_CONFIGURATION.EnableAntiFlashWearout,
              prompt   = STRING_TOKEN(STR_BIOSGUARD_ANTI_FW_PROMPT),
              help     = STRING_TOKEN(STR_BIOSGUARD_ANTI_FW_HELP),
              flags    = RESET_REQUIRED,
              default  = 0, defaultstore = MyStandardDefault,
              default  = 0, defaultstore = MyManufactureDefault,
         endcheckbox;
        endif;
       // APTIOV_SERVER_OVERRIDE_RC_START
        endif;
       // APTIOV_SERVER_OVERRIDE_RC_END : Not used in AMI BG
        oneof varid   = SYSTEM_CONFIGURATION.XmlCliSupport,
          prompt      = STRING_TOKEN (STR_XML_CLI_SUPPORT_PROMPT),
          help        = STRING_TOKEN (STR_XML_CLI_SUPPORT_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value  = 0x0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED),  value  = 0x1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        oneof varid   = SYSTEM_CONFIGURATION.SkipXmlComprs,
          prompt      = STRING_TOKEN (STR_SKIP_XML_COMPRESSION_PROMPT),
          help        = STRING_TOKEN (STR_SKIP_XML_COMPRESSION_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value  = 0x0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED),  value  = 0x1, flags = RESET_REQUIRED;
        endoneof;

        oneof varid   = SYSTEM_CONFIGURATION.PublishSetupPgPtr,
          prompt      = STRING_TOKEN(STR_PUBLISH_SETUP_PG_PTR_PROMPT),
          help        = STRING_TOKEN(STR_PUBLISH_SETUP_PG_PTR_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
        endoneof;
        //
        //  Advance debug function
        //
        oneof varid   = SYSTEM_CONFIGURATION.DfxAdvDebugJumper,
          prompt      = STRING_TOKEN (STR_DFX_ADVANCE_DEBUG_PROMPT),
          help        = STRING_TOKEN (STR_DFX_ADVANCE_DEBUG_HELP),
#if defined(PPO_FLAG)
          option text = STRING_TOKEN(STR_AUTO),     value = 2, flags = MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | RESET_REQUIRED;
#else
          option text = STRING_TOKEN(STR_AUTO),     value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
#endif
        endoneof;

///
///

        //
        // Serial Debug level
        //
#ifndef DEBUG_CODE_BLOCK
        suppressif TRUE;
#endif //DEBUG_CODE_BLOCK
//Transformers_JK022***>>
        oneof varid = SYSTEM_CONFIGURATION.serialDebugMsgLvl,
          questionid =  KEY_SERIAL_DEBUG_MSGLVL,
          prompt      = STRING_TOKEN(STR_SERIAL_DEBUG_MSG_PROMPT),
          help        = STRING_TOKEN(STR_SERIAL_DEBUG_MSG_HELP),
          option text = STRING_TOKEN(STR_DISABLE),                 value = 0, flags = INTERACTIVE | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SERIAL_DEBUG_MINIMUM),    value = 1, flags = INTERACTIVE | RESET_REQUIRED | MANUFACTURING;
          option text = STRING_TOKEN(STR_SERIAL_DEBUG_NORMAL),     value = 2, flags = INTERACTIVE | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SERIAL_DEBUG_MAXIMUM),    value = 3, flags = INTERACTIVE | RESET_REQUIRED | DEFAULT;
          option text = STRING_TOKEN(STR_AUTO),                    value = 4, flags = INTERACTIVE | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_SERIAL_DEBUG_PCD),        value = 5, flags = INTERACTIVE | RESET_REQUIRED;
        endoneof;
//Transformers_JK022***<<
#ifndef DEBUG_CODE_BLOCK
        endif;
#endif //DEBUG_CODE_BLOCK

#ifndef DEBUG_CODE_BLOCK
        suppressif TRUE;
#endif //DEBUG_CODE_BLOCK
        oneof varid = SYSTEM_CONFIGURATION.serialDebugTrace,
          prompt      = STRING_TOKEN(STR_SERIAL_DEBUG_TRACE_PROMPT),
          help        = STRING_TOKEN(STR_SERIAL_DEBUG_TRACE_HELP),
          option text = STRING_TOKEN(STR_DISABLED_STRING),  value = 0, flags = RESET_REQUIRED | MANUFACTURING | DEFAULT;
          option text = STRING_TOKEN(STR_ENABLED_STRING),   value = 4, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED_WITH_TAG), value = 64, flags = RESET_REQUIRED;
        endoneof;
#ifndef DEBUG_CODE_BLOCK
        endif;
#endif //DEBUG_CODE_BLOCK

#ifndef DEBUG_CODE_BLOCK
        suppressif TRUE;
#endif //DEBUG_CODE_BLOCK
        oneof varid = SYSTEM_CONFIGURATION.serialDebugMsgLvlTrainResults,
          prompt      = STRING_TOKEN(STR_MRC_SERIAL_DEBUG_TRAIN_PROMPT),
          help        = STRING_TOKEN(STR_MRC_SERIAL_DEBUG_TRAIN_HELP),
#ifndef CRB_FLAG
          option text = STRING_TOKEN(STR_DISABLED_STRING),  value = 0, flags = RESET_REQUIRED | MANUFACTURING;
          option text = STRING_TOKEN(STR_ENABLED_STRING),   value = 8, flags = RESET_REQUIRED | DEFAULT;
#else
          option text = STRING_TOKEN(STR_DISABLED_STRING),  value = 0, flags = RESET_REQUIRED | MANUFACTURING | DEFAULT;
          option text = STRING_TOKEN(STR_ENABLED_STRING),   value = 8, flags = RESET_REQUIRED;
#endif
        endoneof;
#ifndef DEBUG_CODE_BLOCK
        endif;
#endif //DEBUG_CODE_BLOCK

        //
        // Video Support
        //
        oneof varid     = SYSTEM_CONFIGURATION.VideoSelect,
            prompt      = STRING_TOKEN(STR_VIDEO_SELECT_PROMPT),
            help        = STRING_TOKEN(STR_VIDEO_SELECT_HELP),
            option text = STRING_TOKEN(STR_AUTO),                 value = 0, flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
            option text = STRING_TOKEN(STR_VIDEO_SELECT_ONBOARD), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_VIDEO_SELECT_PCIE),    value = 2, flags = RESET_REQUIRED;
        endoneof;

        //
        // PS2 Port Support
        //
        oneof varid     = SYSTEM_CONFIGURATION.Ps2PortSwap,
            prompt      = STRING_TOKEN(STR_PS2PORT_PROMPT),
            help        = STRING_TOKEN(STR_PS2PORT_HELP),
            option text = STRING_TOKEN(STR_DISABLE),  value = 0, flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
            option text = STRING_TOKEN(STR_ENABLE),   value = 1, flags = RESET_REQUIRED;
        endoneof;

        //
        // Num Lock
        //
        oneof varid     = SYSTEM_CONFIGURATION.Numlock,
            prompt      = STRING_TOKEN(STR_NUMLOCK_PROMPT),
            help        = STRING_TOKEN(STR_NUMLOCK_HELP),
            option text = STRING_TOKEN(STR_DISABLE),  value = 0, flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
            option text = STRING_TOKEN(STR_ENABLE),   value = 1, flags = RESET_REQUIRED;
        endoneof;

        //
        // Wake on Lan S5
        //
        oneof varid     = SYSTEM_CONFIGURATION.WakeOnLanS5,
            prompt      = STRING_TOKEN(STR_WAKE_ON_LAN_S5_PROMPT),
            help        = STRING_TOKEN(STR_WAKE_ON_LAN_S5_HELP),
            option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = INTERACTIVE | RESET_REQUIRED | DEFAULT | MANUFACTURING;
            option text = STRING_TOKEN(STR_ENABLE),  value = 1, flags = INTERACTIVE | RESET_REQUIRED;
        endoneof;

        //
        // Network Boot
        //
        oneof varid     = SYSTEM_CONFIGURATION.BootNetwork,
            prompt      = STRING_TOKEN(STR_BOOT_NETWORK_PROMPT),
            help        = STRING_TOKEN(STR_BOOT_NETWORK_HELP),
#if defined(CLUSTER_ENABLE) && CLUSTER_ENABLE
            option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = INTERACTIVE | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_ENABLE),  value = 1, flags = INTERACTIVE | RESET_REQUIRED | DEFAULT | MANUFACTURING;
#else
            option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = INTERACTIVE | RESET_REQUIRED | DEFAULT | MANUFACTURING;
            option text = STRING_TOKEN(STR_ENABLE),  value = 1, flags = INTERACTIVE | RESET_REQUIRED;
#endif
        endoneof;
#ifdef EFI_PCI_IOV_SUPPORT
        //
        // ARI Enable
        //
        oneof varid     = SYSTEM_CONFIGURATION.ARIEnable,
            prompt      = STRING_TOKEN(STR_ARI_ENABLE_PROMPT),
            help        = STRING_TOKEN(STR_ARI_ENABLE_HELP),
            option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = INTERACTIVE | RESET_REQUIRED ;
            option text = STRING_TOKEN(STR_ENABLE),  value = 1, flags = INTERACTIVE | RESET_REQUIRED | DEFAULT | MANUFACTURING;
        endoneof;

        //
        // ARI FORWARD
        //
        oneof varid     = SYSTEM_CONFIGURATION.ARIForward,
            prompt      = STRING_TOKEN(STR_ARI_FORWARD_PROMPT),
            help        = STRING_TOKEN(STR_ARI_FORWARD_HELP),
            option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = INTERACTIVE | RESET_REQUIRED | DEFAULT | MANUFACTURING;
            option text = STRING_TOKEN(STR_ENABLE),  value = 1, flags = INTERACTIVE | RESET_REQUIRED ;
        endoneof;

        // APTIOV_SERVER_OVERRIDE_RC_START : Suppress IOV option since it is supported in AMI PCI driver.
        suppressif TRUE;
        //
        // SR-IOV Enable
        //
        oneof varid     = SYSTEM_CONFIGURATION.SRIOVEnable,
            prompt      = STRING_TOKEN(STR_SR_IOV_ENABLE_PROMPT),
            help        = STRING_TOKEN(STR_SR_IOV_ENABLE_HELP),
// APTIOV_SERVER_OVERRIDE_RC_START : Syncing Default value with AMI PCI driver.
#if (SRIOV_SUPPORT && SRIOV_SUPPORT_DEFAULT_VALUE)
            option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = INTERACTIVE | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_ENABLE),  value = 1, flags = INTERACTIVE | RESET_REQUIRED | DEFAULT | MANUFACTURING;
#else
            option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = INTERACTIVE | RESET_REQUIRED | DEFAULT | MANUFACTURING;
            option text = STRING_TOKEN(STR_ENABLE),  value = 1, flags = INTERACTIVE | RESET_REQUIRED;
#endif
// APTIOV_SERVER_OVERRIDE_RC_END : Syncing Default value with AMI PCI driver.
        endoneof;

       grayoutif ideqval SYSTEM_CONFIGURATION.SRIOVEnable == 0;
            oneof varid     = SYSTEM_CONFIGURATION.SystemPageSize,
                prompt      = STRING_TOKEN(STR_SR_IOV_SYSTEM_PAGE_SIZE_PROMPT),
                help        = STRING_TOKEN(STR_SR_IOV_SYSTEM_PAGE_SIZE_HELP),
                option text = STRING_TOKEN(STR_4K),   value = 0, flags = RESET_REQUIRED | MANUFACTURING | DEFAULT;
                option text = STRING_TOKEN(STR_8K),   value = 1, flags = RESET_REQUIRED;
                option text = STRING_TOKEN(STR_64K),  value = 4, flags = RESET_REQUIRED;
                option text = STRING_TOKEN(STR_256K), value = 6, flags = RESET_REQUIRED;
                option text = STRING_TOKEN(STR_1M),   value = 8, flags = RESET_REQUIRED;
                option text = STRING_TOKEN(STR_4M),   value = 10, flags = RESET_REQUIRED;

            endoneof;
        endif;

        //
        // MR-IOV Enable
        //
        oneof varid     = SYSTEM_CONFIGURATION.MRIOVEnable,
            prompt      = STRING_TOKEN(STR_MR_IOV_ENABLE_PROMPT),
            help        = STRING_TOKEN(STR_MR_IOV_ENABLE_HELP),
            option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = INTERACTIVE | RESET_REQUIRED | DEFAULT | MANUFACTURING;
            option text = STRING_TOKEN(STR_ENABLE),  value = 1, flags = INTERACTIVE | RESET_REQUIRED;
        endoneof;
        endif;
       // APTIOV_SERVER_OVERRIDE_RC_END : Suppress IOV option since it is supported in AMI PCI driver.
#endif

        /*//
        // Manageability Engine (ME) Support
        //
        oneof varid     = SYSTEM_CONFIGURATION.MESupport,
            prompt      = STRING_TOKEN(STR_ME_SUPPORT_PROMPT),
            help        = STRING_TOKEN(STR_ME_SUPPORT_HELP),
            option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED | MANUFACTURING | DEFAULT;
            option text = STRING_TOKEN(STR_ENABLE),  value = 1, flags = RESET_REQUIRED;
        endoneof;

        grayoutif ideqval SYSTEM_CONFIGURATION.MESupport == 0 OR
                  ideqval SYSTEM_CONFIGURATION.MEFwState == 0;
            oneof varid     = SYSTEM_CONFIGURATION.MEViaBmc,
                prompt      = STRING_TOKEN(STR_ME_VIA_BMC_PROMPT),
                help        = STRING_TOKEN(STR_ME_VIA_BMC_HELP),
                option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED | MANUFACTURING | DEFAULT;
                option text = STRING_TOKEN(STR_ENABLE),  value = 1, flags = RESET_REQUIRED;
            endoneof;
        endif;

        grayoutif ideqval SYSTEM_CONFIGURATION.MESupport == 0;
            oneof varid     = SYSTEM_CONFIGURATION.MEEopSupport,
                prompt      = STRING_TOKEN(STR_ME_END_OF_POST_PROMPT),
                help        = STRING_TOKEN(STR_ME_END_OF_POST_HELP),
                option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
                option text = STRING_TOKEN(STR_ENABLE),  value = 1, flags = RESET_REQUIRED | MANUFACTURING | DEFAULT;
            endoneof;
        endif;

        grayoutif ideqval SYSTEM_CONFIGURATION.MESupport == 0 OR
                  ideqval SYSTEM_CONFIGURATION.MEViaBmc == 1;
            oneof varid     = SYSTEM_CONFIGURATION.MEFwState,
                prompt      = STRING_TOKEN(STR_ME_FW_STATE_PROMPT),
                help        = STRING_TOKEN(STR_ME_FW_STATE_HELP),
                option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
                option text = STRING_TOKEN(STR_ENABLE),  value = 1, flags = RESET_REQUIRED | MANUFACTURING | DEFAULT;
            endoneof;
        endif;
        */
            oneof   varid   = SYSTEM_CONFIGURATION.WakeOnRTCS4S5,
        prompt      = STRING_TOKEN(STR_WAKE_ON_RTC_PROMPT),
        help        = STRING_TOKEN(STR_WAKE_ON_RTC_HELP),
        option text = STRING_TOKEN(STR_DISABLE), value=0, flags=  DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLE), value= 1, flags= RESET_REQUIRED;
          endoneof;

      suppressif  ideqval SYSTEM_CONFIGURATION.WakeOnRTCS4S5 == 0;
        numeric varid  = SYSTEM_CONFIGURATION.RTCWakeupTimeHour,
          prompt      = STRING_TOKEN(STR_RTC_WAKEUP_HOUR_PROMPT),
          help        = STRING_TOKEN(STR_RTC_HOUR_HELP),
          flags       = RESET_REQUIRED,
          minimum     = 0,
          maximum     = 23,
          step        = 1,
          default     = 0, defaultstore = MyStandardDefault,
          default     = 0, defaultstore = MyManufactureDefault,
        endnumeric;

        numeric varid  = SYSTEM_CONFIGURATION.RTCWakeupTimeMinute,
          prompt      = STRING_TOKEN(STR_RTC_WAKEUP_MINUTE_PROMPT),
          help        = STRING_TOKEN(STR_TIME_MINUTE_HELP),
          flags       = RESET_REQUIRED,
          minimum       = 0,
          maximum       = 59,
          step          = 1,
          default       = 0, defaultstore = MyStandardDefault,
          default       = 0, defaultstore = MyManufactureDefault,
        endnumeric;

        numeric varid  = SYSTEM_CONFIGURATION.RTCWakeupTimeSecond,
          prompt      = STRING_TOKEN(STR_RTC_WAKEUP_SECOND_PROMPT),
          help        = STRING_TOKEN(STR_TIME_SECOND_HELP),
          flags       = RESET_REQUIRED,
          minimum       = 0,
          maximum       = 59,
          step          = 1,
          default       = 0, defaultstore = MyStandardDefault,
          default       = 0, defaultstore = MyManufactureDefault,
        endnumeric;
           endif;

        oneof varid   = PCH_SETUP.FirmwareConfiguration,
          prompt      = STRING_TOKEN(STR_FIRMWARE_CONFIG_NAME),
          help        = STRING_TOKEN(STR_FIRMWARE_CONFIG_NAME_HELP),
          option text = STRING_TOKEN(STR_FW_CONFIG_DEFAULT_VALUE), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_FW_CONFIG_PRODUCTION_VALUE), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_FW_CONFIG_TEST_VALUE), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_FW_CONFIG_INTERNAL_VALUE), value = 3, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_FW_CONFIG_RESTRICTED_VALUE), value = 4, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_FW_CONFIG_RESTRICTED_SV_VALUE), value = 5, flags = RESET_REQUIRED;
        endoneof;


        suppressif TRUE;
        oneof varid = SYSTEM_CONFIGURATION.StorageOpROMSuppression,
             prompt   = STRING_TOKEN(STR_SATA_OPROM_SUPPRESSION),
             help     = STRING_TOKEN(STR_SATA_OPROM_SUPPRESSION_HELP),
             option text  = STRING_TOKEN (STR_ENABLED_STRING), value = 1, flags = MANUFACTURING | RESET_REQUIRED;
             option text  = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | RESET_REQUIRED;
        endoneof;
        endif;
        
        //
        //APTIOV_SERVER_OVERRIDE_RC_START : Commenting unused setup options
        //
        suppressif TRUE;
        oneof varid   = SYSTEM_CONFIGURATION.RsaSupport,
            prompt        = STRING_TOKEN(STR_RSA_SUPPORT_PROMPT),
            help          = STRING_TOKEN(STR_RSA_SUPPORT_HELP),
            option text   = STRING_TOKEN(STR_DISABLE),        value = 0, flags = RESET_REQUIRED  | MANUFACTURING | DEFAULT;
            option text   = STRING_TOKEN(STR_ENABLE),         value = 1, flags = RESET_REQUIRED;
        endoneof;

        oneof varid   = SYSTEM_CONFIGURATION.DfxWarmResetEliminationEn,
            prompt        = STRING_TOKEN(STR_DFX_WARM_RESET_ELIMINATION_EN_PROMPT),
            help          = STRING_TOKEN(STR_DFX_WARM_RESET_ELIMINATION_EN_HELP),
            option text   = STRING_TOKEN(STR_DISABLE),        value = 0, flags = RESET_REQUIRED | MANUFACTURING | DEFAULT;
            option text   = STRING_TOKEN(STR_ENABLE),         value = 1, flags = RESET_REQUIRED;
        endoneof;

        oneof varid   = SYSTEM_CONFIGURATION.EnableClockSpreadSpec,
            prompt      = STRING_TOKEN(STR_CLOCK_SPREAD_SPEC_ENABLE),
            help        = STRING_TOKEN(STR_CLOCK_SPREAD_SPEC_ENABLE_HELP),
            option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval SOCKET_COMMONRC_CONFIGURATION.CpuType == CPU_SPRSP;
        oneof varid = SYSTEM_CONFIGURATION.DfxEmuBiosSkipS3MAccess,
            prompt  = STRING_TOKEN(STR_DFX_EMU_BIOS_SKIP_S3M_ACCESS),
            help    = STRING_TOKEN(STR_DFX_EMU_BIOS_SKIP_S3M_ACCESS_HELP),
            option text = STRING_TOKEN(STR_DISABLE),          value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_ENABLE),           value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_AUTO),             value = 2, flags = RESET_REQUIRED | MANUFACTURING | DEFAULT;
        endoneof;
        endif;
            
        endif;
        //
        //APTIOV_SERVER_OVERRIDE_RC_END : Commenting unused setup options
        //
    endform;

  form formid = VFR_FORMID_NETWORK,

    title     = STRING_TOKEN(STR_NETWORK_CONFIGURATION);

    oneof varid = SYSTEM_CONFIGURATION.LegacyPxeRom,
      prompt   = STRING_TOKEN(STR_LEGACY_PXEROM_CONTROL),
      help     = STRING_TOKEN(STR_LEGACY_PXEROM_CONTROL_HELP),
      option text = STRING_TOKEN(STR_ENABLED_STRING), value = 1, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
    endoneof;

    oneof varid = SYSTEM_CONFIGURATION.EfiNetworkSupport,
      prompt   = STRING_TOKEN(STR_EFI_NETWORK_CONTROL),
      help     = STRING_TOKEN(STR_EFI_NETWORK_CONTROL_HELP),
#if defined(CLUSTER_ENABLE) && CLUSTER_ENABLE
      option text = STRING_TOKEN(STR_ENABLED_STRING), value = 1, flags =  DEFAULT | MANUFACTURING |RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
#else
      option text = STRING_TOKEN(STR_ENABLED_STRING), value = 1, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
#endif
    endoneof;

    oneof varid = SYSTEM_CONFIGURATION.LomDisableByGpio,
      prompt   = STRING_TOKEN(STR_LOM_DISABLE_BY_GPIO),
      help     = STRING_TOKEN(STR_LOM_DISABLE_BY_GPIO_HELP),
      option text = STRING_TOKEN(STR_ENABLED_STRING), value = 1, flags =  DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
    endoneof;
  endform;

  form formid = VFR_RESERVE_MEMORY,

    title     = STRING_TOKEN(STR_RESERVE_MEMORY_OPTION);

    //
    // Reserve Memory that is hidden from the OS.
    //

    checkbox varid = SYSTEM_CONFIGURATION.ReserveMem,
      prompt   = STRING_TOKEN(STR_RESERVE_MEMORY_ENABLE),
      help     = STRING_TOKEN(STR_RESERVE_MEMORY_ENABLE_HELP),
      flags    = 0,
      default  = 0, defaultstore = MyStandardDefault,
      default  = 0, defaultstore = MyManufactureDefault,
    endcheckbox;


    grayoutif ideqval SYSTEM_CONFIGURATION.ReserveMem == 0;
      numeric varid = SYSTEM_CONFIGURATION.ReserveStartAddr,
        prompt    = STRING_TOKEN(STR_RESERVE_MEMORY_START_ADDRESS),
        help      = STRING_TOKEN(STR_RESERVE_MEMORY_START_ADDRESS_HELP),
        flags     = DISPLAY_UINT_HEX,
        minimum   = 0x100000,
        maximum   = 0xFFFFFFFFFFFFFFFF,
        step      = 0x1000,
        default   = 0x100000, defaultstore = MyStandardDefault,
        default   = 0x100000, defaultstore = MyManufactureDefault,

      endnumeric;
    endif;

    //
    // ReserveMem Result Display
    //
    suppressif ideqval SYSTEM_CONFIGURATION.ReserveMem == 0;
      text
          help   = STRING_TOKEN(STR_NULL_STRING),
          text   = STRING_TOKEN(STR_RESERVE_MEMORY_RESULT),
          text   = STRING_TOKEN(STR_RESERVE_MEMORY_RESULT_VALUE),
          flags  = 0, key = 0;
    endif;

    //
    // Reserve TAGEC Memory
    //
    oneof varid   = SYSTEM_CONFIGURATION.TagecMem,
        prompt      = STRING_TOKEN(STR_TAGEC_MEMORY),
        help        = STRING_TOKEN(STR_TAGEC_MEMORY_HELP),
        option text = STRING_TOKEN(STR_DISABLE),        value = 0, flags = RESET_REQUIRED | DEFAULT;
        option text = STRING_TOKEN(STR_ENABLE),         value = 1, flags = RESET_REQUIRED | MANUFACTURING;
    endoneof;

  endform;

  #include "PchSetupEbg.hfr"
  #include "SystemEventLog.hfr"
// APTIOV_SERVER_OVERRIDE_RC_START : Removing unused intel setup .uni/.hfr files.
//  #include "ConsoleRedirectionConfigurationSetup.hfr"
// APTIOV_SERVER_OVERRIDE_RC_END : Removing unused intel setup .uni/.hfr files.
//Comment out UsbConfigData header file since we dont need USB Configuration under Advanced setup screen anymore
  //#include "UsbConfigData.hfr"

#if defined(ME_SUPPORT_FLAG) && ME_SUPPORT_FLAG

#if defined(ME_SPS_SUPPORT) && ME_SPS_SUPPORT
  #include "MeSpsSetup.hfr"
#endif // ME_SPS_SUPPORT

  #include "MeDfxSetup.hfr"

#if defined(ME_WS_SUPPORT) && ME_WS_SUPPORT
  #include "MeSetup.hfr"
  #include "IccSetup.hfr"
#endif // ME_WS_SUPPORT

#endif // ME_SUPPORT_FLAG

// APTIOV_SERVER_OVERRIDE_RC_START : Removing unused intel setup .uni/.hfr files.
//  #include "BootAllOptions.hfr"
// APTIOV_SERVER_OVERRIDE_RC_END : Removing unused intel setup .uni/.hfr files.
  #include "Overclocking.hfr"
// APTIOV_SERVER_OVERRIDE_RC_START: Defines dummy control and update value from NVRAM or HOB in order to avoid load defaults issue.
  #include "IntelRcSetupDummyControls.hfr"
// APTIOV_SERVER_OVERRIDE_RC_END: Defines dummy control and update value from NVRAM or HOB in order to avoid load defaults issue.
endformset;
